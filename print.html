<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Robotic Embodied Intelligence - From Zero to Hero</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="src/css/custom-a0f5ac24.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-9218460c.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-a5a73760.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Robotic Embodied Intelligence - From Zero to Hero</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://Yang-Yang.me/" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M272 304h-96C78.8 304 0 382.8 0 480c0 17.67 14.33 32 32 32h384c17.67 0 32-14.33 32-32C448 382.8 369.2 304 272 304zM48.99 464C56.89 400.9 110.8 352 176 352h96c65.16 0 119.1 48.95 127 112H48.99zM224 256c70.69 0 128-57.31 128-128c0-70.69-57.31-128-128-128S96 57.31 96 128C96 198.7 153.3 256 224 256zM224 48c44.11 0 80 35.89 80 80c0 44.11-35.89 80-80 80S144 172.1 144 128C144 83.89 179.9 48 224 48z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="引言"><a class="header" href="#引言">引言</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="机器人领域期刊"><a class="header" href="#机器人领域期刊">机器人领域期刊</a></h1>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Journal name</th><th>2023 JIF</th><th>JIF Quartile</th><th>JIF Rank</th><th>标题翻译</th><th>中科院分区</th><th>接受率</th><th>审稿时间</th><th>缩写</th><th>收录</th><th>link</th></tr>
</thead>
<tbody>
<tr><td>IEEE-CAA Journal of Automatica Sinica</td><td>15.3</td><td>Q1</td><td>1/84</td><td>IEEE-CAA 自动化学报</td><td>Q1</td><td></td><td></td><td></td><td></td><td><a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=6570654">https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=6570654</a></td></tr>
<tr><td>IEEE Transactions on Industrial Informatics</td><td>11.7</td><td>Q1</td><td>2/84</td><td>IEEE 工业信息学学报</td><td>Q1</td><td></td><td>SP-175</td><td></td><td></td><td><a href="https://ieeexplore.ieee.org/xpl/aboutJournal.jsp?punumber=9424">https://ieeexplore.ieee.org/xpl/aboutJournal.jsp?punumber=9424</a></td></tr>
<tr><td>Annual Review of Control Robotics and Autonomous Systems</td><td>11.2</td><td>Q1</td><td>3/84</td><td>控制机器人与自主系统年度回顾</td><td>Q1</td><td></td><td></td><td></td><td></td><td><a href="https://www.annualreviews.org/content/journals/control">https://www.annualreviews.org/content/journals/control</a></td></tr>
<tr><td>IEEE Transactions on Cybernetics</td><td>9.4</td><td>Q1</td><td>4/84</td><td>IEEE 控制论学报</td><td>Q1</td><td></td><td>SP-140</td><td></td><td></td><td><a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=6221036">https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=6221036</a></td></tr>
<tr><td>IEEE Transactions on Systems Man Cybernetics-Systems</td><td>8.6</td><td>Q1</td><td>5/84</td><td>IEEE 系统人机控制论-系统学报</td><td>Q1</td><td></td><td>SP-190</td><td></td><td></td><td><a href="https://www.ieee.org/membership-catalog/productdetail/showProductDetailPage.html?product=PER127-PRT">https://www.ieee.org/membership-catalog/productdetail/showProductDetailPage.html?product=PER127-PRT</a></td></tr>
<tr><td>IEEE TRANSACTIONS ON INDUSTRIAL ELECTRONICS</td><td>7.5</td><td>Q1</td><td>6/84</td><td>IEEE 工业电子学报</td><td>Q1</td><td></td><td>SP-180</td><td></td><td></td><td><a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=41">https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=41</a></td></tr>
<tr><td>ENGINEERING APPLICATIONS OF ARTIFICIAL INTELLIGENCE</td><td>7.5</td><td>Q1</td><td>6/84</td><td>人工智能工程应用</td><td>Q1</td><td>17%</td><td>SA-210</td><td></td><td></td><td><a href="http://www.elsevier.com/wps/find/journaldescription.cws_home/975/description">http://www.elsevier.com/wps/find/journaldescription.cws_home/975/description</a></td></tr>
<tr><td>ANNUAL REVIEWS IN CONTROL</td><td>7.3</td><td>Q1</td><td>8/84</td><td>控制年度回顾</td><td>Q2</td><td>19%</td><td>SA-105</td><td></td><td></td><td><a href="https://www.sciencedirect.com/journal/annual-reviews-in-control">https://www.sciencedirect.com/journal/annual-reviews-in-control</a></td></tr>
<tr><td>Advanced Intelligent Systems</td><td>6.8</td><td>Q1</td><td>9/84</td><td>先进智能系统</td><td>Q3</td><td>36%</td><td>SA-109</td><td></td><td></td><td><a href="https://onlinelibrary.wiley.com/journal/26404567">https://onlinelibrary.wiley.com/journal/26404567</a></td></tr>
<tr><td>ISA TRANSACTIONS</td><td>6.3</td><td>Q1</td><td>11/84</td><td>ISA 学报</td><td>Q1</td><td></td><td></td><td></td><td></td><td><a href="http://www.isa.org/Content/NavigationMenu/Products_and_Services/Publishing/ISA_Transactions2/ISA_Transactions.htm">http://www.isa.org/Content/NavigationMenu/Products_and_Services/Publishing/ISA_Transactions2/ISA_Transactions.htm</a></td></tr>
<tr><td>IEEE TRANSACTIONS ON AUTOMATIC CONTROL</td><td>6.2</td><td>Q1</td><td>12/84</td><td>IEEE 自动控制学报</td><td>Q1</td><td></td><td>SP-153</td><td></td><td></td><td><a href="http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=9">http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=9</a></td></tr>
<tr><td>IEEE-ASME TRANSACTIONS ON MECHATRONICS</td><td>6.1</td><td>Q1</td><td>13/84</td><td>IEEE-ASME 机电一体化学报</td><td>Q1</td><td></td><td>SP-177</td><td></td><td></td><td><a href="http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?reload=true&amp;punumber=3516">http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?reload=true&amp;punumber=3516</a></td></tr>
<tr><td>IEEE ROBOTICS &amp; AUTOMATION MAGAZINE</td><td>6.1</td><td>Q1</td><td>13/84</td><td>IEEE 机器人与自动化杂志</td><td>Q2</td><td>*</td><td>*</td><td></td><td></td><td><a href="https://www.annualreviews.org/content/journals/control">https://www.annualreviews.org/content/journals/control</a></td></tr>
<tr><td>IEEE Transactions on Automation Science and Engineering</td><td>5.9</td><td>Q1</td><td>15/84</td><td>IEEE 自动化科学与工程学报</td><td>Q2</td><td></td><td>SP-105</td><td></td><td></td><td><a href="http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=8856">http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=8856</a></td></tr>
<tr><td>CONTROL ENGINEERING PRACTICE</td><td>5.4</td><td>Q1</td><td>17/84</td><td>控制工程实践</td><td>Q2</td><td>14%</td><td>SA-145</td><td></td><td></td><td><a href="https://www.sciencedirect.com/journal/control-engineering-practice">https://www.sciencedirect.com/journal/control-engineering-practice</a></td></tr>
<tr><td>IEEE TRANSACTIONS ON CONTROL SYSTEMS TECHNOLOGY</td><td>4.9</td><td>Q1</td><td>18/84</td><td>IEEE 控制系统技术学报</td><td>Q2</td><td></td><td>SP-254</td><td></td><td></td><td><a href="http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=87">http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=87</a></td></tr>
<tr><td>INTERNATIONAL JOURNAL OF SYSTEMS SCIENCE</td><td>4.9</td><td>Q1</td><td>18/84</td><td>国际系统科学杂志</td><td>Q4</td><td>23%</td><td>SF-68</td><td></td><td></td><td><a href="http://www.tandfonline.com/toc/tsys20/current">http://www.tandfonline.com/toc/tsys20/current</a></td></tr>
<tr><td>AUTOMATICA</td><td>4.8</td><td>Q1</td><td>20/84</td><td>AUTOMATICA</td><td>Q2</td><td>*</td><td>SA-388</td><td></td><td></td><td><a href="https://www.journals.elsevier.com/automatica">https://www.journals.elsevier.com/automatica</a></td></tr>
<tr><td>JOURNAL OF MACHINE LEARNING RESEARCH</td><td>4.3</td><td>Q1</td><td>21/84</td><td>机器学习研究杂志</td><td>Q3</td><td>16%</td><td>SA-250</td><td></td><td></td><td><a href="http://jmlr.org/">http://jmlr.org/</a></td></tr>
<tr><td>ROBOTICS AND AUTONOMOUS SYSTEMS</td><td>4.3</td><td>Q1</td><td>21/84</td><td>机器人与自主系统</td><td>Q2</td><td>21%</td><td>SA-231</td><td></td><td></td><td><a href="http://www.journals.elsevier.com/robotics-and-autonomous-systems/">http://www.journals.elsevier.com/robotics-and-autonomous-systems/</a></td></tr>
<tr><td>IEEE Transactions on Control of Network Systems</td><td>4.0</td><td>Q2</td><td>23/84</td><td>IEEE 网络系统控制学报</td><td>Q3</td><td></td><td>SP-186</td><td></td><td></td><td><a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=6509490">https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=6509490</a></td></tr>
<tr><td>INTERNATIONAL JOURNAL OF ADAPTIVE CONTROL AND SIGNAL PROCESSING</td><td>3.9</td><td>Q2</td><td>24/84</td><td>国际自适应控制与信号处理</td><td>Q4</td><td>12%</td><td>SA-174</td><td></td><td></td><td><a href="https://onlinelibrary.wiley.com/journal/10991115">https://onlinelibrary.wiley.com/journal/10991115</a></td></tr>
<tr><td>IEEE CONTROL SYSTEMS MAGAZINE</td><td>3.9</td><td>Q2</td><td>24/84</td><td>IEEE 控制系统杂志</td><td>Q3</td><td></td><td></td><td></td><td></td><td><a href="http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=5488303">http://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=5488303</a></td></tr>
<tr><td>Nonlinear Analysis-Hybrid Systems</td><td>3.7</td><td>Q2</td><td>26/84</td><td>非线性分析-混合系统</td><td>Q1</td><td></td><td></td><td></td><td></td><td><a href="https://www.sciencedirect.com/journal/nonlinear-analysis-hybrid-systems/about/aims-and-scope">https://www.sciencedirect.com/journal/nonlinear-analysis-hybrid-systems/about/aims-and-scope</a></td></tr>
<tr><td>CHEMOMETRICS AND INTELLIGENT LABORATORY SYSTEMS</td><td>3.7</td><td>Q2</td><td>26/84</td><td>化学计量学与智能实验室系统</td><td>Q2</td><td>19%</td><td>SA-111</td><td></td><td></td><td><a href="https://www.sciencedirect.com/journal/chemometrics-and-intelligent-laboratory-systems">https://www.sciencedirect.com/journal/chemometrics-and-intelligent-laboratory-systems</a></td></tr>
<tr><td>JOURNAL OF THE FRANKLIN INSTITUTE-ENGINEERING AND APPLIED MATHEMATICS</td><td>3.7</td><td>Q2</td><td>26/84</td><td>富兰克林研究所杂志-工程与应用数学</td><td>Q2</td><td>26%</td><td></td><td></td><td></td><td><a href="http://www.journals.elsevier.com/journal-of-the-franklin-institute/">http://www.journals.elsevier.com/journal-of-the-franklin-institute/</a></td></tr>
<tr><td>International Journal of Fuzzy Systems</td><td>3.6</td><td>Q2</td><td>30/84</td><td>国际模糊系统杂志</td><td>Q3</td><td>*</td><td>SF-5</td><td></td><td></td><td><a href="https://link.springer.com/journal/40815">https://link.springer.com/journal/40815</a></td></tr>
<tr><td>JOURNAL OF PROCESS CONTROL</td><td>3.3</td><td>Q2</td><td>31/84</td><td>过程控制杂志</td><td>Q2</td><td>15%</td><td>SA-126</td><td></td><td></td><td><a href="http://www.journals.elsevier.com/journal-of-process-control/">http://www.journals.elsevier.com/journal-of-process-control/</a></td></tr>
<tr><td>INTERNATIONAL JOURNAL OF ROBUST AND NONLINEAR CONTROL</td><td>3.2</td><td>Q2</td><td>32/84</td><td>国际鲁棒与非线性控制杂志</td><td>Q3</td><td>28%</td><td>SA-187</td><td></td><td></td><td><a href="https://onlinelibrary.wiley.com/journal/10991239">https://onlinelibrary.wiley.com/journal/10991239</a></td></tr>
<tr><td>MECHATRONICS</td><td>3.1</td><td>Q2</td><td>34/84</td><td>机电一体化</td><td>Q2</td><td>14%</td><td>SA-249</td><td></td><td></td><td><a href="http://www.journals.elsevier.com/mechatronics/">http://www.journals.elsevier.com/mechatronics/</a></td></tr>
<tr><td>INTERNATIONAL JOURNAL OF ADVANCED MANUFACTURING TECHNOLOGY</td><td>2.9</td><td>Q2</td><td>36/84</td><td>国际先进制造技术杂志</td><td>Q3</td><td>*</td><td>SF-7</td><td></td><td></td><td><a href="https://www.springer.com/170">https://www.springer.com/170</a></td></tr>
<tr><td>ASIAN JOURNAL OF CONTROL</td><td>2.7</td><td>Q2</td><td>37/84</td><td>亚洲控制杂志</td><td>Q4</td><td>27%</td><td>SA-264</td><td></td><td></td><td><a href="https://onlinelibrary.wiley.com/journal/19346093">https://onlinelibrary.wiley.com/journal/19346093</a></td></tr>
<tr><td>EUROPEAN JOURNAL OF CONTROL</td><td>2.5</td><td>Q2</td><td>38/84</td><td>欧洲控制杂志</td><td>Q3</td><td>25%</td><td>SA-198</td><td></td><td></td><td><a href="https://www.sciencedirect.com/journal/european-journal-of-control">https://www.sciencedirect.com/journal/european-journal-of-control</a></td></tr>
<tr><td>INTERNATIONAL JOURNAL OF CONTROL AUTOMATION AND SYSTEMS</td><td>2.5</td><td>Q2</td><td>38/84</td><td>国际控制自动化与系统杂志</td><td>Q3</td><td>*</td><td>SF-25</td><td>IJCAS</td><td></td><td><a href="https://www.springer.com/12555">https://www.springer.com/12555</a></td></tr>
<tr><td>SIAM JOURNAL ON CONTROL AND OPTIMIZATION</td><td>2.2</td><td>Q2</td><td>41/84</td><td>SIAM 控制与优化杂志</td><td>Q2</td><td>*</td><td>*</td><td></td><td></td><td><a href="https://www.siam.org/publications/siam-journals/siam-journal-on-control-and-optimization/">https://www.siam.org/publications/siam-journals/siam-journal-on-control-and-optimization/</a></td></tr>
<tr><td>IET Control Theory and Applications</td><td>2.2</td><td>Q2</td><td>41/84</td><td>IET 控制理论与应用</td><td>Q4</td><td>48%</td><td>SA-159</td><td></td><td></td><td><a href="https://onlinelibrary.wiley.com/journal/17518652">https://onlinelibrary.wiley.com/journal/17518652</a></td></tr>
<tr><td>SYSTEMS &amp; CONTROL LETTERS</td><td>2.1</td><td>Q3</td><td>44/84</td><td>系统与控制快报</td><td>Q3</td><td>27%</td><td>SA-193</td><td></td><td></td><td><a href="https://www.sciencedirect.com/journal/systems-and-control-letters">https://www.sciencedirect.com/journal/systems-and-control-letters</a></td></tr>
<tr><td>International Journal of Computers Communications &amp; Control</td><td>2.0</td><td>Q3</td><td>45/84</td><td>国际计算机通信与控制杂志</td><td>Q4</td><td>*</td><td>*</td><td></td><td></td><td><a href="https://univagora.ro/jour/index.php/ijccc/about">https://univagora.ro/jour/index.php/ijccc/about</a></td></tr>
<tr><td>OPTIMAL CONTROL APPLICATIONS &amp; METHODS</td><td>2.0</td><td>Q3</td><td>45/84</td><td>最优控制应用与方法</td><td>Q4</td><td>9%</td><td>SA-173</td><td></td><td></td><td><a href="http://onlinelibrary.wiley.com/journal/10.1002/(ISSN)1099-1514">http://onlinelibrary.wiley.com/journal/10.1002/(ISSN)1099-1514</a></td></tr>
<tr><td>AUTONOMOUS AGENTS AND MULTI-AGENT SYSTEMS</td><td>2.0</td><td>Q3</td><td>45/84</td><td>自主代理与多智能体系统</td><td>Q3</td><td>*</td><td>SF-12</td><td></td><td></td><td><a href="https://link.springer.com/journal/10458">https://link.springer.com/journal/10458</a></td></tr>
<tr><td>Information Technology and Control</td><td>2.0</td><td>Q3</td><td>45/84</td><td>信息技术与控制</td><td>Q4</td><td>*</td><td>*</td><td></td><td></td><td><a href="https://itc.ktu.lt/index.php/ITC">https://itc.ktu.lt/index.php/ITC</a></td></tr>
<tr><td>JOURNAL OF CHEMOMETRICS</td><td>1.9</td><td>Q3</td><td>49/84</td><td>化学计量学杂志</td><td>Q4</td><td>25%</td><td>SA-116</td><td></td><td></td><td><a href="https://onlinelibrary.wiley.com/journal/1099128X">https://onlinelibrary.wiley.com/journal/1099128X</a></td></tr>
<tr><td>ASSEMBLY AUTOMATION</td><td>1.9</td><td>Q3</td><td>49/84</td><td>装配自动化</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="http://www.emeraldinsight.com/loi/aa">http://www.emeraldinsight.com/loi/aa</a></td></tr>
<tr><td>Journal of Systems Engineering and Electronics</td><td>1.9</td><td>Q3</td><td>49/84</td><td>系统工程与电子学杂志</td><td>Q4</td><td>*</td><td>*</td><td></td><td></td><td><a href="https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=5971804">https://ieeexplore.ieee.org/xpl/RecentIssue.jsp?punumber=5971804</a></td></tr>
<tr><td>MATHEMATICS OF CONTROL SIGNALS AND SYSTEMS</td><td>1.8</td><td>Q3</td><td>52/84</td><td>控制信号与系统数学</td><td>Q4</td><td>*</td><td>SF-4</td><td></td><td></td><td><a href="https://www.springer.com/498">https://www.springer.com/498</a></td></tr>
<tr><td>Automatika</td><td>1.7</td><td>Q3</td><td>54/84</td><td>Automatika</td><td>Q4</td><td>6%</td><td>SA-198</td><td></td><td></td><td><a href="https://automatika.korema.hr/index.php/automatika">https://automatika.korema.hr/index.php/automatika</a></td></tr>
<tr><td>JOURNAL OF DYNAMIC SYSTEMS MEASUREMENT AND CONTROL-TRANSACTIONS OF THE ASME</td><td>1.7</td><td>Q3</td><td>54/84</td><td>动态系统测量与控制杂志-ASME 会刊</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="https://dynamicsystems.asmedigitalcollection.asme.org/journal.aspx">https://dynamicsystems.asmedigitalcollection.asme.org/journal.aspx</a></td></tr>
<tr><td>TRANSACTIONS OF THE INSTITUTE OF MEASUREMENT AND CONTROL</td><td>1.7</td><td>Q3</td><td>54/84</td><td>测量与控制学会会刊</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="http://tim.sagepub.com/">http://tim.sagepub.com/</a></td></tr>
<tr><td>IMA JOURNAL OF MATHEMATICAL CONTROL AND INFORMATION</td><td>1.6</td><td>Q3</td><td>58/84</td><td>IMA 数学控制与信息杂志</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="https://academic.oup.com/imamci/">https://academic.oup.com/imamci/</a></td></tr>
<tr><td>International Journal of Applied Mathematics and Computer Science</td><td>1.6</td><td>Q3</td><td>58/84</td><td>国际应用数学与计算机科学杂志</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="http://www.amcs.uz.zgora.pl/">http://www.amcs.uz.zgora.pl/</a></td></tr>
<tr><td>INTERNATIONAL JOURNAL OF CONTROL</td><td>1.6</td><td>Q3</td><td>58/84</td><td>国际控制杂志</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="https://www.tandfonline.com/loi/tcon20">https://www.tandfonline.com/loi/tcon20</a></td></tr>
<tr><td>DISCRETE EVENT DYNAMIC SYSTEMS-THEORY AND APPLICATIONS</td><td>1.4</td><td>Q4</td><td>64/84</td><td>离散事件动态系统-理论与应用</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="https://www.springer.com/10626">https://www.springer.com/10626</a></td></tr>
<tr><td>PROCEEDINGS OF THE INSTITUTION OF MECHANICAL ENGINEERS PART I-JOURNAL OF SYSTEMS AND CONTROL ENGINEERING</td><td>1.4</td><td>Q4</td><td>64/84</td><td>机械工程师学会会刊 第一部分-系统与控制工程杂志</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="http://www.sagepub.com/journals/Journal202033">http://www.sagepub.com/journals/Journal202033</a></td></tr>
<tr><td>ESAIM-CONTROL OPTIMISATION AND CALCULUS OF VARIATIONS</td><td>1.3</td><td>Q4</td><td>66/84</td><td>ESAIM-控制优化与变分法</td><td>Q3</td><td></td><td></td><td></td><td></td><td><a href="http://www.esaim-cocv.org/">http://www.esaim-cocv.org/</a></td></tr>
<tr><td>MEASUREMENT &amp; CONTROL</td><td>1.3</td><td>Q4</td><td>66/84</td><td>测量与控制</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="http://mac.sagepub.com/">http://mac.sagepub.com/</a></td></tr>
<tr><td>Archives of Control Sciences</td><td>1.2</td><td>Q4</td><td>69/84</td><td>控制科学档案</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="http://acs.polsl.pl/">http://acs.polsl.pl/</a></td></tr>
<tr><td>Studies in Informatics and Control</td><td>1.2</td><td>Q4</td><td>69/84</td><td>信息学与控制研究</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="http://sic.ici.ro/">http://sic.ici.ro/</a></td></tr>
<tr><td>Revista Iberoamericana de Automatica e Informatica Industrial</td><td>1.1</td><td>Q4</td><td>71/84</td><td>伊比利亚工业自动化与信息学杂志</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="https://www.sciencedirect.com/journal/revista-iberoamericana-de-automatica-e-informatica-industrial-riai">https://www.sciencedirect.com/journal/revista-iberoamericana-de-automatica-e-informatica-industrial-riai</a></td></tr>
<tr><td>INTERNATIONAL JOURNAL OF ROBOTICS &amp; AUTOMATION</td><td>0.8</td><td>Q4</td><td>75/84</td><td>国际机器人与自动化杂志</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="http://www.actapress.com/Content_of_Journal.aspx?JournalID=147">http://www.actapress.com/Content_of_Journal.aspx?JournalID=147</a></td></tr>
<tr><td>MODELING IDENTIFICATION AND CONTROL</td><td>0.7</td><td>Q4</td><td>76/84</td><td>建模、识别与控制</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="http://www.itk.ntnu.no/publikasjoner/mic/mic.html">http://www.itk.ntnu.no/publikasjoner/mic/mic.html</a></td></tr>
<tr><td>AT-Automatisierungstechnik</td><td>0.7</td><td>Q4</td><td>76/84</td><td>AT-自动化技术</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="http://www.degruyter.com/view/j/auto">http://www.degruyter.com/view/j/auto</a></td></tr>
<tr><td>JOURNAL OF DYNAMICAL AND CONTROL SYSTEMS</td><td>0.6</td><td>Q4</td><td>78/84</td><td>动态与控制系统杂志</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="https://link.springer.com/journal/10883">https://link.springer.com/journal/10883</a></td></tr>
<tr><td>AUTOMATION AND REMOTE CONTROL</td><td>0.6</td><td>Q4</td><td>78/84</td><td>自动化与远程控制</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="https://link.springer.com/journal/10513">https://link.springer.com/journal/10513</a></td></tr>
<tr><td>Control Engineering and Applied Informatics</td><td>0.4</td><td>Q4</td><td>82/84</td><td>控制工程与应用信息学</td><td>Q4</td><td></td><td></td><td></td><td></td><td><a href="http://www.ceai.srait.ro/index.php?journal=ceai">http://www.ceai.srait.ro/index.php?journal=ceai</a></td></tr>
<tr><td>Robotic Intelligence and Automation</td><td>N/A</td><td>N/A</td><td>N/A</td><td>机器人智能与自动化</td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody>
</table>
</div>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="工程机械领域期刊"><a class="header" href="#工程机械领域期刊">工程机械领域期刊</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="自动化与控制系统领域期刊"><a class="header" href="#自动化与控制系统领域期刊">自动化与控制系统领域期刊</a></h1>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vla-与具身智能的基本概念"><a href="#vla-与具身智能的基本概念" class="header">VLA 与具身智能的基本概念</a></h1>
<h3 id="011-具身智能embodied-intelligence的定义与核心问题"><a class="header" href="#011-具身智能embodied-intelligence的定义与核心问题">0.1.1 具身智能（Embodied Intelligence）的定义与核心问题</a></h3>
<h4 id="0111-具身智能的基本定义"><a class="header" href="#0111-具身智能的基本定义">0.1.1.1 具身智能的基本定义</a></h4>
<p>从直观上看，“具身智能”就是<strong>有身体的智能</strong>：
智能体不再只是云端的一段代码，而是附着在某种物理载体上——机械臂、轮式底盘、四足机器人、无人机、甚至未来的类人机器人——通过传感器感知环境，再通过执行器对环境施加影响。(<a href="https://www.mdpi.com/2313-7673/9/4/248?utm_source=chatgpt.com">MDPI</a>)</p>
<p>比起纯软件 AI，具身智能至少多了三个关键要素：</p>
<ul>
<li><strong>物理身体（Body）</strong>：带有质量、尺寸、关节、摩擦和磨损的实体，而不是抽象的“向量空间”。</li>
<li><strong>传感器（Sensing）</strong>：摄像头、深度相机、IMU、力/力矩传感器、激光雷达、触觉皮肤等，用来把物理世界转成数据流。</li>
<li><strong>执行器（Actuation）</strong>：电机、关节驱动器、轮子、喷气系统等，将决策转换成真实的力和运动。</li>
</ul>
<p>一个具身智能体（embodied agent）通常被定义为：</p>
<blockquote>
<p>具有物理形态，能够通过传感器感知环境，通过执行器对环境施加作用，并通过这种闭环交互产生、学习和体现智能行为的系统。(<a href="https://www.mdpi.com/2313-7673/9/4/248?utm_source=chatgpt.com">MDPI</a>)</p>
</blockquote>
<p>在本书中，“具身智能”主要指<strong>机器人具身智能</strong>：我们关注的不是抽象哲学讨论，而是如何让具体机器人——机械臂、移动平台、类人机器人——在现实世界里完成各种任务。</p>
<blockquote>
<p><strong>图 1-1（占位）：具身智能基本构成示意</strong>
建议绘制一个方框图：中间是“智能体”，内部有“感知模块”“决策模块”“控制模块”；左侧箭头为来自环境的传感器输入（图像、力觉等），右侧箭头为输出到环境的动作（关节力矩、末端轨迹等），整体构成一个闭环。</p>
</blockquote>
<hr>
<h4 id="0112-核心问题感知认知行动的闭环"><a class="header" href="#0112-核心问题感知认知行动的闭环">0.1.1.2 核心问题：感知–认知–行动的闭环</a></h4>
<p>具身智能最核心的，不是“用了什么模型”，而是<strong>感知–认知–行动（Perception–Cognition–Action）的闭环</strong>如何建立和运行。</p>
<ol>
<li><strong>感知（Perception）</strong>
<ul>
<li>将环境中的光、声、力等物理信号，转换成离散的数字观测：图像、点云、关节编码器读数等。</li>
<li>还需要做状态估计：例如从多帧图像中估计物体的 3D 姿态、机器人自身的位姿等。</li>
</ul>
</li>
<li><strong>认知 / 决策（Cognition / Decision-making）</strong>
<ul>
<li>在高层上理解“现在发生了什么”、“我在哪里”、“目标是什么”、“可能会发生什么”。</li>
<li>典型会涉及任务理解（来自语言指令）、场景语义理解、路径与动作规划、风险评估等。</li>
</ul>
</li>
<li><strong>行动 / 控制（Action / Control）</strong>
<ul>
<li>将高层决策转化成低层可执行的控制命令：关节目标位置、速度、力矩，或者末端位姿增量等。</li>
<li>同时要满足物理约束：电机极限、加速度上限、避免碰撞和自碰等。</li>
</ul>
</li>
</ol>
<p>关键在于，这是一个<strong>实时在线的闭环过程</strong>：机器人一边动作，一边观测新的环境状态，并不断根据反馈调整策略。闭环带来几类核心挑战：</p>
<ul>
<li><strong>实时性</strong>：感知、决策、控制的整体时延必须足够小，才能防止“看到的是刚刚的世界，操作的是此刻的机器”。</li>
<li><strong>适应性</strong>：世界在不断变化，物体位置会变化、光照会变化、地面可能不平整，策略必须能适应分布偏移。</li>
<li><strong>安全性</strong>：误判和延迟直接对应物理风险——撞到人、打翻物体、损坏设备——安全约束必须成为一等公民，而不是事后补丁。</li>
</ul>
<blockquote>
<p><strong>图 1-2（占位）：感知–认知–行动闭环流程图</strong>
建议以时间轴画出：感知模块从环境读取信息 → 认知模块产生决策 → 控制模块输出动作 → 环境状态改变 → 再次感知，如同一个循环控制系统。</p>
</blockquote>
<p>在纯软件 AI 中，模型错误最多导致“答错题”；在具身智能中，同样的错误会变成“砸到人”。这也是为什么具身智能研究必须同时考虑<strong>智能性</strong>与<strong>工程可控性</strong>。</p>
<hr>
<h4 id="0113-具身智能的典型实例"><a class="header" href="#0113-具身智能的典型实例">0.1.1.3 具身智能的典型实例</a></h4>
<p>为了让概念不那么抽象，这里列举几个日常能见到或正在快速出现的具身智能系统：</p>
<ol>
<li><strong>自主移动机器人</strong>
<ul>
<li>仓储物流中的 AGV / AMR（自动引导车 / 自主移动机器人），需要在复杂仓库内自主导航、避障、搬运货物。</li>
<li>外卖配送机器人、无人配送车，需要在室外环境中应对行人、车辆和路况变化。</li>
</ul>
</li>
<li><strong>家庭服务机器人</strong>
<ul>
<li>扫地机器人是最早大规模商业化的具身智能产品之一：通过简单传感器和策略完成地面覆盖、避障和回充。</li>
<li>新一代“家庭助手”机器人（如具备机械臂和视觉系统的家务机器人）正在尝试完成叠衣服、收拾桌面、做简单烹饪等任务。(<a href="https://www.theguardian.com/world/2025/apr/21/humanoid-workers-and-surveillance-buggies-embodied-ai-is-reshaping-daily-life-in-china?utm_source=chatgpt.com">卫报</a>)</li>
</ul>
</li>
<li><strong>工业协作机器人（Cobot）</strong>
<ul>
<li>在制造业中与人协作的机械臂，需要在安全约束下完成装配、搬运等任务，同时感知人的位置与意图。</li>
</ul>
</li>
<li><strong>自动驾驶与无人机</strong>
<ul>
<li>自动驾驶车辆通过多种传感器感知道路环境，在速度、转向和制动之间做出实时决策。</li>
<li>无人机在城市或灾害场景中执行巡检、救援任务，对风场、障碍物和通信质量都有感知与适应需求。</li>
</ul>
</li>
</ol>
<p>这些系统的共同点是：</p>
<blockquote>
<p><strong>必须把“看懂世界”和“在世界中行动”结合起来。</strong></p>
</blockquote>
<p>本书在后续章节会从数学基础、机器学习到 VLA 架构，逐步展开“如何让这些具身系统更聪明、更通用”的技术路径。</p>
<hr>
<h3 id="012-从-cv--nlp-到-vlm再到-vla-的发展脉络"><a class="header" href="#012-从-cv--nlp-到-vlm再到-vla-的发展脉络">0.1.2 从 CV / NLP 到 VLM，再到 VLA 的发展脉络</a></h3>
<p>具身智能的崛起，并不是凭空出现，而是建立在过去十多年 <strong>CV（计算机视觉）</strong>、<strong>NLP（自然语言处理）</strong> 和 <strong>多模态学习</strong> 的连续突破之上。</p>
<h4 id="0121-cv计算机视觉的演进从特征工程到深度视觉"><a class="header" href="#0121-cv计算机视觉的演进从特征工程到深度视觉">0.1.2.1 CV（计算机视觉）的演进：从特征工程到深度视觉</a></h4>
<p>在深度学习普及之前，视觉主要依赖手工特征（如 SIFT、HOG） + 传统分类器（如 SVM、随机森林）来完成图像识别和检测。</p>
<p>2012 年，AlexNet 在 ImageNet 图像分类竞赛上以巨大优势夺冠，被普遍认为是深度学习在视觉领域的“分水岭事件”：它证明了在大规模数据和 GPU 支持下，<strong>多层卷积网络可以远远超越传统方法</strong>。(<a href="https://en.wikipedia.org/wiki/AlexNet?utm_source=chatgpt.com">维基百科</a>)</p>
<p>此后几十个经典视觉任务迅速被深度网络主导：</p>
<ul>
<li>图像分类：ResNet、DenseNet 等结构极大提升了识别精度。</li>
<li>目标检测：R-CNN 系列、YOLO 等方法能在自然场景中定位并分类多个物体。</li>
<li>图像分割：U-Net、Mask R-CNN 等结构让像素级理解成为现实。</li>
</ul>
<p>再往后，视觉 Transformer（ViT）等架构开始出现，将 Transformer 引入图像领域，用全局自注意力替代或补充卷积。本书第 3 章会更系统地介绍这些视觉表示，但在这里需要记住一件事：</p>
<blockquote>
<p><strong>现代机器人视觉基本都站在深度视觉的肩膀上。</strong></p>
</blockquote>
<p>没有这波视觉革命，就没有今天 VLM 和 VLA 的数据基础与网络骨干。</p>
<hr>
<h4 id="0122-nlp自然语言处理的演进从统计到大语言模型"><a class="header" href="#0122-nlp自然语言处理的演进从统计到大语言模型">0.1.2.2 NLP（自然语言处理）的演进：从统计到大语言模型</a></h4>
<p>NLP 的发展路径与视觉类似，也经历了从“手工 + 统计”到“神经网络 + 大模型”的演变：</p>
<ol>
<li><strong>统计时代</strong>
<ul>
<li>以 n-gram 语言模型、HMM、CRF 和统计机器翻译为代表，主要依靠共现统计和概率图模型。</li>
<li>这一阶段的模型难以捕捉长距离依赖，对上下文理解有限。</li>
</ul>
</li>
<li><strong>神经网络时代</strong>
<ul>
<li>词向量（word2vec、GloVe）将离散单词映射到连续向量空间，为神经网络建模语言准备了输入表示。</li>
<li>RNN / LSTM / GRU 等序列模型开始用于机器翻译、语言建模和问答。</li>
</ul>
</li>
<li><strong>Transformer 与大语言模型时代</strong>
<ul>
<li>2017 年提出的 Transformer 架构完全基于自注意力机制，抛弃了循环结构，实现了更高并行度和更长程依赖建模能力。(<a href="https://arxiv.org/abs/1706.03762?utm_source=chatgpt.com">arXiv</a>)</li>
<li>随着算力和数据规模的扩张，BERT、GPT 等大规模预训练语言模型出现；GPT-3 等模型以数百亿到千亿参数规模，在多种语言任务上展现出强大的生成与推理能力。(<a href="https://www.aryaxai.com/article/what-are-large-language-models-llms-key-milestones-and-trends?utm_source=chatgpt.com">aryaxai.com</a>)</li>
<li>2022 年开始，ChatGPT 等对话式系统的出现，让公众第一次直观感受到“语言模型几乎可以扮演一个通用文本助手”。(<a href="https://hatchworks.com/blog/gen-ai/large-language-models-guide/?utm_source=chatgpt.com">HatchWorks AI</a>)</li>
</ul>
</li>
</ol>
<p>对机器人来说，这意味着：</p>
<blockquote>
<p><strong>我们第一次拥有能够“理解人类复杂指令、推理意图并生成多步计划”的通用语言模块。</strong></p>
</blockquote>
<p>这也为后续“用自然语言给机器人下任务”奠定了基础。</p>
<hr>
<h4 id="0123-vlm视觉语言模型的兴起跨模态对齐的第一步"><a class="header" href="#0123-vlm视觉语言模型的兴起跨模态对齐的第一步">0.1.2.3 VLM（视觉–语言模型）的兴起：跨模态对齐的第一步</a></h4>
<p>有了强大的视觉和语言模型，下一步自然问题是：<strong>能不能让模型同时理解图像和文本？</strong></p>
<p>视觉–语言模型（VLM）正是回答这一问题的代表。以 CLIP 为例：(<a href="https://en.wikipedia.org/wiki/Contrastive_Language-Image_Pre-training?utm_source=chatgpt.com">维基百科</a>)</p>
<ul>
<li>使用双编码器结构：一个图像编码器（通常是 CNN/ViT），一个文本编码器（通常是 Transformer）。</li>
<li>在海量图文对（image–text pairs）上进行对比学习：
<ul>
<li>让配对的图像–文本向量在特征空间中更接近；</li>
<li>让不匹配的图像–文本向量更远。</li>
</ul>
</li>
<li>训练完成后，可以实现：
<ul>
<li>图文检索（以文找图、以图找文）；</li>
<li>零样本分类（用文字描述类别，无需额外标注即可做图像分类）；</li>
<li>图像内容粗粒度描述等。</li>
</ul>
</li>
</ul>
<p>其他 VLM（如 Flamingo、PaLI-X、BLIP 系列等）进一步加入生成能力和更复杂的跨模态推理，但共同点是：</p>
<blockquote>
<p><strong>VLM 让模型第一次在“屏幕世界”中同时理解图像和文本。</strong></p>
</blockquote>
<p>然而 VLM 主要还是“看图说话”或“用文字回答关于图像的问题”，它们<strong>不直接输出物理世界中的动作</strong>。在机器人语境中，这种能力更适合作为“理解任务和场景的上层模块”。</p>
<blockquote>
<p><strong>图 1-3（占位）：从 CV / NLP → VLM → VLA 的演进谱系</strong>
建议画一条时间箭头：左边是单模态 CV / NLP，中间是 VLM（图像 + 文本对齐），右边是 VLA（图像 + 文本 + 动作轨迹），以示范模态的逐步扩张。</p>
</blockquote>
<hr>
<h4 id="0124-vla视觉语言动作的出现走向物理世界的关键一步"><a class="header" href="#0124-vla视觉语言动作的出现走向物理世界的关键一步">0.1.2.4 VLA（视觉–语言–动作）的出现：走向物理世界的关键一步</a></h4>
<p>VLM 解决了“看图 + 理解语言”的问题，但还缺少一个关键环节：<strong>如何把这种理解转化为机器人动作？</strong></p>
<p>这正是 VLA（Vision–Language–Action）模型的出发点。根据近年的综述与定义，VLA 通常指：(<a href="https://en.wikipedia.org/wiki/Vision-language-action_model?utm_source=chatgpt.com">维基百科</a>)</p>
<blockquote>
<p>输入：视觉观测（单帧图像或视频） + 语言指令
输出：可以直接在机器人上执行的低层动作（如末端 6-DoF 运动 + 手爪开合），通常以离散化的动作 token 或连续控制向量形式表示。</p>
</blockquote>
<p>典型的 VLA 架构一般分两步：</p>
<ol>
<li><strong>视觉–语言编码</strong>
<ul>
<li>复用一个预训练的 VLM 或多模态大模型，将图像和指令编码到统一的隐空间中。</li>
</ul>
</li>
<li><strong>动作解码</strong>
<ul>
<li>在大量“（图像，指令，动作轨迹）”三元组示教数据上进行微调，学习从隐空间表示到具体机器人动作序列的映射。</li>
</ul>
</li>
</ol>
<p>Google DeepMind 的 RT-2 被广泛认为是确立 VLA 概念的重要工作之一：它在大规模互联网图文预训练基础上，利用真实机器人示教数据微调，使机器人具备“把网页学来的知识迁移到现实操作”的初步能力，例如理解“扔垃圾”“收拾桌面”等语义指令。(<a href="https://arxiv.org/abs/2307.15818?utm_source=chatgpt.com">arXiv</a>)</p>
<p>此后，包括 Octo、OpenVLA、Gemini Robotics 等在内的一系列 VLA 模型陆续提出，支持更多机器人平台、更复杂任务以及更高频实时控制。(<a href="https://arxiv.org/abs/2510.07077?utm_source=chatgpt.com">arXiv</a>)</p>
<p>从研究路线看：</p>
<ul>
<li><strong>CV / NLP</strong>：在各自模态里学会“看得懂 / 听得懂”。</li>
<li><strong>VLM</strong>：在屏幕世界中学会“把看到的”和“说出来的”对齐。</li>
<li><strong>VLA</strong>：在物理世界中学会“在理解之上行动”。</li>
</ul>
<p>本书第 8 章会从架构角度系统展开 VLA 的设计，这里把它放在历史脉络中，作为一个过渡和总览。</p>
<hr>
<h3 id="013-vla-在通用机器人与通用智能中的角色定位"><a class="header" href="#013-vla-在通用机器人与通用智能中的角色定位">0.1.3 VLA 在通用机器人与通用智能中的角色定位</a></h3>
<p>有了 VLA 这个概念，还需要思考：<strong>它在更大版图中的位置是什么？</strong>
也就是：VLA 对“通用机器人”和“通用人工智能（AGI）”意味着什么？</p>
<h4 id="0131-通用机器人的愿景从专用工具到通用助手"><a class="header" href="#0131-通用机器人的愿景从专用工具到通用助手">0.1.3.1 通用机器人的愿景：从专用工具到通用助手</a></h4>
<p>传统工业机器人通常是“专用工具”：</p>
<ul>
<li>工作空间固定（如生产线某一工位）。</li>
<li>任务高度确定（重复装配、焊接、搬运）。</li>
<li>编程方式偏底层（示教器逐点示教、手工编程轨迹）。</li>
</ul>
<p>而所谓“通用机器人”（general-purpose robot）的愿景是：</p>
<ul>
<li><strong>任务多样</strong>：能在不同环境下完成清理、搬运、整理、协作等多种任务。</li>
<li><strong>指令自然</strong>：人类用日常语言描述目标，而不是写程序或给出复杂坐标。</li>
<li><strong>适应变化</strong>：面对新物体、新布局、新任务组合时，依然能凭借已有知识和少量演示快速适应。(<a href="https://arxiv.org/abs/2510.07077?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>在这样的系统中，VLA 模型被视作<strong>机器人的“通用大脑候选”</strong>：</p>
<ul>
<li>通过视觉–语言–动作统一建模，从原始摄像头图像、自然语言指令直接生成低层控制命令。</li>
<li>同一模型可以在多个机器人平台和任务上共享，只需要对输入输出做适配。</li>
</ul>
<p>当然，现实系统中 VLA 往往不会“单独统治一切”，而是与传统导航、运动规划、安全控制模块共同工作——这部分将在第 10 章详细展开。</p>
<hr>
<h4 id="0132-vla-模型的作用把人类友好指令转成机器人可执行行动"><a class="header" href="#0132-vla-模型的作用把人类友好指令转成机器人可执行行动">0.1.3.2 VLA 模型的作用：把“人类友好指令”转成“机器人可执行行动”</a></h4>
<p>从系统架构上看，VLA 模型扮演的是**“从语义到控制”的桥梁**角色：</p>
<ol>
<li><strong>在输入侧</strong>
<ul>
<li>语言侧：接收用户的自然语言描述，例如“把桌上的五本书按大小从左到右排好”。</li>
<li>视觉侧：接收当前场景的相机图像或视频，理解桌子、书本的位置、姿态、遮挡等信息。</li>
</ul>
</li>
<li><strong>在内部表示侧</strong>
<ul>
<li>将“文本目标”和“视觉场景”映射到统一隐空间，形成对“当前状态 + 目标”的综合理解。</li>
<li>这种表示既包含语义抽象（例如“按大小排序”），也包含几何约束（书本的位置、可抓取区域）。(<a href="https://en.wikipedia.org/wiki/Vision-language-action_model?utm_source=chatgpt.com">维基百科</a>)</li>
</ul>
</li>
<li><strong>在输出侧</strong>
<ul>
<li>生成连续时间下的一系列动作：接近目标书本、调整姿态、闭合手爪、移动到目标位置、松开等。</li>
<li>在更高层，可以输出子任务序列或动作原语，由下层控制器进一步实现。</li>
</ul>
</li>
</ol>
<p>相比传统“人写规则 + 手工调参”的机器人系统，VLA 带来的变化主要有三点：</p>
<ul>
<li><strong>指令接口更自然</strong>：用户不用会编程，只需像与人类助手沟通一样给任务。</li>
<li><strong>任务泛化能力更强</strong>：通过在多任务、多场景数据上的统一训练，模型有机会学习到跨任务共性的技能。(<a href="https://arxiv.org/abs/2510.07077?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>与大语言模型深度结合</strong>：可以直接利用 LLM 的规划和推理能力，生成步骤，再由 VLA 承接落地为动作（本书第 4、8 章会详细展开这种接口）。</li>
</ul>
<hr>
<h4 id="0133-里程碑意义vla-作为通往-agi-的实践路径之一"><a class="header" href="#0133-里程碑意义vla-作为通往-agi-的实践路径之一">0.1.3.3 里程碑意义：VLA 作为通往 AGI 的实践路径之一</a></h4>
<p>“通用人工智能（AGI）”是一个仍然带有争议的概念，但有一个共识正在形成：</p>
<blockquote>
<p><strong>如果一种智能从来不与现实世界交互，只在文本或比特空间中“自言自语”，那么它的能力终究是受限的。</strong></p>
</blockquote>
<p>具身智能和 VLA 提供了一条**“从虚拟走向物理”的实践路径**：</p>
<ol>
<li><strong>在物理世界中检验理解与推理</strong>
<ul>
<li>语言模型在对话中会出现幻觉，但当它驱动机器人执行任务时，错误会有非常具体的表现（抓错物体、路径碰撞等），这迫使我们设计更严谨的评测和训练范式。(<a href="https://arxiv.org/abs/2510.07077?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>让模型在长时间、长尺度上积累经验</strong>
<ul>
<li>通用机器人需要在长期部署中持续适应环境变化，这与 AGI 中“终身学习、持续学习”的目标高度一致。</li>
<li>新一代 VLA 研究已开始引入世界模型、长序列记忆等模块，尝试让机器人能在内部模拟未来并规划行动。(<a href="https://arxiv.org/abs/2510.07077?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>统一多模态、多机器人、多任务的基础模型</strong>
<ul>
<li>最新的 VLA 系统（如 Gemini Robotics、Helix 等）强调一个模型可以驱动多种机器人形态（机械臂、双臂、类人等），并执行多种任务，向“具身基础模型”方向演进。(<a href="https://www.reuters.com/technology/google-introduces-new-ai-models-rapidly-growing-robotics-industry-2025-03-12/?utm_source=chatgpt.com">Reuters</a>)</li>
</ul>
</li>
</ol>
<p>从这个角度看，VLA 的意义远不只是“让机器人更好用”：</p>
<ul>
<li>对机器人学，它是通向“通用机器人助手”的关键一环；</li>
<li>对人工智能整体，它是把大模型能力从虚拟世界映射到物理世界的桥梁，为讨论“真正有用的 AGI”提供了具体实验平台。</li>
</ul>
<blockquote>
<p><strong>图 1-4（占位）：VLA 在“AGI 版图”中的位置示意图</strong>
建议画一个同心圆或多层结构：最内层为“感知–控制”，外层为“多模态大模型”，再外一层为“具身基础模型 / VLA”，最外层为“AGI 应用场景”，展示 VLA 处于“多模态智能”和“物理世界”交汇处。</p>
</blockquote>
<hr>
<h3 id="小结与后续衔接"><a class="header" href="#小结与后续衔接">小结与后续衔接</a></h3>
<p>在本节中，我们完成了三件事：</p>
<ol>
<li>给出了<strong>具身智能</strong>的工作定义，并强调了感知–认知–行动闭环和安全约束。</li>
<li>从历史脉络梳理了从 <strong>CV / NLP → VLM → VLA</strong> 的技术演进。</li>
<li>讨论了 <strong>VLA 在通用机器人和 AGI 中的角色</strong>，把它放在更大的技术版图中定位。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="研究生阶段需要具备的能力画像"><a href="#研究生阶段需要具备的能力画像" class="header">研究生阶段需要具备的能力画像</a></h1>
<h3 id="021-能读懂论文的能力理论公式与实验理解"><a class="header" href="#021-能读懂论文的能力理论公式与实验理解">0.2.1 “能读懂论文”的能力：理论、公式与实验理解</a></h3>
<p>在具身智能/VLA 领域，<strong>读论文的最终目标不是“看完”，而是能做到三件事</strong>：
1）判断这篇工作值不值得你投入时间；
2）真正搞懂它的理论与实现；
3）知道该如何在自己的系统里使用、改造甚至超越它。</p>
<p>很多计算机科学教育都推荐类似的“多遍阅读法”，例如 Keshav 提出的“三遍读论文”方法：第一遍抓大意，第二遍扣细节，第三遍才考虑完全复现与质疑。(<a href="https://dl.acm.org/doi/10.1145/1273445.1273458?utm_source=chatgpt.com">ACM Digital Library</a>)
下面三个小节，分别从理论、公式和实验三个维度，把“能读懂论文”变成一套可训练的具体能力。</p>
<hr>
<h4 id="0211-理论基础"><a class="header" href="#0211-理论基础">0.2.1.1 理论基础</a></h4>
<p><strong>“理论基础”在这里不只是指你上过哪些课，而是：你能否把论文中的新概念，准确地挂在自己已有的知识框架上。</strong></p>
<p>一个典型的具身智能/VLA 论文，往往同时包含：</p>
<ul>
<li>深度学习表征（视觉 backbone、Transformer 等）</li>
<li>强化学习/模仿学习或决策理论</li>
<li>控制与机器人学（运动学、动力学、控制结构）</li>
<li>少量概率与优化理论（损失函数、收敛性说明等）</li>
</ul>
<p>对应的“能读懂”，至少包括以下几个层次：</p>
<ol>
<li><strong>识别“这是哪一类方法”。</strong>
读方法部分时，先粗暴分类：
<ul>
<li>这是 RL/IL 为主的策略学习，还是纯行为克隆？</li>
<li>视觉部分是 CNN、ViT 还是直接用预训练 CLIP/VLM？</li>
<li>动作是在关节空间优化，还是末端空间规划？
这些大类标签可以帮你快速把论文挂到自己脑中的“地图”上，知道该召回哪一块理论。</li>
</ul>
</li>
<li><strong>找出论文依赖的“旧理论”与“新假设”。</strong>
每篇论文都有“建在谁的肩膀上”和“自己新加的一小块砖”，
<ul>
<li>旧理论：如 Bellman 方程、策略梯度、Transformer、自注意力、阻抗控制等，后文会在对应章节系统展开。</li>
<li>新假设：例如“视觉编码器已经有足够语义能力”“仿真环境与现实差距可以通过域随机化弥补”等。
读方法时要刻意标注：哪些是教科书级别的东西，哪些是作者自己特有的设定。</li>
</ul>
</li>
<li><strong>在脑中重画“模块框图”。</strong>
对具身智能论文，最实用的做法是自己画一个简化版框图：
<ul>
<li>输入：多帧图像 + 语言指令 + 机器人状态；</li>
<li>中间：视觉编码、语言编码、融合模块、策略 head；</li>
<li>输出：动作表示（轨迹、关节增量、动作 token 等）。
这一步大幅降低你对符号和细节的恐惧感，帮助你把复杂理论收束成几个可理解的模块。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图片占位】
<strong>图 1-2-1：典型 VLA 论文整体结构示意图</strong>
输入模态、模型模块、训练目标、输出动作，用方框图体现，并标出理论依赖（RL / IL / 控制 / 表征学习）。</p>
</blockquote>
<ol start="4">
<li><strong>用“你自己的话”复述论文的核心思想。</strong>
读完方法部分后，尝试用 2–3 句话，向一个“只懂基础 ML，不懂机器人”的同学解释这篇论文在做什么。这是检验你理论理解是否到位的最好自测。</li>
</ol>
<hr>
<h4 id="0212-公式推演理解"><a class="header" href="#0212-公式推演理解">0.2.1.2 公式推演理解</a></h4>
<p>许多同学看到密密麻麻的公式会条件反射：“这我不行”。实际上，绝大多数机器人学习与 VLA 论文中的公式，都可以归结为几类“常见套路”：</p>
<ul>
<li><strong>“期望 + 损失”型公式</strong>：例如行为克隆、策略梯度、多模态对比学习等。</li>
<li><strong>“贝尔曼方程”型递推公式</strong>：在强化学习与世界模型中频繁出现。</li>
<li><strong>“几何与坐标变换”型公式</strong>：在相机标定、手眼标定、运动学里用到。</li>
</ul>
<p>“能读懂公式”，不等于能完整重做所有推导，而是至少要做到：</p>
<ol>
<li><strong>逐个符号对齐语义。</strong>
建议自己养成习惯：
<ul>
<li>打印论文或在平板上阅读时，<strong>把所有出现的符号单独列一张表</strong>：$ s, a, o, x, z, \theta, \phi, \pi, f, g,\dots $</li>
<li>标注其物理或语义含义（例如：$ s $ 是机器人 + 环境状态，$ o $ 是观测，$ a $ 是动作，$ \theta $ 是策略参数）。
许多困惑来自于“同一个字母在不同论文里代表不同概念”，你要主动做 disambiguation。</li>
</ul>
</li>
<li><strong>做“维度检查”和极端情形检查。</strong>
当你看到类似</li>
<li></li>
</ol>
<p>$$
\mathcal{L}(\theta) = \mathbb{E}<em>{(o,a)\sim \mathcal{D}}[-\log \pi</em>\theta(a|o)]
$$</p>
<p>快速检查：
- $ \mathcal{L} $  是标量；
- 期望外面是损失，内部是对数概率；
- 特殊情况：如果只有单步动作，这就退化为普通分类交叉熵。
通过极端/退化情形帮助你把公式和熟悉的机器学习形态对齐。</p>
<ol start="3">
<li>
<p><strong>只在关键一步上“重推”公式。</strong>
真正值得你亲手推导的往往是那些<strong>和算法结构直接对应的公式</strong>，比如：</p>
<ul>
<li>策略梯度的推导如何引出“log π × 回报”的形式；</li>
<li>对比学习损失如何引出相似度的 softmax；</li>
<li>世界模型中 ELBO（证据下界）如何对应到重建和 KL 散度两项。
这些推导是后续你修改损失函数、做 variant 时的基础。</li>
</ul>
</li>
<li>
<p><strong>在代码里“找回”公式。</strong>
很多论文里的公式，在开源实现中通常会直接变成几行 PyTorch 代码。
通过比对代码与公式：</p>
<ul>
<li>你可以验证自己是否读对了符号；</li>
<li>也会发现一些作者没有在论文中写清楚的 trick（如归一化、clip、mask）。
这种“从公式回到实现”的能力，对之后复现与做新工作非常重要。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图片占位】
<strong>图 1-2-2：从论文公式到代码实现的对照示意图</strong>
左边为损失函数数学表达式，右边为对应的伪代码 / PyTorch 代码片段，用箭头将对应项连线。</p>
</blockquote>
<hr>
<h4 id="0213-实验解析"><a class="header" href="#0213-实验解析">0.2.1.3 实验解析</a></h4>
<p>在机器学习与机器人领域，<strong>实验不是“装饰”，而是论证正确性的主体</strong>。近几年顶会也越来越强调可复现性和实验规范，例如 JMLR 等期刊对 ML 研究的复现性提出了系统建议，涉及代码、数据、随机性控制等方面。(<a href="https://www.jmlr.org/papers/volume22/20-303/20-303.pdf?utm_source=chatgpt.com">机器学习研究期刊</a>)</p>
<p>你在读实验时，至少要具备以下几个能力：</p>
<ol>
<li><strong>读懂实验设置：任务、环境与基准。</strong>
具身智能论文的实验通常包括：
<ul>
<li>仿真环境（例如 Mujoco、Isaac Gym）中的操作任务；</li>
<li>真实机器人平台（机械臂型号、末端执行器、相机布局等）；</li>
<li>标准基准任务或自建任务（如抓取成功率、开门、收纳等）。
你要能回答：<strong>“作者到底在什么条件下测试了什么能力？”</strong></li>
</ul>
</li>
<li><strong>理解评价指标与统计意义。</strong>
<ul>
<li>在操作任务中，最常见的指标是<strong>成功率</strong>（%）、平均完成时间、路径长度等；</li>
<li>还会看到标准差、置信区间或箱线图，表示多次试验的波动性。
你需要关注：</li>
<li>差异是 5% 还是 30%？</li>
<li>是否有足够的重复次数支撑这个差异？</li>
<li>是否只在一两个特定场景好看，而在更难场景无优势？</li>
</ul>
</li>
<li><strong>学会阅读消融实验（ablation study）。</strong>
消融实验是理解论文“真贡献”的关键：
<ul>
<li>比如：“没有语言条件”“没有历史轨迹”“不用预训练视觉”时性能下降多少？</li>
<li>哪个模块/损失/训练阶段对结果最关键？
读消融实验时，可以逆向思考：<strong>如果你删掉这个模块，系统会怎样退化？</strong> 这会帮助你在未来复现时决定“哪些可以简化，哪些必须保留”。</li>
</ul>
</li>
<li><strong>关注复现条件与实验细节。</strong>
近年的复现性研究指出，<strong>即便有代码和数据，能否复现结果仍高度依赖环境、超参数与随机性控制等</strong>。(<a href="https://arxiv.org/html/2406.14325v1?utm_source=chatgpt.com">arXiv</a>)
阅读实验部分时，建议刻意寻找：
<ul>
<li>是否公开了代码和模型？</li>
<li>是否说明了关键超参数（学习率、batch size、训练步数）；</li>
<li>是否陈述了硬件配置和训练时间；</li>
<li>是否提到种子、不同随机初始化下的稳定性。</li>
</ul>
</li>
<li><strong>用“是否值得复现”来检验理解程度。</strong>
读完一篇论文的实验部分，你可以给自己几个问题：
<ul>
<li>我能画出一个简化版的实验流程图吗？</li>
<li>如果让我做第一次复现，我知道从哪开始（仿真/真实平台/哪个任务）吗？</li>
<li>有哪些细节我还不确定，需要翻代码或附录确认？</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图片占位】
<strong>图 1-2-3：具身智能论文实验结构示意图</strong>
展示环境设置、数据采集、训练、评估指标、可视化结果等模块之间的关系。</p>
</blockquote>
<hr>
<h3 id="022-能复现系统的能力代码阅读调试与工程落地"><a class="header" href="#022-能复现系统的能力代码阅读调试与工程落地">0.2.2 “能复现系统”的能力：代码阅读、调试与工程落地</a></h3>
<p>在具身智能/VLA 方向，“只看懂论文不写一行代码”的价值非常有限。你真正能站稳脚跟的标志，是<strong>可以根据论文与开源资源，把一个系统在自己的环境中跑起来，并根据需要进行修改和调优</strong>。这既是科研能力，也是工程能力。</p>
<p>近年来，ML 社区围绕“可复现性”（reproducibility）形成了越来越细致的标准，包括代码公开、依赖管理、实验脚本与数据版本化等。(<a href="https://www.jmlr.org/papers/volume22/20-303/20-303.pdf?utm_source=chatgpt.com">机器学习研究期刊</a>)
本小节不讲具体语言语法，而是谈“编程功底”“代码阅读”“工程实践”三个层次的能力画像。</p>
<hr>
<h4 id="0221-编程功底"><a class="header" href="#0221-编程功底">0.2.2.1 编程功底</a></h4>
<p>在本书涉及的方向，你至少需要具备以下层面的编程能力：</p>
<ol>
<li><strong>工具链熟练度，而非“背 API”。</strong>
<ul>
<li>Python（用于深度学习、数据处理、脚本）；</li>
<li>至少了解一种深度学习框架（PyTorch/TensorFlow，以 PyTorch 为主）；</li>
<li>基本 Linux 命令、Shell 脚本、git 版本控制。
“熟练”的含义是：你看到陌生项目时，能<strong>通过查官方文档和搜索，在合理时间内完成环境搭建与小修改</strong>，而不是全部记住函数签名。</li>
</ul>
</li>
<li><strong>理解“从数据到模型”的最小 pipeline。</strong>
理想状态：你能从零写出一个小型项目，包括：
<ul>
<li>数据加载（Dataset/DataLoader）；</li>
<li>模型定义（一个包含前向传播的类）；</li>
<li>训练循环（前向、计算 loss、backward、optimizer.step）；</li>
<li>日志与模型保存。
本书后续关于深度学习与 RL 的章节会反复使用类似的结构，这里你只需意识到：<strong>有能力写出这样一个最小 pipeline，是复现任何论文的起点。</strong></li>
</ul>
</li>
<li><strong>基本的调试意识。</strong>
<ul>
<li>能使用断点、打印张量维度和统计信息；</li>
<li>遇到 NaN、显存溢出、梯度为 0 或爆炸时，知道从哪些方向排查；</li>
<li>知道如何简化问题（先在更小的数据/更简单的模型上跑通）。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="0222-代码阅读"><a class="header" href="#0222-代码阅读">0.2.2.2 代码阅读</a></h4>
<p>现实情况是：越来越多的机器人与 VLA 论文会提供 GitHub 仓库，仓库中的 README 和脚本组织，对复现至关重要。(<a href="https://sudochia.medium.com/common-problems-when-reproducing-a-machine-learning-paper-17178515d6c6?utm_source=chatgpt.com">Medium</a>)</p>
<p>“能读懂代码”，至少包括：</p>
<ol>
<li><strong>先读文档和 README，而不是直接打开源码。</strong>
一个规范的 ML 项目 README 通常会包含：(<a href="https://sudochia.medium.com/common-problems-when-reproducing-a-machine-learning-paper-17178515d6c6?utm_source=chatgpt.com">Medium</a>)
<ul>
<li>依赖与环境（Python 版本、依赖库、CUDA 等）；</li>
<li>数据准备方式（数据下载脚本、预处理脚本）；</li>
<li>训练与评估命令；</li>
<li>预训练模型权重位置以及预期结果。
你应该从这里倒推出整套 pipeline，再去对应地找脚本与模块文件。</li>
</ul>
</li>
<li><strong>识别“主干脚本”和“关键模块”。</strong>
在一个典型的项目中：
<ul>
<li><code>train.py</code> / <code>main.py</code>：训练主流程；</li>
<li><code>model/</code> 或 <code>networks/</code>：模型结构定义；</li>
<li><code>data/</code> 或 <code>datasets/</code>：数据加载相关；</li>
<li><code>configs/</code> 或 YAML 文件：实验配置；</li>
<li><code>scripts/</code>：批量运行或复现实验的脚本。
你的目标是先弄清“执行顺序”和“数据流向”，而不是一开始就试图看懂每一个函数。</li>
</ul>
</li>
<li><strong>将论文结构与代码结构对齐。</strong>
<ul>
<li>论文中每一个重要模块，都应该能在代码里找到对应类或函数（例如 <code>VisualEncoder</code>, <code>PolicyNetwork</code>, <code>WorldModel</code> 等）；</li>
<li>你可以在注释或笔记中记录：论文图中的 Block A ≈ <code>module_a.py</code> 中的某个类。
当你需要做修改（替换视觉 backbone、改损失函数）时，这个对齐表会非常重要。</li>
</ul>
</li>
<li><strong>最小复现：先复现“作者写在 README 里的结果”。</strong>
在试图“改论文”之前，先按 README 的说明跑一遍官方实验，看看结果是否接近论文中的主表或主曲线。如果复现差异太大，优先检查：
<ul>
<li>数据是否下载完全、预处理一致；</li>
<li>配置文件是否和论文默认设置相同；</li>
<li>随机种子与 GPU 数量是否影响结果。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图片占位】
<strong>图 1-2-4：典型深度学习/机器人项目目录结构示意图</strong>
展示 <code>configs/、data/、models/、train.py、eval.py</code> 等，并用箭头表示主执行路径。</p>
</blockquote>
<hr>
<h4 id="0223-工程实践"><a class="header" href="#0223-工程实践">0.2.2.3 工程实践</a></h4>
<p>“能复现系统”最终落点，是你能把算法<strong>放进真实或仿真机器人系统中运行</strong>，这比在 GPU 上跑一个离线脚本要复杂得多。</p>
<p>你需要逐步培养以下几个层次的能力：</p>
<ol>
<li><strong>把算法变成“服务”或“模块”。</strong>
不管底层是 PyTorch 还是 TensorFlow，最终在机器人系统中，它需要：
<ul>
<li>有清晰的输入输出接口（例如订阅图像话题、发布关节命令）；</li>
<li>能够以指定频率运行（例如每秒 5–10 次推理）；</li>
<li>遇到错误时能优雅失败（给出安全动作、记录日志，而不是整个系统崩溃）。
这要求你理解后续章节中 ROS/系统架构相关内容，但在这里要意识到：<strong>工程落地 ≠ 把 <strong><code>python script.py</code></strong> 设为开机自启这么简单。</strong></li>
</ul>
</li>
<li><strong>考虑资源与环境差异。</strong>
实际机器人常用的嵌入式设备算力有限，因此：
<ul>
<li>在服务器上训练好的大模型，可能无法直接部署；</li>
<li>需要考虑模型剪枝、量化、蒸馏等方法（对应后文部署章节）；</li>
<li>环境差异（仿真 vs 真实，实验室 vs 实际场景）也会导致性能偏差，需要你通过参数调整和少量再训练来修补。</li>
</ul>
</li>
<li><strong>建立日志与监控习惯。</strong>
复现系统时，必须要有“可观察性”：
<ul>
<li>记录关键指标：成功率、失败类型、延迟、资源占用；</li>
<li>在异常情况下保留数据（传感器记录、模型输出、系统状态），方便事后分析；</li>
<li>对机器人任务，最好能录像或用可视化工具记录轨迹。</li>
</ul>
</li>
<li><strong>把安全性放在一开始考虑。</strong>
在具身系统中，“跑不起来”只是麻烦，“跑错了”则可能砸坏硬件甚至伤人。
因此，在<strong>第一次部署</strong>任何新策略时，建议：
<ul>
<li>限制速度和力矩；</li>
<li>设定物理安全区域和急停策略；</li>
<li>尽量先在仿真中测试极端情况。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图片占位】
<strong>图 1-2-5：从论文到代码到机器人系统的落地流程图</strong>
论文 → 开源代码 → 本地复现 → 仿真集成 → 真实机器人部署，各阶段的输入输出与关注点。</p>
</blockquote>
<hr>
<h3 id="023-能提出新-idea的能力问题抽象与研究选题"><a class="header" href="#023-能提出新-idea的能力问题抽象与研究选题">0.2.3 “能提出新 idea”的能力：问题抽象与研究选题</a></h3>
<p>对于研究生来说，前两个能力（读论文、复现系统）让你“站在前沿门口”；<strong>能提出新 idea 并验证它，则让你真正走进科研。</strong></p>
<p>在具身智能和 VLA 这样快速发展的领域，好的 idea 往往来自于：
1）对现有系统的深入使用与质疑；
2）对跨领域知识的迁移；
3）对“实验失败”的认真分析。</p>
<p>本节从“问题抽象 → 创新发散 → 评估筛选”三个阶段，构建一套选题思路。部分方法可以和后面关于综述、基准与科研进阶的小节互相印证。(<a href="https://richardmathewsii.substack.com/p/three-pass-research-literature-review?utm_source=chatgpt.com">richardmathewsii.substack.com</a>)</p>
<hr>
<h4 id="0231-问题抽象"><a class="header" href="#0231-问题抽象">0.2.3.1 问题抽象</a></h4>
<p><strong>问题抽象的核心，是从具体的、零碎的失败现象中提炼出“具有普遍意义的明确问题”。</strong></p>
<p>以一个简单示例：你在仿真中训练了一个抓取策略，转到真实机械臂后成功率大幅下降。你可以按以下层次抽象：</p>
<ol>
<li><strong>现象级描述</strong></li>
</ol>
<blockquote>
<p>模型在仿真中成功率 90%，现实中只有 20%，尤其在光照变化或物体纹理复杂时表现很差。</p>
</blockquote>
<ol start="2">
<li><strong>归因假设</strong>
可能的解释包括：
<ul>
<li>视觉分布偏移（sim2real gap）；</li>
<li>机械臂控制延迟与噪声；</li>
<li>数据集中未覆盖现实场景的多样性。</li>
</ul>
</li>
<li><strong>抽象成一般问题</strong>
<ul>
<li>更高层表述可以是：</li>
</ul>
</li>
</ol>
<blockquote>
<p>“如何提高视觉驱动抓取策略在真实环境中的鲁棒性？”</p>
</blockquote>
<pre><code>- 再进一步：
</code></pre>
<blockquote>
<p>“如何在有限真实数据下弥合仿真与现实视觉分布之间的差异？”</p>
</blockquote>
<ol start="4">
<li><strong>形式化技术问题</strong>
<ul>
<li>例如：给定仿真数据分布 $ \mathcal{D}<em>{sim} $ 和少量真实数据 $ \mathcal{D}</em>{real} $，如何设计一种自监督或对比学习目标，使得视觉编码器在 $ \mathcal{D}_{real} $ 上表现良好？</li>
</ul>
</li>
</ol>
<p>这个过程的关键是：<strong>从一次具体 Bug 出发，反复问“这代表了什么更普遍的问题？”</strong>
在具身智能领域，常见的抽象问题包括：</p>
<ul>
<li>分布偏移（domain shift）：仿真 vs 现实、新物体、新布局；</li>
<li>信号稀疏（sparse reward）：任务成功信号难以获取；</li>
<li>多模态不一致：语言指令与视觉观测的对应不完美；</li>
<li>控制约束：高层策略与低层控制器不匹配等。</li>
</ul>
<hr>
<h4 id="0232-创新发散"><a class="header" href="#0232-创新发散">0.2.3.2 创新发散</a></h4>
<p>有了清晰的问题，并不意味着立刻有好 idea。<strong>创新发散阶段的目标，是系统性地列出候选思路，而不是“灵光一闪靠运气”。</strong></p>
<p>可以采用一个简单的“多维头脑风暴”框架，把候选想法按下列维度展开：</p>
<ol>
<li><strong>数据维度</strong>
<ul>
<li>是否可以引入新的数据形式（多视角、触觉、语言反馈）；</li>
<li>是否可以用自监督、合成数据或互联网数据降低真实数据需求；</li>
<li>是否可以重新组织数据（课程学习、难度递增等）。</li>
</ul>
</li>
<li><strong>模型/架构维度</strong>
<ul>
<li>视觉 backbone 是否可以替换为更适合机器人任务的架构；</li>
<li>VLA 中的融合方式（early/late/mid fusion，cross-attention）是否有更合理的变体；</li>
<li>是否存在更适合长序列决策的结构（世界模型、层级策略等）。</li>
</ul>
</li>
<li><strong>目标函数/训练范式维度</strong>
<ul>
<li>损失函数是否可以加入安全约束、能耗惩罚、稳定性正则等；</li>
<li>RL/IL/VLA 预训练三者的配比能否重新设计；</li>
<li>是否可以引入人类偏好或语言反馈（RLHF-style）指导策略。(<a href="https://www.science.org/doi/10.1126/sciadv.adk3452?utm_source=chatgpt.com">科学杂志</a>)</li>
</ul>
</li>
<li><strong>系统与工程维度</strong>
<ul>
<li>是否可以通过更好的仿真工具或更稳健的控制接口，让学习更稳定；</li>
<li>是否可以设计新的评测协议，使得某类能力更显性，从而反过来驱动算法设计。</li>
</ul>
</li>
</ol>
<p>在这个阶段，不要过早否定想法。建议把想法全部粗略记录下来，再进入下一步筛选。</p>
<blockquote>
<p>【图片占位】
<strong>图 1-2-6：从问题到多维创新发散的示意图</strong>
中心为抽象问题，向外沿“数据 / 模型 / 目标 / 系统”四个方向发散出候选思路。</p>
</blockquote>
<hr>
<h4 id="0233-评估筛选"><a class="header" href="#0233-评估筛选">0.2.3.3 评估筛选</a></h4>
<p>真正能成为你研究课题的 idea，通常需要通过三重筛选：<strong>可行性、创新性、影响力</strong>。高校和研究机构在说明研究生培养目标时，也常强调这种平衡：硕士项目侧重在有限时间内完成一个清晰、可行的课题；博士项目则在此基础上追求更高的原创性和影响力。(<a href="https://www.cs.utexas.edu/undergraduate-program/academics/advising/preparing-graduate-school?utm_source=chatgpt.com">德克萨斯大学计算机科学系</a>)</p>
<p>你可以采用一个简单的“三角评估”：</p>
<ol>
<li><strong>可行性（Feasibility）</strong>
<ul>
<li>你是否有必要的资源？（机器人平台、仿真环境、数据采集条件）；</li>
<li>所需实现工作量是否在 1–2 学期内可以完成？</li>
<li>理论与实现是否在你或团队的技能范围内？</li>
</ul>
</li>
<li><strong>创新性（Novelty）</strong>
<ul>
<li>在最近的 survey 和顶会论文中，是否已经有人做过非常相似的事情？(<a href="https://richardmathewsii.substack.com/p/three-pass-research-literature-review?utm_source=chatgpt.com">richardmathewsii.substack.com</a>)</li>
<li>你的 idea 是否只是简单堆砌几种已有方法，还是引入了新的视角或组合方式？</li>
<li>如果别人看你的方法，会不会说“这就是某某方法的直接套用”？</li>
</ul>
</li>
<li><strong>影响力（Impact）</strong>
<ul>
<li>这个问题是否对社区有普遍意义，而不仅仅是你实验室的某个工程小痛点？</li>
<li>你的工作能否在一个合理的基准或真实应用场景中展示清晰收益？</li>
<li>即使结果不如预期，这项探索本身是否能提供有价值的负结果或经验总结？</li>
</ul>
</li>
</ol>
<p>筛选结果不必完美，但至少要确保：</p>
<blockquote>
<p><strong>在可行性和创新性上都不为 0，影响力有潜力。</strong></p>
</blockquote>
<p>最终形成题目时，建议从<strong>最小可行问题</strong>入手：给大问题加上限定条件（特定任务、特定场景、特定数据规模），确保你可以构造清晰的实验验证路径。</p>
<blockquote>
<p>【图片占位】
<strong>图 1-2-7：研究 idea 三角评估图</strong>
三个顶点分别为可行性、创新性、影响力，在图中标出示例课题的相对位置。</p>
</blockquote>
<hr>
<h3 id="024-从课程学习到科研项目的过渡方式"><a class="header" href="#024-从课程学习到科研项目的过渡方式">0.2.4 从课程学习到科研项目的过渡方式</a></h3>
<p>对于大多数学生而言，研究生前半段的日常是“上课 + 作业 + 考试”，后半段逐渐变成“项目 + 论文 + 汇报”。怎样平滑地从前者过渡到后者，是能否在具身智能方向站住脚的关键。</p>
<p>许多经验文章都强调：<strong>课程侧重“学习已有知识”，科研则要求你“在不确定中创造新知识”</strong>，两者在节奏、评估方式和心态上都有明显差别。(<a href="https://www.science.org/content/article/transitioning-undergraduate-graduate-school?utm_source=chatgpt.com">科学杂志</a>)</p>
<p>本小节从“巩固基础 → 参与项目 → 主动探索”三个阶段，勾勒一个现实可行的过渡路径。</p>
<hr>
<h4 id="0241-巩固基础"><a class="header" href="#0241-巩固基础">0.2.4.1 巩固基础</a></h4>
<p>课程阶段的目标不是拿满分，而是为未来科研打下<strong>可重用的知识与代码资产</strong>。</p>
<ol>
<li><strong>把核心课程视为“工具箱建设”。</strong>
<ul>
<li>数学与机器学习课程：给你提供阅读 VLA 理论、理解损失函数与优化算法的工具；</li>
<li>深度学习、强化学习、机器人学课程：让你熟悉本书后续章节会详细展开的关键概念。
上课时，与其追求每个细节都搞懂，不如刻意问自己：<strong>“这门课给我增加了哪些可重复使用的工具？”</strong></li>
</ul>
</li>
<li><strong>把课程大作业当作“微型科研项目”。</strong>
在许多学校，课程 project 已经非常接近真正的小型研究：
<ul>
<li>你需要选题、调研相关工作、实现与实验、写报告；</li>
<li>即使题目看起来简单（如变体的抓取任务、仿真导航），你也可以尝试做一点自己的改动（新损失、不同 backbone 等）。
如果提前做好规划，<strong>很多毕业论文选题都可以看作对某一个课程项目的深入延伸</strong>。</li>
</ul>
</li>
<li><strong>从“考前突击”转向“持续积累”。</strong>
<ul>
<li>尽量把课堂笔记与实验代码整理成可复用的形式（例如独立的 repo、清晰的 README、可复用模块）；</li>
<li>对每门课，留下 1–2 页的“长期纪要”：列出最重要的概念、几篇关键论文和可复用代码位置；
这样，当你在做具身智能项目时，遇到相关问题，可以快速“跳回”这门课，而不是重学一遍。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="0242-参与项目"><a class="header" href="#0242-参与项目">0.2.4.2 参与项目</a></h4>
<p>在很多计算机科学培养方案中，会明确指出：前 1–2 年以课程为主，之后逐渐转入以研究为主。(<a href="https://www.cs.utexas.edu/undergraduate-program/academics/advising/preparing-graduate-school?utm_source=chatgpt.com">德克萨斯大学计算机科学系</a>)
对学生而言，这个过渡的关键步骤是<strong>找到一个合适的项目并参与进去</strong>。</p>
<ol>
<li><strong>主动接触导师与课题组。</strong>
<ul>
<li>提前阅读老师的主页和最近两三篇论文，看看有哪些与你感兴趣且与本书主题相关的方向；</li>
<li>写邮件或在课程结束后当面沟通，表达你希望在具身智能/VLA 方向做项目的意愿，并说明你当前掌握的技能与可投入时间。</li>
</ul>
</li>
<li><strong>接受“从执行者做起”的角色定位。</strong>
刚进入课题组时，你很可能先从以下任务开始：
<ul>
<li>跑已有实验，复现组内或外部论文结果；</li>
<li>清洗数据、整理日志、搭建仿真环境；</li>
<li>为已有系统加小功能（增加一个新基线、新评测脚本）。
这并不是“打杂”，而是你<strong>真正摸清系统细节、建立工程直觉</strong>的阶段，为后续提出 idea 和主导子课题打基础。</li>
</ul>
</li>
<li><strong>在项目中练习“闭环思维”。</strong>
每一个你参与的项目，尽量按下面的闭环标准要求自己：
<ul>
<li>知道项目要解决的高层问题是什么；</li>
<li>明白自己负责的部分如何影响整体结果；</li>
<li>在完成一个阶段后，对结果做简短总结（包括失败原因分析），而不是只“交差”。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图片占位】
<strong>图 1-2-8：从课程到项目的角色演化</strong>
从“课程作业（个人）→ 项目执行者（team member）→ 子课题负责人（lead）”的演进示意图。</p>
</blockquote>
<hr>
<h4 id="0243-主动探索"><a class="header" href="#0243-主动探索">0.2.4.3 主动探索</a></h4>
<p>当你对于一个方向的基础课程和关键论文有了初步理解，也在课题组中完成了一些“执行型工作”之后，就进入了真正意义上的**“研究起步”阶段**：开始从“做别人给的任务”，转为“提出自己的小问题”。</p>
<p>可以从以下几个手段着手：</p>
<ol>
<li><strong>从现有系统中的“不顺眼之处”切题。</strong>
<ul>
<li>在跑实验时，你会遇到一些反复出现的问题：训练不稳定、部署延迟高、现实成功率低等；</li>
<li>试着把这些现象记录下来，按照前文问题抽象的方法，提炼出一两个你觉得值得深入的点。
这种“从本组系统出发”的选题，往往更有资源基础，也更容易在有限时间内产出结果。</li>
</ul>
</li>
<li><strong>设计“最小可行副课题（Mini-Project）”。</strong>
而不是一上来就设计一个“通用具身智能框架”，可以从以下尺度开始：
<ul>
<li>在某一基准任务（如抓取、开门、收纳）上，尝试一个改动（新视觉预训练、新动作表示等）；</li>
<li>在现有 VLA 模型上，添加或替换一个明确的模块（新的融合方式、新的指令编码方式）。
要求是：<strong>在 1–2 个月内，可以完成实验并得到明确结论（成或不成）。</strong></li>
</ul>
</li>
<li><strong>与导师定期对齐方向与节奏。</strong>
许多经验材料指出，课程到科研的过渡失败，很大程度上是因为学生在研究初期缺乏结构化反馈与节奏安排。(<a href="https://www.science.org/content/article/transitioning-undergraduate-graduate-school?utm_source=chatgpt.com">科学杂志</a>)
建议：
<ul>
<li>与导师或带教学长/姐建立固定频率的讨论，如每 1–2 周汇报一次进展；</li>
<li>每次准备简短文档：做了什么、遇到什么问题、接下来两周打算做什么；</li>
<li>通过这样的循环，把“模糊兴趣”切割成一个个具体可操作的行动项。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图片占位】
<strong>图 1-2-9：课程–项目–科研的时间轴示意图</strong>
标出入学 1–2 年内课程与项目的比例随时间变化，展示从“课为主”到“研为主”的过渡。</p>
</blockquote>
<hr>
<p>本节从“读懂论文”到“复现系统”，再到“提出新 idea”与“从课程走向科研项目”，勾勒了研究生阶段在具身智能/VLA 方向需要具备的核心能力画像。后续各章将围绕这些能力展开：先补足数学、机器学习和深度学习的基础，再逐步进入视觉、语言、RL/IL、机器人学与 VLA 架构本身，使读者有机会真正从“零基础读者”成长为能够设计和实现自己具身智能系统的研究者。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="学习路径规划与时间安排"><a href="#学习路径规划与时间安排" class="header">学习路径规划与时间安排</a></h1>
<h3 id="031-基础知识阶段数学--ml--机器人"><a class="header" href="#031-基础知识阶段数学--ml--机器人">0.3.1 基础知识阶段（数学 / ML / 机器人）</a></h3>
<p>这一阶段的目标只有一句话：<strong>把“看不懂论文公式、写不出代码、画不清机器人坐标系”的尴尬全部解决掉。</strong>
后面所有 CV / RL / VLA 的内容，都会默认你已经具备本阶段的能力。</p>
<hr>
<h4 id="0311-时间分配"><a class="header" href="#0311-时间分配">0.3.1.1 时间分配</a></h4>
<p>如果以两年制硕士为例，可以把基础阶段粗略放在<strong>入学后前 6–9 个月</strong>。参考国际上多数机器人 / 计算机视觉硕士项目的课程安排，通常第一学年集中在数学、机器学习和机器人学基础，第二学年才是专题课和项目研究。(<a href="https://www.ri.cmu.edu/education/academic-programs/master-of-science-computer-vision/curriculum/?utm_source=chatgpt.com">ri.cmu.edu</a>)</p>
<p>建议按“周”为单位来规划时间，而不是“有空再看”：</p>
<ul>
<li><strong>每周 25–30 小时：正式学习时间</strong>
<ul>
<li>数学（线代 + 概率 + 优化）：<strong>10–12 小时</strong></li>
<li>机器学习基础：<strong>8–10 小时</strong></li>
<li>机器人学导论 / 运动学：<strong>5–8 小时</strong></li>
</ul>
</li>
<li><strong>每周 5–10 小时：练习与项目</strong>
<ul>
<li>课程作业、代码实现、小实验、读几页简单教材或讲义</li>
</ul>
</li>
</ul>
<p>如果你是下面几种背景，可以略作调整：</p>
<ul>
<li><strong>CS/EE 背景较强、数学较好</strong>：适当压缩数学时间，增加机器学习与机器人学的动手机会（多写代码、多跑实验）。</li>
<li><strong>机械 / 控制背景较强、编程较弱</strong>：保留数学时间，把 ML 部分多做实现练习（PyTorch / NumPy），哪怕一开始是简单的线性回归、逻辑回归。</li>
<li><strong>跨专业转入（数学、物理等）</strong>：前 2–3 个月集中补编程和基本 ML，然后再进入正常节奏。</li>
</ul>
<blockquote>
<p>[图片占位]：一张“基础阶段时间分配”饼图或堆叠条形图，区分数学 / ML / 机器人 / 项目练习所占比例。</p>
</blockquote>
<p>总的原则是：<strong>不要指望“暑假突击”，而是保证每周可持续的学习节奏</strong>。后面 VLA 阶段的复杂模型训练，需要你在这一阶段养成稳定的“长期耐力”。</p>
<hr>
<h4 id="0312-学习内容"><a class="header" href="#0312-学习内容">0.3.1.2 学习内容</a></h4>
<p>本阶段的学习内容不在于“多”，而在于**“打牢关键概念 + 能做典型题 + 能写基本代码”**。本书第 1 章、2 章、6 章会分别系统展开数学、深度学习和机器人学的细节，这里只从“学习目标”的角度做整体规划。</p>
<p>可以把内容分成三条主线：</p>
<ol>
<li><strong>数学主线：看懂公式、会算、懂含义</strong>
<ul>
<li>线性代数：向量 / 矩阵运算、特征值分解、SVD、PCA 等。你至少要能理解“为什么要做对角化 / 降维”这类问题，而不是机械套公式。</li>
<li>概率与统计：随机变量、期望 / 方差、常见分布、贝叶斯公式、最大似然 / 最大后验的直觉。</li>
<li>优化：梯度、梯度下降、学习率、局部极值与鞍点、基本约束优化的思想。
这些内容在本书第 1 章会有详细展开，此处的重点是：<strong>跟着一套系统教材 + 课后习题 + 配套课程，扎实做完一遍</strong>，而不是“看过 PPT”。</li>
</ul>
</li>
<li><strong>机器学习主线：从“名词认识”到“能自己写一个小模型”</strong>
<ul>
<li>监督学习：回归 / 分类的基本设定、损失函数、训练 / 验证 / 测试划分。</li>
<li>模型与泛化：过拟合、欠拟合、正则化、交叉验证、常见评价指标（准确率、精确率、召回率、AUC 等）。</li>
<li>简单模型实践：线性回归、逻辑回归、支持向量机、决策树 / 随机森林等。
这一部分的要求是：至少<strong>用 Python + 一个主流框架（如 PyTorch）完整实现过 2–3 个典型任务</strong>，例如房价预测、简单图像分类等。(<a href="https://www.linkedin.com/posts/jeanklee_learn-math-for-machine-learning-activity-7373721077996367872-EMOD?utm_source=chatgpt.com">领英</a>)</li>
</ul>
</li>
<li><strong>机器人学主线：建立“坐标系 + 运动学 + 基本控制”的直观感</strong>
<ul>
<li>坐标系与齐次变换：理解机器人不同连杆 / 末端的相对位置与姿态如何通过 4×4 矩阵描述。</li>
<li>正 / 逆运动学：已知关节角求末端位姿、给定位姿求关节角的基本问题；至少在 2–3 自由度机械臂上能手算 / 编程实现。</li>
<li>简单控制思想：PID 控制、轨迹跟踪的基本概念，为后面 RL / IL 接入机器人打基础。
很多国际机器人硕士项目都会在第一学年结束前要求学生掌握这些内容，并通过实验课或仿真实验进行验证。(<a href="https://research.gatech.edu/robotics/ms-robotics-detailed-curriculum?utm_source=chatgpt.com">research.gatech.edu</a>)</li>
</ul>
</li>
</ol>
<p>在学习方式上，可以采用“三明治结构”：</p>
<blockquote>
<p>理论 → 习题 → 代码 → 再回到理论（带着问题回看）</p>
</blockquote>
<p>例如：学完线性回归的公式推导后，立刻在 Python 中实现最小二乘拟合，再对比手推和框架自动求导的差异。</p>
<hr>
<h4 id="0313-达到水平"><a class="header" href="#0313-达到水平">0.3.1.3 达到水平</a></h4>
<p>当你完成基础阶段时，应当<strong>具备一种“读论文不再完全晕菜、知道该查哪本书”的安全感</strong>。更具体地，可以用以下几个“自测指标”判断自己是否过关：</p>
<ol>
<li><strong>数学层面</strong>
<ul>
<li>能够独立推导线性回归的闭式解、逻辑回归的梯度；</li>
<li>遇到论文中的常见符号（如 $ E[\cdot] $、$ p(x|\theta) $、$ \nabla_\theta $ 等）不会感到陌生；</li>
<li>能够解释“为什么深度网络训练需要随机梯度下降、为什么学习率太大会发散”等直观问题。</li>
</ul>
</li>
<li><strong>机器学习层面</strong>
<ul>
<li>能用一个你熟悉的框架（如 PyTorch）从零开始写出：数据读取 → 模型定义 → 损失函数 → 训练循环 → 指标计算 的完整脚本；</li>
<li>能够根据数据集和任务选择合理的损失函数和评价指标，并对过拟合有基本感知；</li>
<li>能读懂经典 ML 课程（如 CS229）作业中的大部分题目和解答思路。(<a href="https://www.studocu.vn/vn/document/truong-dai-hoc-su-pham-ky-thuat-thanh-pho-ho-chi-minh/artificial-intelligence/ai-roadmap-based-on-stanford-ai-graduate-certificate/123457458?utm_source=chatgpt.com">studocu.vn</a>)</li>
</ul>
</li>
<li><strong>机器人层面</strong>
<ul>
<li>给定一台简单机械臂的 DH 参数，能用程序计算任意关节角下的末端位姿；</li>
<li>能够理解实验室常见机器人软件栈的大致结构（如“上层规划 → 下层控制”），看懂常用坐标系示意图；</li>
<li>至少在仿真环境中（如 Gazebo / MuJoCo）完成过一次简单“点到点”轨迹规划与执行。(<a href="https://github.com/mikeroyal/Reinforcement-Learning-Guide?utm_source=chatgpt.com">GitHub</a>)</li>
</ul>
</li>
</ol>
<p>如果你已经达到了上述水平，可以认为：<strong>进入 CV / NLP / RL / IL 这类“领域知识阶段”是安全的，不会在基础问题上频繁绊倒。</strong></p>
<hr>
<h3 id="032-领域知识阶段cv--nlp--rl--il"><a class="header" href="#032-领域知识阶段cv--nlp--rl--il">0.3.2 领域知识阶段（CV / NLP / RL / IL）</a></h3>
<p>这一阶段相当于把“通用 AI 基础”转化为“具身智能相关的关键领域能力”，为后面 VLA 奠定四大支柱：<strong>视觉、语言、决策（RL）、模仿学习（IL）</strong>。国际上很多机器人和计算机视觉硕士项目，也会在核心课之上，提供视觉、机器学习、机器人控制、强化学习等模块化选修，形成类似结构。(<a href="https://www.ri.cmu.edu/education/academic-programs/master-of-science-computer-vision/curriculum/?utm_source=chatgpt.com">ri.cmu.edu</a>)</p>
<hr>
<h4 id="0321-时间分配"><a class="header" href="#0321-时间分配">0.3.2.1 时间分配</a></h4>
<p>建议将领域知识阶段安排在<strong>研究生中期（大致 6–18 个月）</strong>，与课程选修和早期科研项目交织进行。</p>
<p>一个典型的时间结构可以是：</p>
<ul>
<li><strong>每学期聚焦 1–2 个主领域 + 1 个辅领域</strong>
<ul>
<li>例如：本学期主攻 CV + RL，辅修 NLP；下学期主攻 RL + IL，巩固 CV。</li>
</ul>
</li>
<li><strong>每周时间安排（参考）</strong>
<ul>
<li>正式课程（听课、作业）：<strong>15–20 小时</strong></li>
<li>小项目 / 课程 Project：<strong>8–10 小时</strong></li>
<li>论文 / 教材阅读：<strong>5–8 小时</strong></li>
</ul>
</li>
</ul>
<p>这里有一个重要的经验：<strong>不要试图一学期同时“精通”四个领域。</strong>
更现实的做法是：<strong>保持宽度，但每个时段有清晰的“主线”。</strong></p>
<blockquote>
<p>[图片占位]：一张“学期级时间轴”示意图，横轴为学期，纵向标注不同领域的重点程度（例如高亮某学期的 CV + RL），展示“轮换主攻”的策略。</p>
</blockquote>
<hr>
<h4 id="0322-理论结合实践"><a class="header" href="#0322-理论结合实践">0.3.2.2 理论结合实践</a></h4>
<p>仅仅“上完课 + 做完作业”是不够的。对于 CV / NLP / RL / IL，每个领域至少应该做到：<strong>理论上听得懂、代码里写得出、实验里调得动</strong>。</p>
<p>可以按领域设计“最小实践单元”：</p>
<ol>
<li><strong>CV：从图片到语义理解</strong>
<ul>
<li>理论：卷积、视觉 Transformer、分类 / 检测 / 分割的基本框架。</li>
<li>实践项目示例：
<ul>
<li>在 ImageNet 子集或 CIFAR 上训练一个简单分类器；</li>
<li>在 COCO 子集上跑通一个开源检测模型的训练与推理。(<a href="https://www.surrey.ac.uk/postgraduate/computer-vision-robotics-and-machine-learning-msc?utm_source=chatgpt.com">University of Surrey</a>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>NLP：从 token 到语义表示</strong>
<ul>
<li>理论：语言模型、子词分词、预训练 + 微调范式。</li>
<li>实践项目示例：
<ul>
<li>使用预训练 Transformer 做一个文本分类 / 问答任务；</li>
<li>通过指令微调或简单 Prompt 设计，体验 LLM 在下游任务中的适应能力。</li>
</ul>
</li>
</ul>
</li>
<li><strong>RL：从 MDP 到可运行的策略</strong>
<ul>
<li>理论：MDP、价值函数、策略梯度、Actor–Critic 等。</li>
<li>实践项目示例：
<ul>
<li>在经典离散环境（如 CartPole）上实现 DQN；</li>
<li>在简单连续控制环境（如倒立摆 / 小车）上实现 PPO 或 SAC。(<a href="https://github.com/mikeroyal/Reinforcement-Learning-Guide?utm_source=chatgpt.com">GitHub</a>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>IL：从示范到策略</strong>
<ul>
<li>理论：行为克隆、分布偏移、DAgger、基本逆强化学习思想。</li>
<li>实践项目示例：
<ul>
<li>在仿真环境中用示范轨迹训练一个行为克隆策略；</li>
<li>分析“策略偏离示范后崩掉”的现象，并尝试通过数据增强 / DAgger 方式改进。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>这些项目的规模不必很大，但要<strong>严格“从数据到结果”走完一遍完整 pipeline</strong>：数据准备 → 模型实现 → 训练调参 → 可视化结果 → 简单总结。
这样你在后面做 VLA 时，才能对每个模块的行为心中有数，而不是把所有问题都怪在“模型太大 / 数据太少”上。</p>
<hr>
<h4 id="0323-知识融会"><a class="header" href="#0323-知识融会">0.3.2.3 知识融会</a></h4>
<p>具身智能的核心不在于“分别学会 CV / NLP / RL / IL”，而在于<strong>把这些领域联通起来</strong>，形成对“感知–语言–决策–动作”的整体理解。近年来关于 VLA 的综述工作，也强调了这一点：单独做视觉或语言已经不够，关键在于把多模态、决策和物理交互整合成统一学习系统。(<a href="https://arxiv.org/html/2405.14093v4?utm_source=chatgpt.com">arXiv</a>)</p>
<p>在领域知识阶段，可以开始有意识地做一些“跨界思考”：</p>
<ul>
<li><strong>视觉 + RL</strong>：思考从像素直接输入 RL 策略，与“先做感知再做决策”的差别；</li>
<li><strong>语言 + RL / IL</strong>：对比“固定任务奖励”与“语言指令描述任务”的两种方式；</li>
<li><strong>CV + NLP</strong>：尝试实现一个简单的图文匹配 / 图文检索模型，体会跨模态对齐的难点。</li>
</ul>
<p>建议定期做一个“小型综合反思”：</p>
<blockquote>
<p><strong>每 1–2 个月挑一个周末，画一张“知识网络图”</strong>：
把学过的主要概念（视觉特征、语言 embedding、价值函数、策略、示范轨迹等）画成节点，用线连接它们之间的关系，并标出你尚未理解清楚的部分。</p>
</blockquote>
<blockquote>
<p>[图片占位]：一张“CV / NLP / RL / IL 知识网络”手绘示意图，展示不同概念之间的箭头关系，用于帮助读者建立整体心智模型。</p>
</blockquote>
<p>当你能流畅回答诸如“为什么现代机器人策略越来越像大型多模态模型，而不仅仅是传统规划器？”这类问题时，就说明你已经从“分科学生”开始转向“具身智能研究者”的思维方式。</p>
<hr>
<h3 id="033-vla-专题与项目实践阶段"><a class="header" href="#033-vla-专题与项目实践阶段">0.3.3 VLA 专题与项目实践阶段</a></h3>
<p>完成前两个阶段后，你已经具备了“通用 AI + 关键子领域”的基础。接下来，重点从“学习课程”转向“围绕 VLA 的系统性研究与工程实践”。</p>
<p>最近几年，Vision-Language-Action 模型已经成为具身智能研究的核心方向之一，相关综述将其视为“指令驱动机器人策略”的重要实现路径。(<a href="https://arxiv.org/html/2405.14093v4?utm_source=chatgpt.com">arXiv</a>)</p>
<hr>
<h4 id="0331-时间分配"><a class="header" href="#0331-时间分配">0.3.3.1 时间分配</a></h4>
<p><strong>时间上，这一阶段通常覆盖研究生后期（大约最后 6–12 个月），也是毕业论文 / 核心科研产出的集中期。</strong></p>
<p>相比前两个阶段，这里需要更加明确“研究型时间”的结构，而不是纯课程节奏。可以参考如下每周分配：</p>
<ul>
<li><strong>论文与调研：6–8 小时</strong>
<ul>
<li>聚焦 VLA、具身基础模型、相关数据集与 benchmark；</li>
</ul>
</li>
<li><strong>代码与系统实现：15–20 小时</strong>
<ul>
<li>搭建 / 修改模型、编写训练与评估脚本；</li>
</ul>
</li>
<li><strong>实验与数据处理：10–12 小时</strong>
<ul>
<li>数据清洗、训练/推理、日志分析、可视化；</li>
</ul>
</li>
<li><strong>思考与写作：4–6 小时</strong>
<ul>
<li>记录实验日志、撰写备忘录、构思论文结构。</li>
</ul>
</li>
</ul>
<p>这意味着：<strong>课程不再是主角</strong>，而是为你的研究提供稳定背景；真正拉开差距的是“你在项目和论文上花了多少高质量时间”。</p>
<hr>
<h4 id="0332-项目实践"><a class="header" href="#0332-项目实践">0.3.3.2 项目实践</a></h4>
<p>在 VLA 阶段，建议至少完成一个“从零搭到能跑”的中等规模项目。为了避免一开始就目标过大、难以落地，可以采用“由浅入深的阶梯式设计”。</p>
<p>可以参考以下三种层级：</p>
<ol>
<li><strong>Level 1：复现 + 小改动</strong>
<ul>
<li>目标：选取一篇 VLA 论文或开源项目（例如基于 CLIP + 行为克隆的策略），在开源数据集上完整复现实验流程，并做少量改动。</li>
<li>工作内容：
<ul>
<li>理解并搭建模型结构（视觉编码器 + 语言编码器 + 动作解码器）；</li>
<li>跑通训练脚本、得到与原文接近的结果；</li>
<li>尝试修改某一个模块（如换 backbone、换动作离散化方式），观察性能变化。(<a href="https://learnopencv.com/vision-language-action-models-lerobot-policy/?utm_source=chatgpt.com">学OpenCV</a>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>Level 2：自建数据 + 仿真实验</strong>
<ul>
<li>目标：在 MuJoCo / Isaac Gym / RLBench 等仿真环境中，采集自己的多模态示教数据（图像 + 语言指令 + 动作），训练一个简单的 VLA 策略。(<a href="https://github.com/mikeroyal/Reinforcement-Learning-Guide?utm_source=chatgpt.com">GitHub</a>)</li>
<li>工作内容：
<ul>
<li>搭建简单场景（如“按颜色分类搬运方块”）；</li>
<li>通过遥操作 / 脚本生成示范轨迹，并设计相应语言指令模板；</li>
<li>训练 VLA 模型，在环境中执行并评估成功率。</li>
</ul>
</li>
</ul>
</li>
<li><strong>Level 3：从仿真走向真实机器人（如实验室机械臂）</strong>
<ul>
<li>目标：将 Level 2 中在仿真训练的策略，迁移到真实平台上，哪怕只完成一个简化任务（例如“桌面抓取 + 放置”）。</li>
<li>工作内容：
<ul>
<li>适配传感器与控制接口（如 ROS）；</li>
<li>处理 sim-to-real 差距：图像差异、延迟、噪声等；</li>
<li>引入安全约束，确保真实实验中不会对人和设备造成损害。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>[图片占位]：一张“VLA 项目阶梯”示意图，展示从“论文复现”到“仿真实验”再到“真实机器人部署”的三层台阶。</p>
</blockquote>
<p>在选择项目时，可以结合导师课题和公开数据资源，避免完全闭门造车。近年来一些 VLA 综述与开源列表，会系统整理相关数据集、任务和模型，对你设计项目非常有参考价值。(<a href="https://github.com/jonyzhang2023/awesome-embodied-vla-va-vln?utm_source=chatgpt.com">GitHub</a>)</p>
<hr>
<h4 id="0333-迭代提高"><a class="header" href="#0333-迭代提高">0.3.3.3 迭代提高</a></h4>
<p>VLA 项目难点往往不在“能不能跑起来”，而在于<strong>如何在一个基线之上持续提升性能，并提炼出有研究价值的结论</strong>。这需要你有意识地进行“科学化迭代”，而不是凭感觉改代码。</p>
<p>可以参考如下迭代循环：</p>
<ol>
<li><strong>建立基线</strong>
<ul>
<li>复现已有方法，得到稳定的基线性能；</li>
<li>确保实验可重复（固定随机种子、记录配置和数据版本）。</li>
</ul>
</li>
<li><strong>提出假设</strong>
<ul>
<li>例如：“增加历史动作上下文会提高策略稳定性”、“更强的语言编码器能够提升多任务泛化”等；</li>
<li>假设应具体到可实验验证的设计。</li>
</ul>
</li>
<li><strong>设计对照实验</strong>
<ul>
<li>只改变一个关键因素，保持其他条件不变；</li>
<li>使用统一指标（成功率、路径长度等）进行比较，必要时统计多次试验均值和方差。</li>
</ul>
</li>
<li><strong>分析与归纳</strong>
<ul>
<li>不仅看“是否提升”，还要分析“在哪些任务、哪些场景下提升显著”；</li>
<li>将失败实验也记录下来，反思假设为何不成立。</li>
</ul>
</li>
<li><strong>整理为论文 / 报告</strong>
<ul>
<li>在本书第 11 章将详细讨论如何设计实验和撰写论文；</li>
<li>在这里，你只需记住：<strong>项目必须沉淀为“可交流的知识”，而不仅是“一个 Git 仓库”。</strong></li>
</ul>
</li>
</ol>
<p>多篇 VLA 工作的经验表明，真正有影响力的贡献往往来自于：<strong>扎实的工程实现 + 清晰的实验设计 + 对失败现象的深入分析</strong>，而不是堆砌复杂模型结构。(<a href="https://proceedings.mlr.press/v229/zitkovich23a/zitkovich23a.pdf?utm_source=chatgpt.com">Proceedings of Machine Learning Research</a>)</p>
<hr>
<h3 id="034-如何在课程项目与论文之间平衡时间"><a class="header" href="#034-如何在课程项目与论文之间平衡时间">0.3.4 如何在课程、项目与论文之间平衡时间</a></h3>
<p>具身智能 / VLA 方向的学习，很容易陷入两种极端：
要么“疯狂修课但不做项目”，要么“沉迷写代码、不顾课程基础”。本节的目标，是帮助你形成一个**“长期可持续”的时间平衡策略**。</p>
<hr>
<h4 id="0341-课程-vs-科研"><a class="header" href="#0341-课程-vs-科研">0.3.4.1 课程 vs 科研</a></h4>
<p>可以把课程与科研的关系理解为：</p>
<ul>
<li><strong>课程 = 安全下限（floor）</strong>：保证你在数学、ML、机器人等方面不会出现致命短板；</li>
<li><strong>科研 / 项目 = 上限（ceiling）</strong>：决定你能走多远，是否具备独立研究能力。</li>
</ul>
<p>从多所机器人 / 计算机视觉硕士项目的培养方案看，典型做法是：前期偏重课程，后期偏重项目和论文，一般会要求核心课程 + Capstone / Thesis 结合。(<a href="https://www.ri.cmu.edu/education/academic-programs/master-of-science-computer-vision/curriculum/?utm_source=chatgpt.com">ri.cmu.edu</a>)</p>
<p>对个人而言，可以遵循以下原则：</p>
<ol>
<li><strong>课程不过度“内卷”</strong>
保证核心课程成绩过关、概念掌握扎实即可，不必在每次作业上投入 200% 精力追求满分。把多出来的精力投入到项目和论文上，长期收益更大。</li>
<li><strong>尽早参与科研 / 项目</strong>
不必等所有课上完才开始做研究。实际更有效的方式是：
<strong>在基础课程刚刚达到“能听懂 70%”时，就开始参与一个小项目</strong>，一边补课一边实践。</li>
<li><strong>用课程作业为科研“打前站”</strong>
尽量把课程 Project 设计成与你未来科研方向相关的小问题，例如：
<ul>
<li>CV 课程的项目做一个小型视觉编码实验，为后续视觉模块打基础；</li>
<li>RL 课程的项目尝试一个简化版本的机器人任务。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="0342-项目管理"><a class="header" href="#0342-项目管理">0.3.4.2 项目管理</a></h4>
<p>具身智能项目往往战线长、依赖多（硬件、仿真、数据、模型都要照顾），如果没有明确的管理方式，很容易陷入“忙了很久却没有实质结果”的困境。</p>
<p>建议采用<strong>轻量级的项目管理策略</strong>：</p>
<ol>
<li><strong>明确里程碑（Milestone）</strong>
<ul>
<li>按 4–6 周为周期，划分几个关键里程碑：
例如“跑通仿真环境”、“完成数据采集脚本”、“完成第一版模型训练”、“完成 ablation 实验”等。</li>
<li>每个里程碑需要有可验证的“完成标准”，而不是泛泛的“差不多可以”。</li>
</ul>
</li>
<li><strong>任务拆分与优先级</strong>
<ul>
<li>把每个里程碑拆分为若干可在 1–2 天内完成的小任务；</li>
<li>按照“对整体进度影响最大”排序优先级，先解决阻塞问题，如环境搭建 / 数据格式统一。</li>
</ul>
</li>
<li><strong>时间块管理</strong>
<ul>
<li>尽量为深度工作预留<strong>连续 2–3 小时的大块时间</strong>，用于写代码、调试或阅读难论文；</li>
<li>把碎片时间用于检查实验结果、整理笔记、写 TODO 列表，而不是开启新工作。</li>
</ul>
</li>
<li><strong>风险预估与范围控制</strong>
<ul>
<li>对每个里程碑预估最坏情况，如果在某个时间点仍未完成，需要果断缩小范围：
例如减少任务种类、简化模型规模，以确保在可控时间内有完整结果，而不是“追求完美但什么都没交付”。</li>
</ul>
</li>
</ol>
<blockquote>
<p>[图片占位]：一张简单的甘特图示例，展示“课程、项目、论文写作”在时间轴上的并行与交叉分布。</p>
</blockquote>
<hr>
<h4 id="0343-论文阅读与写作"><a class="header" href="#0343-论文阅读与写作">0.3.4.3 论文阅读与写作</a></h4>
<p>在具身智能 / VLA 方向，要想从“熟练工程师”走向“独立研究者”，必须建立<strong>持续阅读论文 + 持续写作整理</strong>的习惯。这不是临近毕业才开始的任务，而应该贯穿整个学习路径。</p>
<p>可以考虑以下实践方式：</p>
<ol>
<li><strong>固定“最低阅读配额”</strong>
<ul>
<li>即便课程和项目再忙，也尽量保证：
<strong>每周至少读 1–2 篇与你课题直接相关的论文</strong>，并且写下半页到一页的阅读笔记。</li>
<li>对于难度较高的综述或长文，可以分多次读完。</li>
</ul>
</li>
<li><strong>分层次阅读</strong>
<ul>
<li>第一遍：只看题目、摘要、引言和结论，弄清楚“作者在解决什么问题，用什么方法，大概效果如何”；</li>
<li>第二遍：细读方法部分，尝试复现关键公式或算法；</li>
<li>第三遍：分析实验设计、结果与 ablation，思考你能否提出改进或新的问题。</li>
</ul>
</li>
<li><strong>在项目早期就开始写作</strong>
<ul>
<li>不要等实验全部完成再写论文。更推荐做法是：
<ul>
<li>项目开始时就打开一个文档，按“问题背景 – 相关工作 – 方法设想 – 预期实验”的结构先写一个粗略框架；</li>
<li>随着实验推进逐步往里填内容；</li>
<li>失败实验也要记录，为后续讨论和负面结果提供素材。</li>
</ul>
</li>
</ul>
</li>
<li><strong>建立个人知识库</strong>
<ul>
<li>使用笔记软件（如 Obsidian、Notion）或简单 Markdown 文件，建立“文献卡片”——每篇论文用一页记录关键点、启发和疑问；</li>
<li>对 VLA / 具身智能这类快速发展的领域，个人知识库能帮助你在海量论文中保持清晰结构，而不是每次都从零开始搜索。近期关于 VLA 的综述也指出，系统性整理文献对于掌握这个高速演化的领域尤为重要。(<a href="https://arxiv.org/html/2405.14093v4?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ol>
<hr>
<p>本节从时间与阶段的角度，构建了从基础知识到领域能力，再到 VLA 专题研究的整体路径。下一章开始，我们将正式进入数学与机器学习基础的具体内容，让“第一个阶段”从规划走向落实。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="线性代数基础"><a href="#线性代数基础" class="header">线性代数基础</a></h1>
<p>机器人具身智能本质上是在<strong>高维向量空间中做决策</strong>：相机图像被编码成向量，语言指令被编码成向量，机器人状态也是向量，而控制策略、神经网络权重本质上都是矩阵运算。本节的目标，是让读者掌握这些“向量–矩阵世界”的基本语法，并能把它们自然联想到后面关于深度学习、强化学习和机器人控制的内容。</p>
<hr>
<h3 id="111-向量与矩阵运算内积范数矩阵分块"><a class="header" href="#111-向量与矩阵运算内积范数矩阵分块">1.1.1 向量与矩阵运算（内积、范数、矩阵分块）</a></h3>
<h4 id="1111-内积点积的定义与几何意义投影正交"><a class="header" href="#1111-内积点积的定义与几何意义投影正交">1.1.1.1 内积（点积）的定义与几何意义（投影、正交）</a></h4>
<p>在实数空间 $\mathbb{R}^n$ 中，两个列向量</p>
<p>$$
\mathbf{x} =
\begin{bmatrix}
x_1\
\vdots\
x_n
\end{bmatrix},\quad
\mathbf{y} =
\begin{bmatrix}
y_1\
\vdots\
y_n
\end{bmatrix}
$$</p>
<p>的**内积（点积）**定义为：</p>
<p>$$
\mathbf{x}^\top \mathbf{y} = \sum_{i=1}^n x_i y_i.
$$</p>
<p>这是一个非常简单的代数运算，但它有关键的几何意义：</p>
<ul>
<li>
<p>记 $|\mathbf{x}|$ 和 $|\mathbf{y}|$ 为向量的长度（$L_2$ 范数，见下一小节），$\theta$ 为两向量的夹角，则有</p>
<p>$$
\mathbf{x}^\top \mathbf{y} = |\mathbf{x}||\mathbf{y}| \cos\theta.
$$</p>
<p>也就是说，内积同时编码了<strong>长度</strong>和<strong>方向相似度</strong>：</p>
<ul>
<li>若 $\mathbf{x}^\top \mathbf{y} &gt; 0$：夹角小于 $90^\circ$，大致“同向”；</li>
<li>若 $\mathbf{x}^\top \mathbf{y} &lt; 0$：夹角大于 $90^\circ$，大致“反向”；</li>
<li>若 $\mathbf{x}^\top \mathbf{y} = 0$：夹角为 $90^\circ$，称为<strong>正交</strong>（orthogonal）。</li>
</ul>
</li>
<li>
<p><strong>投影</strong>：向量 $\mathbf{y}$ 在方向 $\mathbf{x}$ 上的投影为</p>
<p>$$
\operatorname{proj}_{\mathbf{x}}(\mathbf{y})
= \frac{\mathbf{x}^\top \mathbf{y}}{|\mathbf{x}|^2}\mathbf{x}.
$$</p>
<p>系数 $\dfrac{\mathbf{x}^\top \mathbf{y}}{|\mathbf{x}|^2}$ 表示 $\mathbf{y}$ 在 $\mathbf{x}$ 方向上“有多少”。</p>
</li>
</ul>
<blockquote>
<p>【图 1-1 占位：二维平面中两个向量 (\mathbf{x})、(\mathbf{y})，示意 (\mathbf{y}) 在 (\mathbf{x}) 方向上的投影，并标出夹角 (\theta)。】</p>
</blockquote>
<p>在机器人具身智能中，内积有许多直接应用：</p>
<ul>
<li>在<strong>视觉–语言模型</strong>中，图像与文本被编码为向量，常用它们的 <strong>归一化内积（余弦相似度）</strong> 衡量句子是否描述了这张图。</li>
<li>在<strong>机器人控制</strong>中，速度向量在某个轴上的分量，就是速度向量与该轴的单位向量的内积；比如沿机械臂某个关节轴的线速度，正是速度在该方向上的投影。</li>
</ul>
<h4 id="1112-向量范数的定义常见类型及物理含义"><a class="header" href="#1112-向量范数的定义常见类型及物理含义">1.1.1.2 向量范数的定义、常见类型及物理含义</a></h4>
<p>直观上，<strong>范数（<a href="https://zh.wikipedia.org/wiki/%E8%8C%83%E6%95%B0" title="Wiki">norm</a>）</strong> 就是向量“有多大”的度量。形式上，范数是从向量空间到非负实数的函数 $(|\cdot|)$，并满足三个性质：非负性、齐次性和三角不等式。(<a href="https://en.wikipedia.org/wiki/Norm_%28mathematics%29?utm_source=chatgpt.com">维基百科</a>)</p>
<p>常见的向量范数包括：</p>
<ul>
<li>
<p><strong>L2 范数（欧几里得范数）</strong></p>
<p>$$
|\mathbf{x}|<em>2 = \sqrt{\sum</em>{i=1}^n x_i^2}.
$$</p>
<p>这是我们最熟悉的“直线距离”，在几何上就是从原点到点 $\mathbf{x}$ 的直线长度（<a href="https://apxml.com/courses/linear-algebra-fundamentals-machine-learning/chapter-2-vector-operations/vector-norms-l1-l2?utm_source=chatgpt.com">ApX Machine Learning</a>）。
物理上可以理解为<strong>位移长度</strong>、<strong>速度大小</strong>、<strong>力的大小</strong>等。</p>
</li>
<li>
<p><strong>L1 范数（曼哈顿范数）</strong>
$$
|\mathbf{x}|<em>1 = \sum</em>{i=1}^n |x_i|.
$$
可以理解为沿坐标轴走到该点时所需要走的“总路程”，类似在棋盘或城市街区中只能沿南北东西方向走路的距离。</p>
</li>
<li>
<p><strong>$L_\infty$ 范数（最大范数）</strong>
$$
|\mathbf{x}|_\infty = \max_i |x_i|.
$$
表示所有坐标分量中绝对值最大的那一个，常用来度量<strong>最坏方向上的误差</strong>。</p>
</li>
</ul>
<p>在机器学习和机器人领域：</p>
<ul>
<li>L2 范数常用于定义<strong>损失函数中的距离</strong>，如均方误差（MSE），或在正则项中约束参数大小；</li>
<li>L1 范数常用于<strong>稀疏性正则</strong>（Lasso），鼓励模型把某些参数压到 0；</li>
<li>在移动机器人导航中，如果机器人只能在网格上上下左右移动，路径长度往往更接近 L1 范数而非 L2 范数。</li>
</ul>
<h4 id="1113-矩阵的基本运算与分块方法"><a class="header" href="#1113-矩阵的基本运算与分块方法">1.1.1.3 矩阵的基本运算与分块方法</a></h4>
<p><strong>矩阵</strong>可以看作是数字的二维数组，也可以看作从一个向量空间到另一个向量空间的线性变换的表示。</p>
<ul>
<li>若 (A\in\mathbb{R}^{m\times n})，(B\in\mathbb{R}^{m\times n})，则
<ul>
<li><strong>矩阵加法</strong>：((A+B)<em>{ij} = A</em>{ij}+B_{ij})；</li>
<li><strong>标量乘法</strong>：((\alpha A)<em>{ij} = \alpha A</em>{ij})。</li>
</ul>
</li>
<li>若 (A\in\mathbb{R}^{m\times n})，(B\in\mathbb{R}^{n\times p})，则<strong>矩阵乘法</strong> (C=AB\in\mathbb{R}^{m\times p}) 定义为
$$
C_{ij} = \sum_{k=1}^n A_{ik} B_{kj}.
$$
这对应于先做变换 (B)，再做变换 (A)：对向量 (\mathbf{x})，有 (AB\mathbf{x} = A(B\mathbf{x}))。</li>
</ul>
<p>在机器人中，一个矩阵可以表示<strong>坐标变换</strong>、<strong>刚体运动线性化后的雅可比矩阵</strong>等，多个矩阵相乘就是连续施加多个变换。</p>
<p><strong>矩阵分块</strong>（block matrix）是处理大矩阵的常用技巧。
例如，将一个 (m\times n) 矩阵按行列分成四块：
$$
A=
\begin{bmatrix}
A_{11} &amp; A_{12}
A_{21} &amp; A_{22}
\end{bmatrix},
$$
其中 (A_{11}) 是上左角的小矩阵，(A_{12}, A_{21}, A_{22}) 类似。对分块矩阵的相加、相乘遵循“块”层面的同样规则（尺寸匹配时）。</p>
<blockquote>
<p>【图 1-2 占位：示意一个大矩阵被分成 2×2 的四个子矩阵块，每块用不同颜色标记。】</p>
</blockquote>
<p>在实际工程中，分块可以自然地把系统拆成“状态–控制”“位置–速度”等部分，有助于推导和实现复杂控制算法。</p>
<hr>
<h3 id="112-线性变换与基变换子空间概念"><a class="header" href="#112-线性变换与基变换子空间概念">1.1.2 线性变换与基变换、子空间概念</a></h3>
<h4 id="1121-线性变换的定义及矩阵表示"><a class="header" href="#1121-线性变换的定义及矩阵表示">1.1.2.1 线性变换的定义及矩阵表示</a></h4>
<p>设 (T:\mathbb{R}^n\to\mathbb{R}^m)，如果对任意向量 (\mathbf{x},\mathbf{y}) 和任意标量 (\alpha) 都有
$$
T(\mathbf{x} + \mathbf{y}) = T(\mathbf{x}) + T(\mathbf{y}),\quad
T(\alpha \mathbf{x}) = \alpha T(\mathbf{x}),
$$
则称 (T) 为一个<strong>线性变换</strong>。</p>
<p>在给定的一组基（如标准基）下，每个线性变换都可以用一个矩阵 (A\in \mathbb{R}^{m\times n}) 来表示，使得
$$
T(\mathbf{x}) = A\mathbf{x}.
$$</p>
<p>常见的几类线性变换及其矩阵表示：</p>
<ul>
<li><strong>缩放（沿坐标轴伸缩）</strong>
$$
A = \begin{bmatrix}
s_x &amp; 0
0   &amp; s_y
\end{bmatrix}
\Rightarrow
\begin{bmatrix}
x’\
y’
\end{bmatrix}
=\begin{bmatrix}
s_x x\
s_y y
\end{bmatrix}.
$$</li>
<li><strong>二维旋转（绕原点旋转角度 (\theta)</strong>）
$$
R(\theta) =
\begin{bmatrix}
\cos\theta &amp; -\sin\theta
\sin\theta &amp; \cos\theta
\end{bmatrix}.
$$</li>
</ul>
<blockquote>
<p>【图 1-3 占位：二维平面上展示一个向量经过旋转矩阵作用前后的关系，标注旋转角度 (\theta)。】</p>
</blockquote>
<p>在机器人学中，我们会大量使用“旋转矩阵 + 平移向量”来描述姿态与坐标变换，都是线性代数在三维空间的具体体现（详见第 6 章）。</p>
<h4 id="1122-基变换坐标系转换"><a class="header" href="#1122-基变换坐标系转换">1.1.2.2 基变换（坐标系转换）</a></h4>
<p>**基（basis）**是一组线性无关的向量，它们的线性组合可以表示空间中的任意向量。
在 (\mathbb{R}^2) 中，标准基是
$$
\mathbf{e}_1=
\begin{bmatrix}
1\
0
\end{bmatrix},\quad
\mathbf{e}_2=
\begin{bmatrix}
0\
1
\end{bmatrix}.
$$</p>
<p>但我们也可以选用别的基，例如
(\mathbf{b}_1 = \begin{bmatrix}1\1\end{bmatrix},\ \mathbf{b}_2=\begin{bmatrix}-1\1\end{bmatrix})，它们同样线性无关，也能生成整个平面。</p>
<p><strong>同一个几何向量，在不同基下的坐标不同。</strong>
如果 ({\mathbf{e}<em>i}) 与 ({\mathbf{b}<em>i}) 是两组基，令
$$
P = [\mathbf{b}<em>1\ \mathbf{b}<em>2\ \cdots\ \mathbf{b}<em>n]
$$
即把新基向量按列排成矩阵，则对任意向量 (\mathbf{v})，它在标准基下的坐标 ([\mathbf{v}]</em>{\text{std}}) 与在新基下的坐标 ([\mathbf{v}]</em>{\text{new}}) 关系是：
$$
[\mathbf{v}]</em>{\text{std}} = P,[\mathbf{v}]</em>{\text{new}},\quad
[\mathbf{v}]</em>{\text{new}} = P^{-1},[\mathbf{v}]_{\text{std}}.
$$</p>
<blockquote>
<p>【图 1-4 占位：二维平面中，原来的 x–y 坐标系与旋转后的新坐标系 ((\mathbf{b}_1,\mathbf{b}_2))，同一个点在两套坐标系中的表示。】</p>
</blockquote>
<p>在机器人中：</p>
<ul>
<li>不同关节、末端执行器、摄像头都有自己的坐标系；</li>
<li>“手眼标定”就是精确计算这些坐标系之间的变换（后面第 6 章、3 章会反复出现）；</li>
<li>基变换的本质，就是把向量在不同“观察视角”下重新表达。</li>
</ul>
<h4 id="1123-向量子空间与维度"><a class="header" href="#1123-向量子空间与维度">1.1.2.3 向量子空间与维度</a></h4>
<p>一个非空子集 (U\subseteq \mathbb{R}^n)，若对任意 (\mathbf{x},\mathbf{y}\in U) 和任意标量 (\alpha,\beta)，有
$$
\alpha \mathbf{x} + \beta \mathbf{y} \in U,
$$
则称 (U) 为一个<strong>向量子空间</strong>。</p>
<p>简单例子：</p>
<ul>
<li>通过原点的一条直线（如所有 ((t,2t)) 的集合）是 (\mathbb{R}^2) 的一维子空间；</li>
<li>通过原点的一张平面是 (\mathbb{R}^3) 的二维子空间。</li>
</ul>
<p><strong>维度（dimension）<strong><strong>是指一组基中向量的个数，也就是子空间中“互相独立方向”的数目。维度可以理解为这个子空间所需的</strong></strong>自由度</strong>个数。</p>
<p>与矩阵相关的典型子空间包括：</p>
<ul>
<li><strong>列空间（column space）</strong>：所有列向量的线性组合，表示线性变换输出可能落在的子空间；</li>
<li><strong>零空间 / 核（null space）</strong>：所有满足 (A\mathbf{x}=0) 的向量集合，表示“被变换压缩成 0 的方向”。</li>
</ul>
<p>线性代数中的一个重要结果（秩–零化度定理）表明：
对 (A:\mathbb{R}^n\to\mathbb{R}^m)，有
$$
\dim(\text{Im}(A)) + \dim(\text{Ker}(A)) = n,
$$
即“输出空间维度 + 被压扁成 0 的方向数 = 原空间维度”。这在理解“冗余自由度”“约束”等概念时非常有用。</p>
<hr>
<h3 id="113-特征值特征向量与对角化"><a class="header" href="#113-特征值特征向量与对角化">1.1.3 特征值、特征向量与对角化</a></h3>
<h4 id="1131-特征值与特征向量的定义和求解"><a class="header" href="#1131-特征值与特征向量的定义和求解">1.1.3.1 特征值与特征向量的定义和求解</a></h4>
<p>给定一个 (n\times n) 矩阵 (A)，非零向量 (\mathbf{v}\in\mathbb{R}^n) 若满足
$$
A\mathbf{v} = \lambda \mathbf{v}
$$
其中标量 (\lambda) 为实数（或复数），则称 (\mathbf{v}) 是 (A) 的一个<strong>特征向量（eigenvector）</strong>，(\lambda) 是对应的<strong>特征值（eigenvalue）</strong>。</p>
<p>几何含义：在变换 (A) 下，大多数向量的方向都会改变，但<strong>特征向量的方向保持不变，仅被拉伸或压缩了一个倍数 (\lambda)</strong>。这使得特征向量成为“最容易理解的方向”。</p>
<p>求解方法（简要）：</p>
<ol>
<li>将方程改写为 ((A - \lambda I)\mathbf{v} = 0)。</li>
<li>要有非零解，需要 (\det(A - \lambda I) = 0)。
这得到关于 (\lambda) 的多项式，称为<strong>特征多项式</strong>。</li>
<li>解出所有特征值 (\lambda_i)，再对每个 (\lambda_i) 解线性方程组 ((A-\lambda_i I)\mathbf{v}=0)，得到对应的特征向量。</li>
</ol>
<p>特征值分解（eigendecomposition）正是围绕这些特征值、特征向量对矩阵进行因式分解，是后续对角化和 SVD、PCA 的基础。(<a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix?utm_source=chatgpt.com">维基百科</a>)</p>
<p>在动态系统中，(|\lambda|&gt;1) 的特征值通常对应不稳定方向，(|\lambda|&lt;1) 对应收缩方向，这在分析机器人控制系统的稳定性时非常重要。</p>
<h4 id="1132-矩阵对角化"><a class="header" href="#1132-矩阵对角化">1.1.3.2 矩阵对角化</a></h4>
<p>若一个 (n\times n) 矩阵 (A) 有 (n) 个线性无关的特征向量 (\mathbf{v}_1,\dots,\mathbf{v}_n)，将它们按列组成矩阵
$$
P = [\mathbf{v}_1,\mathbf{v}_2,\cdots,\mathbf{v}_n],
$$
再将对应特征值排成对角矩阵
$$
\Lambda = \operatorname{diag}(\lambda_1,\dots,\lambda_n),
$$
则有
$$
A = P\Lambda P^{-1}.
$$
这称为矩阵的<strong>对角化</strong>，也称为特征分解的一种形式。(<a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix?utm_source=chatgpt.com">维基百科</a>)</p>
<ul>
<li>若 (A) 是<strong>实对称矩阵</strong>（(A=A^\top)），则由谱定理可知：
<ul>
<li>所有特征值均为实数；</li>
<li>可选择一组<strong>正交特征向量</strong>，此时 (P) 是正交矩阵（(P^{-1}=P^\top)），
对角化形式为 (A = P\Lambda P^\top)。(<a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix?utm_source=chatgpt.com">维基百科</a>)</li>
</ul>
</li>
</ul>
<blockquote>
<p>【图 1-5 占位：示意矩阵 (A) 通过对角化表示为“先在特征向量基下坐标变换 (P^{-1}) ，再沿坐标轴缩放 (\Lambda)，再变回原基 (P)”的几何图。】</p>
</blockquote>
<p>不是所有矩阵都能对角化；如果特征向量数量不够（例如出现“缺陷矩阵”），就不能写成上述形式。</p>
<h4 id="1133-对角化在计算中的作用"><a class="header" href="#1133-对角化在计算中的作用">1.1.3.3 对角化在计算中的作用</a></h4>
<p>对角化最大的好处，是把复杂的矩阵运算变成了<strong>逐元素的标量运算</strong>。例如：</p>
<ul>
<li>计算矩阵高次幂
若 (A=P\Lambda P^{-1})，则
$$
A^k = P\Lambda^k P^{-1},
$$
而 (\Lambda^k) 仅需把对角线元素 (\lambda_i) 各自做 (k) 次方即可。</li>
<li>计算函数 (f(A))（如指数矩阵 (e^A)、多项式 (A^2 + A + I) 等）也可以通过
$$
f(A) = P f(\Lambda) P^{-1}
$$
实现，其中 (f(\Lambda)) 对角线上为 (f(\lambda_i))。</li>
</ul>
<p>在机器学习和机器人中，对角化及其推广（如谱分解、SVD）经常用于：</p>
<ul>
<li>分析协方差矩阵，得到主成分（即 PCA）；</li>
<li>对系统的线性近似进行<strong>模态分解</strong>，识别系统的主振动模式或主变化方向；</li>
<li>简化数值计算，提高算法稳定性。</li>
</ul>
<hr>
<h3 id="114-奇异值分解svd与主成分分析pca"><a class="header" href="#114-奇异值分解svd与主成分分析pca">1.1.4 奇异值分解（SVD）与主成分分析（PCA）</a></h3>
<h4 id="1141-奇异值分解的形式及各部分含义"><a class="header" href="#1141-奇异值分解的形式及各部分含义">1.1.4.1 奇异值分解的形式及各部分含义</a></h4>
<p>对任意实矩阵 (A\in \mathbb{R}^{m\times n})，总可以写成
$$
A = U\Sigma V^\top,
$$
其中：</p>
<ul>
<li>(U\in\mathbb{R}^{m\times m})：列向量为<strong>左奇异向量</strong>，构成一个正交基（(U^\top U = I_m)）；</li>
<li>(V\in\mathbb{R}^{n\times n})：列向量为<strong>右奇异向量</strong>，也构成正交基（(V^\top V = I_n)）；</li>
<li>(\Sigma\in\mathbb{R}^{m\times n})：对角矩阵（主对角线非负，其他为 0），对角线元素 (\sigma_1\ge \sigma_2\ge \dots\ge 0) 称为<strong>奇异值（singular values）</strong>。(<a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix?utm_source=chatgpt.com">维基百科</a>)</li>
</ul>
<p>几何上，SVD 可以理解为：</p>
<ol>
<li>(V^\top)：在输入空间中做一次旋转（或反射），把坐标轴对齐到“最重要方向”上；</li>
<li>(\Sigma)：沿这些坐标轴进行不同程度的缩放（奇异值大小）；</li>
<li>(U)：在输出空间中再做一次旋转（或反射）。</li>
</ol>
<blockquote>
<p>【图 1-6 占位：二维椭圆通过 SVD 分解为“旋转–拉伸–再旋转”的示意，标出左右奇异向量及奇异值。】</p>
</blockquote>
<p>重要性质：(A^\top A) 与 (AA^\top) 的特征分解与 SVD 紧密相关，(\sigma_i^2) 是 (A^\top A) 的特征值，这一性质直接连接到 PCA。</p>
<h4 id="1142-主成分分析利用-svd-降维"><a class="header" href="#1142-主成分分析利用-svd-降维">1.1.4.2 主成分分析利用 SVD 降维</a></h4>
<p>**主成分分析（PCA）**是经典的线性降维方法。给定数据矩阵 (X \in \mathbb{R}^{N\times d})（N 条样本，每条 d 维特征），经过中心化（每列减去均值）后，其协方差矩阵为
$$
C = \frac{1}{N} X^\top X.
$$</p>
<p>PCA 的目标是寻找一组正交方向，使得数据在这些方向上的<strong>方差最大</strong>。可以证明，这些方向正是协方差矩阵 (C) 的特征向量，而对应特征值大小反映在该方向上的方差大小。(<a href="https://en.wikipedia.org/wiki/Principal_component_analysis?utm_source=chatgpt.com">维基百科</a>)</p>
<p>另一方面，对中心化后的 (X) 做 SVD：
$$
X = U\Sigma V^\top,
$$
则：</p>
<ul>
<li>(V) 的列向量就是 PCA 的<strong>主成分方向</strong>；</li>
<li>(\Sigma) 的对角线元素与各主成分上的方差成正比。</li>
</ul>
<p>因此，PCA 实际上可以通过 SVD 来高效实现：取前 (k) 个最大的奇异值及对应的右奇异向量，就能将数据从 (d) 维降到 (k) 维，且在均方误差意义下是最优的<strong>低秩近似（Eckart–Young 定理）</strong>。(<a href="https://arxiv.org/abs/2402.18427?utm_source=chatgpt.com">arXiv</a>)</p>
<h4 id="1143-svdpca-在图像和数据降维中的应用示例"><a class="header" href="#1143-svdpca-在图像和数据降维中的应用示例">1.1.4.3 SVD/PCA 在图像和数据降维中的应用示例</a></h4>
<ol>
<li><strong>图像压缩</strong>
将一张灰度图像表示成矩阵 (A)（行列为像素坐标，元素为灰度值），做 SVD：
$$
A \approx U_k \Sigma_k V_k^\top
$$
只保留前 (k) 个奇异值和对应列向量，就得到一个秩为 (k) 的近似。这时：</li>
</ol>
<blockquote>
<p>【图 1-7 占位：左图原始图像，中间为 rank-5 近似，右图为 rank-20 近似，对比可视化 SVD 压缩效果。】</p>
</blockquote>
<pre><code>- 存储量从原来的 (mn) 降到大约 (k(m+n))；
- 若选择合适的 (k)，肉眼几乎感觉不到图像质量下降。
</code></pre>
<ol start="2">
<li><strong>数据去噪与可视化</strong>
在高维数据中，噪声通常分布在方差较小的方向上。PCA 只保留方差较大的前几个主成分，可以自动抑制噪声，同时把数据降到 2D/3D 以利于可视化。</li>
<li><strong>机器人与具身智能中的应用</strong>
<ul>
<li>将高维视觉特征、关节状态组合成的状态向量压缩到低维“任务子空间”，从而提高强化学习、控制算法的效率；</li>
<li>在多机器人的大规模示教数据中，用 PCA/SVD 发现最主要的运动模式。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="115-在线性代数视角下理解深度学习表示空间低秩近似"><a class="header" href="#115-在线性代数视角下理解深度学习表示空间低秩近似">1.1.5 在线性代数视角下理解深度学习（表示空间、低秩近似）</a></h3>
<h4 id="1151-向量表示空间"><a class="header" href="#1151-向量表示空间">1.1.5.1 向量表示空间</a></h4>
<p>深度学习中，“<strong>向量表示（embedding）</strong>”几乎无处不在：</p>
<ul>
<li>自然语言中的词、句子通过嵌入层映射到 (\mathbb{R}^d)；</li>
<li>图像经过卷积网络或视觉 Transformer 编码后变成特征向量；</li>
<li>机器人状态（关节角、速度、力、接触信息等）也常被进一步映射到一个“潜在空间”。</li>
</ul>
<p>在这些表示空间中：</p>
<ul>
<li>内积/余弦相似度衡量两个对象在语义上的接近程度；</li>
<li>线性组合 (\alpha \mathbf{v}_1 + \beta \mathbf{v}_2) 可以看作是“在语义上介于两者之间”的某种插值；</li>
<li>子空间可以表示某类特定属性（例如“抓取相关特征子空间”“语言指令中的空间关系子空间”）。</li>
</ul>
<p>从线性代数角度看，大模型的许多“奇妙能力”，例如插值生成、线性属性操作（如词向量中的“king - man + woman ≈ queen”现象），都依赖于向量空间结构良好的几何性质。</p>
<h4 id="1152-低秩近似"><a class="header" href="#1152-低秩近似">1.1.5.2 低秩近似</a></h4>
<p>**秩（rank）**反映了矩阵中“真正独立的方向”的个数。许多深度模型的权重矩阵在训练后实际上是“接近低秩”的：虽然形状可能是 (d\times d)，但有效信息主要集中在少数几个方向上。</p>
<p>对权重矩阵 (W \in \mathbb{R}^{m\times n}) 做 SVD：
$$
W = U\Sigma V^\top,
$$
只保留前 (k) 个奇异值和向量，得到 (W_k)：
$$
W_k = U_k\Sigma_k V_k^\top,
$$
它是 (W) 在 Frobenius 范数意义下的<strong>最优秩 (k) 近似</strong>。(<a href="https://arxiv.org/abs/2402.18427?utm_source=chatgpt.com">arXiv</a>)</p>
<p>工程上常用的做法是直接把矩阵分解为两个较小的矩阵：
$$
W \approx AB^\top,\quad A\in\mathbb{R}^{m\times k},\ B\in\mathbb{R}^{n\times k},
$$
这样原本 (mn) 个参数变成 (k(m+n)) 个，当 (k\ll \min(m,n)) 时会大幅降低参数量和计算量。这类思想在：</p>
<ul>
<li>模型压缩与加速（如卷积核低秩近似、Transformer 的低秩注意力）；</li>
<li>参数高效微调（如 LoRA、Adapter 等将在第 2 章详细介绍）</li>
</ul>
<p>中被广泛使用。</p>
<blockquote>
<p>【图 1-8 占位：示意一个大的权重矩阵被分解为两个瘦长矩阵相乘，说明参数数量减少。】</p>
</blockquote>
<h4 id="1153-利用特征向量理解神经网络权重矩阵的模式"><a class="header" href="#1153-利用特征向量理解神经网络权重矩阵的模式">1.1.5.3 利用特征向量理解神经网络权重矩阵的模式</a></h4>
<p>线性代数还可以帮助我们理解深度网络“学到了什么”。</p>
<ul>
<li>对一个层的权重矩阵 (W) 做 SVD，右奇异向量（或特征向量）对应输入空间的“主要变化方向”，左奇异向量对应输出空间的“主要响应模式”；奇异值大小则表明该方向的重要性。(<a href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix?utm_source=chatgpt.com">维基百科</a>)</li>
<li>在卷积层中，将卷积核视作矩阵后做 SVD，可以发现网络偏好检测的纹理、边缘、方向等模式。</li>
<li>在机器人控制中，对线性化后的动力学模型矩阵（如雅可比矩阵、惯量矩阵）进行特征分解，可以识别出“容易运动的方向”和“难以运动的方向”，有利于设计更高效的控制策略。</li>
</ul>
<p>这些分析方法为后续章节中的“可解释性”“模型诊断”“控制稳定性分析”提供了理论工具。</p>
<hr>
<p>本节从向量与矩阵的基本运算出发，逐步引入了线性变换、子空间、特征值与特征向量、SVD 与 PCA，并点到为止地联系了深度学习和机器人具身智能中的典型应用。在后续章节中，我们会在模型结构、优化算法、视觉–语言–动作表示等具体场景中反复使用这些概念；熟练掌握本节内容，就掌握了进入 VLA 与机器人学习世界所需的“线性代数通行证”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="概率与统计基础"><a href="#概率与统计基础" class="header">概率与统计基础</a></h1>
<h3 id="121-随机变量分布期望与方差"><a class="header" href="#121-随机变量分布期望与方差">1.2.1 随机变量、分布、期望与方差</a></h3>
<p>在具身智能里，机器人看到的是一串“带噪声”的观测：距离可能测得偏大一点、偏小一点；每次抓取也不一定都成功。要想在不确定世界里做决策，首先要会用“随机变量”和“分布”来刻画这种不确定性。</p>
<hr>
<h4 id="1211-随机变量的概念"><a class="header" href="#1211-随机变量的概念">1.2.1.1 随机变量的概念</a></h4>
<p><strong>随机试验与样本空间</strong></p>
<ul>
<li>随机试验：结果在单次发生前不确定，但所有可能结果是已知的过程，例如：
<ul>
<li>抛硬币（正面 / 反面）；</li>
<li>机器人执行抓取动作（成功 / 失败）；</li>
<li>激光雷达测距（读数会因噪声略有变化）。</li>
</ul>
</li>
<li>样本空间：所有可能结果构成的集合，记为 $\Omega$。</li>
</ul>
<p><strong>随机变量（Random Variable）</strong>
随机变量本质上是一个<strong>函数</strong>：把样本空间中的每个结果映射到一个实数。</p>
<ul>
<li>
<p>例如：抛硬币，定义</p>
<p>$$
X(\text{正面}) = 1,\quad X(\text{反面}) = 0
$$</p>
<p>这样“抛硬币”就被变成了“取 0 或 1 的随机变量”。</p>
</li>
<li>
<p>对机器人而言，可以令</p>
<ul>
<li>$X$：某次抓取是否成功（成功 = 1，失败 = 0）；</li>
<li>$Y$：某次测距的读数（单位：米）。</li>
</ul>
</li>
</ul>
<p><strong>离散随机变量与连续随机变量</strong></p>
<ul>
<li><strong>离散型</strong>：只取有限或可数多个值，例如 $X\in{0,1}$、骰子点数 ${1,2,3,4,5,6}$。</li>
<li><strong>连续型</strong>：在一个区间上取任意实数，例如测得距离 $Y\in[0,5]$ 米。</li>
</ul>
<p><strong>概率分布</strong></p>
<ul>
<li>
<p>对离散随机变量，用<strong>概率质量函数</strong>（pmf）描述：</p>
<p>$$
p_X(x) = \mathbb{P}(X = x)
$$</p>
</li>
<li>
<p>对连续随机变量，用<strong>概率密度函数</strong>（pdf）描述：</p>
<p>$$
f_X(x) \ge 0,\quad \int_{-\infty}^{+\infty} f_X(x),\mathrm{d}x = 1
$$</p>
</li>
<li>
<p>相应的<strong>分布函数</strong>（CDF）为</p>
<p>$$
F_X(x) = \mathbb{P}(X \le x)
$$</p>
</li>
</ul>
<p>这些定义构成了概率论和统计学习的最基础语言。(<a href="https://bookdown.org/charlotte_micheloud93/Clinical_Biostatistics/expectation-variance-covariance-and-correlation.html?utm_source=chatgpt.com">bookdown.org</a>)</p>
<blockquote>
<p><strong>图片占位</strong>：
【图 1-2-1】一张示意图：上半部分为离散随机变量，在数轴上几个点画柱状条表示各自概率；下半部分为连续随机变量，画一条平滑曲线表示概率密度。</p>
</blockquote>
<hr>
<h4 id="1212-数学期望与方差"><a class="header" href="#1212-数学期望与方差">1.2.1.2 数学期望与方差</a></h4>
<p><strong>数学期望（Expectation）</strong>
直观上，期望就是“长期平均值”或“分布的重心”：</p>
<ul>
<li>
<p>离散情形：</p>
<p>$$
\mathbb{E}[X] = \sum_x x, p_X(x)
$$</p>
</li>
<li>
<p>连续情形：</p>
<p>$$
\mathbb{E}[X] = \int_{-\infty}^{+\infty} x, f_X(x),\mathrm{d}x
$$</p>
</li>
</ul>
<p>例如一个公平骰子 $X\in{1,2,3,4,5,6}$，每个点数概率 $1/6$：</p>
<p>$$
\mathbb{E}[X] = \frac{1+2+3+4+5+6}{6} = 3.5
$$</p>
<p><strong>在机器人中的直觉</strong></p>
<ul>
<li>激光雷达多次测量同一障碍物距离，其平均值接近真实距离。</li>
<li>期望告诉你：如果你在同样条件下重复实验很多次，平均结果会到哪里。(<a href="https://bookdown.org/charlotte_micheloud93/Clinical_Biostatistics/expectation-variance-covariance-and-correlation.html?utm_source=chatgpt.com">bookdown.org</a>)</li>
</ul>
<p><strong>方差（Variance）</strong>
期望只告诉我们“平均在哪”，但不知道“抖动有多大”。方差刻画的是<strong>随机变量偏离其期望的平均平方程度</strong>：</p>
<p>$$
\mathrm{Var}(X) = \mathbb{E}\big[(X - \mathbb{E}[X])^2\big]
$$</p>
<p>常用的等价形式是：</p>
<p>$$
\mathrm{Var}(X) = \mathbb{E}[X^2] - \big(\mathbb{E}[X]\big)^2
$$</p>
<p><strong>示例：公平骰子的方差</strong></p>
<p>$$
\mathrm{Var}(X) = \mathbb{E}[X^2] - \big(\mathbb{E}[X]\big)^2
$$</p>
<p>$$
\mathbb{E}[X^2]
= \frac{1^2+2^2+3^2+4^2+5^2+6^2}{6}
= \frac{91}{6}
$$</p>
<p>$$
\mathrm{Var}(X)
= \frac{91}{6} - 3.5^2
= \frac{91}{6} - 12.25
= \frac{35}{12}
$$</p>
<p>在机器人场景中：</p>
<ul>
<li>如果测距结果方差很大，说明传感器噪声严重；</li>
<li>如果机械臂末端位置的方差小，说明重复执行同一动作结果比较稳定。(<a href="https://bookdown.org/charlotte_micheloud93/Clinical_Biostatistics/expectation-variance-covariance-and-correlation.html?utm_source=chatgpt.com">bookdown.org</a>)</li>
</ul>
<hr>
<h4 id="1213-常用统计量标准差与协方差"><a class="header" href="#1213-常用统计量标准差与协方差">1.2.1.3 常用统计量：标准差与协方差</a></h4>
<p><strong>标准差（Standard Deviation）</strong>
标准差是方差的平方根：</p>
<p>$$
\sigma_X = \sqrt{\mathrm{Var}(X)}
$$</p>
<p>优点：</p>
<ul>
<li>与随机变量 $X$ 的量纲相同（例如都是“米”），直观度量“典型偏离程度”；</li>
<li>在很多工程指标中，比方差更常用，例如“噪声标准差为 0.01 m”。(<a href="https://matrix.skku.ac.kr/intro-math4ai/W11/?utm_source=chatgpt.com">matrix.skku.ac.kr</a>)</li>
</ul>
<p><strong>协方差（Covariance）</strong>
当我们同时考虑两个随机变量 $X, Y$ 时，会关心它们是不是“倾向一起变大或一起变小”。协方差定义为：</p>
<p>$$
\mathrm{Cov}(X,Y) = \mathbb{E}\big[(X - \mu_X)(Y - \mu_Y)\big]
$$</p>
<p>其中 $\mu_X = \mathbb{E}[X]$, $\mu_Y = \mathbb{E}[Y]$。(<a href="https://bookdown.org/charlotte_micheloud93/Clinical_Biostatistics/expectation-variance-covariance-and-correlation.html?utm_source=chatgpt.com">bookdown.org</a>)</p>
<p>直观解释：</p>
<ul>
<li>$\mathrm{Cov}(X,Y) &gt; 0$：当 $X$ 高于自己平均值时，$Y$ 也往往高于自己的平均值（“正相关”）；</li>
<li>$\mathrm{Cov}(X,Y) &lt; 0$：一个偏高时另一个偏低（“负相关”）；</li>
<li>$\mathrm{Cov}(X,Y) \approx 0$：二者之间基本没有线性关系。</li>
</ul>
<p><strong>协方差矩阵</strong>
对多维随机向量 $\mathbf{X}=(X_1,\dots,X_d)$，可以把所有变量两两之间的协方差排成一个矩阵：</p>
<p>$$
\Sigma_{ij} = \mathrm{Cov}(X_i, X_j)
$$</p>
<p>这个矩阵在后续的多元高斯分布、PCA、卡尔曼滤波等场景中将频繁出现。</p>
<p><strong>在机器人中的例子</strong></p>
<ul>
<li>左右轮速度的协方差：如果机器人在直线行驶时，两轮速度偏差往往同向变化，则协方差为正。</li>
<li>多关节机械臂末端误差的协方差：可以描述各方向误差是“独立的”还是“耦合的”。(<a href="https://www.machinelearningmastery.com/introduction-to-expected-value-variance-and-covariance/?utm_source=chatgpt.com">MachineLearningMastery.com</a>)</li>
</ul>
<blockquote>
<p><strong>图片占位</strong>：
【图 1-2-2】二维散点图三组：
1）点云大致沿着右上斜线（正协方差）；
2）点云沿右下斜线（负协方差）；
3）点云几乎圆形云团（协方差约为 0）。</p>
</blockquote>
<hr>
<h3 id="122-条件概率贝叶斯公式独立与条件独立"><a class="header" href="#122-条件概率贝叶斯公式独立与条件独立">1.2.2 条件概率、贝叶斯公式、独立与条件独立</a></h3>
<p>机器人决策几乎总是在“知道了一部分信息”的前提下进行的：</p>
<ul>
<li>已经看见桌上有杯子；</li>
<li>已经知道上一步动作执行成功；</li>
<li>已经检测到前方障碍物。</li>
</ul>
<p>此时我们需要的就是<strong>条件概率</strong>与<strong>贝叶斯更新</strong>。</p>
<hr>
<h4 id="1221-条件概率"><a class="header" href="#1221-条件概率">1.2.2.1 条件概率</a></h4>
<p><strong>定义</strong>
在事件 $B$ 已经发生的前提下，事件 $A$ 发生的概率称为条件概率，记为 $\mathbb{P}(A\mid B)$：</p>
<p>$$
\mathbb{P}(A\mid B) = \frac{\mathbb{P}(A\cap B)}{\mathbb{P}(B)},\quad \mathbb{P}(B)&gt;0
$$</p>
<p>这表示：在“只考虑 $B$ 发生的那些情况”时，$A$ 出现的比例。(<a href="https://math.mit.edu/~dav/05.dir/class3-prep.pdf?utm_source=chatgpt.com">麻省理工学院数学</a>)</p>
<p><strong>乘法公式</strong>
由定义可得：</p>
<p>$$
\mathbb{P}(A\cap B)
= \mathbb{P}(A\mid B),\mathbb{P}(B)
= \mathbb{P}(B\mid A),\mathbb{P}(A)
$$</p>
<p><strong>例子：视觉检测</strong></p>
<ul>
<li>$A$：实际上前方真的有障碍物；</li>
<li>$B$：视觉模型输出“有障碍物”。</li>
</ul>
<p>$\mathbb{P}(B\mid A)$ 是检测器的<strong>召回</strong>，$\mathbb{P}(B\mid\neg A)$ 反映<strong>误报率</strong>；
条件概率允许我们根据检测结果重新评估“前方真的有障碍”的可能性。</p>
<hr>
<h4 id="1222-贝叶斯公式"><a class="header" href="#1222-贝叶斯公式">1.2.2.2 贝叶斯公式</a></h4>
<p>贝叶斯公式给出了“反向推理”的方式：通过观测结果 $B$，更新对原因 $A$ 的信念：</p>
<p>$$
\mathbb{P}(A\mid B) = \frac{\mathbb{P}(B\mid A),\mathbb{P}(A)}{\mathbb{P}(B)}
$$</p>
<p>其中</p>
<ul>
<li>$\mathbb{P}(A)$：<strong>先验概率</strong>，表示在看到数据之前对 $A$ 的主观信念；</li>
<li>$\mathbb{P}(B\mid A)$：<strong>似然</strong>（likelihood），数据在假设 $A$ 成立下出现的概率；</li>
<li>$\mathbb{P}(B)$：<strong>证据</strong>（evidence），是数据在所有可能假设下出现的总体概率；</li>
<li>$\mathbb{P}(A\mid B)$：<strong>后验概率</strong>，看到数据之后对 $A$ 的更新信念。(<a href="https://www.almabetter.com/bytes/tutorials/applied-statistics/bayes-theorem?utm_source=chatgpt.com">AlmaBetter</a>)</li>
</ul>
<p>面向参数 $\theta$ 与数据 $D$ 的形式常写为：</p>
<p>$$
p(\theta\mid D) = \frac{p(D\mid\theta),p(\theta)}{p(D)}
$$</p>
<p><strong>机器人示例：障碍物存在概率</strong></p>
<ul>
<li>$A$：前方有障碍物；</li>
<li>$D$：相机模型给出“有障碍”信号。</li>
</ul>
<p>若我们知道传感器在有障碍 / 无障碍时的检测分布，就可以用贝叶斯公式更新 $\mathbb{P}(A\mid D)$，从而更理性地决定是否减速或绕行。</p>
<hr>
<h4 id="1223-事件独立与条件独立"><a class="header" href="#1223-事件独立与条件独立">1.2.2.3 事件独立与条件独立</a></h4>
<p><strong>独立（Independence）</strong>
事件 $A$ 与 $B$ 独立，当且仅当：</p>
<p>$$
\mathbb{P}(A\cap B) = \mathbb{P}(A),\mathbb{P}(B)
$$</p>
<p>等价地：</p>
<p>$$
\mathbb{P}(A\mid B) = \mathbb{P}(A),\quad
\mathbb{P}(B\mid A) = \mathbb{P}(B)
$$</p>
<p>直觉：$A$ 是否发生对 $B$ 完全没有影响，反之亦然。(<a href="https://math.mit.edu/~dav/05.dir/class3-prep.pdf?utm_source=chatgpt.com">麻省理工学院数学</a>)</p>
<p><strong>条件独立（Conditional Independence）</strong>
在给定条件 $C$ 的前提下，如果</p>
<p>$$
\mathbb{P}(A,B\mid C) = \mathbb{P}(A\mid C),\mathbb{P}(B\mid C)
$$</p>
<p>则称 $A$ 与 $B$ <strong>在条件 $C$ 下独立</strong>，记作 $A \perp B \mid C$。</p>
<p>例子：</p>
<ul>
<li>$C$：房间的布局已知；</li>
<li>$A$：左侧存在障碍；</li>
<li>$B$：右侧存在障碍。</li>
</ul>
<p>在给定布局的条件下，左右是否有障碍可以近似看作相互独立。</p>
<p>条件独立的假设在贝叶斯网络等概率图模型中极其重要，可以使高维概率分布分解为若干简单因子，大幅降低建模与推断的复杂度。(<a href="https://eng.libretexts.org/Bookshelves/Industrial_and_Systems_Engineering/Chemical_Process_Dynamics_and_Controls_%28Woolf%29/13%3A_Statistics_and_Probability_Background/13.04%3A_Bayes_Rule_conditional_probability_independence?utm_source=chatgpt.com">Engineering LibreTexts</a>)</p>
<hr>
<h3 id="123-常见分布高斯伯努利多项式等"><a class="header" href="#123-常见分布高斯伯努利多项式等">1.2.3 常见分布（高斯、伯努利、多项式等）</a></h3>
<p>具身智能中的很多子模块——从传感器噪声建模，到二分类/多分类，再到事件计数——都依赖于少数几个“常见分布”。掌握它们的性质，可以让你快速看懂大多数机器人与机器学习论文中的概率假设。</p>
<hr>
<h4 id="1231-高斯分布正态分布"><a class="header" href="#1231-高斯分布正态分布">1.2.3.1 高斯分布（正态分布）</a></h4>
<p><strong>一维高斯分布</strong>
记为 $X\sim\mathcal{N}(\mu,\sigma^2)$，其密度函数为：</p>
<p>$$
f(x) = \frac{1}{\sqrt{2\pi\sigma^2}}\exp\Big(-\frac{(x-\mu)^2}{2\sigma^2}\Big)
$$</p>
<p>特性：</p>
<ul>
<li>曲线呈钟形，对称地围绕 $\mu$；</li>
<li>$\mu$：期望（位置参数），决定峰值位置；</li>
<li>$\sigma^2$：方差（尺度参数），决定“胖瘦”，$\sigma$ 越大，分布越“平”。(<a href="https://www.analyticsvidhya.com/blog/2017/09/6-probability-distributions-data-science/?utm_source=chatgpt.com">Analytics Vidhya</a>)</li>
</ul>
<p><strong>中心极限定理的直觉</strong>
大量小扰动相加往往近似服从高斯分布——这解释了为什么自然界和工程系统中，高斯噪声如此常见。</p>
<p><strong>多元高斯与协方差矩阵</strong>
对于向量随机变量 $\mathbf{X}\in\mathbb{R}^d$，多元高斯由<strong>均值向量</strong> $\boldsymbol{\mu}$ 和<strong>协方差矩阵</strong> $\Sigma$ 决定：</p>
<p>$$
\mathbf{X}\sim\mathcal{N}(\boldsymbol{\mu},\Sigma)
$$</p>
<p>协方差矩阵中的元素 $\Sigma_{ij}=\mathrm{Cov}(X_i,X_j)$ 描述各维度之间的相关性。(<a href="https://bookdown.org/charlotte_micheloud93/Clinical_Biostatistics/expectation-variance-covariance-and-correlation.html?utm_source=chatgpt.com">bookdown.org</a>)</p>
<p><strong>在机器人中的应用</strong></p>
<ul>
<li>激光雷达 / 深度相机测距误差常建模为高斯噪声；</li>
<li>卡尔曼滤波器（轨迹估计）假设过程噪声和观测噪声服从高斯分布；</li>
<li>机械臂末端误差的联合分布可视作多元高斯，从而用协方差椭球描述“不确定区域”。</li>
</ul>
<blockquote>
<p><strong>图片占位</strong>：
【图 1-2-3】一维高斯分布示意图：均值相同、标准差不同的几条“钟形曲线”；以及二维高斯的等高线椭圆。</p>
</blockquote>
<hr>
<h4 id="1232-伯努利分布与多项分布"><a class="header" href="#1232-伯努利分布与多项分布">1.2.3.2 伯努利分布与多项分布</a></h4>
<p><strong>伯努利分布（Bernoulli）</strong>
如果随机变量 $X$ 只取 0 或 1 两个值，且</p>
<p>$$
\mathbb{P}(X=1)=p,\quad \mathbb{P}(X=0)=1-p
$$</p>
<p>则称 $X$ 服从伯努利分布，记为 $X\sim\mathrm{Bernoulli}(p)$。(<a href="https://www.analyticsvidhya.com/blog/2017/09/6-probability-distributions-data-science/?utm_source=chatgpt.com">Analytics Vidhya</a>)</p>
<p>其期望与方差为：</p>
<p>$$
\mathbb{E}[X]=p,\quad \mathrm{Var}(X)=p(1-p)
$$</p>
<p>机器人中的例子：</p>
<ul>
<li>某次抓取是否成功；</li>
<li>安全监测中某类报警是否触发；</li>
<li>一个二分类模型的标签（“人类 / 非人类”）。</li>
</ul>
<p><strong>多项分布（Multinomial）</strong>
伯努利是“两选一”。如果一次试验有 $K$ 种互斥结果（如红/绿/蓝三个类），各自概率为 $\mathbf{p}=(p_1,\dots,p_K)$，重复进行 $n$ 次独立试验，统计每类出现次数 $\mathbf{X}=(X_1,\dots,X_K)$，则 $\mathbf{X}$ 服从多项分布：</p>
<p>$$
\mathbf{X}\sim \mathrm{Multinomial}(n; p_1,\dots,p_K)
$$</p>
<p>概率质量函数为：</p>
<h1 id="-mathbbpx_1x_1dotsx_kx_k"><a class="header" href="#-mathbbpx_1x_1dotsx_kx_k">$$
\mathbb{P}(X_1=x_1,\dots,X_K=x_K)</a></h1>
<p>\frac{n!}{x_1!\cdots x_K!}, p_1^{x_1}\cdots p_K^{x_K}
$$</p>
<p>满足 $x_1+\cdots+x_K=n$。(<a href="https://www.statlect.com/probability-distributions/?utm_source=chatgpt.com">statlect.com</a>)</p>
<p>在机器学习中，多项分布常用于：</p>
<ul>
<li>建模一个 $K$ 类分类器在 $n$ 次独立预测中的类别计数；</li>
<li>语言模型中，对某词窗口内词类计数建模。</li>
</ul>
<hr>
<h4 id="1233-其他常用分布均匀指数泊松"><a class="header" href="#1233-其他常用分布均匀指数泊松">1.2.3.3 其他常用分布：均匀、指数、泊松</a></h4>
<p><strong>均匀分布（Uniform）</strong></p>
<ul>
<li>
<p>离散均匀：在有限集合 ${1,\dots,N}$ 上，每个值概率 $1/N$；</p>
</li>
<li>
<p>连续均匀：在区间 $[a,b]$ 上密度为</p>
<p>$$
f(x) = \frac{1}{b-a},\quad x\in[a,b]
$$</p>
</li>
</ul>
<p>常被用作“无偏无信息”的简化假设或初始化。例如，在缺乏任何先验时，可以假设机器人初始位置在某区域服从均匀分布。</p>
<p><strong>指数分布（Exponential）</strong>
指数分布用于建模<strong>非负的等待时间</strong>，密度为：</p>
<p>$$
f(x) = \lambda e^{-\lambda x},\quad x\ge 0
$$</p>
<p>其期望为 $1/\lambda$，具有“无记忆性”：已经等了 5 秒，再等 1 秒的概率与之前等了多久无关。(<a href="https://www.analyticsvidhya.com/blog/2017/09/6-probability-distributions-data-science/?utm_source=chatgpt.com">Analytics Vidhya</a>)</p>
<p>在机器人中，可用于近似：</p>
<ul>
<li>两次随机事件（如人进入视野、网络通信中断）之间的时间间隔。</li>
</ul>
<p><strong>泊松分布（Poisson）</strong>
泊松分布常用来描述单位时间内某种稀有事件发生次数：</p>
<p>$$
\mathbb{P}(X=k) = \frac{\lambda^k e^{-\lambda}}{k!},\quad k=0,1,2,\dots
$$</p>
<p>参数 $\lambda$ 同时是其<strong>均值和方差</strong>。(<a href="https://gullayeshwantkumarruler.medium.com/exploring-various-types-of-data-distributions-in-machine-learning-494be6619618?utm_source=chatgpt.com">Medium</a>)</p>
<p>机器人例子：</p>
<ul>
<li>某段时间内传感器“检测到人”的次数；</li>
<li>控制系统中“紧急避障事件”的触发次数。</li>
</ul>
<blockquote>
<p><strong>图片占位</strong>：
【图 1-2-4】三行图：</p>
<ul>
<li>均匀分布的平坦曲线；</li>
<li>指数分布的单调递减曲线；</li>
<li>泊松分布的离散柱状图，展示不同 $\lambda$ 下形状差异。</li>
</ul>
</blockquote>
<hr>
<h3 id="124-最大似然估计最大后验估计"><a class="header" href="#124-最大似然估计最大后验估计">1.2.4 最大似然估计、最大后验估计</a></h3>
<p>在机器人学习和机器学习中，我们经常需要“从数据中估计模型参数”：例如估计传感器噪声方差、估计某类动作成功率。最大似然（MLE）和最大后验（MAP）是两种最常用的参数估计方法。(<a href="https://medium.com/data-science/a-gentle-introduction-to-maximum-likelihood-estimation-and-maximum-a-posteriori-estimation-d7c318f9d22d?utm_source=chatgpt.com">Medium</a>)</p>
<hr>
<h4 id="1241-最大似然估计mle"><a class="header" href="#1241-最大似然估计mle">1.2.4.1 最大似然估计（MLE）</a></h4>
<p><strong>似然函数（Likelihood）</strong>
给定模型参数 $\theta$、数据集 $D={x_1,\dots,x_n}$，我们将<strong>在参数 $\theta$ 下观测到这些数据的概率</strong>视为似然函数：</p>
<p>$$
L(\theta; D) = p(D\mid\theta)
$$</p>
<p>若样本在参数 $\theta$ 下独立同分布（i.i.d.），则</p>
<p>$$
L(\theta; D) = \prod_{i=1}^n p(x_i\mid\theta)
$$</p>
<p>常使用对数似然</p>
<p>$$
\ell(\theta; D)
= \log L(\theta; D)
= \sum_{i=1}^n \log p(x_i\mid\theta)
$$</p>
<p><strong>最大似然估计</strong>
MLE 就是选取使似然函数最大的参数：</p>
<p>$$
\hat{\theta}<em>{\text{MLE}}
= \arg\max</em>{\theta} L(\theta; D)
= \arg\max_{\theta} \ell(\theta; D)
$$</p>
<p><strong>示例：抛硬币估计成功率</strong>
假设硬币正面概率为 $p$，进行 $n$ 次抛掷，结果中有 $k$ 次正面。似然为</p>
<p>$$
L(p) = p^k (1-p)^{n-k}
$$</p>
<p>对数似然：</p>
<p>$$
\ell(p) = k\log p + (n-k)\log(1-p)
$$</p>
<p>对 $p$ 求导并令其为 0，可得到</p>
<p>$$
\hat{p}_{\text{MLE}} = \frac{k}{n}
$$</p>
<p>在机器人里，可类似地用 MLE 估计某动作“成功”的概率，或高斯噪声的均值与方差等。(<a href="https://medium.com/data-science/a-gentle-introduction-to-maximum-likelihood-estimation-and-maximum-a-posteriori-estimation-d7c318f9d22d?utm_source=chatgpt.com">Medium</a>)</p>
<hr>
<h4 id="1242-最大后验估计map"><a class="header" href="#1242-最大后验估计map">1.2.4.2 最大后验估计（MAP）</a></h4>
<p>MLE 只利用数据，不考虑任何“先验经验”。在很多机器人场景中，我们往往<strong>已有经验</strong>：</p>
<ul>
<li>传感器噪声大致在某个范围内；</li>
<li>某抓取动作成功率不太可能比 0.99 还高。</li>
</ul>
<p>此时可以采用 <strong>贝叶斯视角</strong>：</p>
<p>$$
p(\theta\mid D) \propto p(D\mid\theta),p(\theta)
$$</p>
<p>其中 $p(\theta)$ 是先验分布，$p(\theta\mid D)$ 是后验分布。</p>
<p><strong>最大后验估计（MAP）</strong> 选择使后验概率最大的参数：</p>
<p>$$
\hat{\theta}<em>{\text{MAP}}
= \arg\max</em>{\theta} p(\theta\mid D)
= \arg\max_{\theta} \big[p(D\mid\theta),p(\theta)\big]
$$</p>
<p>取对数：</p>
<p>$$
\hat{\theta}<em>{\text{MAP}}
= \arg\max</em>{\theta}
\big[ \log p(D\mid\theta) + \log p(\theta) \big]
$$</p>
<p>这看起来像是在最大化“数据项 + 先验项”。(<a href="https://medium.com/data-science/a-gentle-introduction-to-maximum-likelihood-estimation-and-maximum-a-posteriori-estimation-d7c318f9d22d?utm_source=chatgpt.com">Medium</a>)</p>
<p><strong>示例：带 Beta 先验的硬币</strong>
对硬币成功率 $p$ 施加 Beta 先验 $p\sim\mathrm{Beta}(\alpha,\beta)$，观测到 $k$ 次成功、$n-k$ 次失败后，后验还是 Beta 分布：</p>
<p>$$
p\mid D \sim \mathrm{Beta}(\alpha+k,\beta+n-k)
$$</p>
<p>其众数（在 $\alpha+k&gt;1,\ \beta+n-k&gt;1$ 时）是 MAP 估计：</p>
<p>$$
\hat{p}_{\text{MAP}}
= \frac{\alpha+k-1}{\alpha+\beta+n-2}
$$</p>
<p>可以看到：当样本数不大时，先验参数 $\alpha,\beta$ 会起到“平滑”作用，防止估计过于极端。</p>
<hr>
<h4 id="1243-mle-与-map-的区别联系"><a class="header" href="#1243-mle-与-map-的区别联系">1.2.4.3 MLE 与 MAP 的区别联系</a></h4>
<p><strong>联系</strong></p>
<ul>
<li>
<p>若先验 $p(\theta)$ 为常数（即“非信息先验”），或者在样本数 $n\to\infty$ 时先验影响逐渐被数据淹没，则</p>
<p>$$
\hat{\theta}<em>{\text{MAP}} \approx \hat{\theta}</em>{\text{MLE}}
$$</p>
</li>
<li>
<p>因此，在大量数据场景下，MLE 和 MAP 往往给出非常接近的结果。(<a href="https://medium.com/data-science/a-gentle-introduction-to-maximum-likelihood-estimation-and-maximum-a-posteriori-estimation-d7c318f9d22d?utm_source=chatgpt.com">Medium</a>)</p>
</li>
</ul>
<p><strong>差异与直觉</strong></p>
<p>从优化角度看，MAP = MLE + 正则化：</p>
<p>$$
\max_{\theta} \big[\log p(D\mid\theta) + \log p(\theta)\big]
$$</p>
<ul>
<li>如果先验是高斯 $p(\theta)\propto \exp(-\lambda|\theta|_2^2)$，那么 $-\log p(\theta)$ 就对应 L2 正则；</li>
<li>如果先验是拉普拉斯 $p(\theta)\propto \exp(-\lambda|\theta|_1)$，则对应 L1 正则。</li>
</ul>
<p>这和后面“机器学习中的正则化”一节是同一逻辑，只是换了一种（贝叶斯）语言来理解。</p>
<p><strong>工程取舍</strong></p>
<ul>
<li>数据少、噪声大时，MAP 利用先验经验能给出更稳定的估计；</li>
<li>数据丰富时，MLE 足够，计算更简单；</li>
<li>在具身智能中，利用物理先验（例如“参数不可能无限大”）进入 MAP，是将“常识”注入算法的一个重要途径。</li>
</ul>
<hr>
<h3 id="125-kl-散度交叉熵与在机器学习中的意义"><a class="header" href="#125-kl-散度交叉熵与在机器学习中的意义">1.2.5 KL 散度、交叉熵与在机器学习中的意义</a></h3>
<p>从这一小节开始，概率论和信息论与“损失函数”“训练目标”直接联系起来。几乎所有现代分类模型、概率模型、强化学习策略优化，都在某种形式上最小化 KL 散度或交叉熵。(<a href="https://rain-bow.tistory.com/entry/CrossEntropy?utm_source=chatgpt.com">RAINBOW-LAB</a>)</p>
<hr>
<h4 id="1251-kl-散度"><a class="header" href="#1251-kl-散度">1.2.5.1 KL 散度</a></h4>
<p><strong>定义</strong>
给定两个分布 $P$ 和 $Q$，对同一随机变量 $X$：</p>
<ul>
<li>
<p>离散情形：</p>
<p>$$
D_{\mathrm{KL}}(P|Q)
= \sum_x P(x),\log\frac{P(x)}{Q(x)}
$$</p>
</li>
<li>
<p>连续情形（形式类似，用积分）：</p>
<p>$$
D_{\mathrm{KL}}(P|Q)
= \int P(x),\log\frac{P(x)}{Q(x)},\mathrm{d}x
$$</p>
</li>
</ul>
<p>性质：</p>
<ul>
<li>$D_{\mathrm{KL}}(P|Q)\ge 0$，且等号成立当且仅当 $P=Q$（几乎处处）；</li>
<li><strong>不对称</strong>：一般有 $D_{\mathrm{KL}}(P|Q)\neq D_{\mathrm{KL}}(Q|P)$，因此它不是严格意义上的“距离”。(<a href="https://rain-bow.tistory.com/entry/CrossEntropy?utm_source=chatgpt.com">RAINBOW-LAB</a>)</li>
</ul>
<p><strong>信息论解释</strong>
如果真实分布是 $P$，但你按照 $Q$ 来设计最优编码，那么平均每个样本要多付出</p>
<p>$$
D_{\mathrm{KL}}(P|Q)
$$</p>
<p>这么多“比特”的代价。因此，KL 散度可以理解为：<strong>用 $Q$ 近似 $P$ 的“信息损失”</strong>。(<a href="https://rain-bow.tistory.com/entry/CrossEntropy?utm_source=chatgpt.com">RAINBOW-LAB</a>)</p>
<p><strong>在机器人中的直觉</strong></p>
<ul>
<li>$P$：真实环境中动作/状态的分布；</li>
<li>$Q$：你的模型或策略认为的分布。</li>
</ul>
<p>KL 散度越小，说明模型对环境的刻画越接近真实；在策略优化中，也经常用 KL 来限制新旧策略偏差，防止机器人行为突然变化过大。</p>
<hr>
<h4 id="1252-交叉熵"><a class="header" href="#1252-交叉熵">1.2.5.2 交叉熵</a></h4>
<p><strong>熵（Entropy）与交叉熵</strong>
熵 $H(P)$ 描述分布 $P$ 的不确定性：</p>
<p>$$
H(P) = -\sum_x P(x)\log P(x)
$$</p>
<p>交叉熵 $H(P,Q)$ 则定义为：</p>
<p>$$
H(P,Q) = -\sum_x P(x)\log Q(x)
$$</p>
<p>注意两者的关系：</p>
<p>$$
H(P,Q) = H(P) + D_{\mathrm{KL}}(P|Q)
$$</p>
<p>由于对给定的真实分布 $P$，熵 $H(P)$ 是常数，因此<strong>最小化交叉熵等价于最小化 KL 散度</strong>。(<a href="https://rain-bow.tistory.com/entry/CrossEntropy?utm_source=chatgpt.com">RAINBOW-LAB</a>)</p>
<p><strong>分类问题中的交叉熵损失</strong></p>
<ul>
<li>
<p>二分类（标签 $y\in{0,1}$，模型输出 $\hat{p}=\mathbb{P}(y=1\mid x)$）：</p>
<p>$$
\ell(x,y) = -\big[y\log\hat{p} + (1-y)\log(1-\hat{p})\big]
$$</p>
</li>
<li>
<p>多分类（标签为 one-hot 向量 $\mathbf{y}$，预测分布为 $\hat{\mathbf{p}}$）：</p>
<p>$$
\ell(x,\mathbf{y}) = -\sum_{k} y_k\log \hat{p}_k
$$</p>
<p>对于 one-hot 标签，有 $\ell = -\log \hat{p}_{\text{真实类别}}$。</p>
</li>
</ul>
<p>这正是深度学习中最常用的 <strong>交叉熵损失函数</strong>。(<a href="https://www.datacamp.com/tutorial/the-cross-entropy-loss-function-in-machine-learning?utm_source=chatgpt.com">DataCamp</a>)</p>
<blockquote>
<p><strong>图片占位</strong>：
【图 1-2-5】二维示意图：真实分布 $P$ 与预测分布 $Q$ 的条形图，并在旁边标注 KL$(P|Q)$ 与交叉熵 $H(P,Q)$ 的关系式。</p>
</blockquote>
<hr>
<h4 id="1253-在机器学习中的应用"><a class="header" href="#1253-在机器学习中的应用">1.2.5.3 在机器学习中的应用</a></h4>
<p><strong>监督学习中的损失函数</strong>
大部分分类模型都是在最小化“真实标签分布 $P$ 与模型预测分布 $Q$ 的交叉熵”——这在概率论层面就是让模型分布逼近真实数据分布，从而最小化 KL 散度。(<a href="https://www.datacamp.com/tutorial/the-cross-entropy-loss-function-in-machine-learning?utm_source=chatgpt.com">DataCamp</a>)</p>
<p><strong>生成模型与分布拟合</strong></p>
<ul>
<li>在变分自编码器（VAE）中，我们显式使用 KL 散度约束“近似后验分布”与“先验分布”的差异；</li>
<li>在某些密度估计问题中，训练目标就是 $\min_\theta D_{\mathrm{KL}}(P_{\text{data}}|P_\theta)$，从而让模型 $P_\theta$ 逼近真实数据分布。</li>
</ul>
<p><strong>强化学习与策略优化</strong>
在策略梯度与 PPO 等算法中，常加入 KL 散度约束：</p>
<ul>
<li>$D_{\mathrm{KL}}(\pi_{\text{old}}|\pi_{\text{new}})$ 太大说明新策略与旧策略差异过大，可能导致行为不稳定；</li>
<li>约束 KL 散度可以看作对更新步长的一种“几何”控制，确保策略逐步演化而不是剧烈跳变，这对真实机器人尤为重要。(<a href="https://medium.com/%40mrthinger/kl-divergence-vs-cross-entropy-exploring-the-differences-and-use-cases-3f3dee58c452?utm_source=chatgpt.com">Medium</a>)</li>
</ul>
<p><strong>在具身智能中的意义</strong></p>
<ul>
<li>交叉熵提供了一个统一的度量，把“预测概率分布”和“真实结果”放在同一框架下比较，适用于视觉识别、语言理解、动作分类等各类子任务；</li>
<li>KL 散度则更多地用来控制“模型的变化”和“策略分布的差异”，是把“安全与稳定”融入学习过程的数学工具。</li>
</ul>
<hr>
<p>本节从随机变量、期望方差出发，经由条件概率和贝叶斯更新，到常见分布，再到 MLE / MAP 以及 KL 散度与交叉熵，构成了后续整本书中所有概率建模与学习算法的基础。后面在讨论深度学习损失函数、强化学习策略优化、VLA 模型训练目标时，你会不断看到这些概念再次出现，并在机器人具身智能的具体场景中发挥作用。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="优化基础"><a href="#优化基础" class="header">优化基础</a></h1>
<p>下面是按照你给出的提纲，完整撰写的 <strong>1.3 优化基础</strong> 中几个小节内容草稿，风格偏教材化，适合研究生自学。从读者“会微积分和线性代数，但还没系统学过优化”的背景出发，尽量用通俗语言讲清楚核心概念，并在合适位置加了图片占位说明。公式部分保持到能看懂后面神经网络和 RL 论文为目标。</p>
<hr>
<h2 id="13-优化基础"><a class="header" href="#13-优化基础">1.3 优化基础</a></h2>
<p>在具身智能、深度学习和强化学习中，本质上都在做一件事：</p>
<blockquote>
<p><strong>找到一组参数，使某个“代价”或“损失”尽可能小。</strong></p>
</blockquote>
<p>这一节我们系统介绍优化的基本概念与方法，从最常见的梯度下降到约束优化、再到神经网络训练中的实际问题，为后续深度网络、RL、控制中的各种“求最优”打基础。</p>
<hr>
<h3 id="131-无约束优化与梯度下降"><a class="header" href="#131-无约束优化与梯度下降">1.3.1 无约束优化与梯度下降</a></h3>
<h4 id="1311-导数与梯度概念"><a class="header" href="#1311-导数与梯度概念">1.3.1.1 导数与梯度概念</a></h4>
<p><strong>（1）一元函数的导数：变化率的精确定义</strong></p>
<p>在高中数学里，导数通常被解释为切线斜率。更一般地，可以理解为：</p>
<blockquote>
<p>在一点附近，函数值对自变量的小变化有多敏感。</p>
</blockquote>
<p>设一元函数 (f(x))，在点 (x) 的导数定义为
$$
f’(x) = \lim_{h\to 0} \frac{f(x+h)-f(x)}{h}.
$$</p>
<ul>
<li>若 (f’(x) &gt; 0)：向右（(x) 增大）走一点，函数值会上升。</li>
<li>若 (f’(x) &lt; 0)：向右走一点，函数值会下降。</li>
<li>若 (f’(x) = 0)：在该点附近一阶上看不到“上升/下降”的趋势，这里可能是极大值、极小值或鞍点（后面会详细讲）。</li>
</ul>
<p><strong>（2）多元函数的偏导与梯度</strong></p>
<p>深度学习中的参数往往是高维向量 (\theta \in \mathbb{R}^d)，损失函数 (L(\theta)) 是多元函数。
对每个分量 (\theta_i) 的偏导数
$$
\frac{\partial L}{\partial \theta_i}
$$
衡量“只改变 (\theta_i)，保持其它分量不变”时，损失的变化率。</p>
<p>将所有偏导按分量收集起来，得到 <strong>梯度（gradient）</strong>：
$$
\nabla_\theta L(\theta) =
\begin{bmatrix}
\frac{\partial L}{\partial \theta_1}
\vdots
\frac{\partial L}{\partial \theta_d}
\end{bmatrix}.
$$</p>
<p>几何上，梯度有两个重要性质（在欧几里得度量下）：</p>
<ol>
<li><strong>方向</strong>：在当前点处，梯度指向函数“<strong>上升最快</strong>”的方向。</li>
<li><strong>负梯度方向</strong>：(-\nabla L) 是函数“<strong>下降最快</strong>”的方向。</li>
</ol>
<blockquote>
<p>【图 1.3-1 占位：二维函数的等高线图，标出某点处的梯度向量，显示梯度垂直等高线并指向上升最快方向；负梯度指向下降方向。】</p>
</blockquote>
<p>这两个性质是梯度下降法的核心依据。</p>
<hr>
<h4 id="1312-梯度下降法"><a class="header" href="#1312-梯度下降法">1.3.1.2 梯度下降法</a></h4>
<p><strong>（1）问题形式：无约束优化</strong></p>
<p>最简单也是最常见的优化问题形式是：</p>
<p>$$
\min_{\theta \in \mathbb{R}^d} L(\theta),
$$</p>
<p>没有额外等式/不等式约束（比如不要求 (\theta) 非负等），称为 <strong>无约束优化</strong>。在机器学习中，(\theta) 通常代表模型参数，(L(\theta)) 是在训练集上的损失或代价函数。(<a href="https://www.analyticsvidhya.com/blog/2020/10/how-does-the-gradient-descent-algorithm-work-in-machine-learning/?utm_source=chatgpt.com">Analytics Vidhya</a>)</p>
<p><strong>（2）梯度下降思想</strong></p>
<p>基于“负梯度是下降最快方向”这一事实，梯度下降（Gradient Descent）采用简单迭代：</p>
<p>$$
\theta^{(k+1)} = \theta^{(k)} - \eta \nabla_\theta L(\theta^{(k)}),
$$</p>
<p>其中：</p>
<ul>
<li>(k)：迭代步数；</li>
<li>(\eta &gt; 0)：步长或 <strong>学习率（learning rate）</strong>；</li>
<li>(\nabla_\theta L(\theta^{(k)}))：在当前参数的梯度。</li>
</ul>
<p>直观理解：</p>
<ul>
<li>每一步都“看一眼”当前坡度（梯度），</li>
<li>然后沿着下坡最快的方向走一小步（(-\eta \nabla L)），</li>
<li>希望最终走到“山谷底”（损失最小处）。(<a href="https://www.digitalocean.com/community/tutorials/intro-to-optimization-in-deep-learning-gradient-descent?utm_source=chatgpt.com">DigitalOcean</a>)</li>
</ul>
<blockquote>
<p>【图 1.3-2 占位：一维曲线 (L(\theta)) 图像，展示沿负导数方向移动的离散步点，逐步靠近最小值。】</p>
</blockquote>
<p><strong>（3）梯度下降的基本性质</strong></p>
<p>在一些理想条件下（比如 (L(\theta)) 是光滑且凸的），可以证明梯度下降会收敛到全局最小值，且步长足够小即可保证函数值单调下降。但在非凸问题（深度网络训练）中，梯度下降往往只能保证：</p>
<ul>
<li><strong>找到某个“还不错”的局部极小值或鞍点附近的低损失区域</strong>，
而不是严格意义上的全局最优。</li>
</ul>
<p>不过在深度学习的实际经验中，局部极小值问题远没有想象中那么可怕，重点反而在于收敛速度和训练稳定性，这些会在后面几小节展开。</p>
<hr>
<h4 id="1313-学习率对优化的影响"><a class="header" href="#1313-学习率对优化的影响">1.3.1.3 学习率对优化的影响</a></h4>
<p>学习率 (\eta) 决定每一步走多远，直接影响：</p>
<ul>
<li>收敛速度</li>
<li>是否发散</li>
<li>是否在最优附近震荡</li>
</ul>
<p><strong>（1）学习率过大：发散或震荡</strong></p>
<p>如果 (\eta) 取得非常大，一步走得太远，可能出现：</p>
<ul>
<li>每次更新都“跨过山谷”，在两侧来回跳，导致损失在最小值附近震荡；</li>
<li>甚至越走越远，损失越来越大，出现 <strong>发散</strong>。</li>
</ul>
<blockquote>
<p>【图 1.3-3 占位：一维损失曲线，分别画出合适步长、偏大步长（震荡）、极大步长（发散）的迭代轨迹对比。】</p>
</blockquote>
<p>在凸二次函数 (L(\theta) = \frac{1}{2}a\theta^2) 情况下，可以严格算出：
若 (\eta &gt; 2/a)，迭代就一定发散；(\eta\in(0,2/a)) 则可收敛。</p>
<p><strong>（2）学习率过小：收敛极慢</strong></p>
<p>若 (\eta) 非常小，梯度下降每次只迈出“蚂蚁步”，好处是几乎不会发散，坏处是：</p>
<ul>
<li>要走非常多步才能接近最优；</li>
<li>在实际深度网络训练中，会导致显存和时间成本都非常高。</li>
</ul>
<p><strong>（3）合适学习率：速度与稳定性的折中</strong></p>
<p>在深度学习实践中，一般：</p>
<ul>
<li>开始时使用相对较大的学习率加速下降；</li>
<li>后期逐渐减小学习率，在最优附近“慢慢收敛”，减少震荡。</li>
</ul>
<p>如何具体调度学习率，是 1.3.5 的重点内容之一。很多现代优化算法（如 Adam）本质上就是在智能地“调步长”——对不同参数维度、自不同时刻使用不同的有效学习率。(<a href="https://www.digitalocean.com/community/tutorials/intro-to-optimization-momentum-rmsprop-adam?utm_source=chatgpt.com">DigitalOcean</a>)</p>
<hr>
<h3 id="132-一阶与二阶优化方法直觉sgdmomentumadam-等"><a class="header" href="#132-一阶与二阶优化方法直觉sgdmomentumadam-等">1.3.2 一阶与二阶优化方法直觉（SGD、Momentum、Adam 等）</a></h3>
<p>在 1.3.1 中，梯度下降用到了目标函数的一阶导数（梯度）。更一般地，可以根据使用信息的多少，大致将优化方法分为：</p>
<ul>
<li><strong>一阶方法（first-order methods）</strong>：只依赖梯度；</li>
<li><strong>二阶方法（second-order methods）</strong>：还利用 Hessian（即二阶导信息）。</li>
</ul>
<p>从直觉上看：</p>
<ul>
<li>一阶方法：信息便宜、迭代快，但走路相对“笨拙”；</li>
<li>二阶方法：更聪明地利用“曲率”，但每一步计算非常贵，在大规模神经网络中通常不现实。</li>
</ul>
<hr>
<h4 id="1321-一阶方法"><a class="header" href="#1321-一阶方法">1.3.2.1 一阶方法</a></h4>
<p>一阶方法的共同特征：</p>
<blockquote>
<p>更新规则形如
(\theta^{(k+1)} = \theta^{(k)} + \text{某种函数}({\nabla L(\theta^{(t)})}_{t\le k}))。</p>
</blockquote>
<p><strong>（1）批量梯度下降（Batch GD）</strong></p>
<p>最原始的梯度下降在每一步都用 <strong>整批训练数据</strong> 计算损失和梯度，这在数据量巨大时计算代价非常高。深度学习实践中更常用的是 mini-batch 形式（见下面 SGD），这里略过。</p>
<p><strong>（2）随机梯度下降（Stochastic Gradient Descent, SGD）</strong></p>
<p>理论上需要在整批数据上计算梯度，但在实践中我们常用 <strong>一个样本或一个小批量样本</strong> 的梯度来近似整体梯度，这就是 <strong>随机梯度下降（SGD）</strong>：</p>
<p>$$
\theta^{(k+1)} = \theta^{(k)} - \eta \nabla_\theta \ell(x_{i_k}, y_{i_k}; \theta^{(k)}),
$$</p>
<p>其中：</p>
<ul>
<li>((x_{i_k}, y_{i_k})) 是在第 (k) 步随机抽取的样本或 mini-batch；</li>
<li>(\ell) 是单样本损失。</li>
</ul>
<p>这种“噪声较大的梯度”有两个好处：</p>
<ol>
<li><strong>更新更频繁，单步计算轻量</strong>，适合大数据场景；</li>
<li>由于带噪声，优化过程更容易“抖出”某些鞍点或坏的局部极小值，有助于探索更好的解。(<a href="https://wikidocs.net/166136?utm_source=chatgpt.com">wikidocs.net</a>)</li>
</ol>
<p><strong>（3）带动量的 SGD（Momentum）</strong></p>
<p>纯 SGD 更新路径常常是一条“抖动的折线”：在狭长谷底中来回摆动，收敛慢。<strong>动量（Momentum）</strong> 的思想是：</p>
<blockquote>
<p>不仅考虑当前梯度，还记住“过去一段时间的更新方向”，
就像物理中的惯性一样，让参数沿着过去累积的方向继续前进。(<a href="https://www.digitalocean.com/community/tutorials/intro-to-optimization-momentum-rmsprop-adam?utm_source=chatgpt.com">DigitalOcean</a>)</p>
</blockquote>
<p>典型形式（速度形式）：</p>
<p>$$
\begin{aligned}
v^{(k+1)} &amp;= \mu v^{(k)} - \eta \nabla_\theta L(\theta^{(k)}),
\theta^{(k+1)} &amp;= \theta^{(k)} + v^{(k+1)} ,
\end{aligned}
$$</p>
<p>其中：</p>
<ul>
<li>(v^{(k)})：“速度”或动量向量；</li>
<li>(\mu\in[0,1))：动量衰减系数（如 0.9）。</li>
</ul>
<p>直觉：</p>
<ul>
<li>在损失谷底的长轴方向上，梯度方向长期一致，动量会不断积累，使得沿谷底方向前进更快；</li>
<li>在与谷底垂直方向（损失变化陡峭的方向），梯度符号经常变化，动量会部分抵消震荡。</li>
</ul>
<p><strong>（4）自适应方法：RMSProp、Adam</strong></p>
<p>传统 SGD 对所有参数使用同一个学习率 (\eta)。但不同维度可能有不同尺度和重要性，自适应方法通过统计历史梯度大小，为不同参数自动调整“步长”。</p>
<p>以 <strong>Adam</strong> 为例（非常常见的优化器）：(<a href="https://www.digitalocean.com/community/tutorials/intro-to-optimization-momentum-rmsprop-adam?utm_source=chatgpt.com">DigitalOcean</a>)</p>
<ul>
<li>维护一阶矩（梯度的滑动平均） (m_t)；</li>
<li>维护二阶矩（梯度平方的滑动平均） (v_t)；</li>
<li>用这两个统计量对梯度进行“归一化”和“放缩”。</li>
</ul>
<p>简化后更新类似：
$$
\theta_{t+1} = \theta_t - \eta \cdot \frac{\hat m_t}{\sqrt{\hat v_t} + \epsilon}.
$$</p>
<p>直观上：</p>
<ul>
<li>(m_t) 类似动量，平滑梯度方向；</li>
<li>(\sqrt{v_t}) 则反映梯度幅度，对梯度长期较大的维度减小步长，对梯度较小的维度增大步长，实现自适应学习率。</li>
</ul>
<hr>
<h4 id="1322-二阶方法"><a class="header" href="#1322-二阶方法">1.3.2.2 二阶方法</a></h4>
<p>一阶方法只用梯度，而二阶方法还使用 <strong>Hessian 矩阵</strong>：</p>
<p>$$
H(\theta) = \nabla^2_\theta L(\theta),
$$
它是一个 (d\times d) 矩阵，每个元素是二阶偏导：
$$
H_{ij} = \frac{\partial^2 L}{\partial \theta_i \partial \theta_j}.
$$</p>
<p><strong>（1）曲率信息与“更聪明的步长”</strong></p>
<p>一元函数里，我们知道泰勒展开：
$$
L(\theta) \approx L(\theta_0) + L’(\theta_0)(\theta-\theta_0) + \frac{1}{2}L’’(\theta_0)(\theta-\theta_0)^2.
$$</p>
<p>若在附近用这个二次近似代替原函数，最小值的解析解是：
$$
\theta^\star \approx \theta_0 - \frac{L’(\theta_0)}{L’’(\theta_0)}.
$$</p>
<p>把这个推广到多元情形，就得到 <strong>牛顿法（Newton’s method）</strong> 的迭代：</p>
<p>$$
\theta^{(k+1)} = \theta^{(k)} - H(\theta^{(k)})^{-1} \nabla L(\theta^{(k)}).
$$</p>
<p>相比梯度下降 (-\eta\nabla L)，牛顿法将梯度再乘以 (H^{-1})，等价于在不同方向上动态调整步长，使得：</p>
<ul>
<li>在“弯曲得很厉害”（曲率大）的方向上，步子变小（防止跳太远）；</li>
<li>在“曲率较平缓”的方向上，步子变大，加速收敛。</li>
</ul>
<p><strong>（2）二阶方法的难点</strong></p>
<p>对于深度网络：</p>
<ul>
<li>参数维度 (d) 往往在百万甚至亿级，Hessian 是 (d\times d) 矩阵，
存储和求逆都是天文级成本；</li>
<li>计算 Hessian 本身也极其昂贵，且数值上不稳定。</li>
</ul>
<p>因此直接使用“严格的二阶方法”在深度网络中几乎不可行。</p>
<p><strong>（3）拟牛顿方法（简略了解）</strong></p>
<p>实际中有一些折中方案，如 BFGS、L-BFGS 等 <strong>拟牛顿法</strong>，通过在迭代中近似构造 (H^{-1})，而不显式求出完整 Hessian。这些方法在中等规模问题（如传统机器学习、小型网络）中依然常用，但在大规模深度学习里不再主流。</p>
<hr>
<h4 id="1323-实用考虑"><a class="header" href="#1323-实用考虑">1.3.2.3 实用考虑</a></h4>
<p>在深度学习和具身智能的实际训练里，通常采用：</p>
<ul>
<li><strong>一阶优化器为主</strong>（SGD / SGD+Momentum / Adam / RMSProp 等）；(<a href="https://www.digitalocean.com/community/tutorials/intro-to-optimization-momentum-rmsprop-adam?utm_source=chatgpt.com">DigitalOcean</a>)</li>
<li>在少数规模较小、需要高精度的模块中尝试二阶或拟牛顿方法。</li>
</ul>
<p>主要原因：</p>
<ol>
<li>模型参数维度太高，无法承担 Hessian 级别的计算和内存；</li>
<li>大量实践表明，<strong>好的初始化 + 合理的一阶优化 + 学习率调度</strong>，已足够得到很好的结果。</li>
</ol>
<p>在机器人和 VLA 模型中，优化器的选择往往是工程问题：</p>
<ul>
<li>需要更稳定、自动调节学习率：Adam / AdamW 常见；</li>
<li>更在意最终泛化性能、训练后期表现：不少视觉任务仍偏爱带动量的 SGD。</li>
</ul>
<hr>
<h3 id="133-损失景观与局部极值鞍点现象"><a class="header" href="#133-损失景观与局部极值鞍点现象">1.3.3 损失景观与局部极值、鞍点现象</a></h3>
<h4 id="1331-损失函数景观"><a class="header" href="#1331-损失函数景观">1.3.3.1 损失函数景观</a></h4>
<p><strong>损失景观（loss landscape）</strong> 是指：
在高维参数空间中，损失函数 (L(\theta)) 的取值构成的“山地地形”。</p>
<ul>
<li>每个点 (\theta) 是一组参数；</li>
<li>其对应高度 (L(\theta)) 是训练损失；</li>
<li>优化过程就是在这片高维山地上“下山”。</li>
</ul>
<blockquote>
<p>【图 1.3-4 占位：二维参数空间的损失等高线/三维曲面示意，标出多个谷地、鞍点和平坦区域。】</p>
</blockquote>
<p>在深度网络中，损失景观具有以下特点：(<a href="https://lcnwww.epfl.ch/gerstner/PUBLICATIONS/07Lecture07slidesForVideo.pdf?utm_source=chatgpt.com">lcnwww.epfl.ch</a>)</p>
<ul>
<li>高维（成千上万甚至更多参数）；</li>
<li>强烈非凸（有大量局部极值和鞍点）；</li>
<li>经常存在大面积的“平坦区”（梯度很小）和“陡峭沟壑”。</li>
</ul>
<p>理解损失景观有助于从几何视角解释：</p>
<ul>
<li>为什么梯度下降会卡住或变慢；</li>
<li>为什么初始化会影响最终结果；</li>
<li>为什么带噪声的 SGD 在实践中表现不错。</li>
</ul>
<hr>
<h4 id="1332-局部极小值与鞍点"><a class="header" href="#1332-局部极小值与鞍点">1.3.3.2 局部极小值与鞍点</a></h4>
<p><strong>（1）临界点（critical point）</strong></p>
<p>若在某点 (\theta^\star) 处梯度为零：
$$
\nabla L(\theta^\star) = 0,
$$
则称该点为 <strong>临界点</strong>。临界点可能是：</p>
<ul>
<li>局部极小值（local minimum）</li>
<li>局部极大值（local maximum）</li>
<li>鞍点（saddle point）</li>
</ul>
<p><strong>（2）局部极小值</strong></p>
<p>若存在足够小的邻域，使得：
$$
\forall \theta \text{ 在邻域内},\quad L(\theta) \ge L(\theta^\star),
$$
则 (\theta^\star) 是局部极小值。简单理解：
在附近任何方向稍微走一步，损失都会变大。</p>
<p>在凸优化中，每个局部极小值同时是全局极小值，世界清爽又温柔。可惜深度网络损失往往不是凸的。</p>
<p><strong>（3）鞍点（Saddle Point）</strong></p>
<p>鞍点是这样一种临界点：梯度为零，但在某些方向上表现得像极小值，在另一些方向上则像极大值——类似马鞍的形状：横向是谷，纵向是峰。(<a href="https://data-intelligence.hashnode.dev/saddle-points-machine-learning-deep-learning-optimization?utm_source=chatgpt.com">data-intelligence.hashnode.dev</a>)</p>
<ul>
<li>数学上：Hessian 的特征值有正有负；</li>
<li>几何上：既存在“向下的方向”，也存在“向上的方向”。</li>
</ul>
<p>在高维非凸优化中，研究与数值实验表明：</p>
<ul>
<li><strong>鞍点远比“坏的局部极小值”更多</strong>；</li>
<li>很多“训练卡住”的现象，实则是停在鞍点附近或平坦区域，而非真正的局部最小谷底。(<a href="https://lcnwww.epfl.ch/gerstner/PUBLICATIONS/07Lecture07slidesForVideo.pdf?utm_source=chatgpt.com">lcnwww.epfl.ch</a>)</li>
</ul>
<p><strong>（4）鞍点对优化的影响</strong></p>
<p>在鞍点附近，梯度接近零，普通梯度下降会：</p>
<ul>
<li>更新步长很小，移动缓慢；</li>
<li>可能长时间在附近徘徊，看起来像“训练不动了”。</li>
</ul>
<p>带噪声的 SGD 由于每步梯度有随机性，在一定程度上可以“抖出”鞍点，这也是实践中几乎总是使用 mini-batch 而不是纯 Batch GD 的原因之一。(<a href="https://apxml.com/courses/introduction-to-deep-learning/chapter-3-training-loss-optimization/gradient-descent-challenges?utm_source=chatgpt.com">ApX Machine Learning</a>)</p>
<hr>
<h4 id="1333-深度网络的损失特点"><a class="header" href="#1333-深度网络的损失特点">1.3.3.3 深度网络的损失特点</a></h4>
<p>近年来不少工作分析了深度网络的损失景观，一些典型结论包括：(<a href="https://jmlr.org/papers/volume25/23-0493/23-0493.pdf?utm_source=chatgpt.com">机器学习研究期刊</a>)</p>
<ol>
<li><strong>坏的局部极小值在高维情况下不一定很多。</strong>
在很多设置下，深度线性网络甚至可以证明不存在“劣质局部极小值”，只有全局极小和鞍点。</li>
<li><strong>鞍点和平坦区域是主要障碍。</strong>
训练变慢或停滞往往源于梯度接近零的平原或鞍点，而不是被困在某个特别高的局部谷底。</li>
<li><strong>“好极小值”往往成片存在</strong>（flat minima）。
一些较“平坦”的极小值（改变参数一点点损失不变太多）与泛化性能有一定关联——通常认为平坦极小值对应更好的泛化。</li>
</ol>
<p>对具身智能的实际意义：</p>
<ul>
<li>训练 VLA 或控制策略时，如果损失长时间不下降，未必是“模型不够强”，也可能是优化在不利的几何结构中爬得太慢；</li>
<li>调整优化器（如从 Adam 换成 SGD+Momentum），修改学习率调度、增加噪声等，常常可以改变在损失景观中的“走路方式”，找到更好的解。</li>
</ul>
<hr>
<h3 id="134-约束优化与拉格朗日乘子基本思想"><a class="header" href="#134-约束优化与拉格朗日乘子基本思想">1.3.4 约束优化与拉格朗日乘子基本思想</a></h3>
<p>前面讨论的是 <strong>无约束优化</strong>，但在机器人和具身智能里，很多问题天然带有约束，例如：</p>
<ul>
<li>关节角必须在物理范围内；</li>
<li>控制输入不能超过最大电机扭矩；</li>
<li>概率分布的参数必须非负且和为 1；</li>
<li>路径规划中必须避开障碍物等。</li>
</ul>
<p>这类问题统称为 <strong>约束优化（constrained optimization）</strong>。</p>
<hr>
<h4 id="1341-约束优化"><a class="header" href="#1341-约束优化">1.3.4.1 约束优化</a></h4>
<p>一般形式可以写作：</p>
<p>$$
\begin{aligned}
\min_{x} \quad &amp; f(x)
\text{s.t.} \quad &amp; g_i(x) = 0,\quad i=1,\dots,m \quad \text{（等式约束）}
&amp; h_j(x) \le 0,\quad j=1,\dots,p \quad \text{（不等式约束）}
\end{aligned}
$$</p>
<p>其中：</p>
<ul>
<li>(x\in \mathbb{R}^d)：待求参数（比如控制变量、概率参数等）；</li>
<li>(f(x))：目标函数（损失或代价）；</li>
<li>(g_i(x))、(h_j(x))：约束条件。</li>
</ul>
<p>机器人中的若干例子：</p>
<ul>
<li>机械臂逆运动学求解时要求末端达到给定位置（等式约束）；</li>
<li>控制优化中限制关节速度或力矩不超过上限（不等式约束）；</li>
<li>最大熵模型或概率分布学习中要求 (\sum_i p_i = 1, p_i \ge 0)。</li>
</ul>
<hr>
<h4 id="1342-拉格朗日乘子"><a class="header" href="#1342-拉格朗日乘子">1.3.4.2 拉格朗日乘子</a></h4>
<p><strong>（1）等式约束：拉格朗日乘子法</strong></p>
<p>考虑只有等式约束的情形：</p>
<p>$$
\begin{aligned}
\min_x \quad &amp; f(x)
\text{s.t.}\quad &amp; g_i(x) = 0,\quad i=1,\dots,m.
\end{aligned}
$$</p>
<p><strong>拉格朗日乘子法</strong> 的关键思想是：</p>
<blockquote>
<p>把“在约束面上找极值”的问题，转化为“在更高维空间中找无约束极值”的问题。(<a href="https://www.cs.toronto.edu/~mbrubake/teaching/C11/Handouts/LagrangeMultipliers.pdf?utm_source=chatgpt.com">cs.toronto.edu</a>)</p>
</blockquote>
<p>构造 <strong>拉格朗日函数：</strong></p>
<p>$$
\mathcal{L}(x, \lambda) = f(x) + \sum_{i=1}^m \lambda_i g_i(x),
$$</p>
<p>其中 (\lambda_i) 称为 <strong>拉格朗日乘子</strong>。此时的最优性条件（在一些技术条件下）可以写成：</p>
<p>$$
\nabla_x \mathcal{L}(x^\star,\lambda^\star) = 0,\quad g_i(x^\star)=0.
$$</p>
<p>直观意义：</p>
<ul>
<li>在最优点上，目标函数 (f(x)) 的梯度在约束面切平面内不能再下降；</li>
<li>拉格朗日乘子 (\lambda_i) 可以理解为“满足约束对目标值的边际代价”，在许多物理和经济问题中有很直观的解释。</li>
</ul>
<blockquote>
<p>【图 1.3-5 占位：二维函数等高线 + 一条曲线约束 (g(x)=0)（例如椭圆），示意在最优点处水平集与约束曲线切触，梯度方向与约束的梯度共线。】</p>
</blockquote>
<p><strong>（2）从优化到“方程组”</strong></p>
<p>使用拉格朗日乘子或 KKT 条件，本质上就是把“优化问题”转换为一组方程/不等式系统：
$$
\begin{cases}
\nabla_x \mathcal{L}(x,\lambda,\mu) = 0
g_i(x)=0
h_j(x)\le 0, \dots
\end{cases}
$$
这类系统在理论分析和某些算法（如内点法）中更容易处理。(<a href="https://math.stackexchange.com/questions/381840/lagrange-multipliers-and-kkt-conditions-what-do-we-gain?utm_source=chatgpt.com">Mathematics Stack Exchange</a>)</p>
<hr>
<h4 id="1343-kkt-条件"><a class="header" href="#1343-kkt-条件">1.3.4.3 KKT 条件</a></h4>
<p>当存在不等式约束时，拉格朗日乘子法需要推广到 <strong>Karush–Kuhn–Tucker（KKT）条件</strong>。它是非线性规划中非常重要的一阶必要条件。(<a href="https://en.wikipedia.org/wiki/Karush%E2%80%93Kuhn%E2%80%93Tucker_conditions?utm_source=chatgpt.com">维基百科</a>)</p>
<p>考虑一般问题：</p>
<p>$$
\begin{aligned}
\min_x \quad &amp; f(x)
\text{s.t.} \quad &amp; g_i(x) = 0,\quad i=1,\dots,m
&amp; h_j(x) \le 0,\quad j=1,\dots,p.
\end{aligned}
$$</p>
<p>构造 <strong>拉格朗日函数</strong>：
$$
\mathcal{L}(x,\lambda,\mu) = f(x) + \sum_{i=1}^m \lambda_i g_i(x) + \sum_{j=1}^p \mu_j h_j(x),
$$
其中：</p>
<ul>
<li>(\lambda_i)：等式约束的乘子；</li>
<li>(\mu_j)：不等式约束的乘子。</li>
</ul>
<p><strong>KKT 条件</strong> 包括：</p>
<ol>
<li><strong>原始可行性（primal feasibility）</strong>
满足原始约束：
$$
g_i(x^\star)=0,\quad h_j(x^\star)\le 0.
$$</li>
<li><strong>对偶可行性（dual feasibility）</strong>
不等式乘子非负：
$$
\mu_j^\star \ge 0.
$$</li>
<li><strong>站立条件（stationarity）</strong>
$$
\nabla_x \mathcal{L}(x^\star,\lambda^\star,\mu^\star) = 0.
$$</li>
<li><strong>互补松弛（complementary slackness）</strong>
$$
\mu_j^\star h_j(x^\star) = 0,\quad \forall j.
$$
这表示：
<ul>
<li>若某个不等式约束严格不等（(h_j(x^\star) &lt; 0)），则对应乘子必须为 0；</li>
<li>若乘子 (\mu_j^\star&gt;0)，则该约束一定正好“紧到边上”（(h_j(x^\star)=0)）。</li>
</ul>
</li>
</ol>
<p>在凸优化问题且满足一定正则条件时，KKT 条件不仅是必要条件，也是充分条件——即<strong>解满足 KKT 条件就一定是全局最优解</strong>。这为许多机器学习模型（如支持向量机）的推导提供了理论基础。</p>
<p>后面讲到最大间隔分类、软间隔 SVM 时，会再次用到这些工具。</p>
<hr>
<h3 id="135-神经网络训练中的优化实践问题学习率收敛与稳定性"><a class="header" href="#135-神经网络训练中的优化实践问题学习率收敛与稳定性">1.3.5 神经网络训练中的优化实践问题（学习率、收敛与稳定性）</a></h3>
<p>从这一小节开始，重点从“理论优化”切换到“神经网络训练实践”。在具身智能中，无论训练 VLM、VLA 还是 RL policy，都要面对如下问题：</p>
<ul>
<li>学习率如何设定与调度？</li>
<li>梯度为什么会消失或爆炸？</li>
<li>训练过程算不算收敛？什么时候终止？如何保持稳定？</li>
</ul>
<hr>
<h4 id="1351-学习率调度"><a class="header" href="#1351-学习率调度">1.3.5.1 学习率调度</a></h4>
<p>在 1.3.1.3 中，我们已经看到学习率大小对收敛速度和稳定性的影响。进一步地，<strong>学习率调度（learning rate schedule）</strong> 指的是在训练过程中随时间改变学习率的策略。</p>
<p><strong>（1）为什么要调度？</strong></p>
<ul>
<li>训练初期：需要较大的学习率快速“粗略找到好区域”；</li>
<li>训练后期：需要较小的学习率在最优附近细致调整，避免震荡；</li>
<li>某些模型训练需要“预热”（warm-up），防止一开始梯度太大导致发散。</li>
</ul>
<p><strong>（2）常见调度策略</strong></p>
<ol>
<li><strong>Step Decay</strong>：每过固定若干 epoch，将学习率乘以一个小于 1 的因子（例如每 30 个 epoch 乘以 0.1）。</li>
<li><strong>Exponential Decay</strong>：按 (\eta_t = \eta_0 \cdot \gamma^t) 指数衰减。</li>
<li><strong>Cosine Annealing（余弦退火）</strong>：学习率随训练进度在一个余弦曲线上缓慢减小，有时结合周期性重启使用。</li>
<li><strong>Warm-up + Scheduler</strong>：在前几百/几千步从非常小的值线性升高到目标学习率，然后按上述某种策略减小。</li>
</ol>
<p>实践经验（特别是在 Transformer 和大规模模型训练中）表明，合理的学习率调度往往比“纯粹换更复杂的优化器”带来的收益更稳定且可控。(<a href="https://www.digitalocean.com/community/tutorials/intro-to-optimization-momentum-rmsprop-adam?utm_source=chatgpt.com">DigitalOcean</a>)</p>
<hr>
<h4 id="1352-梯度消失与爆炸"><a class="header" href="#1352-梯度消失与爆炸">1.3.5.2 梯度消失与爆炸</a></h4>
<p><strong>（1）问题现象</strong></p>
<p>在深层网络中，反向传播时梯度会通过链式法则逐层相乘，如果每层的导数绝对值多数小于 1，则梯度会指数级减小，最终前面层几乎得不到更新，这就是 <strong>梯度消失（vanishing gradients）</strong>。(<a href="https://en.wikipedia.org/wiki/Vanishing_gradient_problem?utm_source=chatgpt.com">维基百科</a>)</p>
<p>反过来，如果导数绝对值多为大于 1，则梯度会指数级放大，导致 <strong>梯度爆炸（exploding gradients）</strong>：</p>
<ul>
<li>参数更新剧烈震荡甚至变成 NaN；</li>
<li>loss 突然变得非常大。</li>
</ul>
<p>这些问题在 RNN、非常深的前馈网络以及不合理初始化时尤其严重。(<a href="https://arxiv.org/html/2405.21064v1?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>（2）成因直观</strong></p>
<p>简单看一维链式法则：
$$
\frac{\partial L}{\partial x_0} = \frac{\partial L}{\partial x_1} \frac{\partial x_1}{\partial x_0} = \frac{\partial L}{\partial x_n} \prod_{k=0}^{n-1} \frac{\partial x_{k+1}}{\partial x_k}.
$$</p>
<p>若每个 (\big|\frac{\partial x_{k+1}}{\partial x_k}\big|) 大约为 0.5，10 层后得到 (0.5^{10}\approx 1/1024)，梯度几乎消失；若每层约为 2，则 (2^{10}\approx 1024)，梯度爆炸。</p>
<p>在多层线性/非线性组合中，这种现象极易出现。</p>
<p><strong>（3）缓解方法</strong></p>
<p>常见手段包括：(<a href="https://en.wikipedia.org/wiki/Vanishing_gradient_problem?utm_source=chatgpt.com">维基百科</a>)</p>
<ol>
<li><strong>合理的权重初始化</strong>
<ul>
<li>Xavier 初始化：保证前向/反向信号方差在层间大致保持一致，适合 tanh 等。</li>
<li>Kaiming 初始化：针对 ReLU 族激活，考虑其非对称性。</li>
</ul>
</li>
<li><strong>合适的激活函数</strong>
<ul>
<li>用 ReLU、GELU 等替代 Sigmoid/Tanh，可以减轻梯度饱和问题。</li>
</ul>
</li>
<li><strong>归一化层</strong>
<ul>
<li>Batch Normalization、LayerNorm 等在前向上稳定中间层分布，也有助于避免梯度过大或过小。</li>
</ul>
</li>
<li><strong>残差连接（Residual Connections）</strong>
<ul>
<li>在 ResNet、Transformer 中广泛使用，允许梯度沿“捷径”反向传播，大幅缓解梯度消失问题。</li>
</ul>
</li>
<li><strong>梯度裁剪（Gradient Clipping）</strong>
<ul>
<li>对梯度的范数设置上限，例如若 (|g|_2 &gt; c) 则缩放为 (\frac{c}{|g|_2}g)，常用于 RNN 和强化学习策略网络中，防止爆炸。(<a href="https://datascience.stackexchange.com/questions/72351/how-to-prevent-vanishing-gradient-or-exploding-gradient?utm_source=chatgpt.com">Data Science Stack Exchange</a>)</li>
</ul>
</li>
</ol>
<p>在具身智能相关网络（例如 RNN/Transformer 控制策略、多帧视觉编码器）中，梯度消失与爆炸会直接导致策略不学或训练不稳定，是工程调参中的常见“坑”。</p>
<hr>
<h4 id="1353-收敛判断与稳定训练"><a class="header" href="#1353-收敛判断与稳定训练">1.3.5.3 收敛判断与稳定训练</a></h4>
<p><strong>（1）什么叫“收敛”？</strong></p>
<p>在理论上，收敛可以是：</p>
<ul>
<li>参数 (\theta^{(k)}) 收敛；</li>
<li>梯度 (\nabla L(\theta^{(k)}) \to 0)；</li>
<li>损失 (L(\theta^{(k)})) 收敛到某个值。</li>
</ul>
<p>在深度学习实践中，我们更关心：</p>
<ul>
<li>训练集损失是否持续下降并趋于平稳；</li>
<li>验证集性能是否达到平台期甚至开始下降（过拟合）。</li>
</ul>
<p><strong>（2）训练监控</strong></p>
<p>通常会绘制如下曲线：</p>
<ul>
<li>训练 loss vs. iteration / epoch；</li>
<li>验证 loss / 准确率 vs. epoch。</li>
</ul>
<p>在“健康”的训练过程中，一般会看到：</p>
<ul>
<li>前期训练 loss 快速下降；</li>
<li>中后期下降变缓，接近收敛；</li>
<li>若模型开始过拟合，训练集指标继续变好而验证集变差。</li>
</ul>
<p><strong>（3）稳定训练的常用技巧</strong></p>
<ol>
<li><strong>早停（Early Stopping）</strong>
在验证集性能长时间未提升甚至下降时，停止训练并回退到最佳验证点对应的参数，防止过拟合。</li>
<li><strong>检查学习率与梯度范围</strong>
若 loss 突然爆炸或梯度出现 NaN，优先怀疑学习率是否过大、是否缺少梯度裁剪或数值稳定处理。</li>
<li><strong>使用验证集而非训练 loss 判断收敛</strong>
对具身智能任务尤其重要，因为在真实机器人上往往只关心“在新场景、新物体上的成功率”，不能只看训练轨迹上的表现。</li>
<li><strong>多次重复实验与随机种子控制</strong>
优化过程本身带有随机性（初始化、mini-batch 抽样等），稳定结果应当在不同随机种子下大致一致，防止“偶然跑出一次好结果”。</li>
</ol>
<p>在后续章节（例如 2.2 深度网络训练技巧、9.4 数据工程与 MLOps）中，会进一步结合实验工程细节讨论如何系统监控和管理训练过程。</p>
<hr>
<p>这一节从导数和梯度开始，依次介绍了梯度下降、一阶/二阶方法直觉、损失景观与鞍点、约束优化与拉格朗日/KKT，再到神经网络训练中的学习率、梯度消失/爆炸以及收敛判断。掌握这些内容后，读者应该能：</p>
<ul>
<li>看懂大多数深度学习论文中涉及优化的公式；</li>
<li>理解主流优化器（SGD、Momentum、Adam 等）的核心思想；</li>
<li>在训练自己的网络（包括具身智能中的 VLA 模型）时，有一套清晰的调参和诊断思路。</li>
</ul>
<p>后续章节将在此基础上，进一步讨论深度网络结构、Transformer、RL 与模仿学习中的优化问题，逐步搭建起完整的“从感知到控制”的学习图景。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="机器学习基础"><a href="#机器学习基础" class="header">机器学习基础</a></h1>
<h3 id="141-回归与分类基本问题设置"><a class="header" href="#141-回归与分类基本问题设置">1.4.1 回归与分类基本问题设置</a></h3>
<p>在具身智能场景中，“模型”最常干两件事：
预测一个<strong>数值</strong>（如机械臂末端未来 0.1s 的位移），或预测一个<strong>类别</strong>（如“这次抓取会不会成功”）。前者是<strong>回归</strong>，后者是<strong>分类</strong>。这两类问题构成了监督学习的根基。</p>
<hr>
<h4 id="1411-回归问题"><a class="header" href="#1411-回归问题">1.4.1.1 回归问题</a></h4>
<p><strong>定义与形式化</strong></p>
<p>回归问题中，目标是从输入特征 (\mathbf{x}\in\mathbb{R}^d) 预测一个或多个<strong>连续实数</strong>输出 (y\in\mathbb{R}) 或 (\mathbb{R}^k)：</p>
<p>$$
f_\theta: \mathbf{x} \mapsto \hat{y}
$$</p>
<p>其中 (\theta) 是模型参数（例如线性回归中的权重向量）。损失函数常用<strong>均方误差（MSE）</strong>：</p>
<p>$$
\mathcal{L}(\theta)=\frac{1}{N}\sum_{i=1}^N (\hat{y}_i - y_i)^2
$$</p>
<p>通过最小化损失来学习参数。</p>
<p><strong>典型例子</strong></p>
<ul>
<li>预测机器人末端执行器在下一时刻的位姿偏移量（连续 3D 坐标与角度）。</li>
<li>预测接触力、扭矩、滑动速度等物理量。</li>
<li>预测电机温度、能耗等运行指标。</li>
</ul>
<p><strong>与具身智能的关系</strong></p>
<p>在具身智能中，回归通常用于：</p>
<ul>
<li><strong>动力学建模</strong>：根据当前状态和控制输入预测下一个状态（状态转移模型）。</li>
<li><strong>代价函数学习</strong>：用回归拟合“动作是否优良”的连续评分，为后续规划或强化学习服务。</li>
</ul>
<p>【可插图：二维平面上一条拟合数据点的直线或曲线，展示回归模型拟合连续目标的直观图像。】</p>
<hr>
<h4 id="1412-分类问题"><a class="header" href="#1412-分类问题">1.4.1.2 分类问题</a></h4>
<p><strong>定义与形式化</strong></p>
<p>分类问题中，目标是预测一个<strong>离散标签</strong>：</p>
<p>$$
f_\theta: \mathbf{x} \mapsto \hat{y},\quad \hat{y}\in{1,2,\dots,C}
$$</p>
<p>通常模型先输出每个类别的<strong>概率</strong> (\hat{p}_c = P(y=c|\mathbf{x}))，再取概率最大的类别作为预测。</p>
<p><strong>典型例子</strong></p>
<ul>
<li>场景识别：桌面是否“整理干净/未整理完”。</li>
<li>抓取可行性：当前抓取姿态是“可抓取 / 不可抓取”。</li>
<li>障碍物类型分类：行人 / 桌子 / 箱子 / 墙面等。</li>
</ul>
<p><strong>常用损失：交叉熵</strong></p>
<p>对于单标签多分类，标准损失为交叉熵：</p>
<p>$$
\mathcal{L}(\theta)=-\frac{1}{N}\sum_{i=1}^N \sum_{c=1}^C \mathbf{1}(y_i=c)\log \hat{p}_{i,c}
$$</p>
<p>与前面在深度学习章节中出现的交叉熵损失是一致的，只是这里强调其在一般分类问题中的意义。(<a href="https://developers.google.com/machine-learning/crash-course/classification/accuracy-precision-recall?utm_source=chatgpt.com">Google for Developers</a>)</p>
<hr>
<h4 id="1413-输入特征与模型输出的关系"><a class="header" href="#1413-输入特征与模型输出的关系">1.4.1.3 输入特征与模型输出的关系</a></h4>
<p><strong>监督学习的基本设定</strong></p>
<p>给定训练数据集 (\mathcal{D}={(\mathbf{x}<em>i,y_i)}</em>{i=1}^N)，我们假设存在某个未知的“真实函数”：</p>
<p>$$
y = f^*(\mathbf{x}) + \epsilon
$$</p>
<p>其中 (\epsilon) 是噪声或未建模因素。<strong>模型的目标</strong>就是在一个预先选好的“假设空间”（例如线性函数、决策树、神经网络等）内，找到一个 (f_\theta) 尽量逼近 (f^*)。</p>
<ul>
<li>输入 (\mathbf{x}) 称为<strong>特征</strong>：可以是原始传感器读数（图像像素、关节角度），也可以是经过预处理的高层特征（PCA 主成分、CNN 的特征向量等）。</li>
<li>输出 (y) 是我们关心的目标（回归中的数值，分类中的类别）。</li>
</ul>
<p><strong>经验风险最小化</strong></p>
<p>大多数监督学习算法可以统一理解为<strong>经验风险最小化（ERM）</strong>：</p>
<p>$$
\hat{\theta} = \arg\min_\theta \frac{1}{N}\sum_{i=1}^N \ell(f_\theta(\mathbf{x}_i), y_i)
$$</p>
<p>其中 (\ell(\cdot,\cdot)) 是合适的损失函数（回归用 MSE，分类用交叉熵等）。(<a href="https://www.sciencedirect.com/topics/computer-science/supervised-learning?utm_source=chatgpt.com">科学导向</a>)</p>
<p>在具身智能场景中，这种“输入特征 (\to) 输出预测”的监督学习模块，往往嵌在更大系统中（如用于状态估计、成功预测），与后续的规划或强化学习协同工作。</p>
<hr>
<h3 id="142-过拟合欠拟合与偏差方差权衡"><a class="header" href="#142-过拟合欠拟合与偏差方差权衡">1.4.2 过拟合、欠拟合与偏差–方差权衡</a></h3>
<p>仅靠在训练集上“把损失压到很低”并不等于模型就好用。真正重要的是：<strong>在未见过的新数据上的表现</strong>——即泛化能力。(<a href="https://www.bmc.com/blogs/bias-variance-machine-learning/?utm_source=chatgpt.com">bmc.com</a>)</p>
<hr>
<h4 id="1421-过拟合"><a class="header" href="#1421-过拟合">1.4.2.1 过拟合</a></h4>
<p><strong>现象</strong></p>
<ul>
<li>模型在训练集上的损失很低，准确率很高；</li>
<li>但在验证集/测试集上表现显著变差。</li>
</ul>
<p>这说明模型不仅学到了<strong>有用规律</strong>，还记住了训练数据中的<strong>噪声和偶然性模式</strong>。在机器人场景中，这常表现为：在实验台上训练得很好，换一个桌面或灯光条件就“智商骤降”。(<a href="https://www.interviewcoder.co/blog/ml-interview-questions?utm_source=chatgpt.com">Interview Coder</a>)</p>
<p><strong>典型原因</strong></p>
<ul>
<li>模型过于复杂（参数太多、结构太灵活），相对训练数据量而言容量过大。</li>
<li>训练轮数太多，在训练集上“磨”过头。</li>
<li>特征维度远大于样本数，模型可以用复杂组合记住具体样本。</li>
</ul>
<p>【可插图：横轴为模型复杂度，画出训练误差持续下降，而验证误差先下降后上升的两条曲线，说明过拟合区域。】</p>
<hr>
<h4 id="1422-欠拟合"><a class="header" href="#1422-欠拟合">1.4.2.2 欠拟合</a></h4>
<p><strong>现象</strong></p>
<ul>
<li>模型在训练集和测试集上表现都不好（误差都很大）。</li>
<li>换用更复杂的模型或加入更多有用特征后，训练误差和测试误差都会明显下降。</li>
</ul>
<p>这是因为模型过于简单，表达能力不足，无法捕捉数据内在规律，称为<strong>高偏差</strong>情形。(<a href="https://www.geeksforgeeks.org/machine-learning/ml-bias-variance-trade-off/?utm_source=chatgpt.com">geeksforgeeks.org</a>)</p>
<p>在具身智能中，例如你用一个简单的线性模型预测高度非线性的机械臂动力学，结果就是无论如何调参都拟合不好——典型欠拟合。</p>
<hr>
<h4 id="1423-偏差方差权衡"><a class="header" href="#1423-偏差方差权衡">1.4.2.3 偏差–方差权衡</a></h4>
<p><strong>误差分解直觉</strong></p>
<p>可以将预测误差（例如 MSE）拆成三部分：
“不可约噪声 + 偏差² + 方差”，其中：(<a href="https://www.bmc.com/blogs/bias-variance-machine-learning/?utm_source=chatgpt.com">bmc.com</a>)</p>
<ul>
<li><strong>偏差（Bias）</strong>：模型“平均”预测与真实函数 (f^*) 的系统性偏离，反映模型是否“想错了问题”。
<ul>
<li>模型太简单 → 高偏差。</li>
</ul>
</li>
<li><strong>方差（Variance）</strong>：因训练数据不同（采样不同）导致模型预测波动的程度。
<ul>
<li>模型太复杂 → 容易对数据的小扰动反应剧烈 → 高方差。</li>
</ul>
</li>
</ul>
<p><strong>权衡</strong></p>
<ul>
<li>提高模型复杂度：偏差下降，但方差上升（更容易过拟合）。</li>
<li>降低模型复杂度：方差下降，但偏差上升（更容易欠拟合）。</li>
</ul>
<p>目标是在某个<strong>适中复杂度</strong>处，使二者综合导致的测试误差最小。这就是偏差–方差权衡的核心。(<a href="https://compneuro.neuromatch.io/tutorials/W1D2_ModelFitting/student/W1D2_Tutorial5.html?utm_source=chatgpt.com">compneuro.neuromatch.io</a>)</p>
<p>【可插图：三条曲线——偏差²随模型复杂度单调下降，方差单调上升，总测试误差呈 U 形，最低点对应最优复杂度。】</p>
<p>在具身机器人中，这个权衡尤其关键：</p>
<ul>
<li>过于复杂的模型在真实机器人数据有限的情况下几乎必然过拟合；</li>
<li>过于简单的模型又无法应对复杂接触动力学和视觉变化。</li>
</ul>
<p>后续我们会通过正则化、早停、交叉验证等手段，在工程上实现这种权衡。</p>
<hr>
<h3 id="143-正则化l1l2早停与交叉验证"><a class="header" href="#143-正则化l1l2早停与交叉验证">1.4.3 正则化（L1/L2）、早停与交叉验证</a></h3>
<p>这一节可以理解为：<strong>如何在实践中与过拟合打“持久战”</strong>。</p>
<hr>
<h4 id="1431-l1l2-正则化"><a class="header" href="#1431-l1l2-正则化">1.4.3.1 L1/L2 正则化</a></h4>
<p><strong>基本思想</strong></p>
<p>在经验风险最小化的目标函数中加入对参数大小的惩罚项，鼓励模型“更简单”、参数“更小”，从而降低方差、提升泛化能力。(<a href="https://builtin.com/data-science/l2-regularization?utm_source=chatgpt.com">Built In</a>)</p>
<p>给定原始损失 ( \mathcal{L}_0(\theta) )，加正则化后变为：</p>
<p>$$
\mathcal{L}(\theta) = \mathcal{L}_0(\theta) + \lambda \Omega(\theta)
$$</p>
<p>其中 (\lambda) 控制惩罚强度。</p>
<p><strong>L2 正则化（Ridge）</strong></p>
<p>$$
\Omega_{L2}(\theta) = |\theta|_2^2 = \sum_j \theta_j^2
$$</p>
<p>特点：</p>
<ul>
<li>倾向将所有参数“缩小”但不变为 0。</li>
<li>对异常值更敏感。</li>
<li>在许多线性模型、深度学习中非常常用（权重衰减）。(<a href="https://medium.com/%40alejandro.itoaramendia/l1-and-l2-regularization-part-1-a-complete-guide-51cf45bb4ade?utm_source=chatgpt.com">Medium</a>)</li>
</ul>
<p><strong>L1 正则化（LASSO）</strong></p>
<p>$$
\Omega_{L1}(\theta) = |\theta|_1 = \sum_j |\theta_j|
$$</p>
<p>特点：</p>
<ul>
<li>更倾向把一部分参数直接压到 0，产生<strong>稀疏解</strong>，起到类似“自动特征选择”的作用。</li>
<li>对异常值更鲁棒。(<a href="https://neptune.ai/blog/fighting-overfitting-with-l1-or-l2-regularization?utm_source=chatgpt.com">neptune.ai</a>)</li>
</ul>
<p>在机器人应用中，L1 可用于从大量传感器特征中“自动挑出更重要的一小部分”；L2 更适合作为通用的稳定化手段。</p>
<p>【可插图：二维参数空间中，L2 约束是圆，L1 约束是菱形，展示为什么 L1 更容易压出稀疏解（交点落在坐标轴上）。】</p>
<hr>
<h4 id="1432-早停策略"><a class="header" href="#1432-早停策略">1.4.3.2 早停策略</a></h4>
<p>早停（Early Stopping）是深度学习中最实用的“隐式正则化”之一，本质思想非常简单：</p>
<ol>
<li>将数据分为训练集与验证集。</li>
<li>训练过程中监控验证集的损失或评价指标。</li>
<li>一旦发现验证性能在若干轮内不再提升，甚至开始变差，就停止训练，并回滚到验证集性能最好的那一轮的模型参数。(<a href="https://www.interviewcoder.co/blog/ml-interview-questions?utm_source=chatgpt.com">Interview Coder</a>)</li>
</ol>
<p>从偏差–方差的角度看：</p>
<ul>
<li>前期训练：模型偏差快速下降，方差还不高；</li>
<li>后期训练：模型开始对训练集噪声“死磕”，方差明显上升，验证误差反而上升。</li>
</ul>
<p>早停把学习过程“截断”在最佳点附近，相当于对参数大小施加了一种时间维度上的约束，可以视作一种正则化。</p>
<p>在具身机器人系统训练中，早停尤其常用，因为：</p>
<ul>
<li>真实数据很贵，不希望过拟合少量轨迹；</li>
<li>训练时间长，多跑几轮意味着真实机器人磨损和风险增加。</li>
</ul>
<hr>
<h4 id="1433-交叉验证"><a class="header" href="#1433-交叉验证">1.4.3.3 交叉验证</a></h4>
<p><strong>核心目的：更可靠地评估模型与超参数</strong></p>
<p>单次划分训练/验证集往往运气成分大。**交叉验证（Cross-Validation）**通过多次划分并平均结果，得到更稳健的性能估计。(<a href="https://www.rcac.purdue.edu/files/training/Machine%20Learning%20Overview.pdf?utm_source=chatgpt.com">RCAC</a>)</p>
<p><strong>K 折交叉验证（K-fold CV）</strong></p>
<ol>
<li>将数据随机划分为 K 个大小近似相等的子集。</li>
<li>每次选其中 1 折作为验证集，其余 K-1 折作为训练集，训练并评估模型。</li>
<li>循环 K 次，K 个验证结果取平均，作为这个模型/超参数的最终评价。</li>
</ol>
<p><strong>留一交叉验证（LOO CV）</strong></p>
<ul>
<li>特殊情况：K = N，每次只留出 1 个样本做验证，其余 N-1 个样本训练。</li>
<li>理论上偏差很小，但计算开销极大。</li>
</ul>
<p>交叉验证常用于：</p>
<ul>
<li>比较不同模型（如线性回归 vs 带核的 SVM）；</li>
<li>搜索正则化系数 (\lambda)、核函数参数等超参数的“最佳组合”。</li>
</ul>
<p>在具身智能项目中，由于收集到的数据往往结构复杂（多机器人、多任务），可以按<strong>任务或场景划分折</strong>，从而评估模型的任务泛化能力，而不仅仅是随机样本的泛化。</p>
<p>【可插图：把数据集切成 K 份的小块，依次轮流作为验证集的示意图。】</p>
<hr>
<h3 id="144-核方法与高维特征空间直觉"><a class="header" href="#144-核方法与高维特征空间直觉">1.4.4 核方法与高维特征空间直觉</a></h3>
<p>当数据在原始特征空间中<strong>非线性可分</strong>时，我们可以尝试将它映射到一个更高维的空间，使其<strong>线性可分</strong>，然后再在该空间里做线性模型。这就是<strong>核方法</strong>背后的核心直觉。(<a href="https://en.wikipedia.org/wiki/Kernel_method?utm_source=chatgpt.com">维基百科</a>)</p>
<hr>
<h4 id="1441-核技巧"><a class="header" href="#1441-核技巧">1.4.4.1 核技巧</a></h4>
<p>假设有一个显式特征映射：</p>
<p>$$
\phi: \mathcal{X} \to \mathcal{H}
$$</p>
<p>将原始输入 (\mathbf{x}) 映射到高维（甚至无限维）特征空间 (\mathcal{H})。在该空间中，我们做的是线性模型，例如线性分类或线性回归。</p>
<p>问题在于：(\phi(\mathbf{x})) 可能极高维，<strong>显式计算代价巨大</strong>。</p>
<p><strong>核技巧（Kernel Trick）<strong><strong>利用如下事实：许多线性算法只依赖于数据点之间的</strong></strong>内积</strong> (\phi(\mathbf{x}_i)^\top\phi(\mathbf{x}_j))。如果我们找到一个函数 (K) 使得：(<a href="https://en.wikipedia.org/wiki/Kernel_method?utm_source=chatgpt.com">维基百科</a>)</p>
<p>$$
K(\mathbf{x}_i,\mathbf{x}_j) = \phi(\mathbf{x}_i)^\top\phi(\mathbf{x}_j)
$$</p>
<p>那么就可以直接在原空间计算 (K(\mathbf{x}_i,\mathbf{x}_j))，而不必显式计算 (\phi(\mathbf{x})) 本身，从而“<strong>隐式地</strong>”在高维空间里做线性学习——这就是核技巧。</p>
<p>【可插图：左边是原空间中无法线性分开的红蓝点；右边是高维特征空间中被超平面分开的示意，中间标注“φ(x)”与“K(x,x’)”的关系。】</p>
<hr>
<h4 id="1442-常见核函数"><a class="header" href="#1442-常见核函数">1.4.4.2 常见核函数</a></h4>
<p>常用核函数包括：(<a href="https://en.wikipedia.org/wiki/Kernel_method?utm_source=chatgpt.com">维基百科</a>)</p>
<ol>
<li><strong>线性核</strong>[
K(\mathbf{x},\mathbf{z}) = \mathbf{x}^\top\mathbf{z}
]对应没有显式映射（(\phi) 为恒等映射），即普通线性模型。</li>
<li><strong>多项式核（Polynomial Kernel）</strong>[
K(\mathbf{x},\mathbf{z}) = (\gamma \mathbf{x}^\top\mathbf{z} + r)^d
$$
<ul>
<li>参数 (d) 控制多项式次数，(r) 是偏置项，(\gamma) 控制尺度。</li>
<li>对应在高维空间里包含各种单项式组合（如 (x_1^2x_2) 等）。</li>
</ul>
</li>
<li><strong>高斯核 / RBF 核（Radial Basis Function）</strong>[
K(\mathbf{x},\mathbf{z}) = \exp\left(-\frac{|\mathbf{x}-\mathbf{z}|^2}{2\sigma^2}\right)
$$
<ul>
<li>(\sigma) 控制“影响范围”。</li>
<li>对应于无限维特征空间，具有很强的非线性拟合能力。</li>
</ul>
</li>
</ol>
<p>在机器人具身智能中，核方法可以用于：</p>
<ul>
<li>在低维状态特征上构造非线性回归模型（如动力学、接触力预测）；</li>
<li>在有限训练数据下构建较强的非线性分类器（如“可抓取 vs 不可抓取”）。</li>
</ul>
<hr>
<h4 id="1443-支持向量机中的核方法"><a class="header" href="#1443-支持向量机中的核方法">1.4.4.3 支持向量机中的核方法</a></h4>
<p><strong>线性 SVM 回顾</strong></p>
<p>支持向量机（SVM）是一类通过最大化分类间隔来获得鲁棒决策边界的监督学习方法，可用于分类与回归。其线性版在特征空间中学习一个超平面：(<a href="https://pdg.lbl.gov/2025/reviews/rpp2024-rev-machine-learning.pdf?utm_source=chatgpt.com">Particle Data Group</a>)</p>
<p>$$
f(\mathbf{x}) = \text{sign}(\mathbf{w}^\top\mathbf{x} + b)
$$</p>
<p>训练目标可以写成仅依赖于样本之间的内积 (\mathbf{x}_i^\top\mathbf{x}_j)。</p>
<p><strong>核 SVM</strong></p>
<p>将内积替换为核函数：</p>
<p>$$
\mathbf{x}_i^\top\mathbf{x}_j \quad \Rightarrow \quad K(\mathbf{x}_i,\mathbf{x}_j)
$$</p>
<p>得到的就是<strong>核 SVM</strong>。它等价于：</p>
<ul>
<li>首先用 (\phi) 将数据映射到高维空间；</li>
<li>然后在该空间里寻找最大间隔的线性超平面。</li>
</ul>
<p>优点在于我们从未显式构建高维特征，只是通过核函数计算内积。(<a href="https://stats.stackexchange.com/questions/168051/kernel-svm-i-want-an-intuitive-understanding-of-mapping-to-a-higher-dimensional?utm_source=chatgpt.com">Cross Validated</a>)</p>
<p>在具身智能早期研究中（尤其在深度学习尚未主导的时期），核 SVM 曾是处理中小规模机器人数据（如力觉分类、简单视觉识别）的经典选择。即使在深度学习时代，核方法仍为理解高维特征空间和相似度度量提供重要直觉基础。</p>
<hr>
<h3 id="145-评价指标准确率精确率召回率auc-等"><a class="header" href="#145-评价指标准确率精确率召回率auc-等">1.4.5 评价指标（准确率、精确率、召回率、AUC 等）</a></h3>
<p>训练好模型之后，需要用<strong>统一、可比较的评价指标</strong>量化其性能，尤其在类别不平衡、错误代价不对称的场景中，仅看“准确率”会非常误导。(<a href="https://developers.google.com/machine-learning/crash-course/classification/accuracy-precision-recall?utm_source=chatgpt.com">Google for Developers</a>)</p>
<p>我们先从二分类的混淆矩阵讲起。</p>
<p><strong>混淆矩阵</strong></p>
<p>以“正类 = 机器人成功抓取”的二分类为例，模型输出“抓取/不抓取”，与真实标签对比得到四种情况：</p>
<ul>
<li>TP（True Positive）：真实成功，预测也成功。</li>
<li>FN（False Negative）：真实成功，但预测失败（错杀）。</li>
<li>FP（False Positive）：真实失败，但预测成功（误报）。</li>
<li>TN（True Negative）：真实失败，预测也失败。</li>
</ul>
<p>所有衡量指标都可以用 TP, FP, TN, FN 表达。</p>
<hr>
<h4 id="1451-准确率"><a class="header" href="#1451-准确率">1.4.5.1 准确率</a></h4>
<p><strong>定义</strong></p>
<p>$$
\text{Accuracy} = \frac{TP + TN}{TP + TN + FP + FN}
$$</p>
<p>即预测正确的样本占总样本的比例。(<a href="https://developers.google.com/machine-learning/crash-course/classification/accuracy-precision-recall?utm_source=chatgpt.com">Google for Developers</a>)</p>
<p><strong>适用场景</strong></p>
<ul>
<li>类别相对均衡，且正负样本的重要性相近。</li>
<li>比如机器人在大量正常状态与异常状态中识别异常，其中两类比例相近时，可直接用准确率。</li>
</ul>
<p><strong>局限性</strong></p>
<p>在<strong>高度不平衡数据集</strong>上（如异常率 1%），模型只要“全部预测为负类”，准确率也能达到 99%——显然毫无实际意义。因此在具身智能的安全相关任务（异常检测、碰撞预测）中，准确率通常不足以单独使用。(<a href="https://deeesp.github.io/machine%20learning/Classification-Evaluation-Metrics/?utm_source=chatgpt.com">Jinwoo’s Devlog</a>)</p>
<hr>
<h4 id="1452-精确率与召回率"><a class="header" href="#1452-精确率与召回率">1.4.5.2 精确率与召回率</a></h4>
<p><strong>精确率（Precision）</strong></p>
<p>$$
\text{Precision} = \frac{TP}{TP + FP}
$$</p>
<p>表示：模型预测为“正类”的样本中，有多少是真的正类。精确率高意味着<strong>误报少</strong>。(<a href="https://developers.google.com/machine-learning/crash-course/classification/accuracy-precision-recall?utm_source=chatgpt.com">Google for Developers</a>)</p>
<p><strong>召回率（Recall）</strong></p>
<p>$$
\text{Recall} = \frac{TP}{TP + FN}
$$</p>
<p>表示：真实为正类的样本中，有多少被模型找出来。召回率高意味着<strong>漏报少</strong>。(<a href="https://developers.google.com/machine-learning/crash-course/classification/accuracy-precision-recall?utm_source=chatgpt.com">Google for Developers</a>)</p>
<p>在具身智能中的典型权衡：</p>
<ul>
<li>机器人抓取任务中，“抓空/掉落”带来中等损失，“误抓危险物体”带来巨大损失时，可能希望<strong>高精确率</strong>（预测要谨慎）。</li>
<li>安全监控或异常检测任务中，更重要的是不要漏检危险情况，往往更关注<strong>高召回率</strong>。</li>
</ul>
<p><strong>F1 分数（可简单提一下）</strong></p>
<p>为了在单个数值中综合考虑精确率和召回率，可以使用 F1：</p>
<p>$$
F1 = 2\cdot\frac{\text{Precision}\cdot\text{Recall}}{\text{Precision}+\text{Recall}}
$$</p>
<p>当精确率与召回率相近且都较高时，F1 也会高；两者有一者很低时，F1 会被拉低。(<a href="https://developers.google.com/machine-learning/crash-course/classification/accuracy-precision-recall?utm_source=chatgpt.com">Google for Developers</a>)</p>
<hr>
<h4 id="1453-roc-曲线与-auc"><a class="header" href="#1453-roc-曲线与-auc">1.4.5.3 ROC 曲线与 AUC</a></h4>
<p>许多分类模型（如逻辑回归、神经网络）并不是直接给出“正/负”标签，而是给出“属于正类的概率”或“得分”。我们通过设置一个阈值（例如 0.5）将概率转为类别。改变阈值就会改变 TP、FP、TN、FN，从而改变精确率与召回率。</p>
<p><strong>ROC 曲线</strong></p>
<p>ROC（Receiver Operating Characteristic）曲线以：(<a href="https://deeesp.github.io/machine%20learning/Classification-Evaluation-Metrics/?utm_source=chatgpt.com">Jinwoo’s Devlog</a>)</p>
<ul>
<li>横轴：假正例率</li>
</ul>
<p>$$
\text{FPR} = \frac{FP}{FP + TN}
$$</p>
<ul>
<li>纵轴：真正例率（也就是召回率）</li>
</ul>
<p>$$
\text{TPR} = \frac{TP}{TP + FN}
$$</p>
<p>为不同阈值下得到的一系列点连成的曲线。</p>
<p>直观理解：</p>
<ul>
<li>随着阈值从 1 降到 0，模型会把越来越多样本判为正类，TPR 和 FPR 都会增加。</li>
<li>一个完美分类器的 ROC 曲线接近左上角（高 TPR，低 FPR）。</li>
<li>完全随机的分类器 ROC 曲线接近对角线（TPR≈FPR）。</li>
</ul>
<p><strong>AUC（Area Under ROC Curve）</strong></p>
<p>AUC 是 ROC 曲线下的面积，介于 0 和 1 之间：(<a href="https://deeesp.github.io/machine%20learning/Classification-Evaluation-Metrics/?utm_source=chatgpt.com">Jinwoo’s Devlog</a>)</p>
<ul>
<li>AUC = 0.5：与随机猜测差不多。</li>
<li>AUC → 1：越接近完美分类器。</li>
</ul>
<p>一个重要解释是：AUC 等于“随机抽取一个正样本和一个负样本时，模型给正样本的得分高于负样本的概率”。</p>
<p><strong>在具身智能中的使用建议</strong></p>
<ul>
<li>二分类任务（例如“当前姿态是否危险”、“当前轨迹是否会导致碰撞”）中，常用 ROC-AUC 来衡量模型区分正负样本的整体能力。</li>
<li>当正负样本极度不平衡且我们更关心正类行为（如少数危险情况），<strong>PR 曲线（Precision-Recall Curve）及其面积 PR-AUC</strong>往往更敏感，也值得在后续深入任务时使用。(<a href="https://deeesp.github.io/machine%20learning/Classification-Evaluation-Metrics/?utm_source=chatgpt.com">Jinwoo’s Devlog</a>)</li>
</ul>
<p>【可插图：展示一个典型的 ROC 曲线（良好模型曲线高于随机对角线），并标注 AUC 区域；可以附一个简单的 PR 曲线对比。】</p>
<hr>
<p>到这里，1.4 节从“基本监督学习任务设定（回归和分类）”出发，讨论了模型复杂度与泛化的偏差–方差权衡，并引出了控制复杂度的工具（正则化、早停、交叉验证），以及用于评价模型好坏的一整套指标体系。
在后续深度学习章节中，这些概念会以更复杂的形式再次出现——但本节提供的直观图景将持续作为理解更高级方法的“坐标系”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="推荐阅读与资源"><a href="#推荐阅读与资源" class="header">推荐阅读与资源</a></h1>
<h2 id="15-推荐阅读与资源"><a class="header" href="#15-推荐阅读与资源">1.5 推荐阅读与资源</a></h2>
<p>本章从零开始勾勒了线性代数、概率统计、优化与基础机器学习的“最小必需集合”。
但要在具身智能与 VLA 方向真正做到<strong>能读论文、能推公式、能写代码、能做实验</strong>，仅靠本书的篇幅仍然略显紧凑。</p>
<p>因此，这里推荐三类强相关的配套资源：</p>
<ul>
<li>一本偏统计机器学习理论的中文书；</li>
<li>一条线性代数 / 数值线性代数的进阶路径；</li>
<li>一门成体系的机器学习公开课。</li>
</ul>
<p>它们与本书的关系大致可以理解为：</p>
<blockquote>
<p>本书：给出结构化主线与机器人应用视角
推荐资源：在“理论深度”和“练习密度”上进行补强</p>
</blockquote>
<blockquote>
<p>【图片占位：学习资源结构图——中间是“本书”，周围连出三条箭头：
① 指向《统计学习方法》（补充 1.2/1.4 的统计学习理论）；
② 指向《Matrix Computations》/《Linear Algebra and Learning from Data》（补充 1.1/1.3 的线性代数与数值方法）；
③ 指向 Stanford CS229（将本书第 1 章内容串联成一门完整 ML 课程）。】</p>
</blockquote>
<p>下面分别说明每个资源<strong>适合在什么时候读、怎么读、和本书哪个部分形成互补</strong>。</p>
<hr>
<h3 id="151-统计学习方法"><a class="header" href="#151-统计学习方法">1.5.1 《统计学习方法》</a></h3>
<p><strong>基本信息与定位</strong></p>
<p>《统计学习方法》（李航，清华大学出版社）是国内机器学习领域极为常用的一本教材，目前已有第二版，被许多高校作为“机器学习原理”课程主教材使用。(<a href="https://radio.seu.edu.cn/2022/0301/c20094a400058/pagem.htm?utm_source=chatgpt.com">东南大学信息科学与工程学院</a>)</p>
<p>它的特点可以概括为：</p>
<ul>
<li><strong>理论导向</strong>：以统计学习理论为主线，强调“概率模型 + 损失函数 + 经验风险 / 结构风险最小化”这一统一框架；</li>
<li><strong>覆盖经典算法</strong>：感知机、k 近邻、朴素贝叶斯、决策树、逻辑回归 / 最大熵、支持向量机、提升方法、EM、HMM、CRF 等；</li>
<li><strong>公式推导完整</strong>：绝大多数算法都从“问题设定 → 目标函数 → 优化方法 → 性质”系统展开，非常适合练习看懂和推导公式。</li>
</ul>
<p>这些内容与本书第 <strong>1.2 节（概率与统计基础）</strong>、<strong>1.3 节（优化）</strong>、**1.4 节（机器学习基础）**互相呼应：本书给的是“概念地图”和机器人视角，《统计学习方法》给的是“严格数学版的细节”。</p>
<hr>
<p><strong>建议的阅读顺序与对应关系</strong></p>
<p>如果你已经读完本书第 1 章，建议按下面顺序局部精读，而不是从头到尾机械通读：</p>
<ol>
<li><strong>“统计学习方法概论”章节</strong>
<ul>
<li>对应本书 1.4 整体框架：监督学习、经验风险最小化、结构风险最小化、泛化能力等概念。</li>
<li>阅读目标：把“机器学习 = 拟合一个函数”的朴素印象，升级为“机器学习 = 在假设空间中寻找经验风险 / 结构风险最小的函数”的统计学习观。</li>
</ul>
</li>
<li><strong>线性模型与判别模型相关章节</strong>（如感知机、逻辑回归、最大熵模型）
<ul>
<li>与本书 <strong>1.4.1 回归与分类</strong>、<strong>1.4.2 过拟合与偏差–方差</strong>、以及第 2 章的神经网络基础直接对应。</li>
<li>阅读时可以刻意关注：
<ul>
<li>损失函数是如何从概率模型中导出的（例如对数似然 → 对数损失 / 交叉熵）；</li>
<li>正则化项如何自然出现（先验 + MAP → L1/L2 正则）。</li>
</ul>
</li>
<li>这些内容读懂之后，再回看本书 1.3、1.4，会发现损失与正则化其实一直是“同一个故事”的不同侧面。</li>
</ul>
</li>
<li><strong>支持向量机与核方法章节</strong>
<ul>
<li>与本书 <strong>1.4.4 核方法与高维特征空间直觉</strong>紧密对应。</li>
<li>建议阅读方式：
<ul>
<li>先看“几何直觉”：间隔最大化、支持向量；</li>
<li>再看“对偶问题与核技巧”：如何把高维特征空间的点积“藏进”核函数中。</li>
</ul>
</li>
<li>这一部分对于理解后续 VLA 模型中“高维表示空间”的直觉非常有帮助。</li>
</ul>
</li>
<li><strong>EM、HMM、CRF 等章节</strong>
<ul>
<li>与本书后续关于概率图模型、序列建模（特别是机器人任务中的状态估计与时序决策）遥相呼应。</li>
<li>这些方法在现代深度模型中常以“隐含结构”形式出现，理解它们会让你在阅读更复杂的模型（如带隐变量的世界模型）时不至于“只看结论”。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>如何利用本书 +《统计学习方法》联合学习</strong></p>
<p>一个比较实用的学习节奏是：</p>
<ol>
<li><strong>先看本书</strong>某一小节，获取“概念树”和“在机器人场景下为何需要它”的直觉；</li>
<li><strong>再在《统计学习方法》中对照阅读</strong>对应算法章节，专注于：
<ul>
<li>公式每一项的含义；</li>
<li>优化目标与梯度 / 对偶问题的关系；</li>
<li>与泛化误差、偏差–方差的联系；</li>
</ul>
</li>
<li>最后回到本书的习题或后续章节，在仿真或真实机器人项目中实现 / 调用这些算法。</li>
</ol>
<p>如此循环几轮，你会逐渐形成：<strong>看到一个新模型 → 能够迅速抽象为“统计学习方法”框架</strong>的能力，这对后续阅读具身智能 / VLA 论文非常关键。</p>
<hr>
<h3 id="152-matrix-computations-或-linear-algebra-and-learning-from-data"><a class="header" href="#152-matrix-computations-或-linear-algebra-and-learning-from-data">1.5.2 《Matrix Computations》 或 《Linear Algebra and Learning from Data》</a></h3>
<p>本书第 1.1 节对线性代数只做了“最必要”的回顾：向量空间、特征值与 SVD 等。
在具身智能和 VLA 研究中，线性代数还有两个常被忽视但极其重要的方面：</p>
<ol>
<li>**数值计算层面：**矩阵算法在计算机中究竟是如何实现的、它们为什么稳定或不稳定；</li>
<li>**与机器学习的结合层面：**深度学习、压缩感知、低秩近似等现代工具，本质上都是线性代数思想的延伸。</li>
</ol>
<p>下面这两本书各自从这两个方向对本书做补强。</p>
<hr>
<h4 id="1matrix-computations数值线性代数的算法圣经"><a class="header" href="#1matrix-computations数值线性代数的算法圣经">（1）《Matrix Computations》——数值线性代数的“算法圣经”</a></h4>
<p>《Matrix Computations》（Gene H. Golub &amp; Charles F. Van Loan）是数值线性代数领域的经典教材，对线性方程组、最小二乘问题和特征值问题的数值算法做了系统而深入的总结，被广泛视为计算科学和工程领域的必备参考书。(<a href="https://www.press.jhu.edu/books/title/10678/matrix-computations?srsltid=AfmBOoqnsph7wJ_wv3Zt_qxBN4RnNIK1xTZ7zNTUXAsDSfZbdvNEZ6aR&amp;utm_source=chatgpt.com">约翰霍普金斯大学出版社</a>)</p>
<p><strong>适合解决的问题</strong></p>
<ul>
<li>当你开始关心“矩阵分解在计算机里到底是怎么算的”；</li>
<li>当你需要理解数值稳定性、条件数、舍入误差对算法的影响；</li>
<li>当你在仿真或机器人控制中遇到数值发散、线性系统求解不稳定时。</li>
</ul>
<p><strong>与本书的衔接</strong></p>
<ul>
<li>与本书 <strong>1.1 线性代数基础</strong>：
本书强调“概念与几何直觉”，《Matrix Computations》强调“算法与误差分析”；
例如：LU 分解、QR 分解、SVD，在这里会从算法步骤、复杂度、稳定性等角度彻底展开。</li>
<li>与本书 <strong>1.3 优化基础</strong>、以及后面涉及<strong>最小二乘、最小范数解、低秩近似</strong>的内容一一对应：
<ul>
<li>如何在数值上稳健地解最小二乘问题；</li>
<li>如何实现高效的迭代方法解决大规模线性系统。</li>
</ul>
</li>
</ul>
<p><strong>阅读建议</strong></p>
<p>由于本书面向具身智能方向，不要求你把整本《Matrix Computations》精读完，可以采取“按需查阅 + 局部精读”的策略，例如：</p>
<ul>
<li>重点关注线性方程组、最小二乘与 QR / SVD 相关章节；</li>
<li>遇到数值问题时，将其当作“字典”查表，看某种矩阵问题推荐使用哪类算法。</li>
</ul>
<hr>
<h4 id="2linear-algebra-and-learning-from-data线代与现代机器学习的桥梁"><a class="header" href="#2linear-algebra-and-learning-from-data线代与现代机器学习的桥梁">（2）《Linear Algebra and Learning from Data》——线代与现代机器学习的桥梁</a></h4>
<p>Gilbert Strang 的《Linear Algebra and Learning from Data》将传统线性代数与现代数据科学、深度学习联系起来，整本书围绕“如何用线性代数视角理解数据与学习算法”展开。(<a href="https://math.mit.edu/~gs/learningfromdata/?utm_source=chatgpt.com">麻省理工学院数学</a>)</p>
<p>从目录可以看到，它一方面涵盖了经典内容（四个基本子空间、SVD、矩阵分解等），另一方面专门讨论了大矩阵计算、压缩感知以及深度学习等主题。(<a href="https://math.mit.edu/~gs/learningfromdata/dsla_toc.pdf?utm_source=chatgpt.com">麻省理工学院数学</a>)</p>
<p><strong>适合解决的问题</strong></p>
<ul>
<li>希望用统一的线性代数语言理解：
线性回归、主成分分析、正则化、低秩近似、神经网络中的矩阵运算等；</li>
<li>希望知道“为什么线性代数是机器学习的骨架”，而不仅仅把它当作“会算题目”的课程。</li>
</ul>
<p><strong>与本书的衔接</strong></p>
<ul>
<li>与本书 <strong>1.1 线性代数基础</strong>、<strong>1.4 机器学习基础</strong> 直接互补：
例如，本书提到的 PCA、SVD 在 Strang 的书中会配合更多几何图示和实例；</li>
<li>与本书 <strong>2 章深度学习基础</strong>、以及后面 VLA 模型中“表示空间、低秩近似、注意力的矩阵形式”等内容理念一致：
你会更容易把深度模型的运算看成是矩阵 / 张量操作的堆叠，而不是一堆“黑盒”。</li>
</ul>
<p><strong>推荐的阅读顺序</strong></p>
<p>如果你计划系统阅读，可参考如下顺序：</p>
<ol>
<li>先结合本书 <strong>1.1</strong>，阅读该书的线性代数基础部分（如 Ax 的几种理解、四个基本子空间、LU 分解等）；(<a href="https://math.mit.edu/~gs/learningfromdata/dsla_toc.pdf?utm_source=chatgpt.com">麻省理工学院数学</a>)</li>
<li>再在本书 <strong>1.4</strong> / <strong>2 章</strong> 学习相关算法之后，回头看书中关于 PCA、压缩感知、深度学习的章节，强化对“矩阵视角下的机器学习”的理解；(<a href="https://www.amazon.com/Linear-Algebra-Learning-Gilbert-Strang/dp/0692196382?utm_source=chatgpt.com">亚马逊</a>)</li>
<li>对数值问题有兴趣时，再从这里自然过渡到《Matrix Computations》的算法细节。</li>
</ol>
<hr>
<p><strong>两本书如何取舍？</strong></p>
<ul>
<li>若你目前主要目标是<strong>打通“线代–机器学习”的理解链路</strong>，更推荐优先读 Strang 的《Linear Algebra and Learning from Data》；</li>
<li>若你已经开始写数值算法 / 控制算法代码，或者在仿真中频繁遇到数值问题，则可以逐步引入《Matrix Computations》作为工具书。</li>
</ul>
<hr>
<h3 id="153-stanford-cs229-机器学习公开课"><a class="header" href="#153-stanford-cs229-机器学习公开课">1.5.3 Stanford CS229 机器学习公开课</a></h3>
<p>Stanford CS229 是斯坦福大学经典的研究生级机器学习课程，由 Andrew Ng 等人主讲，提供了系统的课程视频、讲义和课后作业，对监督学习、无监督学习、核方法、神经网络以及强化学习等内容进行较为完整的讲解。(<a href="https://cs229.stanford.edu/syllabus-spring2022.html?utm_source=chatgpt.com">cs229.stanford.edu</a>)</p>
<p>从官方课程描述可以看到，它的核心内容与本书第 1 章高度重合：线性回归、逻辑回归、神经网络、SVM、聚类、降维、核方法、强化学习等，是本书所述基础知识的一条“课程化实现”。(<a href="https://cs229.stanford.edu/syllabus-spring2022.html?utm_source=chatgpt.com">cs229.stanford.edu</a>)</p>
<hr>
<p><strong>为什么推荐 CS229</strong></p>
<ol>
<li><strong>系统性强</strong>
本书在第 1 章以“知识点”为单位组织；CS229 则以“课程节次”为单位，把这些知识点串成一条完整的学习路径，有利于你建立“整门课”的时间线和节奏感。</li>
<li><strong>配套资料丰富</strong>
<ul>
<li>公开的讲义（lecture notes）对很多算法进行了严格推导，是极好的公式练习素材；(<a href="https://cs229.stanford.edu/main_notes.pdf?utm_source=chatgpt.com">cs229.stanford.edu</a>)</li>
<li>视频课程可以帮助你在“推导细节看不懂”时，通过教师的口头解释获取直觉。(<a href="https://www.youtube.com/playlist?list=PLoROMvodv4rMiGQp3WXShtMGgzqpfVfbU&amp;utm_source=chatgpt.com">YouTube</a>)</li>
</ul>
</li>
<li><strong>要求的数学背景与本书契合</strong>
CS229 被普遍认为是一门“偏理论”的课程，需要一定的线性代数、概率论和多元微积分基础。(<a href="https://csdiy.wiki/en/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/CS229/?utm_source=chatgpt.com">csdiy.wiki</a>)
这恰好与本书第 1 章的定位一致：只要你按照本书 1.1–1.3 的要求打好基础，就已经具备了啃 CS229 的数学条件。</li>
</ol>
<hr>
<p><strong>如何将 CS229 与本书结合</strong></p>
<p>可以将 CS229 看作是本书第 1 章的“扩展实验课”，建议采用如下配合方式：</p>
<ul>
<li><strong>第一轮：本书为主，CS229 为辅</strong>
先按照本书章节顺序学习：
<ul>
<li>在阅读完本书 <strong>1.4 机器学习基础</strong>后，选择性观看 CS229 中关于线性 / 逻辑回归、SVM、神经网络、偏差–方差与正则化的讲座；(<a href="https://cs229.stanford.edu/syllabus-new.html?utm_source=chatgpt.com">cs229.stanford.edu</a>)</li>
<li>重点在于听懂问题设定与公式推导思路，而不必强求每一处证明都完全掌握。</li>
</ul>
</li>
<li><strong>第二轮：CS229 为主，本书为“导航 + 补充”</strong>
当你开始正式做机器学习 / 具身智能的课程项目或科研时，可以完整跟一遍 CS229：
<ul>
<li>以课程讲义和作业为主线；</li>
<li>本书第 1 章作为“索引”和“简化注解”：遇到不熟悉的数学 / 概念，可快速翻回本书对应小节回顾直觉与定义；</li>
<li>在强化学习与自适应控制部分，与本书第 5 章内容形成前后呼应。(<a href="https://cs229.stanford.edu/syllabus-spring2022.html?utm_source=chatgpt.com">cs229.stanford.edu</a>)</li>
</ul>
</li>
<li><strong>第三轮：带着机器人问题回头看</strong>
当你进入 VLA、模仿学习或机器人控制的研究阶段，再回看 CS229 的相关章节（尤其是核方法、正则化、偏差–方差、EM、强化学习等），会更清楚这些“基础课上的理论”在机器人任务中分别扮演什么角色。</li>
</ul>
<hr>
<p><strong>小结：本书与三类资源在学习路径中的位置</strong></p>
<ul>
<li><strong>第 0~1 章 + 本书整体</strong>：提供具身智能 / VLA 视角下的数学与机器学习“骨架”；</li>
<li><strong>《统计学习方法》</strong>：把 1.2 / 1.4 中的统计学习理论“加厚”，帮助你真正掌握公式推导和理论框架；</li>
<li><strong>《Matrix Computations》 &amp; 《Linear Algebra and Learning from Data》</strong>：从数值算法与线性代数–数据科学的结合两个方向，补全 1.1 / 1.3 的深度；</li>
<li><strong>CS229</strong>：把这些知识组织成一门逻辑严密的课程，通过作业和项目推动你真正“会用”。</li>
</ul>
<p>在后续章节，我们会逐步进入深度学习、视觉、语言、强化学习以及 VLA 模型的细节；
当你在后面遇到任何“数学或机器学习基础不够扎实”的时刻，都可以回到本书第 1 章，并借助本节列出的资源向下钻研一层，使你的理论根基足以支撑具身智能这个长期而复杂的研究方向。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="神经网络基本结构"><a href="#神经网络基本结构" class="header">神经网络基本结构</a></h1>
<h2 id="21-神经网络基本结构"><a class="header" href="#21-神经网络基本结构">2.1 神经网络基本结构</a></h2>
<p>本节从最经典的感知机出发，逐步推导出现代深度学习中广泛使用的前馈神经网络（MLP），并系统讨论激活函数、损失函数以及反向传播与自动求导。这一部分是后续卷积网络、Transformer、VLA 模型的“通用底层语法”。</p>
<hr>
<h3 id="211-感知机与前馈神经网络"><a class="header" href="#211-感知机与前馈神经网络">2.1.1 感知机与前馈神经网络</a></h3>
<h4 id="2111-感知机模型"><a class="header" href="#2111-感知机模型">2.1.1.1 感知机模型</a></h4>
<p>感知机（Perceptron）是最早的人工神经元模型之一，用于二分类问题。形式非常简单：对输入向量做一次线性加权求和，然后通过一个阈值函数决定输出类别。(<a href="https://en.wikipedia.org/wiki/Perceptron?utm_source=chatgpt.com">维基百科</a>)</p>
<p>设输入为 (x \in \mathbb{R}^d)，权重为 (w \in \mathbb{R}^d)，偏置为 (b \in \mathbb{R})，则感知机的输出为</p>
<p>$$
f(x) = h(w^\top x + b),
$$</p>
<p>其中 (h(\cdot)) 通常取阶跃（Heaviside step）函数：</p>
<p>$$
h(a) =
\begin{cases}
1, &amp; a &gt; 0,[4pt]
0, &amp; a \le 0.
\end{cases}
$$</p>
<p>几何上，(w^\top x + b = 0) 是输入空间中的一个超平面，感知机就是“问：样本在超平面的哪一侧？”。因此它是一个<strong>线性分类器</strong>，只能解决<strong>线性可分</strong>的二分类问题，例如 AND、OR，但无法解决 XOR 这样的非线性问题。(<a href="https://stats.stackexchange.com/questions/410952/why-perceptron-is-linear-classifier?utm_source=chatgpt.com">Cross Validated</a>)</p>
<p>感知机的学习（经典的感知机学习算法）就是不断调整 (w,b)，使训练集中正负样本最终被这个超平面正确分开——只要数据线性可分，经典感知机算法可以在有限步内收敛。(<a href="https://en.wikipedia.org/wiki/Perceptron?utm_source=chatgpt.com">维基百科</a>)</p>
<blockquote>
<p>【图 2-1 占位】
感知机结构示意图：左侧若干输入节点 (x_1,\dots,x_d)，连接到一个神经元，中间标出权重 (w_i)，节点内部显示加权和 (\sum w_i x_i + b)，右侧是经阶跃函数后输出 0/1。</p>
</blockquote>
<p>在具身智能/机器人中，单个感知机本身不常直接使用，但它是理解更复杂神经网络的基石：你可以把它看作“最小决策单元”。</p>
<hr>
<h4 id="2112-前馈神经网络mlp"><a class="header" href="#2112-前馈神经网络mlp">2.1.1.2 前馈神经网络（MLP）</a></h4>
<p>感知机只有一层线性变换 + 非线性，不足以表达复杂模式。为此，人们自然想到：<strong>把很多这样的“神经元”堆叠起来</strong>——于是就有了多层前馈神经网络（Multilayer Perceptron, MLP）。(<a href="https://takeheed.tistory.com/23?utm_source=chatgpt.com">Take heed : 개발 블로그</a>)</p>
<p>前馈网络的典型结构：</p>
<ul>
<li>输入层：接收原始特征，例如图像像素、机器人关节状态、传感器读数等。</li>
<li>若干隐藏层：每一层都是仿照感知机的线性变换 + 激活函数。</li>
<li>输出层：给出回归值、类别概率或动作命令等。</li>
</ul>
<p>以两层 MLP（1 个隐藏层）为例：</p>
<p>$$
\begin{aligned}
h &amp;= \sigma(W_1 x + b_1),
y &amp;= \phi(W_2 h + b_2),
\end{aligned}
$$</p>
<p>其中</p>
<ul>
<li>(x \in \mathbb{R}^{d_{\text{in}}})：输入；</li>
<li>(h \in \mathbb{R}^{d_{\text{hidden}}})：隐藏层表示；</li>
<li>(y)：输出；</li>
<li>(W_1, W_2)、(b_1, b_2) 为可学习参数；</li>
<li>(\sigma(\cdot)) 是隐藏层激活函数（如 ReLU、GELU）；</li>
<li>(\phi(\cdot)) 是输出层激活函数（如恒等、sigmoid 或 softmax，视任务而定）。</li>
</ul>
<p>所有层的连接方向从输入到输出，没有回路，所以称为“前馈（feedforward）”。</p>
<blockquote>
<p>【图 2-2 占位】
两层 MLP 拓扑图：输入层若干节点，经全连接到隐藏层，再全连接到输出层，用箭头表示信息单向流动。</p>
</blockquote>
<p>在机器人具身智能系统中，MLP 通常扮演以下角色：</p>
<ul>
<li>视觉 backbone 后面的<strong>决策头（policy head）</strong>：将高维视觉特征映射为动作参数。</li>
<li>强化学习中的<strong>价值函数 / Q 函数近似器</strong>。</li>
<li>动力学模型或世界模型中的局部近似模块，将状态映射到下一状态或奖励。</li>
</ul>
<hr>
<h4 id="2113-表示能力"><a class="header" href="#2113-表示能力">2.1.1.3 表示能力</a></h4>
<p>为什么 MLP 如此重要？关键是它的<strong>函数逼近能力</strong>。</p>
<p>**通用逼近定理（Universal Approximation Theorem）**表明：在较宽的条件下，<strong>具有非多项式激活函数（如 sigmoid、ReLU）的一隐藏层前馈网络，可以以任意精度逼近定义在紧致集合上的任意连续函数</strong>。(<a href="https://en.wikipedia.org/wiki/Universal_approximation_theorem?utm_source=chatgpt.com">维基百科</a>)</p>
<p>直观地讲：</p>
<ul>
<li>每个隐藏层神经元可以看作一个“小基函数”，例如某个方向上的“台阶”或“拐点”；</li>
<li>通过线性组合足够多的这样的基函数，就能构造出形状非常复杂的曲线和曲面；</li>
<li>因此，只要隐藏单元足够多，MLP 在理论上可以表示任意复杂的输入–输出映射。</li>
</ul>
<p>从工程角度：</p>
<ul>
<li><strong>宽度</strong>（隐藏单元个数）决定单层网络能表示多复杂的函数；</li>
<li><strong>深度</strong>（层数）允许网络通过逐层组合，产生更高层次、更结构化的特征，很多研究表明“适度加深”比“无限加宽”更高效。(<a href="https://en.wikipedia.org/wiki/Universal_approximation_theorem?utm_source=chatgpt.com">维基百科</a>)</li>
</ul>
<p>但要注意：
通用逼近定理只是“存在性定理”，它告诉我们“有某个参数配置”能做到，并不保证我们一定能通过有限数据和有限训练时间找到那个最好配置。这正是前面第 1 章中优化与泛化问题的现实版本。</p>
<p>在具身智能场景里，这个理论给我们信心：只要模型结构合理、数据与训练方法得当，<strong>一个足够大的前馈网络有能力学会从机器人多模态观测到高质量控制命令的映射</strong>。</p>
<hr>
<h3 id="212-激活函数relugelu-等及其性质"><a class="header" href="#212-激活函数relugelu-等及其性质">2.1.2 激活函数（ReLU、GELU 等）及其性质</a></h3>
<h4 id="2121-常见激活函数"><a class="header" href="#2121-常见激活函数">2.1.2.1 常见激活函数</a></h4>
<p>激活函数决定了神经元如何“非线性响应”输入。如果没有激活函数（或者只用线性函数），整个网络退化为一层线性变换，无法表示复杂关系。常见激活函数包括：sigmoid、tanh、ReLU、GELU、SiLU 等。(<a href="https://www.geeksforgeeks.org/machine-learning/activation-functions-neural-networks/?utm_source=chatgpt.com">geeksforgeeks.org</a>)</p>
<ol>
<li><strong>Sigmoid（S 形函数）</strong></li>
</ol>
<p>$$
\text{sigmoid}(x) = \frac{1}{1 + e^{-x}}.
$$</p>
<ul>
<li>输出范围 ((0,1))，早期常用于二分类输出。</li>
<li>曲线在 0 附近较陡，两端（正/负无穷）趋近于 1 和 0。</li>
<li>大输入绝对值区域梯度接近 0，深层网络中容易产生<strong>梯度消失</strong>。</li>
</ul>
<ol start="2">
<li><strong>Tanh（双曲正切）</strong></li>
</ol>
<p>$$
\tanh(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}},
$$</p>
<p>输出范围 ((-1,1))，形状与 sigmoid 相似，但是零中心的。相比 sigmoid，在某些场景下收敛更快，但同样存在饱和区梯度很小的问题。</p>
<ol start="3">
<li><strong>ReLU（Rectified Linear Unit）</strong></li>
</ol>
<p>$$
\text{ReLU}(x) = \max(0, x).
$$</p>
<ul>
<li>(x\le 0) 时输出 0；(x&gt;0) 时保持线性。</li>
<li>计算简单，梯度在正半轴为 1，在负半轴为 0。</li>
<li>在深度网络中表现良好，是目前最常用的激活函数之一。(<a href="https://en.wikipedia.org/wiki/Rectified_linear_unit?utm_source=chatgpt.com">维基百科</a>)</li>
</ul>
<ol start="4">
<li><strong>GELU（Gaussian Error Linear Unit）</strong></li>
</ol>
<p>GELU 大致形状类似一个平滑的“软 ReLU”：对较小或负的输入输出接近 0，对较大的输入近似线性；它的精确表达式可写为与高斯累积分布相关的形式。GELU 在 Transformer 等大模型中被广泛采用，被认为在某些任务上比 ReLU 有更好的性能和更平滑的梯度性质。(<a href="https://medium.com/%40varun_mishra/activation-functions-in-focus-understanding-relu-gelu-and-silu-841ed1c6df0c?utm_source=chatgpt.com">Medium</a>)</p>
<ol start="5">
<li><strong>SiLU / Swish 等平滑 ReLU 变体</strong></li>
</ol>
<p>SiLU（Sigmoid Linear Unit）、Swish 等也是近年常用的激活函数，在负半轴有小的负输出，在正半轴近似线性，兼具平滑与非线性。</p>
<blockquote>
<p>【图 2-3 占位】
多种激活函数曲线对比图：在同一坐标系中绘制 Sigmoid、Tanh、ReLU、GELU 的函数曲线，并在另一幅子图中绘制它们的导数，突出梯度在不同区间的大小差异。</p>
</blockquote>
<hr>
<h4 id="2122-激活函数对梯度的影响"><a class="header" href="#2122-激活函数对梯度的影响">2.1.2.2 激活函数对梯度的影响</a></h4>
<p>激活函数不仅影响网络的表达能力，也直接影响<strong>梯度传播质量</strong>，从而影响训练速度与稳定性。(<a href="https://www.geeksforgeeks.org/machine-learning/activation-functions-neural-networks/?utm_source=chatgpt.com">geeksforgeeks.org</a>)</p>
<ol>
<li><strong>梯度消失（vanishing gradient）</strong></li>
</ol>
<ul>
<li>Sigmoid/Tanh 在远离 0 的区域导数接近 0，深层网络中多次相乘后，梯度会迅速衰减。</li>
<li>结果是靠近输入的前几层几乎得不到有效更新，训练停滞。</li>
</ul>
<ol start="2">
<li><strong>梯度爆炸（exploding gradient）</strong></li>
</ol>
<ul>
<li>若激活函数的导数较大，或者权重初始化不合适，梯度在层间传播时会被放大，导致数值不稳定。</li>
<li>虽然激活函数本身不是唯一原因，但其导数规模是关键因素之一。</li>
</ul>
<ol start="3">
<li><strong>ReLU 的“半线性”优势与问题</strong></li>
</ol>
<ul>
<li>ReLU 在正半轴导数为 1，不会压缩梯度；在负半轴导数为 0，可以增加稀疏性。</li>
<li>这有助于缓解梯度消失问题，也在实践中显著提升了深度网络训练效果。(<a href="https://en.wikipedia.org/wiki/Rectified_linear_unit?utm_source=chatgpt.com">维基百科</a>)</li>
<li>但 ReLU 也会出现“死亡 ReLU”（neuron dying）现象：若某个神经元长期落在负区间，其输出和梯度都为 0，难以再被激活。</li>
</ul>
<ol start="4">
<li><strong>平滑非线性（GELU、SiLU）的折中</strong></li>
</ol>
<ul>
<li>GELU 等函数在零附近平滑过渡，导数在全域不为 0，利于梯度更柔和地传播。(<a href="https://arxiv.org/pdf/2305.12073?utm_source=chatgpt.com">arXiv</a>)</li>
<li>实证研究表明，在 Transformer 等架构中使用 GELU 能带来更好的收敛性质和最终性能。</li>
</ul>
<p>总体来看，激活函数的设计和选择，是在“表达能力—梯度稳定性—计算开销”之间寻找平衡。</p>
<hr>
<h4 id="2123-激活函数选择"><a class="header" href="#2123-激活函数选择">2.1.2.3 激活函数选择</a></h4>
<p>在具体工程实践中，激活函数通常按以下经验进行选择：</p>
<ul>
<li><strong>隐藏层（MLP、CNN、Transformer 前馈）</strong>
<ul>
<li>默认优先：ReLU 或 GELU。</li>
<li>若特别追求平滑性或更高性能，可考虑 GELU、SiLU 等。</li>
</ul>
</li>
<li><strong>输出层</strong>
<ul>
<li>回归：一般使用<strong>线性激活</strong>（恒等函数），直接输出实数。</li>
<li>二分类：常用 sigmoid，将输出映射到 ((0,1))，然后配合二元交叉熵损失。</li>
<li>多分类：使用 softmax，将 logits 映射为概率分布，再配合交叉熵损失。</li>
</ul>
</li>
<li><strong>机器人 / 具身智能中的特殊考虑</strong>
<ul>
<li>输出若为角速度、力矩等连续控制量，通常选择线性或 Tanh，并在 Tanh 输出后再缩放到物理允许范围；</li>
<li>为保证安全，可在激活函数后附加硬裁剪（clamp），确保输出不超出机器人硬件极限。</li>
</ul>
</li>
</ul>
<p>随着模型规模与任务复杂度提升，新的激活函数还在不断被提出；但在掌握基础原理后，读者可以将它们都看作是在“非线性形状”和“梯度传播”上的微调。</p>
<hr>
<h3 id="213-损失函数交叉熵mse-等与任务类型对应关系"><a class="header" href="#213-损失函数交叉熵mse-等与任务类型对应关系">2.1.3 损失函数（交叉熵、MSE 等）与任务类型对应关系</a></h3>
<p>损失函数（Loss function）度量模型输出与真实标签之间的差异，是训练中需要最小化的目标。不同任务适合不同的损失设计，这一点在前面机器学习基础（1.4 节）已有初步介绍，这里结合神经网络再做系统梳理。</p>
<h4 id="2131-均方误差mse"><a class="header" href="#2131-均方误差mse">2.1.3.1 均方误差（MSE）</a></h4>
<p>均方误差（Mean Squared Error, MSE）是回归任务中最常用的损失之一。(<a href="https://simpling.tistory.com/15?utm_source=chatgpt.com">simpling</a>)</p>
<p>单样本情况下：</p>
<p>$$
\mathcal{L}_{\text{MSE}}(y,\hat{y}) = \frac{1}{2}(y - \hat{y})^2,
$$</p>
<p>其中 (y) 为真实值，(\hat{y}) 为模型预测值。对一个批量大小为 (n) 的样本集合，损失通常取平均：</p>
<p>$$
\mathcal{L}<em>{\text{MSE}} = \frac{1}{n} \sum</em>{i=1}^n \frac{1}{2}(y_i - \hat{y}_i)^2.
$$</p>
<p>MSE 的特点：</p>
<ul>
<li>对误差进行平方，<strong>放大大误差</strong>的影响，有利于收敛到整体最优。</li>
<li>对于高斯噪声假设下的线性回归，MSE 对应于最大似然估计，是一个有良好统计意义的目标函数。</li>
<li>梯度简单：(\partial \mathcal{L}/\partial \hat{y} = \hat{y} - y)，便于反向传播。</li>
</ul>
<p>在机器人控制中，若要预测未来状态、关节角度或力矩等连续量，MSE 是自然的选择；在某些 RL 算法中，价值函数近似也常使用 MSE（或 Huber 损失等变体）来拟合目标回报。</p>
<hr>
<h4 id="2132-交叉熵损失"><a class="header" href="#2132-交叉熵损失">2.1.3.2 交叉熵损失</a></h4>
<p>交叉熵损失主要用于分类任务，特别是配合 softmax（多分类）或 sigmoid（二分类）输出时。(<a href="https://simpling.tistory.com/15?utm_source=chatgpt.com">simpling</a>)</p>
<ol>
<li><strong>二分类交叉熵</strong></li>
</ol>
<p>设真实标签 (y \in {0,1})，预测概率 (\hat{p} = \sigma(z)) 为属于正类的概率，则二元交叉熵为：</p>
<p>$$
\mathcal{L}_{\text{BCE}}(y,\hat{p}) = - \big( y \log \hat{p} + (1-y) \log (1-\hat{p}) \big).
$$</p>
<ol start="2">
<li><strong>多分类交叉熵</strong></li>
</ol>
<p>设有 (K) 个类别，真实标签 one-hot 向量 (y \in {0,1}^K)，预测概率 (\hat{p}\in[0,1]^K)，(\sum_k \hat{p}_k=1)。多分类交叉熵为：</p>
<p>$$
\mathcal{L}<em>{\text{CE}}(y,\hat{p}) = - \sum</em>{k=1}^K y_k \log \hat{p}_k.
$$</p>
<p>与 softmax 联用时，这个损失实际上等价于<strong>最大化真实类别对应的 log 概率</strong>。
从信息论角度看，交叉熵与 KL 散度密切相关，是衡量模型预测分布与真实分布差异的自然指标。</p>
<p>为什么分类不用 MSE，而更偏好交叉熵？</p>
<ul>
<li>软最大 + 交叉熵组合在梯度上更“匹配”，能提供更稳定、有效的学习信号；</li>
<li>对于概率模型，交叉熵直接对应于最大似然估计，使模型输出可以被解释为概率。(<a href="https://medium.com/%40bhatadithya54764118/day-47-loss-functions-cross-entropy-mse-and-mae-bdacebc7b428?utm_source=chatgpt.com">Medium</a>)</li>
</ul>
<p>在具身智能中，当我们训练“高层离散决策”（例如动作原语的选择：抓取/放置/导航）或文本指令分类时，交叉熵是主力损失函数。</p>
<hr>
<h4 id="2133-特定任务的损失"><a class="header" href="#2133-特定任务的损失">2.1.3.3 特定任务的损失</a></h4>
<p>除了 MSE 与交叉熵，各类特定任务还发展出大量对应的损失设计，这里只做简要指引：</p>
<ul>
<li><strong>序列任务</strong>
<ul>
<li>语言模型、动作序列预测：通常使用<strong>序列交叉熵</strong>，对每个时间步的 token/动作进行交叉熵损失求和或求平均。</li>
<li>在 VLA 中，若动作被离散化为 token（参见第 8 章），也可以使用交叉熵学习“下一个动作 token”。</li>
</ul>
</li>
<li><strong>生成与对抗学习</strong>
<ul>
<li>GAN 中的对抗损失、KL 散度、Wasserstein 距离等，用于度量生成分布与真实分布的差异。</li>
<li>对于机器人世界模型（生成未来观测/状态），常见组合是 MSE + 感知损失等。</li>
</ul>
</li>
<li><strong>几何与控制相关损失</strong>
<ul>
<li>位姿误差：使用位置误差的 MSE + 姿态误差（如四元数距离）组合。</li>
<li>轨迹平滑正则：对加速度、加加速度（jerk）的平方惩罚。</li>
<li>碰撞惩罚：对发生碰撞的样本加上大损失，或在 RL 中赋予负奖励。</li>
</ul>
</li>
</ul>
<p>本书后续章节在具体任务中会分别介绍对应的损失设计；在本节的层级，我们只要意识到：<strong>损失函数就是把“我们想要的行为”翻译成一个可优化的数学目标</strong>。</p>
<blockquote>
<p>【图 2-4 占位】
(a) MSE 对预测值的曲线示意；(b) 交叉熵随预测正确类别概率变化的曲线示意，直观展示它们对误差的惩罚差异。</p>
</blockquote>
<hr>
<h3 id="214-反向传播算法与链式法则"><a class="header" href="#214-反向传播算法与链式法则">2.1.4 反向传播算法与链式法则</a></h3>
<p>前面的所有内容——网络结构、激活函数、损失函数——最终都要通过<strong>反向传播（Backpropagation）<strong><strong>来连接：我们需要计算损失对每一个参数的梯度，从而用优化算法（如 SGD、Adam）更新参数。反向传播本质上就是</strong></strong>把多元微积分里的链式法则，以系统化的方式应用到计算图上</strong>。(<a href="https://d2l.ai/chapter_preliminaries/autograd.html?utm_source=chatgpt.com">深度学习导引</a>)</p>
<h4 id="2141-链式法则"><a class="header" href="#2141-链式法则">2.1.4.1 链式法则</a></h4>
<p>在 1.3 节中已经回顾过单变量和多变量的链式法则，这里结合神经网络做一个针对性的强化。</p>
<p>假设有复合函数：</p>
<p>$$
y = f(g(x)),
$$</p>
<p>则对 (x) 的导数为</p>
<p>$$
\frac{\mathrm{d}y}{\mathrm{d}x} = f’(g(x)) \cdot g’(x).
$$</p>
<p>推广到多维情况，如果</p>
<p>$$
\begin{aligned}
u &amp;= g(x_1, x_2, \dots, x_n),
y &amp;= f(u),
\end{aligned}
$$</p>
<p>则对某个输入 (x_i) 的偏导数为</p>
<p>$$
\frac{\partial y}{\partial x_i} = \frac{\partial y}{\partial u} \cdot \frac{\partial u}{\partial x_i}.
$$</p>
<p>在神经网络中，每一层的输出都是前一层输出的函数，整个网络就是大量函数的复合。因此，只要我们能写出每个小步骤的导数，就可以通过链式法则逐层把梯度传回去。</p>
<hr>
<h4 id="2142-反向传播算法"><a class="header" href="#2142-反向传播算法">2.1.4.2 反向传播算法</a></h4>
<p>考虑一个简单的两层网络：</p>
<p>$$
\begin{aligned}
h &amp;= \sigma(W_1 x + b_1),
\hat{y} &amp;= \phi(W_2 h + b_2),
\mathcal{L} &amp;= \ell(\hat{y}, y),
\end{aligned}
$$</p>
<p>目标是计算 (\frac{\partial \mathcal{L}}{\partial W_1}, \frac{\partial \mathcal{L}}{\partial b_1}, \frac{\partial \mathcal{L}}{\partial W_2}, \frac{\partial \mathcal{L}}{\partial b_2})。</p>
<p><strong>前向传播（forward pass）</strong>：</p>
<ol>
<li>从输入 (x) 出发，依次计算：
(z_1 = W_1 x + b_1,\ h = \sigma(z_1),\ z_2 = W_2 h + b_2,\ \hat{y} = \phi(z_2),\ \mathcal{L} = \ell(\hat{y}, y))。</li>
</ol>
<p><strong>反向传播（backward pass）</strong>：</p>
<ol>
<li>先计算损失对输出的梯度
(\frac{\partial \mathcal{L}}{\partial \hat{y}} = \nabla_{\hat{y}} \ell(\hat{y}, y))；</li>
<li>对输出层做链式法则：
$$
\frac{\partial \mathcal{L}}{\partial z_2}
= \frac{\partial \mathcal{L}}{\partial \hat{y}} \cdot \phi’(z_2),
$$
$$
\frac{\partial \mathcal{L}}{\partial W_2}
= \frac{\partial \mathcal{L}}{\partial z_2} \cdot h^\top,
\quad
\frac{\partial \mathcal{L}}{\partial b_2}
= \frac{\partial \mathcal{L}}{\partial z_2}.
$$</li>
<li>把梯度“传回”隐藏层：
$$
\frac{\partial \mathcal{L}}{\partial h}
= W_2^\top \frac{\partial \mathcal{L}}{\partial z_2}.
$$</li>
<li>对隐藏层做链式法则：
$$
\frac{\partial \mathcal{L}}{\partial z_1}
= \frac{\partial \mathcal{L}}{\partial h} \odot \sigma’(z_1),
$$
$$
\frac{\partial \mathcal{L}}{\partial W_1}
= \frac{\partial \mathcal{L}}{\partial z_1} \cdot x^\top,
\quad
\frac{\partial \mathcal{L}}{\partial b_1}
= \frac{\partial \mathcal{L}}{\partial z_1}.
$$</li>
</ol>
<p>其中 (\odot) 表示按元素乘。</p>
<p>这一过程可以抽象描述为：</p>
<ul>
<li><strong>前向</strong>：从输入到输出，保存中间结果（如每一层的 (z, h)）。</li>
<li><strong>反向</strong>：从输出到输入，逐层应用链式法则，把 (\partial \mathcal{L}/\partial(\text{当前变量})) 传递给前一层，同时计算相应参数的梯度。</li>
</ul>
<p>反向传播的核心思想在 20 世纪 80 年代已经提出，是现代深度学习训练的核心算法。更形式化地看，它是**反向模式自动微分（reverse-mode automatic differentiation）**在神经网络上的一个具体实现。(<a href="https://www.cs.toronto.edu/~rgrosse/courses/csc2541_2022/tutorials/tut01.pdf?utm_source=chatgpt.com">cs.toronto.edu</a>)</p>
<blockquote>
<p>【图 2-5 占位】
以简单两层 MLP 为例，画出前向图与反向箭头：从输入开始向前计算，再从损失节点反向传播梯度到各层权重的示意图。</p>
</blockquote>
<hr>
<h4 id="2143-计算图与自动求导"><a class="header" href="#2143-计算图与自动求导">2.1.4.3 计算图与自动求导</a></h4>
<p>手工推导复杂网络的梯度既繁琐又容易出错。现代深度学习框架（PyTorch、TensorFlow、JAX 等）普遍采用**计算图（Computational Graph）+ 自动求导（Automatic Differentiation，Autograd）**机制，大幅简化了开发工作。(<a href="https://d2l.ai/chapter_preliminaries/autograd.html?utm_source=chatgpt.com">深度学习导引</a>)</p>
<ol>
<li><strong>计算图</strong></li>
</ol>
<p>在前向计算时，框架会构建一个有向无环图（DAG）：</p>
<ul>
<li>节点：变量或中间结果（张量）；</li>
<li>边：由某个算子（加法、矩阵乘法、激活函数等）连接输入与输出。</li>
</ul>
<p>例如一个简单表达式：</p>
<p>$$
y = (x_1 \cdot x_2 + \sin x_1)^2
$$</p>
<p>即可被拆成若干节点：乘法、加法、sin、平方等。</p>
<ol start="2">
<li><strong>自动求导（Autograd）</strong></li>
</ol>
<p>自动求导是一类算法族，目标是<strong>在计算图上高效、精确地实现链式法则</strong>。(<a href="https://medium.com/%40ritikakumari1302/computational-graphs-and-automatic-differentiation-b5404b5fbaa3?utm_source=chatgpt.com">Medium</a>)</p>
<ul>
<li>在前向传播阶段，框架记录每一步操作以及输入/输出；</li>
<li>在调用 <code>.backward()</code>、<code>grad()</code> 等接口时，框架从损失节点开始，沿计算图<strong>反向</strong>遍历，逐个节点应用链式法则，自动得到所有需要的梯度；</li>
<li>这一过程就是反向模式自动微分（reverse-mode AD），对“多参数、单输出”的场景（典型的神经网络训练）非常高效。</li>
</ul>
<ol start="3">
<li><strong>静态图 vs 动态图</strong></li>
</ol>
<ul>
<li>静态图（如早期 TensorFlow）：先定义好计算图，再执行；优化空间大，但调试不直观。</li>
<li>动态图（如 PyTorch）：前向执行时即时构图，更接近命令式编程，易于调试与与 Python 生态结合。</li>
</ul>
<p>无论哪种形式，对使用者来说，最重要的是理解：<strong>框架帮你做的是链式法则的机械应用，但你仍然需要明白梯度是什么、如何影响训练</strong>。本节的理论理解会在后续你阅读复杂 VLA 模型代码（尤其是自定义算子、非标准损失）时发挥作用。</p>
<blockquote>
<p>【图 2-6 占位】
简单计算图示例：以 (y = (x_1 \cdot x_2 + \sin x_1)^2) 为例，画出节点和有向边，并用另一幅图显示从 (y) 反向传播到 (x_1, x_2) 的梯度流向。</p>
</blockquote>
<hr>
<p>到此为止，我们已经构建了深度学习中“最小工作单元”的全景：
<strong>结构 =（前馈网络） + 非线性（激活函数） + 目标（损失函数） + 训练机制（反向传播与自动求导）</strong>。</p>
<p>在接下来的 2.2 和 2.3 节，我们将在此基础上讨论深层网络训练技巧、卷积与序列建模，并逐步走向 Transformer 与 VLA 的整体结构，为后面在机器人具身智能中的大规模模型应用做好准备。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="深度网络训练技巧"><a href="#深度网络训练技巧" class="header">深度网络训练技巧</a></h1>
<p>下面直接进入 2.2 这一小节的具体内容。你可以把它当作“深度网络工程训练实战篇”的第一部分：在后面训练大规模 VLA / 机器人模型时，这些都是每天会用到的“基本功”。</p>
<hr>
<h3 id="22-深度网络训练技巧概览引入"><a class="header" href="#22-深度网络训练技巧概览引入">2.2 深度网络训练技巧概览（引入）</a></h3>
<p>在第 1 章我们从优化角度讨论了梯度下降、学习率、收敛等概念，这一节则更偏工程实践：<strong>同样一个网络结构，训练得好不好、稳不稳，很大程度取决于权重初始化、归一化、正则化以及训练过程的监控与调度</strong>。
对于后面要训练的 Transformer、视觉骨干、甚至整套 VLA 模型，这些技巧是保证“能训起来”的前提。</p>
<hr>
<h3 id="221-权重初始化与梯度消失--爆炸问题"><a class="header" href="#221-权重初始化与梯度消失--爆炸问题">2.2.1 权重初始化与梯度消失 / 爆炸问题</a></h3>
<h4 id="2211-参数初始化策略xavierkaiming-等"><a class="header" href="#2211-参数初始化策略xavierkaiming-等">2.2.1.1 参数初始化策略：Xavier、Kaiming 等</a></h4>
<p><strong>（1）为什么初始化是个严肃问题？</strong></p>
<p>设一层全连接网络
$$
y = Wx + b
$$
其中 (x \in \mathbb{R}^{n_{\text{in}}})，(y \in \mathbb{R}^{n_{\text{out}}})，权重 (W_{ij}) 独立同分布，均值为 0、方差为 (\sigma^2)。如果输入各维方差相同且独立，可推得每个输出维的方差约为
$$
\mathrm{Var}(y_j) \approx n_{\text{in}} \sigma^2 ,\mathrm{Var}(x).
$$</p>
<ul>
<li>如果 (\sigma^2) 选得太大，随着层数加深，激活的方差会迅速变大，前向信号“发散”，后向梯度也会爆炸。</li>
<li>如果 (\sigma^2) 选得太小，信号层层被压缩，最后几乎全是 0，导致梯度消失。</li>
</ul>
<p><strong>初始化的目标</strong>：让每一层输出的方差与输入大致相当，从而在多层堆叠后，既不过度放大也不过度衰减。(<a href="https://www.pinecone.io/learn/weight-initialization/?utm_source=chatgpt.com">Pinecone</a>)</p>
<hr>
<p><strong>（2）Xavier / Glorot 初始化</strong></p>
<p>Xavier（也叫 Glorot）初始化假设激活函数是<strong>对称且不过度饱和</strong>的（如线性、tanh），希望同时在前向与反向传播中都保持方差稳定。基本思想是根据 fan-in 和 fan-out 调整权重方差：(<a href="https://www.pinecone.io/learn/weight-initialization/?utm_source=chatgpt.com">Pinecone</a>)</p>
<ul>
<li>fan-in：该层每个神经元的输入维数 (n_{\text{in}})；</li>
<li>fan-out：输出维数 (n_{\text{out}})。</li>
</ul>
<p>典型设置：
$$
\mathrm{Var}(W) = \frac{2}{n_{\text{in}} + n_{\text{out}}}.
$$</p>
<p>实现上常见两种形式：</p>
<ul>
<li><strong>均匀分布</strong>：
$$
W_{ij} \sim U\left[-\sqrt{\frac{6}{n_{\text{in}} + n_{\text{out}}}},\ \sqrt{\frac{6}{n_{\text{in}} + n_{\text{out}}}}\right]
$$</li>
<li><strong>正态分布</strong>：
$$
W_{ij} \sim \mathcal{N}\left(0,\ \frac{2}{n_{\text{in}} + n_{\text{out}}}\right).
$$</li>
</ul>
<p>在 PyTorch 等框架中，这通常对应 <code>xavier_uniform_</code> / <code>xavier_normal_</code>。对于卷积层，fan-in/out 会包含卷积核大小（如 (C_{\text{in}} \times k_h \times k_w)）。(<a href="https://docs.pytorch.org/docs/stable/nn.init.html?utm_source=chatgpt.com">PyTorch 文档</a>)</p>
<hr>
<p><strong>（3）Kaiming / He 初始化</strong></p>
<p>ReLU 及其变体（LeakyReLU、GELU 等）在负半轴直接截断，<strong>会把方差“砍掉一半”左右</strong>，Xavier 初始化没有考虑这一点。Kaiming He 等人推导得到对 ReLU 更合适的方差：(<a href="https://www.abhik.xyz/concepts/deep-learning/he-initialization?utm_source=chatgpt.com">www.abhik.xyz</a>)</p>
<ul>
<li>对标准 ReLU：
$$
\mathrm{Var}(W) = \frac{2}{n_{\text{in}}}.
$$</li>
<li>对 LeakyReLU（负半轴斜率为 (a)）等，可推广为：
$$
\mathrm{Var}(W) = \frac{2}{(1 + a^2) n_{\text{in}}}.
$$</li>
</ul>
<p>实现时常用：</p>
<ul>
<li><code>kaiming_normal_(..., mode='fan_in', nonlinearity='relu')</code></li>
<li><code>kaiming_uniform_(...)</code></li>
</ul>
<p>它的目标是<strong>维持前向信号的方差稳定</strong>，从而在很多层 ReLU 堆叠后不会过快衰减或发散。</p>
<hr>
<p><strong>（4）实践建议与偏置初始化</strong></p>
<ul>
<li>多层感知机 + ReLU：优先选用 <strong>Kaiming 初始化</strong>；tanh / sigmoid 仍可以使用 <strong>Xavier</strong>。</li>
<li>卷积网络：同样使用 Xavier/Kaiming，只是 fan-in/out 的计算要把卷积核大小考虑进去。(<a href="https://www.pinecone.io/learn/weight-initialization/?utm_source=chatgpt.com">Pinecone</a>)</li>
<li>偏置项通常初始化为 0（或小常数），避免引入额外偏移。</li>
<li>RNN 常使用<strong>正交初始化</strong>（Orthogonal），以在时间维上更好地保持梯度范数。</li>
</ul>
<blockquote>
<p>【图 2-2-1 占位】
示意图：横轴为层数，纵轴为激活方差，比较“随机大值初始化”（方差迅速爆炸）、“随机小值初始化”（方差迅速衰减）和“Xavier / Kaiming 初始化”（方差在合理区间内平稳）的三条曲线。</p>
</blockquote>
<hr>
<h4 id="2212-梯度消失与梯度爆炸"><a class="header" href="#2212-梯度消失与梯度爆炸">2.2.1.2 梯度消失与梯度爆炸</a></h4>
<p><strong>（1）现象描述</strong></p>
<ul>
<li><strong>梯度消失</strong>：反向传播时，越靠近输入层的梯度越小，接近 0，导致这些层几乎不更新，看起来像“白学了”。</li>
<li><strong>梯度爆炸</strong>：梯度在反向传播中被成倍放大，最终变得非常大，引起参数更新剧烈震荡甚至出现 NaN。</li>
</ul>
<p>这两个问题在<strong>深层网络</strong>和<strong>时间展开很长的 RNN</strong> 中尤为常见。</p>
<hr>
<p><strong>（2）从“链式法则”的角度看</strong></p>
<h1 id="假设一个-l-层网络损失对第-l-层激活-hl-的梯度可以写成一串雅可比矩阵的乘积--fracpartial-mathcallpartial-hl"><a class="header" href="#假设一个-l-层网络损失对第-l-层激活-hl-的梯度可以写成一串雅可比矩阵的乘积--fracpartial-mathcallpartial-hl">假设一个 L 层网络，损失对第 (l) 层激活 (h^{(l)}) 的梯度可以写成一串雅可比矩阵的乘积：
$$
\frac{\partial \mathcal{L}}{\partial h^{(l)}}</a></h1>
<p>\frac{\partial \mathcal{L}}{\partial h^{(L)}}
\prod_{k=l+1}^{L}
\frac{\partial h^{(k)}}{\partial h^{(k-1)}}.
$$</p>
<p>每个 (\frac{\partial h^{(k)}}{\partial h^{(k-1)}}) 的“平均尺度”如果略小于 1，很多层相乘后就指数级趋近于 0；略大于 1，就指数级增长。配合饱和型激活函数（sigmoid / tanh 在两端导数接近 0），非常容易出现梯度消失。(<a href="https://www.pinecone.io/learn/weight-initialization/?utm_source=chatgpt.com">Pinecone</a>)</p>
<p>在 RNN 中，这个乘积沿着时间展开，更容易出问题：</p>
<p>$$
\frac{\partial \mathcal{L}<em>T}{\partial h_t}
;=;
\frac{\partial \mathcal{L}<em>T}{\partial h_T}
\prod</em>{k=t+1}^{T}
\frac{\partial h_k}{\partial h</em>{k-1}}.
$$</p>
<p>当序列很长时，<strong>远处的梯度要么弱得像“幽灵”，要么强得像“爆炸”</strong>。</p>
<hr>
<p><strong>（3）对训练的影响</strong></p>
<ul>
<li>梯度消失：
<ul>
<li>靠近输入的层训练极慢，网络只能“学会”靠后的几层；</li>
<li>难以捕获长距离依赖（长序列、深层语义）。</li>
</ul>
</li>
<li>梯度爆炸：
<ul>
<li>损失值突然暴涨，优化器步长过大直接跳出稳定区域；</li>
<li>参数变成 NaN，训练中断。</li>
</ul>
</li>
</ul>
<p>机器人与具身智能中，任务往往涉及<strong>长时间决策序列</strong>，梯度消失 / 爆炸会直接导致策略难以学到稳定的长时行为，这也是后面在 RNN / Transformer、RL 章节要重点处理的问题。</p>
<blockquote>
<p>【图 2-2-2 占位】
示意图：左图展示从输出层向前传播的梯度在层数增加时指数级衰减（梯度消失）；右图展示梯度指数级增长（梯度爆炸），对比两种极端情况。</p>
</blockquote>
<hr>
<h4 id="2213-缓解梯度消失--爆炸的常见方法"><a class="header" href="#2213-缓解梯度消失--爆炸的常见方法">2.2.1.3 缓解梯度消失 / 爆炸的常见方法</a></h4>
<ol>
<li><strong>合理的权重初始化</strong>
<ul>
<li>使用 Xavier / Kaiming 等能保持前向、反向方差适中的初始化方法，是最基础的一步（见 2.2.1.1）。(<a href="https://www.pinecone.io/learn/weight-initialization/?utm_source=chatgpt.com">Pinecone</a>)</li>
</ul>
</li>
<li><strong>选择合适的激活函数</strong>
<ul>
<li>ReLU 与其变体（LeakyReLU、ELU、GELU 等）在大部分输入区间有非零导数，相比 sigmoid/tanh 更能缓解梯度消失。</li>
<li>同时要防止 ReLU“死亡”（大量神经元长期输出 0），通常通过 Kaiming 初始化、稍微增大学习率、或使用 LeakyReLU/GELU 来缓解。</li>
</ul>
</li>
<li><strong>归一化技术</strong>
<ul>
<li>BatchNorm、LayerNorm 会在每层强行把中间激活标准化到均值接近 0、方差接近 1，从而在一定程度上阻止方差在层间无限放大或缩小。(<a href="https://arxiv.org/abs/1502.03167?utm_source=chatgpt.com">arXiv</a>)</li>
<li>这也是 2.2.2 的主题。</li>
</ul>
</li>
<li><strong>结构设计：残差连接（Residual Connections）</strong>
<ul>
<li>ResNet 中的 skip-connection 让梯度可以“绕过”若干非线性层直接传到更前面，减少有效深度，使梯度更容易流动。</li>
</ul>
</li>
<li><strong>梯度裁剪（Gradient Clipping）</strong>
<ul>
<li>对每次反向传播得到的梯度范数做上界限制，如
$$
g \leftarrow g \cdot \min\left(1,\frac{\tau}{|g|}\right),
$$
其中 (\tau) 是预设阈值。</li>
<li>在 RNN、RL 和真实机器人训练中非常常见，用来防止偶发的“梯度尖峰”引起训练崩溃。</li>
</ul>
</li>
<li><strong>合理的学习率与调度</strong>
<ul>
<li>过大的学习率会放大梯度爆炸的风险；过小则放大梯度消失的效果。</li>
<li>第 2.2.4 节会系统讨论学习率调度和训练监控。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="222-batch-normalization--layernorm-等归一化技术"><a class="header" href="#222-batch-normalization--layernorm-等归一化技术">2.2.2 Batch Normalization / LayerNorm 等归一化技术</a></h3>
<p>归一化（Normalization）的核心思想是：<strong>在每一层把神经元的激活“拉回到一个合适的统计范围”，让优化问题变得更稳定</strong>。这在深层网络中特别重要。</p>
<hr>
<h4 id="2221-批归一化batch-normalization"><a class="header" href="#2221-批归一化batch-normalization">2.2.2.1 批归一化（Batch Normalization）</a></h4>
<p>BatchNorm 由 Ioffe 和 Szegedy 提出，用来缓解所谓的“内部协变量偏移”（internal covariate shift）——即某一层输入的分布，随着前面层参数更新不断变化，从而让这一层不停适应新分布，训练变慢。(<a href="https://arxiv.org/abs/1502.03167?utm_source=chatgpt.com">arXiv</a>)</p>
<p>尽管后续研究发现“内部协变量偏移”并非 BN 有效性的根本解释，但 BN 在实践中确实显著<strong>加速收敛、稳定训练，并带来一定正则化效果</strong>。(<a href="https://en.wikipedia.org/wiki/Batch_normalization?utm_source=chatgpt.com">维基百科</a>)</p>
<p><strong>（1）前向计算公式</strong></p>
<p>对一个 mini-batch (B = {x_1,\dots,x_m})，对每个通道 / 特征维度 (k)，计算：</p>
<ul>
<li>均值：
$$
\mu_B^{(k)} = \frac{1}{m} \sum_{i=1}^m x_i^{(k)}
$$</li>
<li>方差：
$$
(\sigma_B^{(k)})^2 = \frac{1}{m} \sum_{i=1}^m \big(x_i^{(k)} - \mu_B^{(k)}\big)^2
$$</li>
</ul>
<p>然后标准化：
$$
\hat{x}_i^{(k)} = \frac{x_i^{(k)} - \mu_B^{(k)}}{\sqrt{(\sigma_B^{(k)})^2 + \varepsilon}}
$$</p>
<p>再通过<strong>可学习的缩放和平移参数</strong>：
$$
y_i^{(k)} = \gamma^{(k)} \hat{x}_i^{(k)} + \beta^{(k)}
$$
其中 (\gamma, \beta) 也是模型参数，可以恢复或改变归一化后的分布。(<a href="https://medium.com/data-science/the-math-behind-batch-normalization-90ebbc0b1b0b?utm_source=chatgpt.com">Medium</a>)</p>
<p>在卷积网络中，BN 一般对“batch × 空间维度（H×W）”整体求通道均值与方差。</p>
<hr>
<p><strong>（2）训练 vs 推理（inference）</strong></p>
<ul>
<li>训练阶段：使用当前 mini-batch 的统计量 (\mu_B, \sigma_B^2)。</li>
<li>推理阶段：使用<strong>滑动平均</strong>累积的“全局均值 / 方差”，避免单个 batch 不稳定。</li>
</ul>
<hr>
<p><strong>（3）BN 的作用与局限</strong></p>
<ul>
<li>允许使用<strong>更大的学习率</strong>，加速收敛；</li>
<li>在一定程度上减轻了初始化敏感性；</li>
<li>mini-batch 统计带来的噪声本身具有正则化效果，有时可以减弱 Dropout 强度；(<a href="https://arxiv.org/abs/1502.03167?utm_source=chatgpt.com">arXiv</a>)</li>
<li>对 batch size <strong>非常敏感</strong>：当 batch 很小时（如 2～8），估计的方差很不稳定，这时往往需要使用 GroupNorm、LayerNorm 等替代方案。</li>
</ul>
<blockquote>
<p>【图 2-2-3 占位】
示意图：展示一层网络中“线性变换 → BatchNorm（减均值 / 除标准差 / 乘 γ 加 β）→ 非线性激活”的数据流。</p>
</blockquote>
<hr>
<h4 id="2222-层归一化layernorm"><a class="header" href="#2222-层归一化layernorm">2.2.2.2 层归一化（LayerNorm）</a></h4>
<p>LayerNorm 由 Ba 等人提出，最初就是为了解决 BN 在 RNN 等场景中不易使用的问题。核心区别在于：<strong>BN 是在 batch 维上做统计，而 LN 是在“特征维”上对单个样本做统计</strong>。(<a href="https://arxiv.org/abs/1607.06450?utm_source=chatgpt.com">arXiv</a>)</p>
<p>给定单个样本的隐藏状态向量 (\mathbf{h} \in \mathbb{R}^d)，LN 计算：</p>
<p>$$
\mu = \frac{1}{d}\sum_{j=1}^{d} h_j,\quad
\sigma^2 = \frac{1}{d}\sum_{j=1}^{d} (h_j - \mu)^2
$$
$$
\hat{h}_j = \frac{h_j - \mu}{\sqrt{\sigma^2 + \varepsilon}},\quad
y_j = \gamma_j \hat{h}_j + \beta_j
$$</p>
<p>特点：</p>
<ul>
<li>与 batch size <strong>无关</strong>，非常适合小 batch 或 batch=1 的场景；</li>
<li>训练和推理阶段完全一致，无需维护滑动平均；</li>
<li>已成为 Transformer 中的标准组件（前 / 后 LayerNorm）。</li>
</ul>
<hr>
<p><strong>（3）其他归一化变体（了解即可）</strong></p>
<ul>
<li>InstanceNorm：对每个样本、每个通道单独在空间维上归一化，多用于风格迁移等视觉任务。</li>
<li>GroupNorm：将通道分组，每组内部做归一化，兼具 BN/LN 的一些优点，适合小 batch 的 CNN。(<a href="https://d2l.ai/chapter_convolutional-modern/batch-norm.html?utm_source=chatgpt.com">d2l.ai</a>)</li>
</ul>
<p>在后续的视觉与 VLA 模型中，你会看到：<strong>CNN 常用 BN / GroupNorm，Transformer 常用 LayerNorm / RMSNorm</strong>，这是由各自的数据形式和训练方式决定的。</p>
<hr>
<h4 id="2223-归一化技术的作用与实践要点"><a class="header" href="#2223-归一化技术的作用与实践要点">2.2.2.3 归一化技术的作用与实践要点</a></h4>
<ol>
<li><strong>稳定中间层分布，改善优化几何</strong>归一化相当于把每一层的输入都“重置”到均值零、方差一的尺度上，使得损失函数在参数空间中更“平滑”，从而允许更大的学习率、加速收敛。理论和实证研究都表明 BN/LN 的主要收益与<strong>平滑损失景观</strong>密切相关。(<a href="https://en.wikipedia.org/wiki/Batch_normalization?utm_source=chatgpt.com">维基百科</a>)</li>
<li><strong>提高训练速度与深度可达性</strong>
<ul>
<li>VGG 这类极深网络在引入 BN 后变得更容易训练；</li>
<li>在 Transformer 中，如果没有 LN，几十层的深度几乎无法稳定收敛。</li>
</ul>
</li>
<li><strong>正则化效果</strong>
<ul>
<li>BN 通过 batch 统计引入噪声，有类似模型集成的效果，对过拟合有抑制；</li>
<li>这也意味着<strong>BN + 强 Dropout</strong> 有时反而会伤害性能，需要适度调整。(<a href="https://arxiv.org/abs/1706.05350?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>机器人 / 具身智能中的注意点</strong>
<ul>
<li>在强化学习或机器人场景中，输入数据往往不是独立同分布（non-iid），BN 的 batch 统计可能与策略变化纠缠在一起，导致不稳定；这时 LayerNorm 或不依赖 batch 统计的归一化往往更稳定。</li>
<li>对多模态输入（图像、关节状态、语言 embedding）时，可以分别在各模态分支中使用最合适的归一化方式，再做融合。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="223-dropout数据增广等正则化方法"><a class="header" href="#223-dropout数据增广等正则化方法">2.2.3 Dropout、数据增广等正则化方法</a></h3>
<p>为了防止第 1.4 节所说的<strong>过拟合</strong>，深度学习发展出一系列正则化手段，其中 Dropout 和数据增广几乎出现在所有成功的视觉 / 语言 / 机器人模型中。</p>
<hr>
<h4 id="2231-dropout随机丢弃神经元"><a class="header" href="#2231-dropout随机丢弃神经元">2.2.3.1 Dropout：随机丢弃神经元</a></h4>
<p>Dropout 由 Srivastava 等人提出，本质上是一种<strong>随机丢弃神经元的模型集成方法</strong>。训练时，每个神经元以一定概率被“关掉”，迫使网络不能依赖某些特定特征，从而降低过拟合。(<a href="https://jmlr.org/papers/v15/srivastava14a.html?utm_source=chatgpt.com">机器学习研究杂志</a>)</p>
<p><strong>（1）数学形式（以“反向缩放”实现为例）</strong></p>
<p>给定一层的激活 (h)，生成掩码向量 (m)，其中每个元素独立服从 Bernoulli 分布：</p>
<p>$$
m_i \sim \mathrm{Bernoulli}(p_{\text{keep}}),
$$</p>
<p>然后在训练时计算：</p>
<p>$$
\tilde{h}<em>i = \frac{m_i}{p</em>{\text{keep}}} h_i.
$$</p>
<p>这样 (\mathbb{E}[\tilde{h}_i] = h_i)，保证训练和测试阶段的激活期望一致。
测试时则不再随机丢弃，而是使用完整网络（或在权重上做等价缩放）。</p>
<hr>
<p><strong>（2）直观理解</strong></p>
<ul>
<li>每次训练都在随机采样一个“变薄的子网络”（thinned network），不同子网络共享权重；</li>
<li>测试时等价于对大量子网络做平均（ensemble）；</li>
<li>因为神经元不能依赖于固定的“队友”，模型被迫学到更鲁棒、更分散的特征。</li>
</ul>
<hr>
<p><strong>（3）实践经验</strong></p>
<ul>
<li>全连接层常用 dropout rate 在 0.1～0.5 之间；</li>
<li>卷积层中，如果直接对单个像素位置做 Dropout，效果往往一般，可以使用更结构化的 <strong>SpatialDropout / DropBlock</strong> 等变体；(<a href="https://www.sciencedirect.com/science/article/abs/pii/S0893608018301096?utm_source=chatgpt.com">ScienceDirect</a>)</li>
<li>与 BatchNorm 叠加时要小心，一般将 Dropout 放在 BN 之后、激活函数之后，且强度不宜过大。</li>
</ul>
<blockquote>
<p>【图 2-2-4 占位】
示意图：左边是完整网络，右边是训练时启用 Dropout 后“随机熄灭部分神经元”的网络，配上测试阶段使用完整网络的说明。</p>
</blockquote>
<hr>
<h4 id="2232-数据增广让数据学会变身"><a class="header" href="#2232-数据增广让数据学会变身">2.2.3.2 数据增广：让数据“学会变身”</a></h4>
<p>数据增广（Data Augmentation）通过对已有样本做各种变换，<strong>在不改变标签的前提下制造更多样本</strong>，是深度学习中效果最直接的正则化手段之一。(<a href="https://www.sciencedirect.com/science/article/pii/S2590005622000911?utm_source=chatgpt.com">ScienceDirect</a>)</p>
<p><strong>（1）图像任务中的经典增广</strong></p>
<p>几乎所有视觉模型都会用到以下几类增广：(<a href="https://foreverhappiness.tistory.com/112?utm_source=chatgpt.com">forever_happiness</a>)</p>
<ul>
<li>几何变换：随机水平翻转、旋转、平移、缩放、裁剪；</li>
<li>光照 / 颜色变换：亮度、对比度、饱和度、色相扰动，加入高斯噪声、模糊等；</li>
<li>遮挡 / 混合类增广：
<ul>
<li>Cutout：随机挖掉图像中的方块区域；</li>
<li>Mixup：将两张图像按比例线性混合、标签也加权混合；</li>
<li>CutMix：剪切一块图像贴到另一张上，同时按面积混合标签。(<a href="https://medium.com/data-science/cutout-mixup-and-cutmix-implementing-modern-image-augmentations-in-pytorch-a9d7db3074ad?utm_source=chatgpt.com">Medium</a>)</li>
</ul>
</li>
</ul>
<p>这些方法可以显著提升模型在噪声、遮挡和标签噪声条件下的鲁棒性。</p>
<hr>
<p><strong>（2）具身智能场景下的数据增广</strong></p>
<p>对于机器人场景，我们可以在更多模态上做增广和“域随机化”（Domain Randomization）：</p>
<ul>
<li>视觉增广：改变背景纹理、光照条件、物体颜色、摄像机视角等，使模型不过度依赖特定桌面材质或灯光；</li>
<li>状态 / 轨迹增广：对关节角、末端位姿、动作加入小扰动，保证物理可行的前提下丰富轨迹分布；</li>
<li>语言增广：对指令做同义改写、改变语序而不改变语义；</li>
<li>在仿真中更激进地随机环境参数（摩擦系数、物体质量），为后续的 Sim2Real 做铺垫。</li>
</ul>
<blockquote>
<p>【图 2-2-5 占位】
示意图：展示同一个机器人抓取场景的原图与若干增广结果（光照改变、背景纹理随机、遮挡、颜色扰动等）。</p>
</blockquote>
<hr>
<h4 id="2233-其他正则化l1l2batchnorm-的正则作用模型集成"><a class="header" href="#2233-其他正则化l1l2batchnorm-的正则作用模型集成">2.2.3.3 其他正则化：L1/L2、BatchNorm 的正则作用、模型集成</a></h4>
<p><strong>（1）L2 正则化 / 权重衰减（Weight Decay）</strong></p>
<p>在损失函数中附加惩罚项：
$$
\mathcal{L}<em>{\text{total}} = \mathcal{L}</em>{\text{task}} + \lambda |W|_2^2
$$</p>
<p>对梯度下降而言，等价于在每轮更新中给权重乘上一个略小于 1 的系数（向 0 收缩），抑制权重无限变大，有助于提高泛化能力。(<a href="https://d2l.ai/chapter_linear-regression/weight-decay.html?utm_source=chatgpt.com">d2l.ai</a>)</p>
<ul>
<li>在纯 SGD 下，L2 正则与显式的 weight decay 本质等价；</li>
<li>在 Adam / AdamW 等自适应优化中，两者存在差别，实践中更推荐使用“解耦的权重衰减”（AdamW）。</li>
</ul>
<p><strong>（2）L1 正则化</strong></p>
<ul>
<li>惩罚项为 (\lambda |W|_1)，鼓励参数稀疏；</li>
<li>用于特征选择或模型压缩时常见，在大规模深网中使用频率相对较低。</li>
</ul>
<p><strong>（3）BatchNorm 的正则化效果</strong></p>
<ul>
<li>前面的 2.2.2 已经提到，BN 利用 batch 统计带来的噪声，实际上起到了一定“模型集成”的作用；</li>
<li>有研究指出，在存在 BN 等归一化层时，L2 正则的“真正作用”更多是调整有效学习率，而不是传统意义上控制模型容量。(<a href="https://arxiv.org/abs/1706.05350?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p><strong>（4）模型集成（Ensemble）</strong></p>
<ul>
<li>训练多个结构相同但初始化不同的模型，对其输出取平均，可以显著提高泛化性能；</li>
<li>在机器人场景中，完整 ensemble 会带来较大计算成本，但可以在离线阶段或关键任务上使用；</li>
<li>Dropout、BN 等都可以视为隐式 ensemble 的一种。</li>
</ul>
<p>总体来说，在真实机器人数据昂贵、样本有限的条件下，<strong>数据增广 + 适度的权重衰减 + 归一化</strong>，往往比单纯加大 Dropout 更有效、更稳定。</p>
<hr>
<h3 id="224-训练监控损失曲线学习率调度早停策略"><a class="header" href="#224-训练监控损失曲线学习率调度早停策略">2.2.4 训练监控：损失曲线、学习率调度、早停策略</a></h3>
<p>深度网络训练是一个<strong>动态过程</strong>，不是“一键跑完看结果”。对损失与指标的持续监控、适当调整学习率以及使用早停策略，是保证训练效率和避免过拟合的关键。</p>
<hr>
<h4 id="2241-监控损失曲线与训练状态"><a class="header" href="#2241-监控损失曲线与训练状态">2.2.4.1 监控损失曲线与训练状态</a></h4>
<p><strong>（1）训练集 vs 验证集</strong></p>
<ul>
<li>训练集损失：反映模型对<strong>已见数据</strong>的拟合程度；</li>
<li>验证集损失 / 指标：反映模型对<strong>未见数据</strong>的泛化性能；</li>
<li>通常每若干 step 或每个 epoch 记录一次两者的曲线，并可视化（如 TensorBoard、Weights &amp; Biases 等）。</li>
</ul>
<p>在机器人 / RL 场景中，验证指标可以是：</p>
<ul>
<li>平均回报（average return）；</li>
<li>任务成功率（success rate）；</li>
<li>任务完成时间、路径长度等。</li>
</ul>
<hr>
<p><strong>（2）典型曲线形态与诊断</strong></p>
<ol>
<li><strong>正常收敛</strong>：
<ul>
<li>训练损失稳步下降；</li>
<li>验证损失也下降并最终趋于平稳；</li>
<li>说明模型容量和正则化基本合适。</li>
</ul>
</li>
<li><strong>欠拟合</strong>：
<ul>
<li>训练和验证损失都高，且都不再明显下降；</li>
<li>可能的原因：模型太小、训练轮数不够、学习率过低或特征表达不足。</li>
</ul>
</li>
<li><strong>过拟合</strong>：
<ul>
<li>训练损失持续下降；</li>
<li>验证损失先降后升，出现“U 型”或“碗型”曲线；</li>
<li>表明模型已经开始记忆训练噪声，这时应增加正则化或使用早停。(<a href="https://medium.com/%40piyushkashyap045/early-stopping-in-deep-learning-a-simple-guide-to-prevent-overfitting-1073f56b493e?utm_source=chatgpt.com">Medium</a>)</li>
</ul>
</li>
<li><strong>训练不稳定 / 发散</strong>：
<ul>
<li>损失忽然剧烈抖动或直冲无穷大，甚至 NaN；</li>
<li>常见原因：学习率过大、梯度爆炸、数值不稳定（如 log(0)）。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 2-2-6 占位】
示意图：画出“正常收敛”“欠拟合”“过拟合”三种场景下的训练/验证损失曲线，并用标注指出过拟合开始点。</p>
</blockquote>
<hr>
<h4 id="2242-学习率调度从粗调到精调"><a class="header" href="#2242-学习率调度从粗调到精调">2.2.4.2 学习率调度：从“粗调”到“精调”</a></h4>
<p>学习率（learning rate）是影响训练速度和稳定性最敏感的超参数之一。很多现代训练策略都会对学习率做<strong>随时间变化的调度（schedule）</strong>。(<a href="https://arxiv.org/pdf/1608.03983?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>（1）为什么需要学习率调度？</strong></p>
<ul>
<li>初期希望快速探索、跳出不良局部极小和鞍点——需要较大的学习率；</li>
<li>后期希望细致“打磨”参数——需要较小的学习率以免在最优点附近抖动；</li>
<li>固定学习率往往很难兼顾这两种需求。</li>
</ul>
<hr>
<p><strong>（2）常见学习率调度策略</strong></p>
<ol>
<li><strong>阶梯衰减（Step Decay）</strong>
<ul>
<li>每过若干 epoch（如 30、60、90）就将学习率乘以一个固定因子（如 0.1）；</li>
<li>经典 CNN 训练（如 ResNet）中很常见。</li>
</ul>
</li>
<li><strong>指数 / 多项式衰减</strong>
<ul>
<li>按 epoch 或 step 指数级减小学习率，平滑一些，但超参数较多。</li>
</ul>
</li>
<li><strong>余弦退火（Cosine Annealing）</strong>
<ul>
<li>Loshchilov &amp; Hutter 在 SGDR 中提出的一类调度：(<a href="https://arxiv.org/pdf/1608.03983?utm_source=chatgpt.com">arXiv</a>)
$$
\eta_t = \eta_{\min} + \frac{1}{2}(\eta_{\max} - \eta_{\min}) \left(1 + \cos\frac{T_{\text{cur}}}{T_{\max}}\pi\right),
$$
其中 (T_{\text{cur}}) 是当前 step，(T_{\max}) 是一个周期长度。</li>
<li>学习率随训练呈“半个余弦”缓慢减小，比阶梯衰减平滑；</li>
<li>在很多视觉与 Transformer 训练中表现良好。</li>
</ul>
</li>
<li><strong>余弦退火 + 重启（Cosine Annealing with Warm Restarts, SGDR）</strong>
<ul>
<li>当学习率降低到很小值后，<strong>突然“重启”回大值</strong>，再一次余弦衰减，如此周期往复；</li>
<li>可以帮助模型反复跳出局部极小，获得更好的最终结果。</li>
</ul>
</li>
<li><strong>循环学习率（Cyclical LR）与 One-cycle Policy</strong>
<ul>
<li>学习率在一个区间内来回震荡（上升再下降），有助于快速找到合适区域；</li>
<li>One-cycle 策略常用于大批量、短训练任务。</li>
</ul>
</li>
</ol>
<hr>
<p><strong>（3）Warmup（预热）</strong></p>
<p>大模型、尤其是 Transformer，在训练开始时对大学习率非常敏感，容易发散。常用的技巧是在前若干 step/epoch 使用“学习率线性增加”的 warmup：</p>
<ul>
<li>从非常小的值开始，逐步线性增至目标学习率；</li>
<li>Warmup 结束后再接上余弦退火或其他调度。(<a href="https://www.researchgate.net/publication/319770226_SGDR_Stochastic_Gradient_Descent_with_Restarts?utm_source=chatgpt.com">ResearchGate</a>)</li>
</ul>
<blockquote>
<p>【图 2-2-7 占位】
示意图：绘制常数学习率、阶梯衰减、余弦退火和带 warmup 的余弦退火曲线，直观比较不同策略随时间的变化。</p>
</blockquote>
<p>在后续训练 VLA 大模型（第 9 章）时，<strong>Warmup + 余弦退火</strong>会是一个非常常见的默认配置。</p>
<hr>
<h4 id="2243-早停early-stopping在最合适的时候踩刹车"><a class="header" href="#2243-早停early-stopping在最合适的时候踩刹车">2.2.4.3 早停（Early Stopping）：在最合适的时候“踩刹车”</a></h4>
<p>早停是一种非常实用、实现简单的正则化技巧：<strong>当模型在验证集上的性能不再提升甚至开始下降时，提前停止训练，并回滚到效果最好的那一轮。</strong>(<a href="https://medium.com/%40piyushkashyap045/early-stopping-in-deep-learning-a-simple-guide-to-prevent-overfitting-1073f56b493e?utm_source=chatgpt.com">Medium</a>)</p>
<p><strong>（1）基本流程</strong></p>
<ol>
<li>划分出验证集或验证任务集；</li>
<li>在训练过程中定期评估验证指标（如验证损失、准确率、成功率等）；</li>
<li>维护一个“最佳验证指标”和对应模型参数的缓存；</li>
<li>当连续若干次评估（patience）都没有改善时，停止训练，将模型恢复到最佳状态。</li>
</ol>
<hr>
<p><strong>（2）超参数与实现细节</strong></p>
<ul>
<li><strong>监控指标</strong>：
<ul>
<li>通常选择验证损失 / 准确率；</li>
<li>在机器人任务中可以选择任务成功率、平均回报等。</li>
</ul>
</li>
<li><strong>patience（耐心）</strong>：
<ul>
<li>过小：可能在指标随机波动时误判“变差”；</li>
<li>过大：早停效果变弱；</li>
<li>实践中可以从 5～10 个评估周期起步，根据任务调整。(<a href="https://www.geeksforgeeks.org/deep-learning/using-early-stopping-to-reduce-overfitting-in-neural-networks/?utm_source=chatgpt.com">GeeksforGeeks</a>)</li>
</ul>
</li>
<li><strong>最小训练轮数</strong>：
<ul>
<li>避免一开始就触发早停，一般设置一个最小 epoch 数，如至少训练 20～30 个 epoch 后才考虑早停。</li>
</ul>
</li>
</ul>
<hr>
<p><strong>（3）在 RL / 机器人任务中的注意点</strong></p>
<ul>
<li>RL 中性能波动较大，单次评估的噪声很高；</li>
<li>可以采用：
<ul>
<li>在多个随机种子、多个环境实例上取平均；</li>
<li>使用滑动平均平滑验证曲线；</li>
<li>提高 patience，以免过早停止。</li>
</ul>
</li>
</ul>
<blockquote>
<p>【图 2-2-8 占位】
示意图：显示验证集指标随 epoch 变化，在某一点达到峰值后出现下降，并标出早停触发的位置。</p>
</blockquote>
<hr>
<h3 id="小结从这一节过渡到更大规模模型训练"><a class="header" href="#小结从这一节过渡到更大规模模型训练">小结：从这一节过渡到更大规模模型训练</a></h3>
<p>2.2 小节从<strong>权重初始化 → 归一化 → 正则化 → 训练监控与调度</strong>，搭起了“如何把一个深度网络训稳、训好”的基本框架。这些技巧在后续章节会不断复用：</p>
<ul>
<li>在第 2.4 节 Transformer 结构中，你会看到 LayerNorm + 残差连接如何让数十层网络可训练；</li>
<li>在第 9 章 VLA 预训练与模仿学习中，我们会具体讨论如何结合数据增广、学习率调度和早停，稳健地训练大规模视觉–语言–动作模型；</li>
<li>在第 5、7 章强化学习和仿真环境中，梯度稳定性与正则化会直接决定机器人策略能否安全收敛。</li>
</ul>
<p>掌握了这一节的内容，就相当于为后面所有“大模型 + 机器人”的实验打好了一个坚实的“工程地基”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="卷积与序列建模"><a href="#卷积与序列建模" class="header">卷积与序列建模</a></h1>
<h3 id="231-卷积神经网络cnn基本结构与感受野"><a class="header" href="#231-卷积神经网络cnn基本结构与感受野">2.3.1 卷积神经网络（CNN）基本结构与感受野</a></h3>
<p>卷积神经网络是现代视觉感知的“工作马”，几乎所有机器人视觉系统——从桌面机械臂抓取、移动机器人导航，到自动驾驶感知——都在某种形式上依赖 CNN。与前面介绍的全连接网络相比，CNN 利用了图像的“局部性”和“平移不变性”，大幅减少参数并提升泛化能力。</p>
<h4 id="2311-卷积运算"><a class="header" href="#2311-卷积运算">2.3.1.1 卷积运算</a></h4>
<p>从直觉上看，卷积就是拿一个小窗口（卷积核，kernel），在图像上滑动，在每个位置做“加权求和”，得到该位置的特征响应。每种卷积核都在寻找一种特定的局部模式：水平边缘、垂直边缘、角点、某种纹理等。</p>
<p>设输入为三通道图像 (x \in \mathbb{R}^{H \times W \times C})，卷积核大小为 (K_h \times K_w)，通道数与输入相同，为 (C)，则输出特征图某个通道在位置 ((i,j)) 的值可写成：</p>
<p>$$
y_{i,j} = \sum_{c=1}^{C} \sum_{m=0}^{K_h-1} \sum_{n=0}^{K_w-1} w_{c,m,n} , x_{c,i+m,j+n} + b,
$$</p>
<p>其中 (w) 是卷积核参数，(b) 是偏置。通过在空间上滑动卷积核，可以得到一整张输出特征图。步幅（stride）控制滑动步长，填充（padding）决定是否在边界补零以控制输出大小。(<a href="https://cs231n.github.io/convolutional-networks/?utm_source=chatgpt.com">cs231n.github.io</a>)</p>
<p>与全连接层相比，卷积有两个核心特点：</p>
<ul>
<li><strong>局部连接</strong>：每个输出神经元只与输入的一个局部区域相连，而不是与整张图像相连。</li>
<li><strong>参数共享</strong>：同一个卷积核在不同位置复用，检测“同一种模式在不同位置是否存在”。</li>
</ul>
<p>这样的设计使 CNN 特别适合图像和深度图等“具有空间结构”的输入：对于机器人而言，无论物体出现在图像左上角还是右下角，只要模式相同，卷积核都能给出相似的响应。</p>
<blockquote>
<p>【图 2-XX：2D 卷积运算示意图——3×3 卷积核在灰度图像上滑动，标出一个位置处的卷积计算过程（图片占位）】</p>
</blockquote>
<h4 id="2312-cnn-层级结构"><a class="header" href="#2312-cnn-层级结构">2.3.1.2 CNN 层级结构</a></h4>
<p>单层卷积只能看到很局部的模式；而深度 CNN 通过多层堆叠，逐步从“像素”上升到“语义”。</p>
<p>典型 CNN 的主干结构可以抽象为反复堆叠的模块：</p>
<blockquote>
<p>卷积层（Conv） → 非线性激活（如 ReLU）→（可选）池化或下采样</p>
</blockquote>
<p>底层卷积核通常会学到非常简单的局部特征，例如水平或垂直边缘、角点等；中层逐渐聚合这些低级特征，形成纹理、局部形状（如圆弧、孔洞）；高层则组合出更抽象的概念，如物体部件（车轮、桌面边缘）乃至整个物体类别的典型轮廓。(<a href="https://cs231n.github.io/convolutional-networks/?utm_source=chatgpt.com">cs231n.github.io</a>)</p>
<p>对于具身智能中的机器人，这种层级表示非常关键：</p>
<ul>
<li>底层特征帮忙分辨边缘、空隙等几何信息，有利于抓取点或障碍物边界的估计；</li>
<li>高层特征则更多编码“这是杯子”“这是抽屉把手”这样的语义信息，方便上层决策模块根据人类指令（如“拿起杯子”）去关联对应视觉区域。</li>
</ul>
<blockquote>
<p>【图 2-XX：CNN 层级特征示意图——从输入图像开始，展示浅层特征图（突出边缘）、中层特征图（纹理/轮廓）、深层特征图（物体部件）（图片占位）】</p>
</blockquote>
<h4 id="2313-感受野"><a class="header" href="#2313-感受野">2.3.1.3 感受野</a></h4>
<p><strong>感受野（receptive field）</strong> 指的是，网络中某一层的一个神经元在原始输入上“能看到”的区域大小——即输入图像中有哪一块区域会影响到这个神经元的输出。(<a href="https://theaisummer.com/receptive-field/?utm_source=chatgpt.com">AI Summer</a>)</p>
<p>需要特别区分：</p>
<ul>
<li><strong>卷积核大小</strong>：某一层卷积操作本身的窗口大小，例如 3×3、5×5。</li>
<li><strong>感受野大小</strong>：考虑到前面所有层（卷积、池化、下采样）的组合效果后，高层单元在原始输入上的覆盖范围。</li>
</ul>
<p>一个简单例子：连续堆叠两层 3×3、stride=1 的卷积（假设无池化），看起来每层都只看 3×3 的局部，但第二层的每个神经元实际上已经“间接看到了”输入的 5×5 区域——第一层每个单元看 3×3，第二层再在这些单元上卷积 3×3，两者叠加扩张了实际感受野。随着层数增加，感受野会越来越大。(<a href="https://www.ultralytics.com/glossary/receptive-field?utm_source=chatgpt.com">ultralytics.com</a>)</p>
<p>更严格地，若第 (l) 层卷积核大小为 (k_l)，步幅为 (s_l)，则可以递推该层感受野大小 (r_l) 和“步距” (j_l)：</p>
<p>$$
\begin{aligned}
r_l &amp;= r_{l-1} + (k_l - 1), j_{l-1},
j_l &amp;= j_{l-1} \cdot s_l,
\end{aligned}
$$</p>
<p>其中第 0 层（输入）有 (r_0 = 1, j_0 = 1)。我们不必在实践中手算所有层的感受野，但要形成直觉：</p>
<ul>
<li>堆叠小卷积核（例如多层 3×3）可以渐进扩大感受野；</li>
<li>下采样（stride 或池化）会让每个高层单元对应更大的输入区域。</li>
</ul>
<p>更进一步的研究指出，<strong>有效感受野（effective receptive field）</strong> 往往比理论计算的小——中心区域对输出影响最大，边缘区域的权重逐渐减弱，大致近似高斯分布。(<a href="https://proceedings.neurips.cc/paper_files/paper/2016/file/c8067ad1937f728f51288b3eb986afaa-Paper.pdf?utm_source=chatgpt.com">NeurIPS Proceedings</a>)</p>
<p>对机器人来说，感受野大小直接影响行为安全性与全局规划能力：</p>
<ul>
<li>如果用于抓取的视觉特征感受野太小，模型可能只看到目标物体的一角，而忽略桌边、障碍物等关键信息；</li>
<li>在导航任务中，如果高层特征感受野不足，机器人难以从单帧图像中理解整个通道或房间布局，会造成局部最优、反复“来回试探”。</li>
</ul>
<p>后续 2.3.2 中的池化与特征金字塔，以及 3 章中的视觉主干选择，本质上都在围绕“如何在不同尺度与足够大的感受野之间做平衡”。</p>
<blockquote>
<p>【图 2-XX：感受野随网络深度扩大的示意图——三层 3×3 卷积叠加后，高层单元对应输入上较大的方块区域（图片占位）】</p>
</blockquote>
<hr>
<h3 id="232-池化下采样与特征金字塔"><a class="header" href="#232-池化下采样与特征金字塔">2.3.2 池化、下采样与特征金字塔</a></h3>
<p>卷积层负责发现局部模式，而<strong>池化和下采样</strong>则在空间尺度上“压缩信息”，构建多尺度表示。对于机器人来说，这关系到：</p>
<ul>
<li>模型是否能在有限算力下实时运行；</li>
<li>是否能同时识别远处的大物体和近处的小物体；</li>
<li>是否对相机轻微抖动、物体位置的小变化保持鲁棒。</li>
</ul>
<h4 id="2321-池化层"><a class="header" href="#2321-池化层">2.3.2.1 池化层</a></h4>
<p><strong>池化（Pooling）</strong> 是在局部窗口内对特征进行聚合的操作，其输入是一张特征图，输出为尺寸更小的特征图。常见形式包括最大池化（Max Pooling）和平均池化（Average Pooling）。(<a href="https://www.geeksforgeeks.org/deep-learning/cnn-introduction-to-pooling-layer/?utm_source=chatgpt.com">geeksforgeeks.org</a>)</p>
<p>设输入特征图为 (x \in \mathbb{R}^{H \times W \times C})，池化窗口大小为 (f \times f)，步幅为 (s)，则最大池化可写成：</p>
<p>$$
y_{i,j,c} = \max_{0 \le m, n &lt; f} x_{is+m,, js+n,, c},
$$</p>
<p>平均池化则是取窗口内所有值的平均。</p>
<p>从效果上看：</p>
<ul>
<li><strong>最大池化</strong>：保留局部区域内最强的激活，适合回答“这里是否存在某种特征”；</li>
<li><strong>平均池化</strong>：平均化局部响应，更关注整体强度，起到一定平滑和去噪作用；</li>
<li><strong>全局平均池化（Global Average Pooling）</strong>：对整张特征图在空间维度上取平均，将每个通道压缩为一个数，常用来替代最后的全连接层。(<a href="https://towardsai.net/p/l/introduction-to-pooling-layers-in-cnn?utm_source=chatgpt.com">Towards AI</a>)</li>
</ul>
<p>池化的主要作用包括：(<a href="https://milvus.io/ai-quick-reference/what-is-the-role-of-pooling-layers-in-cnns?utm_source=chatgpt.com">Milvus</a>)</p>
<ul>
<li><strong>降低空间维度</strong>：缩小特征图尺寸，减少后续层的参数和计算量；</li>
<li><strong>抑制过拟合</strong>：通过聚合邻域信息，减少模型对单个像素噪声的敏感度；</li>
<li><strong>提升平移不变性</strong>：微小位置偏移在池化后往往不会改变聚合结果，使模型对物体位置变化更鲁棒。</li>
</ul>
<p>在机器人视觉中，池化有助于应对：相机轻微抖动、机器人自身微小位姿变化导致的图像差异，使感知对高层任务而言更加“稳定”。</p>
<blockquote>
<p>【图 2-XX：池化层示意图——左侧为输入特征图，局部 2×2 区域通过最大池化或平均池化被压缩成单个值，右侧为下采样后的特征图（图片占位）】</p>
</blockquote>
<h4 id="2322-下采样的作用"><a class="header" href="#2322-下采样的作用">2.3.2.2 下采样的作用</a></h4>
<p><strong>下采样（Downsampling）</strong> 并不局限于显式的池化层，使用卷积层时将步幅设为大于 1（如 stride=2）同样可以实现下采样效果。(<a href="https://cs231n.github.io/convolutional-networks/?utm_source=chatgpt.com">cs231n.github.io</a>)</p>
<p>从信号处理的视角看，下采样会丢失部分高频细节，但带来几个重要好处：</p>
<ol>
<li><strong>扩大有效感受野</strong>
每向下采样一次，后续卷积层的每一个单元对应的输入区域就成倍扩大。几层卷积 + 下采样之后，高层特征能“看到”更大的场景，用较小的特征图表达更大范围的信息，这对理解全局布局至关重要。</li>
<li><strong>降低计算成本</strong>
特征图尺寸每缩小一半，后续卷积的计算量大致缩小为原来的四分之一。对于需要高帧率感知的机器人系统，下采样是控制推理时间的关键手段。</li>
<li><strong>提高尺度与平移鲁棒性</strong>
多次下采样后的特征更关注粗尺度的语义结构，对物体位置、大小的小幅变化不敏感。这使机器人在不同距离观察同一物体时仍能做出相似判断。(<a href="https://milvus.io/ai-quick-reference/what-is-the-role-of-pooling-layers-in-cnns?utm_source=chatgpt.com">Milvus</a>)</li>
</ol>
<p>当然，下采样也带来一个明显问题：<strong>小物体信息容易在多次压缩后消失</strong>。例如桌面上的螺丝、插头，或者远处的路标、行人，如果在感知链路中过早、过多地下采样，最终用于决策的高层特征中可能再也看不到这些小目标。这正是后面特征金字塔与 FPN 要解决的问题。</p>
<blockquote>
<p>【图 2-XX：下采样级联示意——一张输入图像经过若干层卷积+下采样，特征图从 256×256 逐步缩小到 128×128、64×64、32×32 等（图片占位）】</p>
</blockquote>
<h4 id="2323-特征金字塔应用"><a class="header" href="#2323-特征金字塔应用">2.3.2.3 特征金字塔应用</a></h4>
<p><strong>特征金字塔（Feature Pyramid）</strong> 的思想源自传统计算机视觉中的图像金字塔：通过对输入图像做多次下采样，在不同尺度上进行处理，从而同时兼顾大物体和小物体。深度学习时代的特征金字塔进一步利用了 CNN 各层天然具有不同分辨率的特征图。(<a href="https://openaccess.thecvf.com/content_cvpr_2017/papers/Lin_Feature_Pyramid_Networks_CVPR_2017_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</p>
<p><strong>Feature Pyramid Network（FPN）</strong> 是这一思想的代表性结构，其核心设计包括：(<a href="https://openaccess.thecvf.com/content_cvpr_2017/papers/Lin_Feature_Pyramid_Networks_CVPR_2017_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</p>
<ol>
<li><strong>自下而上的路径（Bottom-up）</strong>
主干 CNN（如 ResNet）逐层下采样，得到一系列从高分辨率到低分辨率的特征图。浅层特征分辨率高但语义弱，深层特征分辨率低但语义强。</li>
<li><strong>自上而下的路径（Top-down）</strong>
将最深层、语义最强的特征图通过上采样（如最近邻或双线性插值）逐层放大，再与对应的浅层特征通过横向连接（lateral connections）相加或拼接，让每一层既保留高分辨率，又拥有足够的语义信息。</li>
<li><strong>多尺度检测头</strong>
在构成的金字塔每一层上分别布置检测头：高分辨率层负责小物体，中等分辨率层负责中等物体，低分辨率层负责大物体。实践表明，FPN 极大提升了小物体检测性能，已成为现代目标检测框架（如 Faster R-CNN、RetinaNet）的标准组件。(<a href="https://arxiv.org/abs/1612.03144?utm_source=chatgpt.com">arXiv</a>)</li>
</ol>
<p>在机器人具身智能领域，多尺度特征的价值同样显著：</p>
<ul>
<li>桌面操作中，机器人既要看清“桌子整体布局”（大尺度），又要准确识别“插头孔位、螺丝孔、瓶盖刻度”（小尺度）；</li>
<li>移动机器人或自动驾驶，需要同时感知远处道路结构和近处行人脚步、小物体障碍物；</li>
<li>在复杂场景中，小目标（开关、按钮）往往决定任务是否成功，FPN 等结构因此常被用于机器人视觉感知前端。</li>
</ul>
<blockquote>
<p>【图 2-XX：FPN 结构示意图——底部为 CNN backbone 的多层特征图，自上而下路径通过上采样和横向连接构成多尺度特征金字塔，每一层连接到相应检测头（图片占位）】</p>
</blockquote>
<p>CNN、池化、下采样和特征金字塔共同构成了现代机器人视觉中的“基础设施”。在此基础上，我们还需要处理另一类核心数据：<strong>时间序列</strong>，这正是下一小节 RNN/LSTM/GRU 所要解决的问题。</p>
<hr>
<h3 id="233-rnn--lstm--gru-的基本结构与局限性"><a class="header" href="#233-rnn--lstm--gru-的基本结构与局限性">2.3.3 RNN / LSTM / GRU 的基本结构与局限性</a></h3>
<p>具身智能不仅要看“这一帧是什么样子”，还要理解“之前发生了什么”、“接下来会发生什么”。机器人每一步的决策都依赖历史观测、动作和隐含的环境状态，这天然是一个时间序列问题。循环神经网络（Recurrent Neural Networks, RNN）及其门控变体 LSTM、GRU 是在 Transformer 出现之前，处理序列数据的主力模型。</p>
<h4 id="2331-rnn"><a class="header" href="#2331-rnn">2.3.3.1 RNN</a></h4>
<p><strong>循环神经网络（RNN）</strong> 的核心思想是：在每个时间步 (t)，不仅处理当前输入 (x_t)，还维护一个隐藏状态 (h_t)，用于“记住”此前的信息。更新可以写成：(<a href="https://aws.amazon.com/what-is/recurrent-neural-network/?utm_source=chatgpt.com">Amazon Web Services, Inc.</a>)</p>
<p>$$
\begin{aligned}
h_t &amp;= \phi(W_x x_t + W_h h_{t-1} + b),
y_t &amp;= W_y h_t + c,
\end{aligned}
$$</p>
<p>其中 (\phi) 通常是非线性函数（如 (\tanh)）。如果把 RNN 沿时间轴展开，可以看到它是一条链式结构：同一个单元在每个时间步重复使用，参数在时间维度共享。</p>
<p>直观理解：</p>
<ul>
<li>(h_t) 相当于到目前为止序列的“压缩记忆”；</li>
<li>给定整个输入序列 ((x_1, x_2, \dots, x_T))，RNN 依次递推，得到隐藏状态序列 ((h_1, \dots, h_T)) 和输出序列 ((y_1, \dots, y_T))。</li>
</ul>
<p>在机器人场景中，RNN 可以用来：</p>
<ul>
<li>处理关节角度、速度、力矩等时间序列，预测未来状态或控制信号；</li>
<li>对连续的视觉特征序列进行建模，例如从视频序列中推断物体动态；</li>
<li>建模传感器序列（IMU、力传感器）以检测异常模式。</li>
</ul>
<p>然而，<strong>基础 RNN 存在明显缺陷</strong>：反向传播过程中的梯度在时间维很容易出现 <strong>消失或爆炸</strong>，使得网络难以学习长时间跨度的依赖关系。这正是 LSTM 和 GRU 被提出的背景。(<a href="https://www.researchgate.net/publication/350950396_Introduction_to_Sequence_Learning_Models_RNN_LSTM_GRU?utm_source=chatgpt.com">ResearchGate</a>)</p>
<blockquote>
<p>【图 2-XX：RNN 展开结构示意——单个 RNN 单元在多个时间步重复，显示输入 x_t、隐藏状态 h_t 的递推关系（图片占位）】</p>
</blockquote>
<h4 id="2332-lstm"><a class="header" href="#2332-lstm">2.3.3.2 LSTM</a></h4>
<p><strong>长短期记忆网络（Long Short-Term Memory, LSTM）</strong> 通过引入显式的“记忆单元”和门控机制，缓解了普通 RNN 的长期依赖问题。(<a href="https://arxiv.org/pdf/1909.09586?utm_source=chatgpt.com">arXiv</a>)</p>
<p>LSTM 的核心是两条状态：</p>
<ul>
<li><strong>单元状态 (c_t)</strong>：用于长期存储信息，相对“直通”，可跨越多个时间步几乎不变；</li>
<li><strong>隐藏状态 (h_t)</strong>：对外暴露的状态，用于当前预测。</li>
</ul>
<p>以及三个门：</p>
<ul>
<li><strong>遗忘门 (f_t)</strong>：决定保留多少旧记忆；</li>
<li><strong>输入门 (i_t)</strong>：决定写入多少新信息；</li>
<li><strong>输出门 (o_t)</strong>：决定暴露多少记忆给当前输出。</li>
</ul>
<p>一组典型的更新公式是：</p>
<p>$$
\begin{aligned}
f_t &amp;= \sigma(W_f [x_t, h_{t-1}] + b_f),
i_t &amp;= \sigma(W_i [x_t, h_{t-1}] + b_i),
g_t &amp;= \tanh(W_g [x_t, h_{t-1}] + b_g),
c_t &amp;= f_t \odot c_{t-1} + i_t \odot g_t,
o_t &amp;= \sigma(W_o [x_t, h_{t-1}] + b_o),
h_t &amp;= o_t \odot \tanh(c_t),
\end{aligned}
$$</p>
<p>其中 (\sigma) 是 sigmoid，(\odot) 为逐元素乘。</p>
<p>直觉上：</p>
<ul>
<li>如果遗忘门 (f_t) 接近 1，输入门 (i_t) 接近 0，则 (c_t \approx c_{t-1})，网络就会“几乎原样地”把记忆传下去；</li>
<li>如果遗忘门接近 0，输入门接近 1，则 LSTM 会丢弃旧记忆并写入新内容。</li>
</ul>
<p>这一机制使得 LSTM 在许多序列任务（语言建模、语音识别、时间序列预测等）上远优于普通 RNN，也更擅长处理长距离依赖。(<a href="https://arxiv.org/pdf/1909.09586?utm_source=chatgpt.com">arXiv</a>)</p>
<p>在机器人具身智能中，可以用 LSTM 来建模：</p>
<ul>
<li>长时间的操作序列，例如“开门→进入→关门→走向桌子→抓取杯子→放进柜子”，帮助机器人记住所处阶段；</li>
<li>复杂环境动态，例如预测移动障碍物的轨迹。</li>
</ul>
<p>但 LSTM 的代价也很明显：结构复杂、参数较多，计算量大，训练时间长。这在算力受限、需要实时响应的机器人平台上，有时会成为瓶颈。(<a href="https://medium.com/%40harshvivek14/rnn-lstm-and-gru-59574189047e?utm_source=chatgpt.com">Medium</a>)</p>
<blockquote>
<p>【图 2-XX：LSTM 单元结构示意——展示 c_t 的水平流动、f/i/o 三个门与候选更新 g_t 的乘加路径（图片占位）】</p>
</blockquote>
<h4 id="2333-gru"><a class="header" href="#2333-gru">2.3.3.3 GRU</a></h4>
<p><strong>门控循环单元（Gated Recurrent Unit, GRU）</strong> 是 LSTM 的一种简化变体，试图在保持长期依赖建模能力的同时减少参数数量与计算复杂度。(<a href="https://www.researchgate.net/publication/350950396_Introduction_to_Sequence_Learning_Models_RNN_LSTM_GRU?utm_source=chatgpt.com">ResearchGate</a>)</p>
<p>GRU 只有一个状态 (h_t)，不再区分 (c_t) 和 (h_t)，并使用两个门：</p>
<ul>
<li><strong>更新门 (z_t)</strong>：在“保留旧记忆”和“写入新记忆”之间做权衡；</li>
<li><strong>重置门 (r_t)</strong>：决定在计算当前候选状态时，参考过去记忆的程度。</li>
</ul>
<p>典型更新公式为：</p>
<p>$$
\begin{aligned}
z_t &amp;= \sigma(W_z [x_t, h_{t-1}] + b_z),
r_t &amp;= \sigma(W_r [x_t, h_{t-1}] + b_r),
\tilde{h}<em>t &amp;= \tanh(W_h [x_t, r_t \odot h</em>{t-1}] + b_h),
h_t &amp;= (1 - z_t) \odot h_{t-1} + z_t \odot \tilde{h}_t.
\end{aligned}
$$</p>
<p>直觉上：</p>
<ul>
<li>若 (z_t) 很小，(h_t) 接近旧状态 (h_{t-1})；</li>
<li>若 (z_t) 很大，则更多采用新候选状态 (\tilde{h}_t)。</li>
</ul>
<p>GRU 相比 LSTM 有更少的门、更少的矩阵乘法，在许多任务上能获得相近甚至更好的性能，同时训练和推理速度更快；这对实时性要求高的机器人场景尤其有吸引力。(<a href="https://medium.com/%40harshvivek14/rnn-lstm-and-gru-59574189047e?utm_source=chatgpt.com">Medium</a>)</p>
<blockquote>
<p>【图 2-XX：GRU 单元结构示意——显示更新门、重置门以及新旧状态的加权合成路径（图片占位）】</p>
</blockquote>
<h4 id="2334-序列建模局限"><a class="header" href="#2334-序列建模局限">2.3.3.4 序列建模局限</a></h4>
<p>尽管 RNN / LSTM / GRU 在一段时间内是序列建模的主角，至今仍在很多工业系统中发挥作用，但在机器人具身智能这一更复杂的场景下，它们也暴露出一些核心局限，为后续 Transformer 类架构的出现埋下伏笔。(<a href="https://arxiv.org/pdf/1909.09586?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>对极长序列依然吃力</strong>
LSTM 和 GRU 相比基本 RNN 大幅改善了梯度消失问题，但在需要建模数百甚至上千步依赖的场景中（例如几十分钟的多阶段任务），训练仍然困难，模型往往倾向于只利用较近的历史。对于希望“记住用户最开头指令细节”的家庭服务机器人，这是明显瓶颈。</li>
<li><strong>时间维度无法并行</strong>
RNN 家族在时间维度上具有天然的顺序依赖：(h_t) 必须先计算 (h_{t-1})。这导致训练和推理都难以在时间轴上做大规模并行。相比之下，卷积和自注意力可以同时处理整个序列，大幅提升训练效率。对于需要处理高帧率传感数据或长时间视频的机器人系统，这种串行计算会严重限制模型规模和性能。(<a href="https://www.geeksforgeeks.org/deep-learning/rnn-vs-lstm-vs-gru-vs-transformers/?utm_source=chatgpt.com">geeksforgeeks.org</a>)</li>
<li><strong>优化敏感、调参成本高</strong>
RNN 的训练对学习率、梯度裁剪阈值、序列截断长度等超参数都较为敏感，很容易出现梯度爆炸（loss 突然变成 NaN）或收敛到次优。对于实际机器人系统，工程团队往往无法像离线 NLP 训练那样反复尝试多套配置，这限制了其大规模应用。(<a href="https://alinlab.kaist.ac.kr/resource/Lec6_RNN_architectures.pdf?utm_source=chatgpt.com">alinlab.kaist.ac.kr</a>)</li>
<li><strong>难以直接建模“任意远”的交互</strong>
在 RNN 框架下，所有历史信息被“压缩”进一个向量序列 ((h_t))，模型难以显式知道“当前决策依赖于哪几个关键时间点”。而基于自注意力的模型可以通过注意力权重直接连接任意两个时间步，更容易表达“当前动作需要参考 20 步之前那次观察”的模式，也更易于可视化和解释。(<a href="https://www.geeksforgeeks.org/deep-learning/rnn-vs-lstm-vs-gru-vs-transformers/?utm_source=chatgpt.com">geeksforgeeks.org</a>)</li>
<li><strong>多模态长序列融合能力有限</strong>
在具身智能任务中，我们常常需要同时处理：视觉特征序列、语言指令 token 序列、机器人状态轨迹等多种模态。如果全部塞进一个 RNN，其隐藏状态必须非常高维才能容纳这些信息，训练难度和参数规模都迅速膨胀；而多头自注意力则更自然地支持在不同模态、不同时间步之间建立稀疏而有结构的相关性。</li>
</ol>
<p>综合来看，RNN / LSTM / GRU 在处理短到中等长度的序列、传统时间序列预测任务时依然有用，也在早期机器人控制与预测中发挥了重要作用。但随着数据规模增大、序列变长、模态变多、并行计算硬件发展，自注意力与 Transformer 架构逐渐成为主流选择。下一节将从自注意力机制切入，系统介绍 Transformer 如何在时间与空间上统一建模，为后文的视觉-语言-动作（VLA）模型打下基础。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="transformer-结构"><a href="#transformer-结构" class="header">Transformer 结构</a></h1>
<p>下面是按你给出的提纲，完整展开后的 <strong>2.4.1–2.4.5</strong> 章节正文草稿（书稿风格）。我会适度承接前文 RNN/CNN 内容，并给后续 VLA 章节留呼应点，图片用占位说明。</p>
<hr>
<h3 id="241-self-attention-机制与-querykeyvalue"><a class="header" href="#241-self-attention-机制与-querykeyvalue">2.4.1 Self-Attention 机制与 Query/Key/Value</a></h3>
<p>在前面的序列建模部分已经看到，RNN/LSTM 通过“递归地”一格一格地处理序列，这使得长距离依赖不易捕获，也难以并行训练。Self-Attention（自注意力）则直接在序列中任意两个位置之间建立可学习的“相似度连接”，从而在一次运算中融合全局信息，是 Transformer 的核心思想之一。(<a href="https://arxiv.org/abs/1706.03762?utm_source=chatgpt.com">arXiv</a>)</p>
<h4 id="2411-自注意力机制在序列内部做加权信息汇总"><a class="header" href="#2411-自注意力机制在序列内部做加权信息汇总">2.4.1.1 自注意力机制：在序列内部做“加权信息汇总”</a></h4>
<p>设输入序列长度为 (n)，每个位置的向量维度为 (d_\text{model})，将整个序列写成矩阵形式：
$$
X \in \mathbb{R}^{n \times d_\text{model}}.
$$</p>
<p>通过三组不同的线性变换，得到 Query（Q）、Key（K）、Value（V）：
$$
Q = X W^Q,\quad K = X W^K,\quad V = X W^V,
$$
其中 (W^Q, W^K, W^V \in \mathbb{R}^{d_\text{model} \times d_k}) 或 (\mathbb{R}^{d_\text{model} \times d_v}) 是可训练的权重矩阵。</p>
<p>标准的 <strong>scaled dot-product attention</strong> 定义为：(<a href="https://en.wikipedia.org/wiki/Attention_%28machine_learning%29?utm_source=chatgpt.com">维基百科</a>)</p>
<p>$$
\text{Attention}(Q, K, V)
= \text{softmax}!\left(\frac{Q K^\top}{\sqrt{d_k}}\right) V.
$$</p>
<p>其中：</p>
<ul>
<li>(QK^\top \in \mathbb{R}^{n\times n}) 给出序列中任意两个位置之间的“相关性分数”（内积越大，越相似）；</li>
<li>除以 (\sqrt{d_k}) 是为了避免维度过大时内积值过大导致 softmax 饱和；</li>
<li>softmax 在每一行上做归一化，将相关性分数转为“注意力权重”（非负且和为 1）；</li>
<li>将这些权重对 (V) 做加权和，得到每个位置融合了整句信息的新表示。</li>
</ul>
<p>直观地看，每个位置 (i) 的输出向量就是“从全序列所有位置的 Value 中，按相关性做加权平均”的结果，自注意力因此可以在单层中捕获任意距离的依赖关系。</p>
<p>【图 2-4-1 占位：自注意力示意图。上方是一行 token（或 patch）向量，中间通过 Q/K/V 线性变换，下面是一个 (n\times n) 注意力矩阵热力图；矩阵第 i 行突出显示该位置对其它位置的关注程度。】</p>
<h4 id="2412-query--key--value-的含义与类比"><a class="header" href="#2412-query--key--value-的含义与类比">2.4.1.2 Query / Key / Value 的含义与类比</a></h4>
<p>Q/K/V 的命名可以类比为“查字典”的过程：(<a href="https://www.billparker.ai/2024/10/transformer-attention-simple-guide-to-q.html?utm_source=chatgpt.com">billparker.ai</a>)</p>
<ul>
<li><strong>Query（Q，查询）</strong>：当前想要“查”的词条，如一个位置上的 token 表示；</li>
<li><strong>Key（K，键）</strong>：所有候选词条的“索引标签”，用于和 Query 做匹配；</li>
<li><strong>Value（V，值）</strong>：与每个 Key 对应的内容，一旦某个 Key 与 Query 匹配度高，就会更多地读取其对应的 Value 信息。</li>
</ul>
<p>注意力分数由 Query 与各个 Key 的相似度决定（通常就是向量内积），再通过 softmax 归一化后，作为对 Value 的加权系数。因此：</p>
<ul>
<li>若 Query 与某个 Key 成“高相似度”，对应 Value 在输出中权重更大；</li>
<li>若 Query 与某些 Key 几乎无关，则它们对应的 Value 在输出中的权重接近 0。</li>
</ul>
<p>在 <strong>编码器自注意力</strong> 中，Q/K/V 都来自同一个输入序列；在 <strong>解码器的交叉注意力（encoder-decoder attention）</strong> 中，Q 来自解码器当前状态，而 K/V 来自编码器输出，这将在 2.4.4 节进一步展开。(<a href="https://en.wikipedia.org/wiki/Attention_%28machine_learning%29?utm_source=chatgpt.com">维基百科</a>)</p>
<p>从具身智能的角度可以这样理解：机器人在某个时间步要做决策时，它把当前状态向量作为 Query，把过去观测或语言指令编码后的向量作为 Key/Value，通过 attention“查”到与当前状况最相关的信息，再基于这些信息输出动作。</p>
<h4 id="2413-注意力矩阵与掩码机制"><a class="header" href="#2413-注意力矩阵与掩码机制">2.4.1.3 注意力矩阵与掩码机制</a></h4>
<p>把自注意力的权重部分单独记为矩阵：
$$
A = \text{softmax}!\left(\frac{QK^\top}{\sqrt{d_k}}\right) \in \mathbb{R}^{n\times n}.
$$</p>
<ul>
<li>(A_{ij}) 表示“序列中位置 (i) 对位置 (j) 的注意力权重”；</li>
<li>每一行都是一个概率分布（和为 1），体现了位置 (i) 对各个位置的关注程度。</li>
</ul>
<p>Encoder 层中常用的 <strong>全连接自注意力</strong>，允许每个位置关注序列中任意位置；而在 Decoder 的自回归生成中，为避免“偷看未来”，会对注意力矩阵进行下三角 <strong>因果掩码（causal mask）</strong> 处理：在 softmax 前将所有“未来位置”的相关性分数置为 (-\infty)，softmax 之后它们的权重就变为 0，仅允许当前位置看到自己与其之前的 token。(<a href="https://en.wikipedia.org/wiki/Attention_%28machine_learning%29?utm_source=chatgpt.com">维基百科</a>)</p>
<p>【图 2-4-2 占位：注意力矩阵与掩码示意图。左图为完整的 (n\times n) 注意力矩阵热力图；右图为 Decoder 中的下三角掩码矩阵，上三角区域被灰色遮挡（权重为 0）。】</p>
<p>在机器人动作序列建模中，自回归 Decoder-only 架构同样使用这种因果掩码，以保证每一步动作仅依赖过去的观测和动作历史，符合物理因果顺序。</p>
<hr>
<h3 id="242-多头注意力multi-head-attention"><a class="header" href="#242-多头注意力multi-head-attention">2.4.2 多头注意力（Multi-Head Attention）</a></h3>
<p>单一的自注意力头相当于从一个“投影子空间”里计算相似度和信息汇总。Transformer 引入 <strong>多头注意力（Multi-Head Attention）</strong>，并行地在多个子空间中计算注意力，从而提高表达能力。(<a href="https://papers.neurips.cc/paper/7181-attention-is-all-you-need.pdf?utm_source=chatgpt.com">NeurIPS论文</a>)</p>
<h4 id="2421-多头机制的形式化定义"><a class="header" href="#2421-多头机制的形式化定义">2.4.2.1 多头机制的形式化定义</a></h4>
<p>在多头注意力中，我们为每个头 (i) 单独学习一组线性变换：
$$
W_i^Q, W_i^K, W_i^V \in \mathbb{R}^{d_\text{model} \times d_k},\quad i = 1,\dots,h,
$$
令
$$
\text{head}_i = \text{Attention}(QW_i^Q,\ KW_i^K,\ VW_i^V).
$$</p>
<p>然后将所有头的输出在特征维上拼接，再通过一个线性层 (W^O) 做整合：
$$
\text{MultiHead}(Q,K,V) = \text{Concat}(\text{head}_1, \dots, \text{head}_h), W^O.
$$
(<a href="https://en.wikipedia.org/wiki/Attention_%28machine_learning%29?utm_source=chatgpt.com">维基百科</a>)</p>
<p>这样，每个头都在各自的投影子空间中学习不同的相似性模式，最终汇聚为一个更丰富的表示。</p>
<p>【图 2-4-3 占位：多头注意力结构图。上方 Q/K/V 通过多组线性变换分别进入多个 attention 单元（Head 1, Head 2, …, Head h），各自输出后在特征维拼接，再经过一个线性层得到最终输出。】</p>
<h4 id="2422-不同注意力头学习不同的关系"><a class="header" href="#2422-不同注意力头学习不同的关系">2.4.2.2 不同注意力头学习不同的关系</a></h4>
<p>大量实证分析表明，不同注意力头往往会“专注”于不同类型的模式：(<a href="https://www.sciencedirect.com/science/article/pii/S2666651022000146?utm_source=chatgpt.com">科学导向</a>)</p>
<ul>
<li>在自然语言任务中，有的头擅长捕获邻近词之间的局部依赖（如短语结构），有的头捕获长距离依赖（如跨句子的共指、主题联系）；</li>
<li>在视觉 Transformer 中，有的头聚焦局部 patch 的几何关系，有的头关注整体场景结构或物体的语义轮廓。</li>
</ul>
<p>对于具身智能任务，可以预期：</p>
<ul>
<li>某些头重点关注与目标物体相关的视觉区域；</li>
<li>某些头偏重障碍物和安全边界；</li>
<li>还有一些头可能更关注时间维度上动作的连续性或物体轨迹。</li>
</ul>
<p>虽然这些“功能分工”不是硬编码的，而是训练过程中自发涌现，但在实践中，可以通过可视化注意力权重来分析模型行为，从而对机器人决策过程获得一定的可解释性（在第 10 章可解释性部分会再回到这一点）。</p>
<p>【图 2-4-4 占位：多头注意力可视化示例。对同一句话（或同一图像 patch 序列），展示多个头的注意力矩阵热力图，每个头关注的模式不同。】</p>
<h4 id="2423-计算开销与并行执行"><a class="header" href="#2423-计算开销与并行执行">2.4.2.3 计算开销与并行执行</a></h4>
<p>从复杂度角度看，多头注意力虽然引入了多个头，但每个头通常使用较小的 (d_k)（例如 (d_k = d_\text{model} / h)），因此总的计算量与单个大头的注意力同阶，只是常数因子有所增加。(<a href="https://papers.neurips.cc/paper/7181-attention-is-all-you-need.pdf?utm_source=chatgpt.com">NeurIPS论文</a>)</p>
<p>更重要的是，各个头之间完全可以在 GPU/TPU 上并行计算，因此在现代硬件上，多头注意力的实际计算效率很高，与标准矩阵乘法的实现高度契合。这也是 Transformer 能够在视觉、语言以及多模态任务上高效扩展到大规模模型的关键工程基础。</p>
<p>在机器人应用中，多头注意力使得单个 VLA 模型可以同时在不同“视角”下理解环境与任务指令，为后续的动作决策提供更丰富的上下文表征。</p>
<hr>
<h3 id="243-位置编码绝对--相对"><a class="header" href="#243-位置编码绝对--相对">2.4.3 位置编码（绝对 / 相对）</a></h3>
<p>自注意力机制本身对输入顺序是“置换不变”的——如果不显式加入位置信息，模型仅将序列视为一个“集合”，无法区分不同排列顺序，从而无法正确建模时间顺序或语序。(<a href="https://aclanthology.org/2021.emnlp-main.828.pdf?utm_source=chatgpt.com">ACL Anthology</a>)</p>
<p>为了解决这一问题，Transformer 在输入层或各层内部引入 <strong>位置编码（Positional Encoding）</strong>，将位置信息注入到每个 token 或 patch 的表示中。</p>
<h4 id="2431-绝对位置编码正弦余弦函数形式"><a class="header" href="#2431-绝对位置编码正弦余弦函数形式">2.4.3.1 绝对位置编码：正弦/余弦函数形式</a></h4>
<p>原始 Transformer 论文提出了一种 <strong>固定的正弦–余弦位置编码</strong>，给每个位置 (pos) 分配一个维度为 (d_\text{model}) 的向量：(<a href="https://arxiv.org/abs/1706.03762?utm_source=chatgpt.com">arXiv</a>)</p>
<p>$$
\begin{aligned}
\text{PE}(pos, 2i)   &amp;= \sin\left(\frac{pos}{10000^{2i/d_\text{model}}}\right),
\text{PE}(pos, 2i+1) &amp;= \cos\left(\frac{pos}{10000^{2i/d_\text{model}}}\right),
\end{aligned}
$$
其中 (i = 0,1,\dots, d_\text{model}/2-1)。</p>
<p>特点与直觉：</p>
<ul>
<li>不同维度对应不同波长的正弦波，低频维度编码粗粒度的位置信息，高频维度编码细粒度的局部差异；</li>
<li>由于是解析函数定义，不需要训练额外参数，并且可以自然地外推到比训练时更长的序列长度；</li>
<li>通过线性组合不同维度，模型可以在一定程度上推断两个位置之间的相对距离。</li>
</ul>
<p>在实现上，常见做法是在输入 embedding 上“相加”位置编码：
$$
X^\text{input}_i = X^\text{embed}_i + \text{PE}(i).
$$</p>
<p>【图 2-4-5 占位：若干维度的正弦/余弦位置编码随位置变化的曲线图，展示不同频率、不同波长的波形。】</p>
<p>除正弦编码之外，很多模型也采用 <strong>可学习的绝对位置 embedding</strong>，即像词向量一样为每个位置建立一个可训练表，将其加到输入上。实现更简单，但在泛化到更长序列时往往需要额外技巧。</p>
<h4 id="2432-相对位置编码对相对距离更敏感"><a class="header" href="#2432-相对位置编码对相对距离更敏感">2.4.3.2 相对位置编码：对相对距离更敏感</a></h4>
<p>绝对位置编码强调的是“某个 token 在整个序列中处于第几位”；然而很多任务更关心的是 <strong>token 之间的相对距离</strong>——例如“当前词前面最近的名词在哪里”，“上一时刻与当前时刻的相对差值”等。(<a href="https://arxiv.org/pdf/2310.04418?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>相对位置编码（Relative Positional Encoding, RPE）</strong> 的基本思想，是让注意力分数不仅依赖于内容相似度 (q_i^\top k_j)，还依赖于位置差值 ((i-j)) 对应的一个向量或偏置，例如：(<a href="https://lilianweng.github.io/posts/2023-01-27-the-transformer-family-v2/?utm_source=chatgpt.com">Lilian Weng</a>)</p>
<p>$$
\text{score}<em>{ij}
= \frac{q_i^\top k_j + q_i^\top r</em>{i-j}}{\sqrt{d_k}},
$$
其中 (r_{i-j}) 是与相对位移 ((i-j)) 相关的参数向量或标量偏置。</p>
<p>代表性工作包括：</p>
<ul>
<li>Shaw 等人在机器翻译中的相对位置编码；</li>
<li>Transformer-XL 使用相对位置编码解决长上下文建模问题；</li>
<li>后续的 T5、RoPE（Rotary Position Embedding）等方法，对相对位置进一步推广，使模型对序列整体平移具有更好的不变性。(<a href="https://lilianweng.github.io/posts/2023-01-27-the-transformer-family-v2/?utm_source=chatgpt.com">Lilian Weng</a>)</li>
</ul>
<p>在机器人与具身智能任务中，时间维度往往很长，而我们关注的是“前后几步”动作与观测之间的因果关系，相对位置编码因此更加契合时序决策的需求。</p>
<p>【图 2-4-6 占位：相对位置编码示意图。以当前时间步为中心，展示不同相对位移（-k…0…+k）的编码向量，或绘制一个相对位置偏置矩阵。】</p>
<h4 id="2433-位置编码的重要性从集合到有序序列"><a class="header" href="#2433-位置编码的重要性从集合到有序序列">2.4.3.3 位置编码的重要性：从“集合”到“有序序列”</a></h4>
<p>如果不给 Transformer 加入任何位置信息，网络对输入的任何排列都将给出相同的输出（只是对应位置发生置换），这会导致：</p>
<ul>
<li>在语言任务中无法区分 “把红色方块放入盒子” 与 “盒子放入红色方块”；</li>
<li>在机器人控制中无法区分“先抓取后放置”与“先放置后抓取”的时序逻辑。</li>
</ul>
<p>位置编码正是将 <strong>“序列顺序”</strong> 显式注入到模型中的关键步骤，使自注意力从“集合运算”转变为真正的“序列建模”。(<a href="https://aclanthology.org/2021.emnlp-main.828.pdf?utm_source=chatgpt.com">ACL Anthology</a>)</p>
<p>在后续构建 VLA 模型时，时间步编号、视频帧序号、甚至任务分段（如“示教阶段/执行阶段”）都会通过某种形式的“位置或阶段编码”进入模型，使机器人能够理解“何时发生了什么”。</p>
<hr>
<h3 id="244-encoderdecoder-架构与纯-decoder-架构"><a class="header" href="#244-encoderdecoder-架构与纯-decoder-架构">2.4.4 Encoder–Decoder 架构与纯 Decoder 架构</a></h3>
<p>Transformer 最初以 <strong>编码器–解码器（Encoder–Decoder）</strong> 形式提出，用于机器翻译等序列到序列任务。随后，纯 <strong>Decoder-only</strong> 架构（如 GPT 系列）成为大语言模型和部分 VLA 模型的主流。理解两者差异，有助于后面选择适合具身智能任务的结构。(<a href="https://arxiv.org/abs/1706.03762?utm_source=chatgpt.com">arXiv</a>)</p>
<h4 id="2441-编码器解码器架构典型-seq2seq-形式"><a class="header" href="#2441-编码器解码器架构典型-seq2seq-形式">2.4.4.1 编码器–解码器架构：典型 Seq2Seq 形式</a></h4>
<p>在 Encoder–Decoder Transformer 中：</p>
<ul>
<li><strong>编码器（Encoder）</strong>：由多层“自注意力 + 前馈网络（FFN）”组成。输入为源序列（例如源语言句子、环境描述、视觉特征序列），经过多层编码后，得到每个位置的上下文表示。</li>
<li><strong>解码器（Decoder）</strong>：同样由多层堆叠组成，但每一层一般包括：
<ol>
<li>带因果掩码的自注意力（masked self-attention），建模目标序列内部已生成部分；</li>
<li>编码器–解码器注意力（encoder-decoder cross-attention），使用解码器当前层隐藏状态作为 Query，编码器输出作为 Key/Value，从源序列里“查找”与当前生成位置相关的信息；</li>
<li>前馈网络。</li>
</ol>
</li>
</ul>
<p>这种结构天然适合“把一段信息转换为另一段信息”的任务，例如机器翻译、摘要生成等。(<a href="https://arxiv.org/abs/1706.03762?utm_source=chatgpt.com">arXiv</a>)</p>
<p>【图 2-4-7 占位：Encoder–Decoder 架构总览图。左侧是若干 Encoder 层叠加，右侧是 Decoder 层，Decoder 每层中有 self-attention、cross-attention 两种注意力模块，中间用箭头表示 cross-attention 连接。】</p>
<p>在具身智能场景中，如果希望“根据视觉感知或状态序列生成一整段动作脚本”，也可以将视觉/状态作为编码器输入，把动作序列作为解码器输出，这与机器翻译非常类似，只是“目标语言”换成了“机器人动作语言”。</p>
<h4 id="2442-纯解码器decoder-only架构统一序列建模"><a class="header" href="#2442-纯解码器decoder-only架构统一序列建模">2.4.4.2 纯解码器（Decoder-only）架构：统一序列建模</a></h4>
<p><strong>Decoder-only</strong> 架构则去掉了单独的编码器，仅保留一堆带因果掩码的自注意力层。训练时将所有内容串成一个长序列，采用自回归语言建模目标：给定前缀 token 预测下一个 token。(<a href="https://huggingface.co/learn/llm-course/en/chapter1/6?utm_source=chatgpt.com">Hugging Face</a>)</p>
<p>其特点是：</p>
<ul>
<li>所有信息（指令、上下文、历史观测、历史动作等）都以统一 token 序列的形式输入；</li>
<li>模型结构更加简洁——本质上就是一个大号自回归 Transformer；</li>
<li>通过合适的分隔符 token 和位置段编码，可以区分“指令区域”“状态区域”“动作区域”等。</li>
</ul>
<p>这正是 GPT 系列等大语言模型采用的结构，也是许多最新 VLM/VLA 模型采用的范式 —— 将视觉特征、语言指令、机器人状态和动作都离散化成 token，统一交给一个 Decoder-only 模型处理。(<a href="https://www.sciencedirect.com/science/article/pii/S2666651022000146?utm_source=chatgpt.com">科学导向</a>)</p>
<h4 id="2443-架构选择任务类型与工程需求"><a class="header" href="#2443-架构选择任务类型与工程需求">2.4.4.3 架构选择：任务类型与工程需求</a></h4>
<p>总结两者的适用场景：</p>
<ul>
<li><strong>Encoder–Decoder 架构</strong>：
<ul>
<li>适合“源序列–目标序列”有明显区分的任务，如机器翻译、长文本摘要、将一段视觉/语言描述转换为完整动作脚本；</li>
<li>在具身智能中，可用于“先感知–后离线规划”的场景，例如根据任务描述和环境扫描生成一条完整的执行计划。</li>
</ul>
</li>
<li><strong>Decoder-only 架构</strong>：
<ul>
<li>适合大规模预训练的通用语言/多模态模型。通过把不同模态与任务都统一到 token 序列上，可以用同一套训练目标和基础设施扩展到非常大的规模；</li>
<li>在具身智能中，可通过“指令 + 多模态观测 + 历史轨迹”的统一序列，让同一个基础模型同时学会多种机器人和多种任务的行为模式。</li>
</ul>
</li>
</ul>
<p>在第 8 章讨论 VLA 架构时，将可以看到两种思路的具体实现：一类是“感知模块 + Decoder 生成动作”的结构（更接近 Encoder–Decoder），另一类则是基于大号 Decoder-only 模型，通过 token 化动作实现统一序列建模的结构。</p>
<p>【图 2-4-8 占位：架构对比图。左侧是 Encoder–Decoder 结构示意，右侧是 Decoder-only 结构示意，下方各自标注典型应用场景（机器翻译 vs GPT 风格生成 vs 多模态 VLA）。】</p>
<hr>
<h3 id="245-参数规模与计算复杂度"><a class="header" href="#245-参数规模与计算复杂度">2.4.5 参数规模与计算复杂度</a></h3>
<p>Transformer 的表达能力很强，但背后对应的是相当可观的参数规模与计算复杂度。本节从参数量和时间/空间复杂度两个角度建立直观认识，这对于后续讨论机器人系统部署、模型压缩与高效注意力尤为重要。(<a href="https://www.sciencedirect.com/science/article/pii/S2666651022000146?utm_source=chatgpt.com">科学导向</a>)</p>
<h4 id="2451-transformer-参数规模估算"><a class="header" href="#2451-transformer-参数规模估算">2.4.5.1 Transformer 参数规模估算</a></h4>
<p>以一个标准 Transformer Block 为例，假设：</p>
<ul>
<li>模型隐藏维度为 (d_\text{model})；</li>
<li>前馈网络内部维度为 (d_\text{ff})（通常取 (4d_\text{model}) 左右）；</li>
<li>注意力头数为 (h)。</li>
</ul>
<p>单层的大致参数量：</p>
<ol>
<li><strong>自注意力部分</strong>
<ul>
<li>Q/K/V 三个线性层：约 (3 d_\text{model}^2) 参数；</li>
<li>输出线性层 (W^O)：约 (d_\text{model}^2) 参数。
合计 (\approx 4 d_\text{model}^2)。</li>
</ul>
</li>
<li><strong>前馈网络部分（两层 MLP）</strong>
<ul>
<li>第一层：(d_\text{model} \times d_\text{ff})；</li>
<li>第二层：(d_\text{ff} \times d_\text{model})。
合计 (\approx 2 d_\text{model} d_\text{ff})，在 (d_\text{ff} \approx 4d_\text{model}) 时，同样是 (\mathcal{O}(d_\text{model}^2)) 量级。(<a href="https://arxiv.org/abs/1706.03762?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ol>
<p>因此，单层 Transformer Block 的参数规模近似为：
$$
\mathcal{O}\big(d_\text{model}^2\big),
$$
整个模型若有 (L) 层，则总参数量大致为：
$$
\mathcal{O}\big(L, d_\text{model}^2\big).
$$</p>
<p>这解释了为何在提升模型能力时，增大 (d_\text{model}) 和层数会带来近似“平方级别”的参数增长。现代大语言模型和多模态模型往往具有数十到数百层、数千到上万的隐藏维度，对应参数规模可以轻松达到百亿甚至万亿级别。(<a href="https://www.sciencedirect.com/science/article/pii/S2666651022000146?utm_source=chatgpt.com">科学导向</a>)</p>
<p>对于具身智能而言，大参数模型意味着更强的跨任务、跨场景泛化能力（“一个模型包办很多机器人和任务”），但也意味着更重的训练和部署成本，这在后续“模型压缩与边缘部署”相关章节中会成为反复讨论的话题。</p>
<h4 id="2452-自注意力的时间与空间复杂度"><a class="header" href="#2452-自注意力的时间与空间复杂度">2.4.5.2 自注意力的时间与空间复杂度</a></h4>
<p>从计算复杂度角度，自注意力的瓶颈在于构造和使用 (n \times n) 的注意力矩阵，其中 (n) 为序列长度。(<a href="https://proceedings.mlr.press/v201/duman-keles23a/duman-keles23a.pdf?utm_source=chatgpt.com">Proceedings of Machine Learning Research</a>)</p>
<p>假设隐藏维度为 (d)：</p>
<ol>
<li>计算 Q/K/V：需要三次矩阵乘法，复杂度约为 (\mathcal{O}(n d^2))；</li>
<li>计算相关性矩阵 (QK^\top)：复杂度约为 (\mathcal{O}(n^2 d))；</li>
<li>计算 softmax 并与 V 相乘：同样约为 (\mathcal{O}(n^2 d))。</li>
</ol>
<p>当 (n) 较大时，(\mathcal{O}(n^2 d)) 项占主导，因此通常说 <strong>自注意力在序列长度上的时间和空间复杂度均为 (\mathcal{O}(n^2))</strong>。(<a href="https://aclanthology.org/2023.eacl-main.273.pdf?utm_source=chatgpt.com">ACL Anthology</a>)</p>
<p>这在 NLP 中已经构成长文本建模的瓶颈，而在具身智能中，情况往往更加严峻：</p>
<ul>
<li>机器人控制序列可能包含成千上万步决策；</li>
<li>视觉输入可能是一长段视频（每帧又被切分为多个 patch）；</li>
<li>若将语言、视觉、状态、动作 token 统一串成一个长序列 (n)，则注意力矩阵大小和计算量会极快增长。</li>
</ul>
<p>为此，近几年出现了大量 <strong>高效 Transformer 变体</strong>，如 Linformer、Performer、Longformer 等，通过低秩近似、稀疏注意力、窗口注意力等机制，将复杂度从 (\mathcal{O}(n^2)) 降低到近似线性的 (\mathcal{O}(n)) 或 (\mathcal{O}(n \log n))，使得长序列任务（包括视频、长轨迹建模）变得可行。(<a href="https://arxiv.org/abs/2006.04768?utm_source=chatgpt.com">arXiv</a>)</p>
<p>【图 2-4-9 占位：复杂度对比曲线。横轴为序列长度 (n)（对数尺度），纵轴为计算/显存开销（对数尺度），画出标准自注意力的 (n^2) 曲线与若干近似方法的线性或次线性曲线，标出典型 Transformer 变体名称。】</p>
<p>在本书后面更偏工程实践的章节，将会简要介绍这些高效注意力结构的使用场景，帮助读者在实际机器人项目中根据环境复杂度与硬件条件做出合理选择。</p>
<h4 id="2453-模型规模与性能缩放效应与资源约束"><a class="header" href="#2453-模型规模与性能缩放效应与资源约束">2.4.5.3 模型规模与性能：缩放效应与资源约束</a></h4>
<p>大量工作表明，在足够的数据和计算资源下，Transformer 模型的性能往往随着参数量、训练数据量和训练算力的增加呈现近似幂律关系，即“缩放定律（scaling laws）”：更大模型在语言理解、视觉感知和多模态任务上往往获得更好的泛化能力和少样本学习能力。(<a href="https://www.sciencedirect.com/science/article/pii/S2666651022000146?utm_source=chatgpt.com">科学导向</a>)</p>
<p>然而，在具身智能与机器人领域，还必须严肃考虑以下现实因素：</p>
<ul>
<li><strong>训练数据与成本限制</strong>
真实机器人互动数据极其昂贵，仿真数据也需要大量算力生成。很难像语言模型那样简单地“堆数据、堆算力”。因此实践中往往采用“互联网多模态预训练 + 少量机器人数据微调”的方式，让大模型在丰富的视觉–语言知识基础上学习具身技能。</li>
<li><strong>推理延迟与实时性要求</strong>
机器人控制通常需要在几十毫秒级内完成一次决策，超出这个延迟可能会明显影响动作平滑性甚至安全性。过大的模型虽然能力强，但若推理速度不足，就只能用于离线规划或云端辅助，而难以直接用于实时闭环控制。</li>
<li><strong>部署位置与算力约束</strong>
在云端运行大模型可以使用强大 GPU/TPU，但极度依赖网络连接，且存在安全与隐私问题；在机器人本体或边缘设备上，则必须结合嵌入式 GPU、专用加速芯片等选择合适规模的模型。这些问题将在第 10 章“部署与评测”和第 10.4 节“工程优化与压缩”中进一步展开。</li>
</ul>
<p>因此，在实际的 VLA 系统设计中，<strong>“尽可能大”并不总是最佳答案</strong>。更合理的策略通常是：</p>
<ul>
<li>利用大规模模型作为“通用基础模型”或云端规划者；</li>
<li>同时通过蒸馏、量化和架构简化，在机器人本体上部署较小的实时控制模型；</li>
<li>在任务复杂度、泛化能力、实时控制、安全性和成本之间寻找平衡点。</li>
</ul>
<p>这也是本书从理论到实践不断强调的一条主线：Transformer 和大模型为具身智能提供了前所未有的表达能力，但要真正落地到物理机器人上，必须在 <strong>模型能力与系统工程</strong> 之间进行精心权衡与设计。</p>
<hr>
<p>以上就是 2.4.1–2.4.5 的完整展开稿，后续在第 8 章你就可以直接把这里的 Self-Attention、多头、位置编码、架构差异自然嫁接到具体 VLA 模型的输入输出与训练设计上。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="大模型训练与微调"><a href="#大模型训练与微调" class="header">大模型训练与微调</a></h1>
<p>下面是按你给出的提纲，完整展开后的 <strong>2.5.1–2.5.5</strong> 章节正文草稿（书稿风格）。我会适度承接前文 RNN/CNN 内容，并给后续 VLA 章节留呼应点，图片用占位说明。</p>
<hr>
<h3 id="251-self-attention-机制与-querykeyvalue"><a class="header" href="#251-self-attention-机制与-querykeyvalue">2.5.1 Self-Attention 机制与 Query/Key/Value</a></h3>
<p>在前面的序列建模部分已经看到，RNN/LSTM 通过“递归地”一格一格地处理序列，这使得长距离依赖不易捕获，也难以并行训练。Self-Attention（自注意力）则直接在序列中任意两个位置之间建立可学习的“相似度连接”，从而在一次运算中融合全局信息，是 Transformer 的核心思想之一。(<a href="https://arxiv.org/abs/1706.03762?utm_source=chatgpt.com">arXiv</a>)</p>
<h4 id="2511-自注意力机制在序列内部做加权信息汇总"><a class="header" href="#2511-自注意力机制在序列内部做加权信息汇总">2.5.1.1 自注意力机制：在序列内部做“加权信息汇总”</a></h4>
<p>设输入序列长度为 (n)，每个位置的向量维度为 (d_\text{model})，将整个序列写成矩阵形式：
$$
X \in \mathbb{R}^{n \times d_\text{model}}.
$$</p>
<p>通过三组不同的线性变换，得到 Query（Q）、Key（K）、Value（V）：
$$
Q = X W^Q,\quad K = X W^K,\quad V = X W^V,
$$
其中 (W^Q, W^K, W^V \in \mathbb{R}^{d_\text{model} \times d_k}) 或 (\mathbb{R}^{d_\text{model} \times d_v}) 是可训练的权重矩阵。</p>
<p>标准的 <strong>scaled dot-product attention</strong> 定义为：(<a href="https://en.wikipedia.org/wiki/Attention_%28machine_learning%29?utm_source=chatgpt.com">维基百科</a>)</p>
<p>$$
\text{Attention}(Q, K, V)
= \text{softmax}!\left(\frac{Q K^\top}{\sqrt{d_k}}\right) V.
$$</p>
<p>其中：</p>
<ul>
<li>(QK^\top \in \mathbb{R}^{n\times n}) 给出序列中任意两个位置之间的“相关性分数”（内积越大，越相似）；</li>
<li>除以 (\sqrt{d_k}) 是为了避免维度过大时内积值过大导致 softmax 饱和；</li>
<li>softmax 在每一行上做归一化，将相关性分数转为“注意力权重”（非负且和为 1）；</li>
<li>将这些权重对 (V) 做加权和，得到每个位置融合了整句信息的新表示。</li>
</ul>
<p>直观地看，每个位置 (i) 的输出向量就是“从全序列所有位置的 Value 中，按相关性做加权平均”的结果，自注意力因此可以在单层中捕获任意距离的依赖关系。</p>
<p>【图 2-4-1 占位：自注意力示意图。上方是一行 token（或 patch）向量，中间通过 Q/K/V 线性变换，下面是一个 (n\times n) 注意力矩阵热力图；矩阵第 i 行突出显示该位置对其它位置的关注程度。】</p>
<h4 id="2512-query--key--value-的含义与类比"><a class="header" href="#2512-query--key--value-的含义与类比">2.5.1.2 Query / Key / Value 的含义与类比</a></h4>
<p>Q/K/V 的命名可以类比为“查字典”的过程：(<a href="https://www.billparker.ai/2024/10/transformer-attention-simple-guide-to-q.html?utm_source=chatgpt.com">billparker.ai</a>)</p>
<ul>
<li><strong>Query（Q，查询）</strong>：当前想要“查”的词条，如一个位置上的 token 表示；</li>
<li><strong>Key（K，键）</strong>：所有候选词条的“索引标签”，用于和 Query 做匹配；</li>
<li><strong>Value（V，值）</strong>：与每个 Key 对应的内容，一旦某个 Key 与 Query 匹配度高，就会更多地读取其对应的 Value 信息。</li>
</ul>
<p>注意力分数由 Query 与各个 Key 的相似度决定（通常就是向量内积），再通过 softmax 归一化后，作为对 Value 的加权系数。因此：</p>
<ul>
<li>若 Query 与某个 Key 成“高相似度”，对应 Value 在输出中权重更大；</li>
<li>若 Query 与某些 Key 几乎无关，则它们对应的 Value 在输出中的权重接近 0。</li>
</ul>
<p>在 <strong>编码器自注意力</strong> 中，Q/K/V 都来自同一个输入序列；在 <strong>解码器的交叉注意力（encoder-decoder attention）</strong> 中，Q 来自解码器当前状态，而 K/V 来自编码器输出，这将在 2.5.4 节进一步展开。(<a href="https://en.wikipedia.org/wiki/Attention_%28machine_learning%29?utm_source=chatgpt.com">维基百科</a>)</p>
<p>从具身智能的角度可以这样理解：机器人在某个时间步要做决策时，它把当前状态向量作为 Query，把过去观测或语言指令编码后的向量作为 Key/Value，通过 attention“查”到与当前状况最相关的信息，再基于这些信息输出动作。</p>
<h4 id="2513-注意力矩阵与掩码机制"><a class="header" href="#2513-注意力矩阵与掩码机制">2.5.1.3 注意力矩阵与掩码机制</a></h4>
<p>把自注意力的权重部分单独记为矩阵：
$$
A = \text{softmax}!\left(\frac{QK^\top}{\sqrt{d_k}}\right) \in \mathbb{R}^{n\times n}.
$$</p>
<ul>
<li>(A_{ij}) 表示“序列中位置 (i) 对位置 (j) 的注意力权重”；</li>
<li>每一行都是一个概率分布（和为 1），体现了位置 (i) 对各个位置的关注程度。</li>
</ul>
<p>Encoder 层中常用的 <strong>全连接自注意力</strong>，允许每个位置关注序列中任意位置；而在 Decoder 的自回归生成中，为避免“偷看未来”，会对注意力矩阵进行下三角 <strong>因果掩码（causal mask）</strong> 处理：在 softmax 前将所有“未来位置”的相关性分数置为 (-\infty)，softmax 之后它们的权重就变为 0，仅允许当前位置看到自己与其之前的 token。(<a href="https://en.wikipedia.org/wiki/Attention_%28machine_learning%29?utm_source=chatgpt.com">维基百科</a>)</p>
<p>【图 2-4-2 占位：注意力矩阵与掩码示意图。左图为完整的 (n\times n) 注意力矩阵热力图；右图为 Decoder 中的下三角掩码矩阵，上三角区域被灰色遮挡（权重为 0）。】</p>
<p>在机器人动作序列建模中，自回归 Decoder-only 架构同样使用这种因果掩码，以保证每一步动作仅依赖过去的观测和动作历史，符合物理因果顺序。</p>
<hr>
<h3 id="252-多头注意力multi-head-attention"><a class="header" href="#252-多头注意力multi-head-attention">2.5.2 多头注意力（Multi-Head Attention）</a></h3>
<p>单一的自注意力头相当于从一个“投影子空间”里计算相似度和信息汇总。Transformer 引入 <strong>多头注意力（Multi-Head Attention）</strong>，并行地在多个子空间中计算注意力，从而提高表达能力。(<a href="https://papers.neurips.cc/paper/7181-attention-is-all-you-need.pdf?utm_source=chatgpt.com">NeurIPS论文</a>)</p>
<h4 id="2521-多头机制的形式化定义"><a class="header" href="#2521-多头机制的形式化定义">2.5.2.1 多头机制的形式化定义</a></h4>
<p>在多头注意力中，我们为每个头 (i) 单独学习一组线性变换：
$$
W_i^Q, W_i^K, W_i^V \in \mathbb{R}^{d_\text{model} \times d_k},\quad i = 1,\dots,h,
$$
令
$$
\text{head}_i = \text{Attention}(QW_i^Q,\ KW_i^K,\ VW_i^V).
$$</p>
<p>然后将所有头的输出在特征维上拼接，再通过一个线性层 (W^O) 做整合：
$$
\text{MultiHead}(Q,K,V) = \text{Concat}(\text{head}_1, \dots, \text{head}_h), W^O.
$$
(<a href="https://en.wikipedia.org/wiki/Attention_%28machine_learning%29?utm_source=chatgpt.com">维基百科</a>)</p>
<p>这样，每个头都在各自的投影子空间中学习不同的相似性模式，最终汇聚为一个更丰富的表示。</p>
<p>【图 2-4-3 占位：多头注意力结构图。上方 Q/K/V 通过多组线性变换分别进入多个 attention 单元（Head 1, Head 2, …, Head h），各自输出后在特征维拼接，再经过一个线性层得到最终输出。】</p>
<h4 id="2522-不同注意力头学习不同的关系"><a class="header" href="#2522-不同注意力头学习不同的关系">2.5.2.2 不同注意力头学习不同的关系</a></h4>
<p>大量实证分析表明，不同注意力头往往会“专注”于不同类型的模式：(<a href="https://www.sciencedirect.com/science/article/pii/S2666651022000146?utm_source=chatgpt.com">科学导向</a>)</p>
<ul>
<li>在自然语言任务中，有的头擅长捕获邻近词之间的局部依赖（如短语结构），有的头捕获长距离依赖（如跨句子的共指、主题联系）；</li>
<li>在视觉 Transformer 中，有的头聚焦局部 patch 的几何关系，有的头关注整体场景结构或物体的语义轮廓。</li>
</ul>
<p>对于具身智能任务，可以预期：</p>
<ul>
<li>某些头重点关注与目标物体相关的视觉区域；</li>
<li>某些头偏重障碍物和安全边界；</li>
<li>还有一些头可能更关注时间维度上动作的连续性或物体轨迹。</li>
</ul>
<p>虽然这些“功能分工”不是硬编码的，而是训练过程中自发涌现，但在实践中，可以通过可视化注意力权重来分析模型行为，从而对机器人决策过程获得一定的可解释性（在第 10 章可解释性部分会再回到这一点）。</p>
<p>【图 2-4-4 占位：多头注意力可视化示例。对同一句话（或同一图像 patch 序列），展示多个头的注意力矩阵热力图，每个头关注的模式不同。】</p>
<h4 id="2523-计算开销与并行执行"><a class="header" href="#2523-计算开销与并行执行">2.5.2.3 计算开销与并行执行</a></h4>
<p>从复杂度角度看，多头注意力虽然引入了多个头，但每个头通常使用较小的 (d_k)（例如 (d_k = d_\text{model} / h)），因此总的计算量与单个大头的注意力同阶，只是常数因子有所增加。(<a href="https://papers.neurips.cc/paper/7181-attention-is-all-you-need.pdf?utm_source=chatgpt.com">NeurIPS论文</a>)</p>
<p>更重要的是，各个头之间完全可以在 GPU/TPU 上并行计算，因此在现代硬件上，多头注意力的实际计算效率很高，与标准矩阵乘法的实现高度契合。这也是 Transformer 能够在视觉、语言以及多模态任务上高效扩展到大规模模型的关键工程基础。</p>
<p>在机器人应用中，多头注意力使得单个 VLA 模型可以同时在不同“视角”下理解环境与任务指令，为后续的动作决策提供更丰富的上下文表征。</p>
<hr>
<h3 id="253-位置编码绝对--相对"><a class="header" href="#253-位置编码绝对--相对">2.5.3 位置编码（绝对 / 相对）</a></h3>
<p>自注意力机制本身对输入顺序是“置换不变”的——如果不显式加入位置信息，模型仅将序列视为一个“集合”，无法区分不同排列顺序，从而无法正确建模时间顺序或语序。(<a href="https://aclanthology.org/2021.emnlp-main.828.pdf?utm_source=chatgpt.com">ACL Anthology</a>)</p>
<p>为了解决这一问题，Transformer 在输入层或各层内部引入 <strong>位置编码（Positional Encoding）</strong>，将位置信息注入到每个 token 或 patch 的表示中。</p>
<h4 id="2531-绝对位置编码正弦余弦函数形式"><a class="header" href="#2531-绝对位置编码正弦余弦函数形式">2.5.3.1 绝对位置编码：正弦/余弦函数形式</a></h4>
<p>原始 Transformer 论文提出了一种 <strong>固定的正弦–余弦位置编码</strong>，给每个位置 (pos) 分配一个维度为 (d_\text{model}) 的向量：(<a href="https://arxiv.org/abs/1706.03762?utm_source=chatgpt.com">arXiv</a>)</p>
<p>$$
\begin{aligned}
\text{PE}(pos, 2i)   &amp;= \sin\left(\frac{pos}{10000^{2i/d_\text{model}}}\right),
\text{PE}(pos, 2i+1) &amp;= \cos\left(\frac{pos}{10000^{2i/d_\text{model}}}\right),
\end{aligned}
$$
其中 (i = 0,1,\dots, d_\text{model}/2-1)。</p>
<p>特点与直觉：</p>
<ul>
<li>不同维度对应不同波长的正弦波，低频维度编码粗粒度的位置信息，高频维度编码细粒度的局部差异；</li>
<li>由于是解析函数定义，不需要训练额外参数，并且可以自然地外推到比训练时更长的序列长度；</li>
<li>通过线性组合不同维度，模型可以在一定程度上推断两个位置之间的相对距离。</li>
</ul>
<p>在实现上，常见做法是在输入 embedding 上“相加”位置编码：
$$
X^\text{input}_i = X^\text{embed}_i + \text{PE}(i).
$$</p>
<p>【图 2-4-5 占位：若干维度的正弦/余弦位置编码随位置变化的曲线图，展示不同频率、不同波长的波形。】</p>
<p>除正弦编码之外，很多模型也采用 <strong>可学习的绝对位置 embedding</strong>，即像词向量一样为每个位置建立一个可训练表，将其加到输入上。实现更简单，但在泛化到更长序列时往往需要额外技巧。</p>
<h4 id="2532-相对位置编码对相对距离更敏感"><a class="header" href="#2532-相对位置编码对相对距离更敏感">2.5.3.2 相对位置编码：对相对距离更敏感</a></h4>
<p>绝对位置编码强调的是“某个 token 在整个序列中处于第几位”；然而很多任务更关心的是 <strong>token 之间的相对距离</strong>——例如“当前词前面最近的名词在哪里”，“上一时刻与当前时刻的相对差值”等。(<a href="https://arxiv.org/pdf/2310.04418?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>相对位置编码（Relative Positional Encoding, RPE）</strong> 的基本思想，是让注意力分数不仅依赖于内容相似度 (q_i^\top k_j)，还依赖于位置差值 ((i-j)) 对应的一个向量或偏置，例如：(<a href="https://lilianweng.github.io/posts/2023-01-27-the-transformer-family-v2/?utm_source=chatgpt.com">Lilian Weng</a>)</p>
<p>$$
\text{score}<em>{ij}
= \frac{q_i^\top k_j + q_i^\top r</em>{i-j}}{\sqrt{d_k}},
$$
其中 (r_{i-j}) 是与相对位移 ((i-j)) 相关的参数向量或标量偏置。</p>
<p>代表性工作包括：</p>
<ul>
<li>Shaw 等人在机器翻译中的相对位置编码；</li>
<li>Transformer-XL 使用相对位置编码解决长上下文建模问题；</li>
<li>后续的 T5、RoPE（Rotary Position Embedding）等方法，对相对位置进一步推广，使模型对序列整体平移具有更好的不变性。(<a href="https://lilianweng.github.io/posts/2023-01-27-the-transformer-family-v2/?utm_source=chatgpt.com">Lilian Weng</a>)</li>
</ul>
<p>在机器人与具身智能任务中，时间维度往往很长，而我们关注的是“前后几步”动作与观测之间的因果关系，相对位置编码因此更加契合时序决策的需求。</p>
<p>【图 2-4-6 占位：相对位置编码示意图。以当前时间步为中心，展示不同相对位移（-k…0…+k）的编码向量，或绘制一个相对位置偏置矩阵。】</p>
<h4 id="2533-位置编码的重要性从集合到有序序列"><a class="header" href="#2533-位置编码的重要性从集合到有序序列">2.5.3.3 位置编码的重要性：从“集合”到“有序序列”</a></h4>
<p>如果不给 Transformer 加入任何位置信息，网络对输入的任何排列都将给出相同的输出（只是对应位置发生置换），这会导致：</p>
<ul>
<li>在语言任务中无法区分 “把红色方块放入盒子” 与 “盒子放入红色方块”；</li>
<li>在机器人控制中无法区分“先抓取后放置”与“先放置后抓取”的时序逻辑。</li>
</ul>
<p>位置编码正是将 <strong>“序列顺序”</strong> 显式注入到模型中的关键步骤，使自注意力从“集合运算”转变为真正的“序列建模”。(<a href="https://aclanthology.org/2021.emnlp-main.828.pdf?utm_source=chatgpt.com">ACL Anthology</a>)</p>
<p>在后续构建 VLA 模型时，时间步编号、视频帧序号、甚至任务分段（如“示教阶段/执行阶段”）都会通过某种形式的“位置或阶段编码”进入模型，使机器人能够理解“何时发生了什么”。</p>
<hr>
<h3 id="254-encoderdecoder-架构与纯-decoder-架构"><a class="header" href="#254-encoderdecoder-架构与纯-decoder-架构">2.5.4 Encoder–Decoder 架构与纯 Decoder 架构</a></h3>
<p>Transformer 最初以 <strong>编码器–解码器（Encoder–Decoder）</strong> 形式提出，用于机器翻译等序列到序列任务。随后，纯 <strong>Decoder-only</strong> 架构（如 GPT 系列）成为大语言模型和部分 VLA 模型的主流。理解两者差异，有助于后面选择适合具身智能任务的结构。(<a href="https://arxiv.org/abs/1706.03762?utm_source=chatgpt.com">arXiv</a>)</p>
<h4 id="2541-编码器解码器架构典型-seq2seq-形式"><a class="header" href="#2541-编码器解码器架构典型-seq2seq-形式">2.5.4.1 编码器–解码器架构：典型 Seq2Seq 形式</a></h4>
<p>在 Encoder–Decoder Transformer 中：</p>
<ul>
<li><strong>编码器（Encoder）</strong>：由多层“自注意力 + 前馈网络（FFN）”组成。输入为源序列（例如源语言句子、环境描述、视觉特征序列），经过多层编码后，得到每个位置的上下文表示。</li>
<li><strong>解码器（Decoder）</strong>：同样由多层堆叠组成，但每一层一般包括：
<ol>
<li>带因果掩码的自注意力（masked self-attention），建模目标序列内部已生成部分；</li>
<li>编码器–解码器注意力（encoder-decoder cross-attention），使用解码器当前层隐藏状态作为 Query，编码器输出作为 Key/Value，从源序列里“查找”与当前生成位置相关的信息；</li>
<li>前馈网络。</li>
</ol>
</li>
</ul>
<p>这种结构天然适合“把一段信息转换为另一段信息”的任务，例如机器翻译、摘要生成等。(<a href="https://arxiv.org/abs/1706.03762?utm_source=chatgpt.com">arXiv</a>)</p>
<p>【图 2-4-7 占位：Encoder–Decoder 架构总览图。左侧是若干 Encoder 层叠加，右侧是 Decoder 层，Decoder 每层中有 self-attention、cross-attention 两种注意力模块，中间用箭头表示 cross-attention 连接。】</p>
<p>在具身智能场景中，如果希望“根据视觉感知或状态序列生成一整段动作脚本”，也可以将视觉/状态作为编码器输入，把动作序列作为解码器输出，这与机器翻译非常类似，只是“目标语言”换成了“机器人动作语言”。</p>
<h4 id="2542-纯解码器decoder-only架构统一序列建模"><a class="header" href="#2542-纯解码器decoder-only架构统一序列建模">2.5.4.2 纯解码器（Decoder-only）架构：统一序列建模</a></h4>
<p><strong>Decoder-only</strong> 架构则去掉了单独的编码器，仅保留一堆带因果掩码的自注意力层。训练时将所有内容串成一个长序列，采用自回归语言建模目标：给定前缀 token 预测下一个 token。(<a href="https://huggingface.co/learn/llm-course/en/chapter1/6?utm_source=chatgpt.com">Hugging Face</a>)</p>
<p>其特点是：</p>
<ul>
<li>所有信息（指令、上下文、历史观测、历史动作等）都以统一 token 序列的形式输入；</li>
<li>模型结构更加简洁——本质上就是一个大号自回归 Transformer；</li>
<li>通过合适的分隔符 token 和位置段编码，可以区分“指令区域”“状态区域”“动作区域”等。</li>
</ul>
<p>这正是 GPT 系列等大语言模型采用的结构，也是许多最新 VLM/VLA 模型采用的范式 —— 将视觉特征、语言指令、机器人状态和动作都离散化成 token，统一交给一个 Decoder-only 模型处理。(<a href="https://www.sciencedirect.com/science/article/pii/S2666651022000146?utm_source=chatgpt.com">科学导向</a>)</p>
<h4 id="2543-架构选择任务类型与工程需求"><a class="header" href="#2543-架构选择任务类型与工程需求">2.5.4.3 架构选择：任务类型与工程需求</a></h4>
<p>总结两者的适用场景：</p>
<ul>
<li><strong>Encoder–Decoder 架构</strong>：
<ul>
<li>适合“源序列–目标序列”有明显区分的任务，如机器翻译、长文本摘要、将一段视觉/语言描述转换为完整动作脚本；</li>
<li>在具身智能中，可用于“先感知–后离线规划”的场景，例如根据任务描述和环境扫描生成一条完整的执行计划。</li>
</ul>
</li>
<li><strong>Decoder-only 架构</strong>：
<ul>
<li>适合大规模预训练的通用语言/多模态模型。通过把不同模态与任务都统一到 token 序列上，可以用同一套训练目标和基础设施扩展到非常大的规模；</li>
<li>在具身智能中，可通过“指令 + 多模态观测 + 历史轨迹”的统一序列，让同一个基础模型同时学会多种机器人和多种任务的行为模式。</li>
</ul>
</li>
</ul>
<p>在第 8 章讨论 VLA 架构时，将可以看到两种思路的具体实现：一类是“感知模块 + Decoder 生成动作”的结构（更接近 Encoder–Decoder），另一类则是基于大号 Decoder-only 模型，通过 token 化动作实现统一序列建模的结构。</p>
<p>【图 2-4-8 占位：架构对比图。左侧是 Encoder–Decoder 结构示意，右侧是 Decoder-only 结构示意，下方各自标注典型应用场景（机器翻译 vs GPT 风格生成 vs 多模态 VLA）。】</p>
<hr>
<h3 id="255-参数规模与计算复杂度"><a class="header" href="#255-参数规模与计算复杂度">2.5.5 参数规模与计算复杂度</a></h3>
<p>Transformer 的表达能力很强，但背后对应的是相当可观的参数规模与计算复杂度。本节从参数量和时间/空间复杂度两个角度建立直观认识，这对于后续讨论机器人系统部署、模型压缩与高效注意力尤为重要。(<a href="https://www.sciencedirect.com/science/article/pii/S2666651022000146?utm_source=chatgpt.com">科学导向</a>)</p>
<h4 id="2551-transformer-参数规模估算"><a class="header" href="#2551-transformer-参数规模估算">2.5.5.1 Transformer 参数规模估算</a></h4>
<p>以一个标准 Transformer Block 为例，假设：</p>
<ul>
<li>模型隐藏维度为 (d_\text{model})；</li>
<li>前馈网络内部维度为 (d_\text{ff})（通常取 (4d_\text{model}) 左右）；</li>
<li>注意力头数为 (h)。</li>
</ul>
<p>单层的大致参数量：</p>
<ol>
<li><strong>自注意力部分</strong>
<ul>
<li>Q/K/V 三个线性层：约 (3 d_\text{model}^2) 参数；</li>
<li>输出线性层 (W^O)：约 (d_\text{model}^2) 参数。
合计 (\approx 4 d_\text{model}^2)。</li>
</ul>
</li>
<li><strong>前馈网络部分（两层 MLP）</strong>
<ul>
<li>第一层：(d_\text{model} \times d_\text{ff})；</li>
<li>第二层：(d_\text{ff} \times d_\text{model})。
合计 (\approx 2 d_\text{model} d_\text{ff})，在 (d_\text{ff} \approx 4d_\text{model}) 时，同样是 (\mathcal{O}(d_\text{model}^2)) 量级。(<a href="https://arxiv.org/abs/1706.03762?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ol>
<p>因此，单层 Transformer Block 的参数规模近似为：
$$
\mathcal{O}\big(d_\text{model}^2\big),
$$
整个模型若有 (L) 层，则总参数量大致为：
$$
\mathcal{O}\big(L, d_\text{model}^2\big).
$$</p>
<p>这解释了为何在提升模型能力时，增大 (d_\text{model}) 和层数会带来近似“平方级别”的参数增长。现代大语言模型和多模态模型往往具有数十到数百层、数千到上万的隐藏维度，对应参数规模可以轻松达到百亿甚至万亿级别。(<a href="https://www.sciencedirect.com/science/article/pii/S2666651022000146?utm_source=chatgpt.com">科学导向</a>)</p>
<p>对于具身智能而言，大参数模型意味着更强的跨任务、跨场景泛化能力（“一个模型包办很多机器人和任务”），但也意味着更重的训练和部署成本，这在后续“模型压缩与边缘部署”相关章节中会成为反复讨论的话题。</p>
<h4 id="2552-自注意力的时间与空间复杂度"><a class="header" href="#2552-自注意力的时间与空间复杂度">2.5.5.2 自注意力的时间与空间复杂度</a></h4>
<p>从计算复杂度角度，自注意力的瓶颈在于构造和使用 (n \times n) 的注意力矩阵，其中 (n) 为序列长度。(<a href="https://proceedings.mlr.press/v201/duman-keles23a/duman-keles23a.pdf?utm_source=chatgpt.com">Proceedings of Machine Learning Research</a>)</p>
<p>假设隐藏维度为 (d)：</p>
<ol>
<li>计算 Q/K/V：需要三次矩阵乘法，复杂度约为 (\mathcal{O}(n d^2))；</li>
<li>计算相关性矩阵 (QK^\top)：复杂度约为 (\mathcal{O}(n^2 d))；</li>
<li>计算 softmax 并与 V 相乘：同样约为 (\mathcal{O}(n^2 d))。</li>
</ol>
<p>当 (n) 较大时，(\mathcal{O}(n^2 d)) 项占主导，因此通常说 <strong>自注意力在序列长度上的时间和空间复杂度均为 (\mathcal{O}(n^2))</strong>。(<a href="https://aclanthology.org/2023.eacl-main.273.pdf?utm_source=chatgpt.com">ACL Anthology</a>)</p>
<p>这在 NLP 中已经构成长文本建模的瓶颈，而在具身智能中，情况往往更加严峻：</p>
<ul>
<li>机器人控制序列可能包含成千上万步决策；</li>
<li>视觉输入可能是一长段视频（每帧又被切分为多个 patch）；</li>
<li>若将语言、视觉、状态、动作 token 统一串成一个长序列 (n)，则注意力矩阵大小和计算量会极快增长。</li>
</ul>
<p>为此，近几年出现了大量 <strong>高效 Transformer 变体</strong>，如 Linformer、Performer、Longformer 等，通过低秩近似、稀疏注意力、窗口注意力等机制，将复杂度从 (\mathcal{O}(n^2)) 降低到近似线性的 (\mathcal{O}(n)) 或 (\mathcal{O}(n \log n))，使得长序列任务（包括视频、长轨迹建模）变得可行。(<a href="https://arxiv.org/abs/2006.04768?utm_source=chatgpt.com">arXiv</a>)</p>
<p>【图 2-4-9 占位：复杂度对比曲线。横轴为序列长度 (n)（对数尺度），纵轴为计算/显存开销（对数尺度），画出标准自注意力的 (n^2) 曲线与若干近似方法的线性或次线性曲线，标出典型 Transformer 变体名称。】</p>
<p>在本书后面更偏工程实践的章节，将会简要介绍这些高效注意力结构的使用场景，帮助读者在实际机器人项目中根据环境复杂度与硬件条件做出合理选择。</p>
<h4 id="2553-模型规模与性能缩放效应与资源约束"><a class="header" href="#2553-模型规模与性能缩放效应与资源约束">2.5.5.3 模型规模与性能：缩放效应与资源约束</a></h4>
<p>大量工作表明，在足够的数据和计算资源下，Transformer 模型的性能往往随着参数量、训练数据量和训练算力的增加呈现近似幂律关系，即“缩放定律（scaling laws）”：更大模型在语言理解、视觉感知和多模态任务上往往获得更好的泛化能力和少样本学习能力。(<a href="https://www.sciencedirect.com/science/article/pii/S2666651022000146?utm_source=chatgpt.com">科学导向</a>)</p>
<p>然而，在具身智能与机器人领域，还必须严肃考虑以下现实因素：</p>
<ul>
<li><strong>训练数据与成本限制</strong>
真实机器人互动数据极其昂贵，仿真数据也需要大量算力生成。很难像语言模型那样简单地“堆数据、堆算力”。因此实践中往往采用“互联网多模态预训练 + 少量机器人数据微调”的方式，让大模型在丰富的视觉–语言知识基础上学习具身技能。</li>
<li><strong>推理延迟与实时性要求</strong>
机器人控制通常需要在几十毫秒级内完成一次决策，超出这个延迟可能会明显影响动作平滑性甚至安全性。过大的模型虽然能力强，但若推理速度不足，就只能用于离线规划或云端辅助，而难以直接用于实时闭环控制。</li>
<li><strong>部署位置与算力约束</strong>
在云端运行大模型可以使用强大 GPU/TPU，但极度依赖网络连接，且存在安全与隐私问题；在机器人本体或边缘设备上，则必须结合嵌入式 GPU、专用加速芯片等选择合适规模的模型。这些问题将在第 10 章“部署与评测”和第 10.4 节“工程优化与压缩”中进一步展开。</li>
</ul>
<p>因此，在实际的 VLA 系统设计中，<strong>“尽可能大”并不总是最佳答案</strong>。更合理的策略通常是：</p>
<ul>
<li>利用大规模模型作为“通用基础模型”或云端规划者；</li>
<li>同时通过蒸馏、量化和架构简化，在机器人本体上部署较小的实时控制模型；</li>
<li>在任务复杂度、泛化能力、实时控制、安全性和成本之间寻找平衡点。</li>
</ul>
<p>这也是本书从理论到实践不断强调的一条主线：Transformer 和大模型为具身智能提供了前所未有的表达能力，但要真正落地到物理机器人上，必须在 <strong>模型能力与系统工程</strong> 之间进行精心权衡与设计。</p>
<hr>
<p>以上就是 2.5.1–2.5.5 的完整展开稿，后续在第 8 章你就可以直接把这里的 Self-Attention、多头、位置编码、架构差异自然嫁接到具体 VLA 模型的输入输出与训练设计上。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="经典视觉任务与数据集"><a href="#经典视觉任务与数据集" class="header">经典视觉任务与数据集</a></h1>
<p>下面这一节，可以直接作为你书里 3.1.1–3.1.3 的主体内容使用。我会尽量和前面“机器学习评价指标”“CNN 基础”等不重复，只在需要的地方作联结，并在必要处留出“图片占位”。</p>
<hr>
<h3 id="311-图像分类目标检测实例分割--语义分割"><a class="header" href="#311-图像分类目标检测实例分割--语义分割">3.1.1 图像分类、目标检测、实例分割 / 语义分割</a></h3>
<p>这一小节讨论的任务，可以理解为“视觉理解的三个层级”：</p>
<ul>
<li><strong>图像分类</strong>：只回答“这张图整体是什么？”</li>
<li><strong>目标检测</strong>：回答“图里有哪些目标、在什么位置？”</li>
<li><strong>分割（语义 / 实例）</strong>：精确到“每一个像素属于什么东西？哪些像素属于同一个物体个体？”</li>
</ul>
<p>从具身智能角度看，这三个层级对应着从“看懂是什么”到“知道在哪里”再到“知道它的形状和边界”，直接影响机器人能否安全地移动、对物体进行精细操作。</p>
<blockquote>
<p>图片占位建议：一张包含多辆车和行人的街景，分别画出
– 只标注整图类别（如 “city street”）；
– 带边界框的检测结果；
– 语义分割伪彩色图；
– 实例分割图（同类物体用不同颜色或不同边界）。</p>
</blockquote>
<hr>
<h4 id="3111-图像分类image-classification"><a class="header" href="#3111-图像分类image-classification">3.1.1.1 图像分类（Image Classification）</a></h4>
<p><strong>任务定义</strong></p>
<p>给定一张图像 (x)，输出一个或多个类别标签 (y)：</p>
<ul>
<li><strong>单标签分类</strong>：一张图只对应一个主类别，例如 “狗”“飞机”。
数学上是 (y \in {1,\dots, C})。</li>
<li><strong>多标签分类</strong>：一张图可以同时属于多个类别，例如“室内 + 厨房 + 有人”。
数学上是 (y \in {0,1}^C)。</li>
</ul>
<p>典型做法是：用 <strong>CNN 或 ViT</strong> 把图像编码成一个向量特征，然后接一个全连接层 + Softmax（多标签时用 Sigmoid）输出每个类别的概率。前面章节已经介绍过 CNN/Transformer 的结构，这里不再展开。</p>
<p><strong>在机器人中的角色</strong></p>
<ul>
<li>场景识别：判断当前是“走廊 / 楼梯间 / 厨房”，帮助移动机器人选择行为模式。</li>
<li>物体存在性检测（粗粒度）：例如“桌上是否有杯子”“仓库里是否有托盘”，不要求精确位置，只要知道有没有。</li>
<li>状态识别：例如“红绿灯状态”“门是开着还是关着”，本质上也是一种分类。</li>
</ul>
<p>随着后面引入更细粒度的视觉任务，单纯分类在机器人中更多扮演“高层语义标签”的角色，而不是唯一的信息来源。</p>
<blockquote>
<p>图片占位建议：图像分类网络结构示意图：左边是一张输入图片，中间是若干卷积/Transformer 模块，右边是一个类别概率条形图（dog, cat, car…）。</p>
</blockquote>
<hr>
<h4 id="3112-目标检测object-detection"><a class="header" href="#3112-目标检测object-detection">3.1.1.2 目标检测（Object Detection）</a></h4>
<p><strong>任务定义</strong></p>
<p>目标检测要在图像中找出<strong>所有感兴趣的目标</strong>，并给出：</p>
<ul>
<li>每个目标的 <strong>类别标签</strong>；</li>
<li>每个目标的 <strong>位置</strong>，通常用矩形边界框（bounding box）表示：
<ul>
<li>形式一：((x_{\min}, y_{\min}, x_{\max}, y_{\max}))</li>
<li>形式二：((c_x, c_y, w, h))（中心点 + 宽高）</li>
</ul>
</li>
</ul>
<p>输出是一个<strong>可变长集合</strong>：
$$
{(b_i, c_i, s_i)}_{i=1}^N
$$
其中 (b_i) 是边界框，(c_i) 是类别，(s_i) 是置信度（模型认为这个框有多靠谱）。</p>
<p>与图像分类相比，检测多了两件事：</p>
<ol>
<li><strong>目标个数是未知的</strong>（0 个、1 个、很多个都有可能），模型要自己决定输出多少个框；</li>
<li><strong>要精准定位</strong>——不仅要“认得出”，还要“画得准”。</li>
</ol>
<p><strong>典型检测器结构</strong></p>
<p>现代深度学习检测器大致可以分成两类：</p>
<ol>
<li><strong>两阶段（two-stage）检测器</strong>
<ul>
<li>代表：R-CNN 系列（Fast R-CNN、Faster R-CNN、Mask R-CNN 等）。</li>
<li>流程：
1）先用一个网络产生少量“候选框”（Region Proposal）；
2）再对每个候选框进行精细分类和位置回归修正。</li>
<li>特点：精度高、速度相对较慢，适合离线分析或对实时性要求不特别苛刻的机器人应用。</li>
</ul>
</li>
<li><strong>单阶段（one-stage）检测器</strong>
<ul>
<li>代表：YOLO 系列、SSD、RetinaNet 等。(<a href="https://arxiv.org/abs/2011.08036?utm_source=chatgpt.com">arXiv</a>)</li>
<li>流程：直接在特征图上预测每个位置可能有哪些目标、对应的框和类别。</li>
<li>特点：速度快，适合实时场景（如无人机、移动机器人），精度略低但在工程中往往更受欢迎。</li>
</ul>
</li>
</ol>
<p>此外，还有 <strong>anchor-based</strong>（在预定义框上微调）与 <strong>anchor-free</strong>（直接预测框中心和尺寸）等差异，这些细节在后续讲检测网络时可以展开。</p>
<p><strong>在机器人中的角色</strong></p>
<ul>
<li>行人 / 障碍物检测：移动机器人或自动驾驶车辆的基础能力。</li>
<li>操作前目标定位：机械臂抓取前，需要知道目标的 2D 位置，用于进一步估计 3D 位姿（见 3.3 节）。</li>
<li>多目标场景理解：例如一个仓库机器人需要知道哪些是“货架”“箱子”“叉车”，并区分它们的位置关系。</li>
</ul>
<blockquote>
<p>图片占位建议：同一张街景图，标出不同类别的边界框，并在旁边画一个典型检测网络示意（backbone + FPN + detection head）。</p>
</blockquote>
<hr>
<h4 id="3113-实例分割-vs-语义分割"><a class="header" href="#3113-实例分割-vs-语义分割">3.1.1.3 实例分割 vs 语义分割</a></h4>
<p><strong>共同点：都是“每个像素要有标签”</strong></p>
<p>分割任务比检测更精细：不再满足于框出一个矩形，而是要知道<strong>每个像素属于哪一类</strong>，甚至属于哪一个具体物体。</p>
<ol>
<li><strong>语义分割（Semantic Segmentation）</strong>
<ul>
<li>目标：为图像中的每一个像素分配一个语义类别，如“路面 / 行人 / 汽车 / 建筑 / 背景”。</li>
<li>特点：<strong>不区分实例</strong>。所有“汽车像素”都被标为同一个类别 ID，不管场景中有几辆车。</li>
</ul>
</li>
<li><strong>实例分割（Instance Segmentation）</strong>
<ul>
<li>目标：不仅要告诉你每个像素“是什么”，还要告诉你“属于哪一个物体实例”。</li>
<li>特点：同一类别的不同物体要有不同的实例 ID，例如“车 1”“车 2”“车 3”。</li>
<li>技术上通常结合检测 + 分割（如 Mask R-CNN：先检测出框，再为每个框预测掩膜）。</li>
</ul>
</li>
</ol>
<p>可以用简单的类比理解：</p>
<ul>
<li>语义分割：把城市地图按区域涂色（道路全是灰色、绿地全是绿色）；</li>
<li>实例分割：不仅涂色，还给每一辆车、每一个行人单独编号。</li>
</ul>
<blockquote>
<p>图片占位建议：一张街景图的三种输出对比：
– 语义分割：所有车相同颜色；
– 实例分割：每辆车不同颜色；
– 并用箭头标出“同类不同实例”的区别。</p>
</blockquote>
<p><strong>Panoptic Segmentation（全景分割）简单点到为止</strong></p>
<p>在 COCO 等数据集中，还提出了 <strong>panoptic segmentation</strong>：
同时输出“语义类别 + 实例 ID”，并区分“thing 类”（可数的物体，如车、人）和“stuff 类”（背景材料，如天空、草地）。(<a href="https://cocodataset.org/?utm_source=chatgpt.com">cocodataset.org</a>)</p>
<p>这是语义分割和实例分割的统一视角，本书在后续更高级的场景理解部分可以再展开。</p>
<p><strong>在机器人中的角色</strong></p>
<ul>
<li>精准抓取与放置：知道物体的形状和边界，才能规划手爪接触点、避免夹到旁边物体。</li>
<li>可通行区域检测：语义分割可把“可走区域”（地面、台阶）与“不可走区域”（桌子、墙）区分出来，用于导航。</li>
<li>精细安全约束：机器人可以通过分割结果理解“人体的轮廓”，从而在靠近人体时自动减速或绕行。</li>
</ul>
<hr>
<h3 id="312-常见基准数据集imagenetcoco-等的作用"><a class="header" href="#312-常见基准数据集imagenetcoco-等的作用">3.1.2 常见基准数据集（ImageNet、COCO 等）的作用</a></h3>
<p>在深度学习时代，<strong>大规模标注数据集 + 标准评测协议</strong> 是推动视觉算法发展的关键基础设施：</p>
<ul>
<li>提供<strong>统一的“试卷”</strong>，方便比较不同模型的好坏；</li>
<li>提供大规模、多样化的数据，用于<strong>预训练通用视觉特征</strong>；</li>
<li>形成社区共识：大家默认在 ImageNet / COCO 等基准上“打分”，就像标准化考试成绩一样。</li>
</ul>
<p>在具身智能里，大多数视觉 backbone（ResNet、ViT 等）都来自这些数据集上的预训练模型，然后再迁移到机器人场景。</p>
<hr>
<h4 id="3121-imagenet"><a class="header" href="#3121-imagenet">3.1.2.1 ImageNet</a></h4>
<p><strong>基本情况</strong></p>
<p>ImageNet 是一个规模巨大的图像分类数据集，最经典的是 ILSVRC 使用的 <strong>ImageNet-1K</strong> 子集：</p>
<ul>
<li>1000 个类别；</li>
<li>约 128 万张训练图像、5 万张验证图像、10 万张测试图像。(<a href="https://www.image-net.org/download.php?utm_source=chatgpt.com">image-net.org</a>)</li>
<li>整个 ImageNet 项目总共包含 1400 万以上图像、2 万多个类别。(<a href="https://en.wikipedia.org/wiki/ImageNet?utm_source=chatgpt.com">维基百科</a>)</li>
</ul>
<p>从 2010 年开始，ImageNet 每年举办 <strong>ILSVRC 挑战赛</strong>，主要任务就是大规模图像分类和定位。2012 年 AlexNet 在 ImageNet 上大幅超越传统方法，被普遍视作深度学习在计算机视觉中爆发的起点。</p>
<p><strong>为什么对机器人仍然重要？</strong></p>
<p>尽管 ImageNet 中大多是互联网图片（和机器人摄像头看到的分布不完全一样），但：</p>
<ul>
<li>低层的边缘、纹理等特征具有较好的通用性；</li>
<li>在 ImageNet 上预训练的 CNN / ViT，在很多下游任务（检测、分割、机器人操作）上都展现出显著更快的收敛和更好的性能，这一点在大量论文中得到验证。</li>
</ul>
<p>因此，<strong>“从 ImageNet 预训练开始”几乎是视觉模型的默认选项</strong>，本书后面提到 ResNet、ViT 等 backbone 时，默认你已经知道它们通常是先在 ImageNet 上训练好的。</p>
<blockquote>
<p>图片占位建议：展示 ImageNet 一些类别示例（动物、工具、交通工具），以及挑战赛年份与错误率下降的简单折线图。</p>
</blockquote>
<hr>
<h4 id="3122-coco"><a class="header" href="#3122-coco">3.1.2.2 COCO</a></h4>
<p><strong>基本情况</strong></p>
<p>COCO（Common Objects in Context）是面向<strong>检测 + 分割 + 关键点 + 图像描述</strong>的综合性数据集：(<a href="https://cocodataset.org/?utm_source=chatgpt.com">cocodataset.org</a>)</p>
<ul>
<li>约 33 万张图像，其中约 20 万张带检测 / 分割 / 描述标注；</li>
<li><strong>80 个“thing”类</strong>（可数物体，如人、车、椅子等），并扩展出 91 个“stuff”类（天空、路面等）形成 COCO-Stuff，合计 172 类。(<a href="https://cocodataset.org/?utm_source=chatgpt.com">cocodataset.org</a>)</li>
<li>每张图配有 <strong>5 条图像描述（captions）</strong>，支持视觉–语言任务。(<a href="https://cocodataset.org/?utm_source=chatgpt.com">cocodataset.org</a>)</li>
<li>提供边界框、实例分割 mask、人体关键点（姿态）等丰富标注。</li>
</ul>
<p>COCO 的评测标准以 <strong>AP@[0.5:0.95]</strong> 为核心（后面 3.1.3 会详细解释），已经成为检测、实例分割论文中最常见的“成绩单格式”。</p>
<p><strong>COCO 的特点</strong></p>
<ul>
<li>“In Context”：强调<strong>物体在复杂背景中的关系</strong>，而不是简单白底产品图；</li>
<li>目标尺度变化大，小物体（如远处行人、路牌）较多，是检验模型鲁棒性的好试金石；</li>
<li>评测细致：按照小 / 中 / 大物体分别统计 AP，对检测大物体、小物体的能力都有要求。(<a href="https://docs.ultralytics.com/guides/yolo-performance-metrics/?utm_source=chatgpt.com">Ultralytics Docs</a>)</li>
</ul>
<p><strong>面向机器人的启示</strong></p>
<ul>
<li>用 COCO 预训练的检测器，是移动机器人和操作机器人常用的“起点模型”；</li>
<li>但 COCO 仍然是“互联网自然场景”，与具体实验室或工厂环境有 domain gap，因此在机器人系统中通常需要再做<strong>微调或增补专用数据</strong>。</li>
</ul>
<blockquote>
<p>图片占位建议：COCO 官方样例图：一张室内场景，标注出人、椅子、桌子等边界框 + 实例掩膜 + 文字描述。</p>
</blockquote>
<hr>
<h4 id="3123-其他数据集pascal-voccityscapeskitti-等"><a class="header" href="#3123-其他数据集pascal-voccityscapeskitti-等">3.1.2.3 其他数据集（Pascal VOC、Cityscapes、KITTI 等）</a></h4>
<p>本书后面会在机器人专用数据集章节进一步展开，这里只介绍几个对“经典视觉任务”很重要、同时和机器人密切相关的基准。</p>
<ol>
<li><strong>PASCAL VOC</strong></li>
</ol>
<ul>
<li>早期非常重要的目标检测 / 分割 / 分类基准；</li>
<li>典型年份（VOC2007 / 2012）包含约 20k 张图像，<strong>20 个常见类别</strong>（人、车、自行车、动物等），提供边界框和分割标注。(<a href="https://docs.ultralytics.com/datasets/detect/voc/?utm_source=chatgpt.com">Ultralytics Docs</a>)</li>
<li>使用 mAP@0.5 做为主要指标（后文解释），历史上很多经典检测器（Faster R-CNN、早期 YOLO 版本）都是首先在 VOC 上验证。</li>
</ul>
<p>VOC 如今在学术论文中使用较少，但仍是<strong>入门实践</strong>很好的数据集（规模适中、类别简单）。</p>
<ol start="2">
<li><strong>Cityscapes</strong></li>
</ol>
<p>专注于<strong>城市街景语义理解</strong>的数据集：(<a href="https://www.cityscapes-dataset.com/?utm_source=chatgpt.com">cityscapes-dataset.com</a>)</p>
<ul>
<li>在 50 个城市采集的街景双目视频序列；</li>
<li>5000 张图像具有<strong>高质量的像素级分割标注</strong>，额外 2 万张带粗标注；</li>
<li>主要任务：语义分割（路面、人行道、建筑、车辆、行人等）。</li>
</ul>
<p>Cityscapes 特别适合研究<strong>自动驾驶和城市移动机器人</strong>中的感知问题，是各种语义分割网络（FCN、DeepLab、PSPNet 等）的常用评测基准。</p>
<ol start="3">
<li><strong>KITTI</strong></li>
</ol>
<p>KITTI Vision Benchmark Suite 面向自动驾驶场景，提供 <strong>多模态传感器数据</strong>：(<a href="https://www.cvlibs.net/datasets/kitti/?utm_source=chatgpt.com">cvlibs.net</a>)</p>
<ul>
<li>采用配备多相机、LiDAR、GPS/IMU 的车辆采集；</li>
<li>提供 2D/3D 目标检测、立体匹配、光流、视觉里程计、语义分割等多个子任务；</li>
<li>3D 检测基准中，约 7k 训练图像、7k 测试图像，并配有点云标注。(<a href="https://www.cvlibs.net/datasets/kitti/eval_object.php?obj_benchmark=3d&amp;utm_source=chatgpt.com">cvlibs.net</a>)</li>
</ul>
<p>对具身智能来说，KITTI 是典型的“<strong>从 2D 到 3D 感知</strong>”过渡数据集，帮助你理解如何从相机 / LiDAR 获得三维信息。</p>
<blockquote>
<p>图片占位建议：三张小图拼在一起，分别展示
– VOC 中标注的边界框；
– Cityscapes 的街景语义分割伪彩色图；
– KITTI 的 2D 图像配合 3D 检测框和点云示意。</p>
</blockquote>
<hr>
<h3 id="313-评价指标mapiou-等"><a class="header" href="#313-评价指标mapiou-等">3.1.3 评价指标（mAP、IoU 等）</a></h3>
<p>前面机器学习基础部分已经介绍过“准确率、精确率、召回率”等通用指标。本节重点放在<strong>视觉检测/分割场景下常用的几个专门指标</strong>，并说明它们如何影响机器人系统的实际效果。</p>
<hr>
<h4 id="3131-准确率accuracy"><a class="header" href="#3131-准确率accuracy">3.1.3.1 准确率（Accuracy）</a></h4>
<p>在<strong>图像分类</strong>任务中，准确率定义很直接：</p>
<p>$$
\text{Accuracy} = \frac{\text{预测正确的样本数}}{\text{总样本数}}
$$</p>
<p>在 ImageNet 竞赛中，经常看到 <strong>Top-1 / Top-5 准确率</strong>：</p>
<ul>
<li>Top-1：预测概率最高的类别是否等于真实类别。</li>
<li>Top-5：真实类别是否出现在预测概率最高的前 5 个类别中。</li>
</ul>
<p>在机器人领域，分类准确率仍然有用，例如判断“当前场景类别”“开关状态”等。但对于 <strong>目标检测和分割</strong>：</p>
<ul>
<li>一个图像中可能有多个目标；</li>
<li>预测的是框 / 掩膜集合，而不是单一标签；</li>
</ul>
<p>此时简单的准确率已经不够，必须结合<strong>位置精度</strong>和<strong>多个预测之间的对应关系</strong>，这就引出了 IoU 和 mAP。</p>
<hr>
<h4 id="3132-平均精度均值map"><a class="header" href="#3132-平均精度均值map">3.1.3.2 平均精度均值（mAP）</a></h4>
<p><strong>1）核心思想：基于 Precision–Recall 曲线</strong></p>
<p>假设你训练了一个检测器，它对每个候选框输出一个置信度分数（score）。如果我们从高到低改变这个分数阈值：</p>
<ul>
<li>阈值高：只保留特别有信心的框，<strong>精确率（Precision）高</strong>，但漏检多，召回率低；</li>
<li>阈值低：检测更多目标，召回率高，但也引入许多假阳性，精确率下降。</li>
</ul>
<p>在每个阈值下，我们都可以计算一对 ((P, R))，在平面上连起来就是一条 <strong>Precision–Recall 曲线</strong>。</p>
<blockquote>
<p>图片占位建议：一条典型的 P–R 曲线，并用阴影区域表示“曲线下的面积”。</p>
</blockquote>
<p><strong>2）单类别的 AP（Average Precision）</strong></p>
<p>对某一个类别，<strong>AP 就是 P–R 曲线下面积</strong>，数值范围在 0–1 之间：(<a href="https://www.v7labs.com/blog/mean-average-precision?utm_source=chatgpt.com">v7labs.com</a>)</p>
<ul>
<li>AP 越高，说明在各种阈值下，这个类别的精确率和召回率整体越好；</li>
<li>AP 会受到 <strong>IoU 阈值</strong> 的影响：要先用 IoU 决定每个预测框是否算“正确”（下节讲）。</li>
</ul>
<p><strong>3）多类别的 mAP（mean Average Precision）</strong></p>
<p>如果有 (C) 个类别，可以对每个类别分别算一遍 AP，然后取平均：</p>
<p>$$
\text{mAP} = \frac{1}{C}\sum_{c=1}^{C} AP_c
$$</p>
<p>mAP 提供一个单一数字，方便比较模型整体性能。</p>
<p><strong>4）VOC mAP vs COCO AP</strong></p>
<p>这里需要特别指出：不同数据集对 “mAP” 的定义略有不同：</p>
<ul>
<li><strong>PASCAL VOC</strong>：
<ul>
<li>传统上使用 AP@0.5：即只在 IoU ≥ 0.5 的情况下计算 AP；</li>
<li>mAP 就是 20 个类别 AP@0.5 的平均。(<a href="https://docs.ultralytics.com/datasets/detect/voc/?utm_source=chatgpt.com">Ultralytics Docs</a>)</li>
<li>指标相对宽松，对框定位要求不那么苛刻。</li>
</ul>
</li>
<li><strong>COCO</strong>：
<ul>
<li>使用更严格的 <strong>AP@[0.50:0.95]</strong>：在 0.5, 0.55, …, 0.95 共 10 个 IoU 阈值下分别计算 AP，然后取平均；(<a href="https://kharshit.github.io/blog/2019/09/20/evaluation-metrics-for-object-detection-and-segmentation?utm_source=chatgpt.com">kharshit.github.io</a>)</li>
<li>COCO 文档常直接把这个量记为 AP，也就是所谓 “COCO mAP”；</li>
<li>还会报告 AP50、AP75 等子指标。</li>
</ul>
</li>
</ul>
<p>这种设计使得 COCO 的 AP 对“定位偏差”更加敏感：框稍微画不准，IoU 从 0.9 掉到 0.5，多数阈值下都会受到惩罚。</p>
<p><strong>5）阅读论文和工程实践时的注意事项</strong></p>
<ul>
<li>看别人报 “mAP = 40” 时，一定要确认是 VOC@0.5** 还是 COCO@[0.5:0.95]**，两者差别非常大；</li>
<li>对机器人任务，如果偏重“是否发现目标”，AP50 更相关；如果关心“抓取位置是否足够精确”，更严格的 AP75 或 COCO AP@[0.5:0.95] 更有意义；</li>
<li>在自建数据集时，建议沿用 <strong>COCO 风格评测</strong>，避免只在单一 IoU 阈值上评价。</li>
</ul>
<hr>
<h4 id="3133-交并比iouintersection-over-union"><a class="header" href="#3133-交并比iouintersection-over-union">3.1.3.3 交并比（IoU，Intersection over Union）</a></h4>
<p><strong>1）定义</strong></p>
<p>IoU 是衡量两个区域重叠程度的指标，广泛用于目标检测和分割评估。给定预测区域 (A) 和真值区域 (B)：</p>
<p>$$
IoU(A, B) = \frac{|A \cap B|}{|A \cup B|}
$$</p>
<ul>
<li>完全重合：IoU = 1；</li>
<li>完全不相交：IoU = 0；</li>
<li>部分重叠：介于 0 和 1 之间。</li>
</ul>
<p>在目标检测中，(A) 和 (B) 是两个矩形框；在分割中，则是两个像素集合。(<a href="https://learnopencv.com/intersection-over-union-iou-in-object-detection-and-segmentation/?utm_source=chatgpt.com">learnopencv.com</a>)</p>
<blockquote>
<p>图片占位建议：两个矩形框的重叠示意图，用不同颜色涂出交集和并集，并标出 IoU = 交集面积 / 并集面积。</p>
</blockquote>
<p><strong>2）在评测中的用法</strong></p>
<ul>
<li>在 <strong>目标检测</strong> 中，通常先设定一个 IoU 阈值，例如 0.5：
<ul>
<li>如果预测框与某个真值框的 IoU ≥ 0.5，则认为是一次 True Positive（正确检测）；</li>
<li>否则是 False Positive（错误检测），或者如果真值框没有被任何预测框“覆盖”，则记为 False Negative（漏检）。(<a href="https://wikidocs.net/177706?utm_source=chatgpt.com">wikidocs.net</a>)</li>
</ul>
</li>
<li>在 <strong>分割</strong> 中，IoU 常直接用作主要指标（也称 Jaccard 指数），表示预测掩膜与真值掩膜的重叠程度。(<a href="https://wikidocs.net/177706?utm_source=chatgpt.com">wikidocs.net</a>)</li>
</ul>
<p>IoU 是 mAP 计算的基础：只有知道每个预测是 TP 还是 FP，才能画精确率–召回率曲线，从而得到 AP / mAP。</p>
<p><strong>3）对机器人的含义</strong></p>
<ul>
<li>对移动机器人来说，检测到障碍物就行，框的边缘偏差一点问题不大，IoU 0.5 可能已经足够；</li>
<li>对精细操作（插销、抓小物体）来说，即使 IoU 达到 0.7、0.8，也可能意味着末端位置偏差数厘米，对任务成功率有明显影响；</li>
<li>因此，在具体工程中，应该根据任务容忍误差的大小，选择合适的 IoU 阈值和指标（如 AP75、AP@[0.75:0.95]）。</li>
</ul>
<hr>
<p>小结一下这一节的逻辑：</p>
<ul>
<li><strong>图像分类 → 检测 → 分割</strong>，是视觉理解精度不断提高的三个层级；</li>
<li><strong>ImageNet / COCO / VOC / Cityscapes / KITTI</strong> 等数据集，提供了从分类、检测、分割到 3D 感知的一整套“训练场”；</li>
<li><strong>IoU 和 mAP</strong> 是连接“模型输出”和“我们如何评价它”的关键纽带，它们的具体定义（VOC vs COCO）会直接影响结论解读。</li>
</ul>
<p>在后续 3.2 及以后的章节，我们会从特征表示（ResNet、ViT、自监督）和三维几何的角度，进一步讨论如何让这些视觉能力真正服务于具身智能和机器人控制。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="视觉特征与表示学习"><a href="#视觉特征与表示学习" class="header">视觉特征与表示学习</a></h1>
<p><img src="https://cdn.nlark.com/yuque/0/2025/jpeg/12879689/1763976271512-4855259b-9948-4206-ae85-0442eb2e8146.jpeg" alt=""></p>
<p>注：上面只是示意图，实际书稿中建议用自绘或重画的简洁示意图替换。</p>
<hr>
<h2 id="32-视觉特征与表示学习节选"><a class="header" href="#32-视觉特征与表示学习节选">3.2 视觉特征与表示学习（节选）</a></h2>
<p>本节聚焦“视觉 backbone 究竟在学什么”。从卷积的层级特征，到 Vision Transformer 的 patch-token 表示，再到自监督预训练与迁移使用方式，这一节是后面 VLM / VLA 模型视觉部分的“放大镜”。</p>
<hr>
<h3 id="321-卷积特征与层级表示直觉"><a class="header" href="#321-卷积特征与层级表示直觉">3.2.1 卷积特征与层级表示直觉</a></h3>
<p>卷积神经网络（CNN）已经被证明会自动学习出从边缘、纹理到物体部件、完整对象的分层表征，与生物视觉皮层中从 V1 到 IT 的层级处理有相似之处。(<a href="https://arxiv.org/abs/1311.2901?utm_source=chatgpt.com">arXiv</a>) 对机器人来说，这意味着：同一个相机画面，在不同层中被编码成不同抽象层级的信息，为后续抓取、导航、场景理解提供基础。</p>
<h4 id="3211-卷积网络的层级特征"><a class="header" href="#3211-卷积网络的层级特征">3.2.1.1 卷积网络的层级特征</a></h4>
<p>可以把卷积核看成一块块可学习的小“模板”，在图像上滑动，检测某种局部模式是否出现。早期层的模板非常“原始”，后期层变得“语义化”。</p>
<ul>
<li><strong>低层特征：边缘和纹理</strong></li>
</ul>
<p>在第一、二层卷积中，可视化滤波器时，经常能看到“Gabor 滤波器”式的条纹、斑点、方向性边缘等。(<a href="https://arxiv.org/abs/1311.2901?utm_source=chatgpt.com">arXiv</a>)
对机器人来说，这一层类似回答“这里有一条明暗边界”“这里有一段重复纹理”的问题，有助于后续识别桌沿、物体轮廓。</p>
<ul>
<li><strong>中层特征：局部图形和部件</strong></li>
</ul>
<p>随着网络加深，卷积层的感受野（能“看到”的输入区域）逐渐变大，中层卷积核开始响应更复杂的局部结构，比如圆形角落、T 字交界、物体的一部分（杯把、车轮、门把手等）。这些特征已经脱离“几何原始元素”，开始向“物体部件”靠拢。(<a href="https://www.spiedigitallibrary.org/journals/Optical-Engineering/volume-58/issue-04/040901/Development-of-convolutional-neural-network-and-its-application-in-image/10.1117/1.OE.58.4.040901.full?utm_source=chatgpt.com">SPIE Digital Library</a>)</p>
<ul>
<li><strong>高层特征：对象和类别级模式</strong></li>
</ul>
<p>在靠近分类头的高层卷积中，特征往往与具体类别强相关，例如“狗头”“键盘区域”“车前脸”等高度语义化的激活。Zeiler &amp; Fergus 的可视化工作表明，高层 feature map 上，一整块区域常常只在特定类别图像中被激活。(<a href="https://arxiv.org/abs/1311.2901?utm_source=chatgpt.com">arXiv</a>)</p>
<p>【插图占位 3.2.1-1】
“CNN 不同层的卷积核与激活可视化”：
左侧为浅层卷积核（类似边缘检测器）；中间为中层对纹理与局部形状的响应；右侧为高层对物体部件/对象的响应。用一张输入图（如桌面上有杯子）对应三层 feature map 激活。</p>
<p>在具身智能场景中，可以这样理解：当机械臂视觉系统通过 ResNet 看一张桌面图像时，早期层主要检测各种边缘和纹理（桌沿、物体阴影），中层开始形成“杯子边缘”“盒子角”等部件特征，高层则直接形成“杯子”“蓝色盒子”等对象级特征，供上层任务（如“抓起杯子”）使用。</p>
<h4 id="3212-特征图feature-map"><a class="header" href="#3212-特征图feature-map">3.2.1.2 特征图（Feature Map）</a></h4>
<p>卷积操作对输入图像进行处理后，输出的是一个多通道的张量，通常记作大小为 (H \times W \times C)：</p>
<ul>
<li>(H, W)：空间维度，对应图像在当前层的分辨率；</li>
<li>(C)：通道数，每个通道就是一个 <strong>feature map</strong>，代表某个卷积核在整幅图上的“响应强度图”。</li>
</ul>
<p>可以把 feature map 看成：“对于这一种视觉模式，每个像素位置匹配的程度是多少”。例如某个通道专门响应“垂直边缘”，那在所有垂直物体边缘的位置，这个通道的值会比较大。</p>
<p>随着网络前进，卷积步长和池化层会逐步降低 (H,W)，而提高通道数 (C)。这意味着：</p>
<ul>
<li><strong>空间分辨率下降</strong>：单个激活对应的物理区域更大；</li>
<li><strong>通道维表达能力增强</strong>：每一个空间位置上，C 维向量可以编码非常丰富的语义。</li>
</ul>
<p>这样的结构自然形成了<strong>多尺度特征金字塔</strong>：浅层 feature map 分辨率高，适合描述精细边界和小物体；深层 feature map 分辨率低、语义强，适合理解“这块区域大致是什么东西”。</p>
<p>【插图占位 3.2.1-2】
“Feature Map 尺寸变化示意”：
画出一张输入图像，经过多层卷积+池化后 feature map 的形状从 (224\times224\times3) 变为 (112\times112\times64)、(56\times56\times128)…直至 (7\times7\times2048)，用不同颜色方块表示不同通道。</p>
<p>在机器人应用中，这些 feature map 通常不会直接显示，而是输入到检测头、抓取预测头或下游 Transformer 中，作为视觉语义的“压缩表达”。</p>
<h4 id="3213-层级表示直觉"><a class="header" href="#3213-层级表示直觉">3.2.1.3 层级表示直觉</a></h4>
<p>总结起来，卷积网络的层级表示有几个直观要点：</p>
<ol>
<li><strong>从局部到全局</strong>
早期层只“看见”局部几像素，后期层的感受野可以覆盖图像中很大的区域甚至全图，逐步整合上下文。</li>
<li><strong>从具体到抽象</strong>
表征从“这有条边”“这里有条纹理”逐渐演化为“这个区域像是一个杯子”“这大概是桌面的一角”。这种从低级特征到高级语义的抽象，与认知科学中人类视觉皮层的层级处理趋势相似。(<a href="https://www.sciencedirect.com/science/article/pii/S014193822200066X?utm_source=chatgpt.com">ScienceDirect</a>)</li>
<li><strong>局部平移不变性和结构先验</strong>
卷积核在整幅图上共享权重，让网络天然对小范围平移具有不变性。这种强归纳偏置使 CNN 在中等规模数据集上非常高效、稳定，但也导致其对更复杂的长程关系（如远处两个物体之间的关系）建模能力有限。</li>
</ol>
<p>对具身智能来说，这意味着：如果任务主要依赖局部形状与纹理（例如检测桌沿、防止跌落、识别可抓取边缘），卷积 backbone 通常已经足够；而当任务涉及复杂全局关系（例如“把桌面最左边的杯子移到靠近门的那边”），我们更希望有能力建模“全局 patch 之间关系”的结构——这正是 Vision Transformer 要解决的问题。</p>
<hr>
<h3 id="322-视觉-transformervit的基本结构"><a class="header" href="#322-视觉-transformervit的基本结构">3.2.2 视觉 Transformer（ViT）的基本结构</a></h3>
<p>Vision Transformer（ViT）直接把图像视为一串“视觉 token”，用 Transformer 编码器处理，从而将 NLP 中已经验证有效的全局自注意力机制引入视觉。(<a href="https://arxiv.org/pdf/2010.11929?utm_source=chatgpt.com">arXiv</a>)</p>
<h4 id="3221-图像分块"><a class="header" href="#3221-图像分块">3.2.2.1 图像分块</a></h4>
<p>经典 ViT 的第一步是 <strong>图像分块（patch embedding）</strong>：</p>
<ol>
<li>给定一幅大小为 (H \times W \times C) 的图像；</li>
<li>使用固定大小的 patch（如 (P \times P)）将图像划分为 (N = \frac{HW}{P^2}) 个不重叠的小块；</li>
<li>每个 patch 展平为长度 (P^2 C) 的向量，并通过一个线性层投影到 (D) 维，得到一个 token；</li>
<li>所有 patch token 组成长度为 (N) 的序列，再<strong>加上一个 learnable 的 class token</strong>，总长度为 (N+1)；</li>
<li>再加上可学习的<strong>位置编码</strong>，以保留 patch 的空间位置信息。(<a href="https://arxiv.org/pdf/2010.11929?utm_source=chatgpt.com">arXiv</a>)</li>
</ol>
<p>【插图占位 3.2.2-1】
“ViT patch embedding 架构”：
左侧是一张输入图像，被切成若干 (P\times P) 的小 patch；每个 patch 展平后通过线性层映射为 D 维向量；所有 patch token 与一个 class token 拼接成序列，并加上位置编码输入 Transformer encoder。</p>
<p>在机器人视角下，可以理解为：摄像头拍到的画面首先被离散为几十到上百个“小视野格子”，每个格子由一个向量描述。后续的自注意力层决定这些格子之间如何互相“交流”。</p>
<h4 id="3222-自注意力在图像中的应用"><a class="header" href="#3222-自注意力在图像中的应用">3.2.2.2 自注意力在图像中的应用</a></h4>
<p>在 ViT 中，Transformer 编码器对 token 序列应用多层 <strong>自注意力（self-attention）</strong>：</p>
<ul>
<li>每个 patch token 通过线性变换产生 Query / Key / Value；</li>
<li>每个 patch 的 Query 与所有 patch 的 Key 计算相似度，经 softmax 得到注意力权重；</li>
<li>使用权重对 Value 做加权和，得到融合了全局信息的新表示。(<a href="https://d2l.ai/chapter_attention-mechanisms-and-transformers/vision-transformer.html?utm_source=chatgpt.com">d2l.ai</a>)</li>
</ul>
<p>直觉上，这相当于：<strong>每个 patch 决定“应该向哪些其他位置要信息”</strong>。例如在桌面场景中：</p>
<ul>
<li>表示“杯子”的 patch 可能会关注桌面边缘（判断杯子是否在边缘，是否安全）；</li>
<li>表示“目标盒子”的 patch 会关注周围障碍物 patch，辅助规划路径。</li>
</ul>
<p>多头注意力让不同“注意力头”在不同子空间内学习不同的关注模式：有的头关注近邻局部纹理，有的头捕捉对称、重复结构，有的头专门建模远距离物体间的关联。(<a href="https://wikidocs.net/237408?utm_source=chatgpt.com">wikidocs.net</a>)</p>
<p>与 CNN 相比，自注意力有两大关键差异：</p>
<ul>
<li><strong>显式全局建模</strong>：每个位置可以直接与任意位置交互，而不需要堆叠许多局部卷积才能间接感知远处；</li>
<li><strong>归纳偏置更弱</strong>：不强假设局部平移不变性，网络在足够数据上可以学习更丰富的模式，但在小数据集上也更容易过拟合或训练不稳定。</li>
</ul>
<h4 id="3223-vit-特点"><a class="header" href="#3223-vit-特点">3.2.2.3 ViT 特点</a></h4>
<p>综合来说，ViT 作为视觉 backbone 具有以下特点：(<a href="https://arxiv.org/pdf/2010.11929?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>全局视野与强表示能力</strong></li>
</ol>
<p>自注意力使得 ViT 在每一层就能获取全局信息，对复杂布局、长程关系建模有天然优势。在大规模预训练（如 ImageNet-21k 或图文对齐数据）下，ViT 在分类、检测、分割等任务上已经超越或媲美同规模 CNN。</p>
<ol start="2">
<li><strong>对数据量敏感</strong></li>
</ol>
<p>由于缺乏 CNN 那种强的局部归纳偏置，ViT 在小数据集从头训练通常表现不佳，需要：</p>
<pre><code>- 借助大规模有监督或自监督预训练；
- 或在结构中引入层次化、局部窗口（如 Swin Transformer 一类）。
</code></pre>
<ol start="3">
<li><strong>与自监督方法高度契合</strong></li>
</ol>
<p>ViT 的“token 化”结构与掩码建模（MAE 等）天然匹配，在自监督框架下表现尤为突出，这是后续 3.2.3 将重点展开的内容。(<a href="https://arxiv.org/abs/2111.06377?utm_source=chatgpt.com">arXiv</a>)</p>
<ol start="4">
<li><strong>对机器人应用的影响</strong>
<ul>
<li>在算力足够（如云端推理或高性能边缘设备）且数据丰富时，可使用 ViT/层次 Transformer backbone 作为机器人视觉主干，更好地理解复杂场景；</li>
<li>在实时性、算力严苛的场景中，往往采用轻量化 Transformer 变体，或与 CNN 混合使用，以兼顾性能与速度。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="323-自监督视觉表征对比学习mae-等基本思想"><a class="header" href="#323-自监督视觉表征对比学习mae-等基本思想">3.2.3 自监督视觉表征（对比学习、MAE 等基本思想）</a></h3>
<p>对于具身智能而言，最稀缺的不是图像，而是 <strong>高质量标注和示教</strong>。机器人可以 24 小时拍视频，但人类不可能 24 小时在旁边标注。这使得“<strong>如何利用大量未标注视觉数据学习通用表示</strong>”成为关键问题，自监督学习正是目前最主流的答案之一。(<a href="https://link.springer.com/article/10.1007/s10994-024-06708-7?utm_source=chatgpt.com">SpringerLink</a>)</p>
<h4 id="3231-对比学习"><a class="header" href="#3231-对比学习">3.2.3.1 对比学习</a></h4>
<p>对比学习（contrastive learning）的核心想法是：<strong>把“同一个事物的不同观察”拉近，把“不同事物”拉远</strong>。在视觉自监督中，常见做法是“实例判别（instance discrimination）”：每张图像被视为自己的“类别”。(<a href="https://openaccess.thecvf.com/content/ICCV2021/papers/Zhao_Self-Supervised_Visual_Representations_Learning_by_Contrastive_Mask_Prediction_ICCV_2021_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</p>
<p>典型框架（SimCLR、MoCo 等）的基本流程：</p>
<ol>
<li>对同一张原始图像做两次随机数据增强（裁剪、翻转、颜色抖动、模糊等），得到两张“视角不同”的图像；</li>
<li>使用共享参数的编码器（CNN 或 ViT）分别将这两张图像映射到特征向量；</li>
<li>通过一个小的投影头（MLP）映射到对比空间；</li>
<li>设计对比损失（如 InfoNCE）：
<ul>
<li>把这两个来自同一图像的向量视为“正样本对”；</li>
<li>与 batch 中其他图像的向量作为“负样本”；</li>
<li>优化目标是让正样本对在特征空间距离更近，负样本更远。</li>
</ul>
</li>
</ol>
<p>直觉上，相当于告诉网络：“即便这杯子的姿态、光照改变，它在特征空间也应该是同一个‘点附近’。”
训练完成后，编码器就学到了一种对常见变化（旋转、光照、轻微遮挡）<strong>不敏感、但对语义差异敏感</strong>的特征。</p>
<p>在机器人场景中：</p>
<ul>
<li>正样本可以是同一次操作的不同帧，或同一物体在不同位置、不同抓取阶段的图像；</li>
<li>负样本是其他物体或其他任务场景；</li>
</ul>
<p>这样，机器人在没有任何“类别标签”的情况下，就能学会“哪些图像属于同一事物或同一过程”，为后续的抓取预测或策略学习提供基础特征。</p>
<h4 id="3232-掩码图像建模mae"><a class="header" href="#3232-掩码图像建模mae">3.2.3.2 掩码图像建模（MAE）</a></h4>
<p>对比学习强调“区分”，而 <strong>掩码图像建模（Masked Image Modeling, MIM）</strong> 更强调“重建”。其中影响力最大的工作之一就是 MAE（Masked Autoencoders）。(<a href="https://arxiv.org/abs/2111.06377?utm_source=chatgpt.com">arXiv</a>)</p>
<p>MAE 的关键思想：</p>
<ol>
<li>仍然基于 ViT 的 patch 表示，将图像切成若干 patch；</li>
<li><strong>随机遮挡大部分 patch（例如 75%）</strong>，只保留少量可见 patch；</li>
<li>编码器（ViT encoder）只处理可见 patch，生成其高维表示；</li>
<li>将可见 patch 表示与位置编码、掩码标记一起输入一个轻量解码器；</li>
<li>解码器的任务是<strong>重建被遮挡部分的像素</strong>（或某种压缩形式，如低分辨率图）。</li>
</ol>
<p>重要特性有两点：</p>
<ul>
<li><strong>极高遮挡比例</strong>：迫使模型必须真正理解全局结构，而不是简单“补纹理”；</li>
<li><strong>编码器轻负载</strong>：只对可见 patch 计算自注意力，大幅节约计算，特别适合大规模预训练。(<a href="https://arxiv.org/abs/2111.06377?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>直觉上，MAE 要求模型回答的问题是：“在只看见一小部分图像补丁的情况下，这张图合理的完整样子是什么？”
这使得模型必须学到：</p>
<ul>
<li>物体典型形状（杯子大致是圆柱、桌子是平面等）；</li>
<li>背景与物体的相互约束关系；</li>
<li>不同 patch 之间的纹理、颜色、结构一致性。</li>
</ul>
<p>在机器人应用中，遮挡是常态——机械臂自己会挡住部分视野，桌面物体会相互遮挡。通过 MAE 预训练的 ViT 在面对大面积遮挡、视角变化时，往往比纯监督训练的模型更稳健。后续还有很多基于 MIM 的变体，扩展到视频、点云等模态，在这里不展开。(<a href="https://www.sciencedirect.com/science/article/abs/pii/S1361841525003160?utm_source=chatgpt.com">ScienceDirect</a>)</p>
<p>【插图占位 3.2.3-1】
“MAE 自监督框架”：
左侧为原始图像和其 patch；中间展示随机遮挡的 patch（大面积灰块）；右侧是编码器只处理可见 patch，解码器重建完整图像的流程图。</p>
<h4 id="3233-自监督的意义"><a class="header" href="#3233-自监督的意义">3.2.3.3 自监督的意义</a></h4>
<p>自监督视觉学习对具身智能的意义，并不仅仅是“省标签”，更深层的价值在于：</p>
<ol>
<li><strong>大幅提高数据利用率</strong></li>
</ol>
<p>现实中很容易收集到“机器人看到的一切”：摄像头视频、深度图、点云等。但完整标注每一帧中的物体、语义、动作几乎不可能。自监督允许我们用这些原始数据构建大规模预训练语料库，让视觉 backbone 从“无标签的观察”中学习世界的结构。(<a href="https://link.springer.com/article/10.1007/s10994-024-06708-7?utm_source=chatgpt.com">SpringerLink</a>)</p>
<ol start="2">
<li><strong>得到更通用、与任务无关的表示</strong></li>
</ol>
<p>和在单一标注任务（比如 ImageNet 分类）上训练得到的特征相比，对比学习和 MAE 这种预训练方式往往给出更“面向世界”的表征——它们捕捉到的是一般性的视觉规律，而不是某个数据集里特定类别的边界。因此，在目标检测、分割、3D 理解乃至机器人策略学习上迁移时，都更容易适配。</p>
<ol start="3">
<li><strong>为世界模型和长期规划打基础</strong></li>
</ol>
<p>重建式自监督（如 MAE）和时序预测式自监督（预测下一帧、未来轨迹）本质上都是在学习“如果世界缺了一部分信息，我能不能根据上下文补完”的能力。这种能力对于构建具身智能的“世界模型”至关重要，是后续章节（例如 9.3、12.1）要讨论的核心方向之一。</p>
<ol start="4">
<li><strong>实际工程中的策略</strong></li>
</ol>
<p>对一个真实机器人平台，常见做法是：</p>
<pre><code>- 长时间录制未标注视频，构建视觉自监督预训练数据；
- 先用对比学习或 MAE 预训练视觉 backbone；
- 再用少量示教数据、标注任务数据微调到具体操作任务上（抓取、分类、可抓取检测等）。
</code></pre>
<p>这种“先学看，再学做”的范式，在多模态 VLM/VLA 模型中会进一步扩展为“先学看 + 听（视觉 + 语言），再学做（动作）”。</p>
<hr>
<h3 id="324-视觉-backbone-的选择与迁移resnetvit-等"><a class="header" href="#324-视觉-backbone-的选择与迁移resnetvit-等">3.2.4 视觉 Backbone 的选择与迁移（ResNet、ViT 等）</a></h3>
<p>在具身系统中，视觉 backbone 不只是一个“分类器的前半部分”，而是整个系统对世界的主要感知入口。选择何种 backbone，以及如何迁移预训练权重，对最终性能、实时性、部署成本都有直接影响。</p>
<p>这里重点讨论两类主力骨干：ResNet（典型 CNN）与 ViT（典型 Transformer），以及它们在迁移学习中的常见用法。</p>
<h4 id="3241-resnet"><a class="header" href="#3241-resnet">3.2.4.1 ResNet</a></h4>
<p>ResNet（Residual Network）的核心思想是引入 <strong>残差连接</strong>，即让每一层只需要学习相对于输入的“增量”。这极大缓解了深层网络中的梯度消失问题，使得 50 层、101 层甚至更深的 CNN 训练变得可行。(<a href="https://www.spiedigitallibrary.org/journals/Optical-Engineering/volume-58/issue-04/040901/Development-of-convolutional-neural-network-and-its-application-in-image/10.1117/1.OE.58.4.040901.full?utm_source=chatgpt.com">SPIE Digital Library</a>)</p>
<p>从视觉 backbone 的角度看，ResNet 有几个工程上非常重要的特点：</p>
<ol>
<li><strong>强归纳偏置与稳定性能</strong></li>
</ol>
<p>标准的卷积+池化+残差结构，使得 ResNet 在中等规模数据集上具有极高的收敛稳定性和泛化能力。即便没有大规模自监督预训练，直接在任务数据上微调也常能得到不错的结果。</p>
<ol start="2">
<li><strong>成熟的工具链与硬件友好性</strong></li>
</ol>
<p>各种深度学习框架和推理引擎对卷积操作高度优化，在嵌入式 GPU、加速器上都有现成的高效实现；因此 ResNet 类 backbone 在移动机器人、嵌入式机械臂上非常常见。</p>
<ol start="3">
<li><strong>多尺度特征易于复用</strong></li>
</ol>
<p>ResNet 的分层结构天然适合构造特征金字塔（如 FPN），用于目标检测、实例分割等任务——这些任务又恰恰是机器人抓取、障碍检测的基础模块。(<a href="https://www.spiedigitallibrary.org/journals/Optical-Engineering/volume-58/issue-04/040901/Development-of-convolutional-neural-network-and-its-application-in-image/10.1117/1.OE.58.4.040901.full?utm_source=chatgpt.com">SPIE Digital Library</a>)</p>
<p>在具身智能的实践中，一条常见经验是：</p>
<ul>
<li><strong>初期实验 / 小规模项目</strong>：优先选用 ResNet-18 / 34 等轻量骨干，保证训练和部署简单、鲁棒；</li>
<li><strong>性能要求更高</strong>：可升级到 ResNet-50 / 101 加 FPN，用于精度更高的场景理解，再将结果提供给上层 VLA 决策模块。</li>
</ul>
<h4 id="3242-vit"><a class="header" href="#3242-vit">3.2.4.2 ViT</a></h4>
<p>相比之下，ViT 系列 backbone 更“现代”，也更依赖大规模预训练。当前主流开源模型（如 <code>vit-base-patch16-224</code> 等）通常先在 ImageNet-21k 等大数据集上预训练，再在 ImageNet-1k 上微调。(<a href="https://huggingface.co/google/vit-base-patch16-224?utm_source=chatgpt.com">Hugging Face</a>)</p>
<p>作为视觉 backbone，ViT 有几方面的特点：</p>
<ol>
<li><strong>全局建模能力</strong></li>
</ol>
<p>利用自注意力，ViT 对全图 patch 之间的关系进行显式建模，尤其有利于需要理解复杂场景关系的任务，例如：</p>
<pre><code>- 判断多个物体之间的相对位置（哪一个“更靠近门口”）；
- 推理遮挡关系（哪个物体被挡住、相对深度）。
</code></pre>
<ol start="2">
<li><strong>与图文预训练、VLM 的天然适配</strong></li>
</ol>
<p>ViT 常被用作图文对齐模型（如 CLIP）中的视觉编码器，学习到的特征与语言空间对齐良好，非常适合直接用作机器人 VLM/VLA 模型的视觉 backbone。(<a href="https://arxiv.org/html/2510.04794v1?utm_source=chatgpt.com">arXiv</a>)</p>
<ol start="3">
<li><strong>在大数据下优于 CNN，小数据下需谨慎</strong></li>
</ol>
<p>多项比较研究显示，当训练和预训练数据足够大时，ViT 在分类、识别类任务上的表现可以显著超越或至少不弱于同规模 ResNet。(<a href="https://arxiv.org/html/2510.04794v1?utm_source=chatgpt.com">arXiv</a>)
但在小数据集、从头训练或迁移数据分布与预训练差异很大时，原始 ViT 可能难以训练稳定，这时需要：</p>
<pre><code>- 使用 MAE/对比学习等自监督权重；
- 或采用带卷积前端、窗口注意力的改进架构（如 Swin、ConvNeXt 等）。
</code></pre>
<p>在具身智能系统中，常见的一种组合是：<strong>语言–视觉对齐用 ViT（或其变体），低层几何理解和实时感知仍以 CNN 为主</strong>，二者通过特征融合或多任务训练结合起来。</p>
<h4 id="3243-迁移学习"><a class="header" href="#3243-迁移学习">3.2.4.3 迁移学习</a></h4>
<p>无论使用 ResNet 还是 ViT，视觉 backbone 在机器人任务中几乎总是以“预训练 + 迁移”的方式出现，而不是从零开始训练。迁移学习通常包含几个关键决策：(<a href="https://arxiv.org/html/2301.05712v4?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>选择预训练来源</strong>
<ul>
<li>经典监督预训练：如 ImageNet 分类；</li>
<li>自监督预训练：对比学习（SimCLR、MoCo、DINO 等）、MAE 等；</li>
<li>多模态预训练：图文对齐模型（CLIP 风格）、视频自监督等。</li>
</ul>
</li>
</ol>
<p>对机器人来说，多模态和自监督预训练往往更有优势，因为它们捕捉到的是更通用的世界结构，而不是某个特定分类任务。</p>
<ol start="2">
<li><strong>“冻结 vs 全量微调 vs 参数高效微调”</strong>
<ul>
<li><strong>冻结特征 + 训练任务头</strong>：适合数据较少、算力有限、对性能要求不极致的场景；</li>
<li><strong>全量微调</strong>：适合数据相对充足、希望 backbone 充分适应特定场景（特殊光照、视角、相机）的情况；</li>
<li><strong>参数高效微调（Adapter / LoRA 等）</strong>：在不修改大部分预训练权重的前提下，仅训练少量插入模块，达到较好适应能力，又控制了训练成本；这与第 2.5.3 节中语言模型微调的思想完全一致。</li>
</ul>
</li>
<li><strong>根据任务和资源选择 backbone 类型</strong></li>
</ol>
<p>一个实用的经验表，可以帮助在具身智能项目中快速做出初步选择：</p>
<pre><code>- **小数据集 + 强实时性 + 嵌入式设备**
</code></pre>
<p>→ 轻量 CNN（ResNet-18/34、MobileNet 等），使用 ImageNet 或自监督预训练权重，冻结大部分层，仅微调最后几层和任务头。
- <strong>中等数据规模 + 单一场景（固定工位、固定相机）</strong>
→ 可以使用更深的 ResNet 或轻量 ViT / Swin；优先使用自监督预训练权重（SimCLR/MoCo/MAE）以提高数据效率。
- <strong>大规模多场景数据 + 多任务机器人平台</strong>
→ 优先使用 ViT 或层次 Transformer backbone（如 Swin）、甚至直接采用 CLIP-ViT 或 MAE-ViT 作为视觉模块，与大语言模型共同组成 VLM / VLA 系统。在这种情况下，视觉编码器的能力将成为整个系统泛化能力的关键瓶颈之一。</p>
<p>【插图占位 3.2.4-1】
“视觉 backbone 迁移流程”：
画出一个从左到右的流程：
“大规模预训练数据（ImageNet/图文/未标注视频）” → “预训练视觉 backbone（ResNet/ViT）” → “加入机器人特定任务头（检测、抓取预测等）” → “在机器人任务数据上微调（可选：冻结部分层、Adapter 微调）”。</p>
<p>在后续章节中，视觉 backbone 会以多种角色重复出现：在第 4 章中作为图文对齐模型的一部分，在第 8 章中作为 VLA 统一模型的视觉输入模块。读者理解了本节中 CNN 层级特征与 ViT patch-token 表示、自监督预训练与迁移学习的基本思路，就具备了“读懂后面模型结构图中视觉那一坨方块究竟干什么”的能力。接下来，我们会在 3.3 节进一步将 2D 视觉表示延伸到 3D 场景理解，为机器人在物理世界中行动铺路。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="场景理解与-3d-信息"><a href="#场景理解与-3d-信息" class="header">场景理解与 3D 信息</a></h1>
<h3 id="331-多视角几何与相机模型基本概念"><a class="header" href="#331-多视角几何与相机模型基本概念">3.3.1 多视角几何与相机模型基本概念</a></h3>
<p>从这一节开始，我们正式从“看一张图像”升级到“理解三维世界”。具身机器人要在真实空间中抓、放、躲、走，都离不开对 3D 几何的建模，而这一切的入口就是相机模型和多视角几何。</p>
<hr>
<h4 id="3311-针孔相机模型"><a class="header" href="#3311-针孔相机模型">3.3.1.1 针孔相机模型</a></h4>
<p><strong>1）从透视投影开始</strong></p>
<p>理想化的相机可以看作一个“针孔”：所有从场景出发的光线都通过同一个小孔，投到后面的成像平面上。这就是经典的 <em>针孔相机模型</em>。</p>
<p>在相机坐标系下，设三维点为
$$
P=(X, Y, Z)^\top
$$
针孔相机的基本透视关系可以写成：
$$
x = f \frac{X}{Z},\quad y = f \frac{Y}{Z}
$$
其中 (f) 是焦距，((x,y)) 是该点在成像平面的坐标（以相机光轴与成像平面的交点为原点）。(<a href="https://www.cs.cmu.edu/~16385/s17/Slides/11.1_Camera_matrix.pdf?utm_source=chatgpt.com">cs.cmu.edu</a>)</p>
<blockquote>
<p>【图 3-1 占位：针孔相机几何示意图】
图中画出相机坐标系、针孔位置、成像平面，以及从 3D 点 (P) 射向针孔并投影到平面的光线，标出焦距 (f)、坐标 (X,Y,Z) 与投影点 ((x,y)) 的关系。</p>
</blockquote>
<p><strong>2）从“理想平面”到真实像素：相机内参矩阵</strong></p>
<p>真实图像的坐标是以左上角为原点的像素坐标 ((u,v))，与上面的理想几何坐标 ((x,y)) 还差一个线性变换和偏移。常用 <em>相机内参矩阵</em> (K) 将两者联系起来：
$$
K =
\begin{bmatrix}
f_x &amp; s   &amp; c_x
0   &amp; f_y &amp; c_y
0   &amp; 0   &amp; 1
\end{bmatrix}
$$
其中：</p>
<ul>
<li>(f_x, f_y)：x/y 方向的“有效焦距”（包含像素尺寸的缩放）；</li>
<li>(c_x, c_y)：主点（principal point），即光轴在图像上的交点；</li>
<li>(s)：像素轴之间的切变（大多数相机可近似为 0）。</li>
</ul>
<p>在齐次坐标下，三维点 (X=(X,Y,Z,1)^\top) 到图像点 (x=(u,v,1)^\top) 的投影可写成矩阵形式：
$$
x \sim K [R\mid t] X
$$</p>
<p>这里：</p>
<ul>
<li>([R\mid t]) 是相机相对于世界坐标的旋转矩阵和平移向量（外参）；</li>
<li>“(\sim)” 表示相差一个非零尺度因子。(<a href="https://users.cecs.anu.edu.au/~hartley/Papers/CVPR99-tutorial/tutorial.pdf?utm_source=chatgpt.com">users.cecs.anu.edu.au</a>)</li>
</ul>
<blockquote>
<p>【图 3-2 占位：相机坐标系、世界坐标系及内参与外参示意图】
图中画出世界坐标系、相机坐标系，标出相机位姿 ([R|t])，以及内参矩阵 (K) 将相机坐标投影到图像像素的流程框图。</p>
</blockquote>
<p><strong>3）畸变一笔带过</strong></p>
<p>真实镜头往往存在 <em>径向畸变</em>（直线变弯）和 <em>切向畸变</em>。在多视几何理论中常假设图像已经做了去畸变，便于使用简单的针孔模型。具体如何标定和去畸变会在 3.4 节详细讨论，这里只需记住：</p>
<blockquote>
<p>绝大多数视觉几何公式，都默认你已经把像素坐标“拉直”成理想针孔相机的坐标了。</p>
</blockquote>
<hr>
<h4 id="3312-多视角几何"><a class="header" href="#3312-多视角几何">3.3.1.2 多视角几何</a></h4>
<p>单张图像只能看到“投影”，距离信息被压缩到 2D 中。多视角几何研究的是：<strong>当我们有两张或多张从不同视点拍摄的图像时，如何恢复场景的三维结构和相机之间的相对关系</strong>。这是立体视觉、结构光重建、SLAM 等技术的理论基础。(<a href="https://www.r-5.org/files/books/computers/algo-list/image-processing/vision/Richard_Hartley_Andrew_Zisserman-Multiple_View_Geometry_in_Computer_Vision-EN.pdf?utm_source=chatgpt.com">r-5.org</a>)</p>
<p><strong>1）极几何与基础矩阵</strong></p>
<p>考虑两个针孔相机，拍到同一个三维点 (X)。在两张图像中的投影分别是 (x) 和 (x’)。两张图像之间存在一个几何约束，叫做 <em>极线约束</em>：
$$
x’^{\top} F x = 0
$$
这里 (F) 是一个 (3\times3) 的 <em>基础矩阵</em>（Fundamental Matrix）。它编码了两台 <em>未标定</em> 相机之间的全部极几何信息。(<a href="https://en.wikipedia.org/wiki/Fundamental_matrix_%28computer_vision%29?utm_source=chatgpt.com">维基百科</a>)</p>
<p>几何含义是：</p>
<ul>
<li>给定左图上的一点 (x)，右图中与其对应的点 (x’) 必须落在一条 <em>极线</em> 上：(l’ = F x)；</li>
<li>搜索匹配点时，不必在整张图上盲目搜索，只需要沿这条线搜索，大幅降低匹配难度。</li>
</ul>
<p><strong>2）本质矩阵与相机标定</strong></p>
<p>如果两台相机的内参 (K, K’) 已知，则可以定义 <em>本质矩阵</em>（Essential Matrix） (E)：
$$
E = K’^{\top} F K
$$
本质矩阵与相机间的相对旋转 (R) 与平移 (t) 直接相关。通过估计 (F) 再结合内参，就能恢复两台相机的相对位姿（最多有少数离散歧义）。(<a href="https://en.wikipedia.org/wiki/Fundamental_matrix_%28computer_vision%29?utm_source=chatgpt.com">维基百科</a>)</p>
<p>对于机器人而言，这意味着：</p>
<ul>
<li>只要能在两帧图像中匹配到足够多的特征点，就能估计相机的运动（视觉里程计）；</li>
<li>再结合多帧图像的 3D 点重建，就能逐步构建环境地图——这就是视觉 SLAM 背后的核心几何。</li>
</ul>
<hr>
<h4 id="3313-三角测量"><a class="header" href="#3313-三角测量">3.3.1.3 三角测量</a></h4>
<p>有了多视角、相机位姿和匹配到的特征点，对应的三维点怎样求出来？答案就是 <em>三角测量</em>（Triangulation）。(<a href="https://www.ics.uci.edu/~majumder/vispercep/cameracalib.pdf?utm_source=chatgpt.com">ics.uci.edu</a>)</p>
<p><strong>1）几何直觉</strong></p>
<p>对同一个 3D 点 (X)，从相机中心 (C_1) 和 (C_2) 发出的两条光线分别“穿过”像平面上的点 (x) 和 (x’)。理论上，这两条光线在空间中会相交于 (X)。</p>
<blockquote>
<p>【图 3-3 占位：两相机三角测量几何示意图】
图中画出两个相机中心、两条投影光线以及三维点交点，示意通过两条线求交得到 3D 位置。</p>
</blockquote>
<p>在无噪声理想情况下，直接求两条直线的交点即可。但真实世界中，由于检测误差、标定误差，光线往往不会完全相交，而是“错开”一小段距离。</p>
<p><strong>2）线性三角测量（概念层面）</strong></p>
<p>在齐次形式下，两相机投影矩阵分别为 (P_1, P_2)，图像点为 (x, x’)。由于
$$
x \sim P_1 X,\quad x’ \sim P_2 X
$$
可以写出一组关于 (X) 的线性方程组，通过最小二乘求解，使得重投影误差最小。这就是经典的线性三角测量方法。(<a href="https://www.ics.uci.edu/~majumder/vispercep/cameracalib.pdf?utm_source=chatgpt.com">ics.uci.edu</a>)</p>
<p>对具身智能来说，你可以简单记住：</p>
<blockquote>
<p>“三角测量”就是：给我两个视角下同一个像素点的位置 + 两个相机是如何摆放的，我就能算出这个点在三维世界大概在哪里。</p>
</blockquote>
<p>后续在 3.3.2 的立体视觉深度中，我们会看到三角测量在规则双目系统中可以简化成非常漂亮的一个公式。</p>
<hr>
<h3 id="332-深度估计与点云表示"><a class="header" href="#332-深度估计与点云表示">3.3.2 深度估计与点云表示</a></h3>
<p>前面的多视角几何更多关注“稀疏的点”：少量特征点的 3D 恢复。对于机器人操作与导航，更常用的是：<strong>为每个像素估计一个深度（生成深度图），再把整个场景表示成点云</strong>。</p>
<hr>
<h4 id="3321-双目视觉深度"><a class="header" href="#3321-双目视觉深度">3.3.2.1 双目视觉深度</a></h4>
<p><strong>1）视差与深度公式</strong></p>
<p>考虑一对平行摆放、经过极线校正的双目相机，左右相机的光轴大致平行，基线长度为 (B)，焦距为 (f)。同一 3D 点在左右图像上投影为 ((u_L, v)) 和 ((u_R, v))。定义 <em>视差</em>（disparity）：
$$
d = u_L - u_R
$$</p>
<p>经典双目几何推导给出深度公式：
$$
Z = \frac{fB}{d}
$$
其中 (Z) 是点到相机平面的距离。可见视差越大（左右像素差越大），物体离相机越近；视差越小，物体越远。(<a href="https://www.teledynevisionsolutions.com/support/support-center/technical-guidance/iis/how-is-depth-determined-from-a-disparity-image/?utm_source=chatgpt.com">teledynevisionsolutions.com</a>)</p>
<blockquote>
<p>【图 3-4 占位：立体双目几何与视差示意图】
画出左右相机、基线 (B)、焦距 (f)、空间点以及左右图像中的投影位置，标出视差 (d) 与深度关系。</p>
</blockquote>
<p><strong>2）视差计算与极线约束</strong></p>
<p>要利用公式估深度，需要为每个像素找到左、右图之间的 <em>对应点</em>。在极线校正后，对应点应该在同一行上，因此只需沿水平方向搜寻视差，大大简化计算。(<a href="https://www.ni.com/docs/en-US/bundle/ni-vision/page/what-to-expect-from-a-stereo-vision-system.html?srsltid=AfmBOoqIesFCxQ5KDrVuDZ1ld_ooSbnz-ebEEKffYWrdk1UZ1Q4EHE05&amp;utm_source=chatgpt.com">ni.com</a>)</p>
<p>实际算法会：</p>
<ul>
<li>使用块匹配或代价聚合（SGBM 等）在左右图上匹配；</li>
<li>对每个像素估计一个视差值 (d)，形成视差图；</li>
<li>再用 (Z=\frac{fB}{d}) 变换成深度图。</li>
</ul>
<p>深度分辨率与 (B, f) 和视差测量精度密切相关——基线越大、焦距越长，近距离深度精度越高，但视野和最大可测距离也会发生变化。(<a href="https://www.ni.com/docs/en-US/bundle/ni-vision/page/what-to-expect-from-a-stereo-vision-system.html?srsltid=AfmBOoqIesFCxQ5KDrVuDZ1ld_ooSbnz-ebEEKffYWrdk1UZ1Q4EHE05&amp;utm_source=chatgpt.com">ni.com</a>)</p>
<p><strong>3）双目与其他深度传感器的比较</strong></p>
<ul>
<li>双目优点：只需两台普通 RGB 相机，成本较低，室外和远距离适用；</li>
<li>双目缺点：纹理少、强反光区域容易匹配失败；远距离时视差很小，深度噪声大；</li>
<li>其他选择：结构光 / ToF 深度相机、LiDAR 等将会在后续点云表示与机器人章节中频繁出现。</li>
</ul>
<hr>
<h4 id="3322-单目深度估计"><a class="header" href="#3322-单目深度估计">3.3.2.2 单目深度估计</a></h4>
<p><strong>1）纯几何角度：多帧单目结构恢复</strong></p>
<p>如果只有单目相机，但有一段时间序列（视频），可以利用相机的运动产生视差：相机移动时，每一帧可以看作一个新的“视角”，配合估计的相机位姿，再通过三角测量得到稀疏或稠密深度。这是 <em>单目视觉 SLAM / SfM</em> 的传统思路。(<a href="https://www.ijcai.org/proceedings/2020/0134.pdf?utm_source=chatgpt.com">IJCAI</a>)</p>
<p><strong>2）深度学习的单帧 / 视频深度估计</strong></p>
<p>近年来更主流的路线是：<strong>直接训练一个网络，从单张图像或短视频片段预测每个像素的深度</strong>。</p>
<ul>
<li>监督式方法使用有真值深度的数据集（如 LiDAR 测量）进行回归；</li>
<li>自监督方法则通过 <em>视图合成</em> 作为监督信号：给定相邻帧图像、预测的深度与相机相对位姿，重投影前后帧，让网络最小化光度重建误差，而不需要真值深度标签。(<a href="https://openaccess.thecvf.com/content/WACV2023/papers/Petrovai_MonoDVPS_A_Self-Supervised_Monocular_Depth_Estimation_Approach_to_Depth-Aware_Video_WACV_2023_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</li>
</ul>
<p>例如经典的自监督单目深度工作将深度估计网络和位姿估计网络一起训练，使得从视频中学习出几何一致的深度图和相机运动。</p>
<p>同时，基于 Vision Transformer 的单目深度网络（如 DPT，Dense Prediction Transformer）在大规模数据上预训练后，能够在不同场景中提供较为准确且平滑的深度估计。(<a href="https://arxiv.org/abs/2103.13413?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>3）单目深度的特点</strong></p>
<ul>
<li>优点：只需一台普通 RGB 相机；可以离线地从互联网视频或机器人日志中学习，适合大规模数据预训练；</li>
<li>局限：绝对尺度存在不确定性（除非有额外尺度信息），预测容易受训练数据分布影响；对纹理贫乏区域仍然困难。</li>
</ul>
<p>在机器人系统中，单目深度估计常与 SLAM、结构化光或额外传感器结合使用，用于补充或增强深度感知。</p>
<hr>
<h4 id="3323-点云"><a class="header" href="#3323-点云">3.3.2.3 点云</a></h4>
<p><strong>1）什么是点云？</strong></p>
<p><em>点云（Point Cloud）</em> 是一组三维点的集合，每个点通常包含：
$$
(x, y, z)\quad (+\text{颜色/强度/法向等属性})
$$
点云可以来自：</p>
<ul>
<li>立体视觉/单目深度估计生成的深度图（每个像素反投影为一点）；</li>
<li>LiDAR、闪光 LiDAR 等测距设备；</li>
<li>结构光或 ToF 深度相机。(<a href="https://link.springer.com/article/10.1007/s41315-023-00302-1?utm_source=chatgpt.com">SpringerLink</a>)</li>
</ul>
<blockquote>
<p>【图 3-5 占位：室内场景点云可视化】
展示一个简单室内场景（桌子、椅子、墙壁）的彩色点云，点的稠密程度中等，便于读者直观感受点云是什么。</p>
</blockquote>
<p><strong>2）有序点云与无序点云</strong></p>
<ul>
<li>有序点云：由深度图反投影而来，点的排列与像素网格一致（可以看作带深度的图像）；</li>
<li>无序点云：由 LiDAR 或多视角融合得到，点通常是不规则散布的。</li>
</ul>
<p>有序点云便于和图像特征对齐，无序点云则更适合全局建图、三维重建与高精度几何计算。</p>
<p><strong>3）点云在机器人中的作用</strong></p>
<ul>
<li>建图与定位：对连续帧点云进行配准（如 ICP、NDT 等算法），构建三维地图并估计机器人位姿，是 3D SLAM 的核心。(<a href="https://en.wikipedia.org/wiki/Iterative_closest_point?utm_source=chatgpt.com">维基百科</a>)</li>
<li>障碍物检测与避障：从点云中分割出地面、障碍物，给路径规划模块使用。(<a href="https://sensors.myu-group.co.jp/sm_pdf/SM2265.pdf?utm_source=chatgpt.com">sensors.myu-group.co.jp</a>)</li>
<li>物体识别与抓取：在点云中拟合几何形状（平面、圆柱、盒子），或基于点云特征进行 3D 检测与 6D 位姿估计。(<a href="https://arxiv.org/abs/2103.13539?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>在后面的 3.3.3 和 3.3.4 节中，我们会看到点云如何与物体检测、抓取和避障紧密结合。</p>
<hr>
<h3 id="333-物体检测与-6d-位姿估计"><a class="header" href="#333-物体检测与-6d-位姿估计">3.3.3 物体检测与 6D 位姿估计</a></h3>
<p>机器人若要“抓住某个物体”，光知道“画面里有个杯子”是不够的，还必须知道：<strong>杯子在三维空间中的位置和朝向</strong>。这由 <em>6D 位姿估计</em> 提供。</p>
<hr>
<h4 id="3331-6d-位姿"><a class="header" href="#3331-6d-位姿">3.3.3.1 6D 位姿</a></h4>
<p><strong>1）6 自由度位姿的定义</strong></p>
<p>6D 位姿（6-DoF pose）通常指刚体在三维空间中的：</p>
<ul>
<li><strong>3 维平移</strong>：((x, y, z))，位置；</li>
<li><strong>3 维旋转</strong>：可以用欧拉角（roll/pitch/yaw）、旋转矩阵 (R)、四元数 (q) 等表示。</li>
</ul>
<p>我们经常直接写成一个齐次变换矩阵：
$$
T =
\begin{bmatrix}
R &amp; t
0 &amp; 1
\end{bmatrix}
$$</p>
<p>在 6D 物体姿态估计问题中，我们关心的是物体相对于 <em>某个坐标系</em> 的位姿，常见为相机坐标系或者机器人基座坐标系。(<a href="https://arxiv.org/html/2403.16238v3?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>2）为什么 6D 位姿对机器人如此关键？</strong></p>
<ul>
<li>抓取：爪子从哪个方向接近物体、如何旋转才能避免碰撞，完全取决于物体的 6D 姿态；</li>
<li>精密操作：如插入插座、对接零件，要求物体与工具之间的姿态误差在毫米/角度量级；</li>
<li>多物体操作：在堆叠、整理、装箱任务中，需要准确知道每个物体的空间布局。</li>
</ul>
<p>从具身智能宏观角度看，6D 位姿估计可以视为连接“视觉理解”和“工程控制”的关键桥梁，是许多机器人抓取系统的前置步骤。(<a href="https://arxiv.org/html/2403.16238v3?utm_source=chatgpt.com">arXiv</a>)</p>
<hr>
<h4 id="3332-物体检测--姿态估计流水线"><a class="header" href="#3332-物体检测--姿态估计流水线">3.3.3.2 物体检测 + 姿态估计流水线</a></h4>
<p>现实系统中，6D 位姿估计通常建立在 2D 物体检测的基础上形成一个 <em>流水线</em>。可以概括为以下几个步骤：</p>
<p><strong>1）2D 物体检测或分割</strong></p>
<p>使用目标检测或实例分割网络（如 YOLO、Faster/Mask R-CNN 等），识别出图像中的物体类别与 2D 边界框 / 像素掩膜。此时我们知道 <em>哪里</em> 有一个“杯子”或“方块”，但还不知道它的空间姿态。</p>
<p><strong>2）建立 2D–3D 对应关系</strong></p>
<p>根据物体类型，通常有以下几种方式建立 2D–3D 对应：</p>
<ul>
<li>已知 CAD 模型或模板：在模型坐标系中选取一组 3D 特征点（如角点），网络预测这些点在图像中的 2D 位置。</li>
<li>类别级 3D 盒子：网络预测物体的 3D 包围盒形状和方向，从而隐含给出一些“虚拟”3D 点与 2D 点的对应关系。(<a href="https://www.mdpi.com/2076-3417/14/17/8009?utm_source=chatgpt.com">MDPI</a>)</li>
</ul>
<p><strong>3）求解 PnP 或直接回归位姿</strong></p>
<p>有了若干个对应的 3D 点 ({X_i}) 和像素点 ({x_i})，再加上相机内参 (K)，就可以通过 <em>PnP（Perspective-n-Point）</em> 问题求解物体相对于相机的旋转 (R) 和平移 (t)。(<a href="https://www.r-5.org/files/books/computers/algo-list/image-processing/vision/Richard_Hartley_Andrew_Zisserman-Multiple_View_Geometry_in_Computer_Vision-EN.pdf?utm_source=chatgpt.com">r-5.org</a>)</p>
<p>另一类方法则直接用神经网络回归 6D 位姿参数，然后再结合渲染或 ICP 进行几何优化。</p>
<p><strong>4）利用深度 / 点云进行精细对齐</strong></p>
<p>如果有深度图或点云，可以将 CAD 模型渲染到深度图中，与观测到的点云对齐，利用 ICP 或概率配准（如 NDT）进行 <em>pose refinement</em>，以提升位姿精度，尤其是对遮挡部分的补偿。(<a href="https://en.wikipedia.org/wiki/Iterative_closest_point?utm_source=chatgpt.com">维基百科</a>)</p>
<blockquote>
<p>【图 3-6 占位：典型“检测 + 6D 位姿估计”流水线示意图】
用流程图展示：输入 RGB/深度 → 2D 检测 → 关键点/分割 → PnP 解位姿 → 利用点云 refine → 输出 6D pose。</p>
</blockquote>
<p>整体来看，这条流水线帮助机器人从“这张图里有一个杯子”上升到“杯子在相机前方 0.6m、右侧 0.2m、高度 0.1m，绕 z 轴转了 30°”。</p>
<hr>
<h4 id="3333-应用"><a class="header" href="#3333-应用">3.3.3.3 应用</a></h4>
<p><strong>1）抓取与放置</strong></p>
<p>在抓取任务中，6D 位姿估计最直接的用途是为运动规划提供目标约束。例如：</p>
<ul>
<li>已知某个物体相对于相机的姿态 (T_{\text{obj}}^{\text{cam}})，再结合相机-机械臂的手眼标定 (T_{\text{cam}}^{\text{base}})，可求出物体在机器人基座坐标系下的位姿；</li>
<li>运动规划器据此生成一条无碰路径，让末端执行器在期望的姿态下接近并抓住物体。(<a href="https://arxiv.org/html/2403.16238v3?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p><strong>2）装配、对接与精确操作</strong></p>
<p>对于插拔连接器、插销入孔等操作，稍有角度偏差就会导致卡顿甚至损坏。6D 位姿估计结合高分辨率点云，可以提供毫米级的位姿测量，为高精度装配与工业机器人应用提供基础。(<a href="https://arxiv.org/html/2403.16238v3?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>3）多物体场景理解与 VLA</strong></p>
<p>在更复杂的场景中，6D 位姿与 3D 检测结果可以构成一个“物体级 3D 场景图”：每个物体都有类别标签和空间位姿。这种表示与语言指令（“把右边那个蓝色杯子放到桌子上”）天然契合，为后续第 8 章中的 VLA 模型提供结构化的感知输入。(<a href="https://arxiv.org/abs/2103.13539?utm_source=chatgpt.com">arXiv</a>)</p>
<hr>
<h3 id="334-对机器人特别重要的视觉能力可抓取检测障碍物检测等"><a class="header" href="#334-对机器人特别重要的视觉能力可抓取检测障碍物检测等">3.3.4 对机器人特别重要的视觉能力（可抓取检测、障碍物检测等）</a></h3>
<p>前面介绍的多视几何、深度估计和 6D 位姿，为机器人提供了“几何级”的理解。本节聚焦几个在具身智能中极为关键、又高度依赖前面几何基础的 <em>专项视觉能力</em>：可抓取检测、障碍物检测和场景语义理解。</p>
<hr>
<h4 id="3341-可抓取检测"><a class="header" href="#3341-可抓取检测">3.3.4.1 可抓取检测</a></h4>
<p><strong>1）从“物体姿态”到“抓取姿态”</strong></p>
<p>6D 位姿估计告诉我们“物体在哪里、怎么放”，但机器人真正执行的是“手爪在哪里、怎么放”。<em>可抓取检测（grasp detection）</em> 更关心的是：</p>
<blockquote>
<p>在当前场景几何和任务需求下，哪些手爪位姿是“可行且安全”的抓取姿态？</p>
</blockquote>
<p>早期方法常用二维抓取矩形来表示抓取，即在图像平面上预测一个长方形 ((x, y, w, h, \theta))，矩形中心是抓取中心，角度 (\theta) 决定手爪闭合方向。(<a href="https://arxiv.org/pdf/1301.3592?utm_source=chatgpt.com">arXiv</a>)</p>
<p>在 3D 中，抓取姿态则通常包括：抓取接触点的 3D 坐标、抓取方向（法向）、手爪张开宽度以及手爪自身的姿态——本质上就是一个针对末端执行器的 6D pose。(<a href="https://www.sciencedirect.com/science/article/abs/pii/S0893608023006998?utm_source=chatgpt.com">ScienceDirect</a>)</p>
<p><strong>2）基于深度学习的抓取检测</strong></p>
<p>现代抓取检测普遍采用深度学习，从 RGB-D 图像或点云输入直接预测一组抓取候选及其“成功概率”：</p>
<ul>
<li>将场景映射到一个 <em>graspability map</em>：每个像素或点都有“可抓概率”，再从中选取评分高的局部作为抓取目标；(<a href="https://arxiv.org/pdf/1301.3592?utm_source=chatgpt.com">arXiv</a>)</li>
<li>使用 CNN/GCN 等对点云或图像进行编码，预测一批 6-DoF 抓取姿态和对应的评分。(<a href="https://www.sciencedirect.com/science/article/abs/pii/S0893608023006998?utm_source=chatgpt.com">ScienceDirect</a>)</li>
</ul>
<blockquote>
<p>【图 3-7 占位：可抓取检测示意图】
上图：叠放杂物的桌面；中图：可抓取热力图（颜色越红越容易抓）；下图：选出的若干 3D 抓取姿态用绿色手爪示意。</p>
</blockquote>
<p><strong>3）可供性（Affordance）视角</strong></p>
<p>与其先识别物体类别再决定如何抓取，另一种更“具身”的视角是：直接学习场景中哪些区域 <em>具有某种操作可供性</em>（affordance），比如“可抓”、“可按”、“可拉”。</p>
<ul>
<li>这类方法预测每个像素 / 点的任务相关可供性标签，再生成相应的抓取或操作动作；(<a href="https://www.cs.columbia.edu/~allen/S19/Student_Papers/kragic_affordance_grasp_planning.pdf?utm_source=chatgpt.com">cs.columbia.edu</a>)</li>
<li>对 VLA 模型而言，可供性图可以看作把视觉输入转化为“行动机会”的中间表征，有利于在复杂任务中做高层决策。</li>
</ul>
<hr>
<h4 id="3342-障碍物检测"><a class="header" href="#3342-障碍物检测">3.3.4.2 障碍物检测</a></h4>
<p>机器人不仅要“抓到东西”，还必须“别撞到东西”。<em>障碍物检测</em> 是所有具身系统最基本的安全能力之一。</p>
<p><strong>1）移动机器人：从深度 / 点云到占据图</strong></p>
<p>对于轮式移动机器人或无人车，常见流程是：</p>
<ol>
<li>使用双目、LiDAR 或其他深度传感器获取周围环境的点云或深度图；</li>
<li>将这些点投影到地平面坐标系下，构建 <em>占据栅格（occupancy grid）</em> 或 <em>voxel map</em>，标记哪些单元格为“被障碍物占据”；</li>
<li>在此基础上，局部规划算法（如 VFH、DWA）生成避免障碍的安全路径。(<a href="https://en.wikipedia.org/wiki/Vector_Field_Histogram?utm_source=chatgpt.com">维基百科</a>)</li>
</ol>
<p>有些工作会用更加紧凑的场景表示，如 <em>stixels</em>：将深度信息压缩为一系列垂直“柱子”，每根柱子表示在该方向上的最近障碍物，大大提升了处理效率。(<a href="https://en.wikipedia.org/wiki/Stixel?utm_source=chatgpt.com">维基百科</a>)</p>
<p><strong>2）机械臂工作空间内的障碍物</strong></p>
<p>对固定底座的机械臂来说，障碍物通常分为：</p>
<ul>
<li>静态环境，例如桌边、墙面、固定装置；</li>
<li>动态物体，例如其他机器人、人或者当前操作的物品。</li>
</ul>
<p>利用机载 RGB-D 相机或外部 3D 传感器，可将障碍物点云融合到机器人坐标系下，交给运动规划器（如基于 RRT* 或轨迹优化的规划器），在规划路径时用碰撞检测排除会穿过障碍物的轨迹。(<a href="https://www.sciencedirect.com/science/article/pii/S2772375524003563?utm_source=chatgpt.com">ScienceDirect</a>)</p>
<p><strong>3）透明 / 复杂障碍物</strong></p>
<p>现实环境中，玻璃、亚克力板等透明障碍物对 RGB 和深度相机都是难点。最近有工作利用 LiDAR 点云 <em>强度</em> 信息和多层网格表示，专门针对透明障碍物进行检测，以提升室内机器人导航的安全性。(<a href="https://arxiv.org/abs/2408.05608?utm_source=chatgpt.com">arXiv</a>)</p>
<hr>
<h4 id="3343-场景语义理解"><a class="header" href="#3343-场景语义理解">3.3.4.3 场景语义理解</a></h4>
<p>仅仅知道“哪儿有障碍物”还不够。具身智能系统还需要理解：<strong>哪儿是桌面、哪儿是抽屉、哪儿是垃圾桶、哪儿是不该进入的区域</strong>。这就是 <em>场景语义理解</em> 的任务。</p>
<p><strong>1）从像素到语义：2D/3D 语义分割</strong></p>
<p>在 2D 视角上，语义分割模型为每个像素分配类别标签（桌子、地面、墙、物体种类等）；结合深度信息或点云，可将这些语义标记提升到 3D，构建 <em>语义点云</em> 或 <em>语义体素地图</em>。(<a href="https://openaccess.thecvf.com/content/ICCV2021/papers/Ranftl_Vision_Transformers_for_Dense_Prediction_ICCV_2021_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</p>
<p><strong>2）多层次场景表示</strong></p>
<p>一个对机器人有用的场景表征往往包含多层信息：</p>
<ul>
<li>几何层：深度图、点云，提供可通行空间和障碍物；</li>
<li>物体层：各个物体的 6D 位姿和形状；</li>
<li>语义层：物体和区域的类别及功能（桌子、垃圾桶、储物箱、禁区等）。</li>
</ul>
<p>例如，多视图融合系统可以从一系列“相机在手”的 RGB 图像中构建场景点云、估算未知物体的大致形状，并对已知物体估计精确 6D 姿态，为机器人操作提供全方位信息。(<a href="https://arxiv.org/abs/2103.13539?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>3）与语言和任务的结合</strong></p>
<p>语义理解是后续“语言——视觉——行动”闭环的关键支撑：</p>
<ul>
<li>当用户说“把桌子上的红杯子放进垃圾桶”，语义分割与检测为 VLA 模型提供“桌子”“杯子”“垃圾桶”等概念在场景中的位置；</li>
<li>高层规划可以基于“区域”而不是“裸坐标”思考：先找到桌面区域，再在桌面上搜索目标，再规划路径到垃圾桶区域。</li>
</ul>
<p>这部分将在第 4 章语言与多模态表示、以及第 8 章 VLA 架构中被系统化地使用。本节的角色是：<strong>为具身智能提供一套能够支撑复杂任务的几何与语义感知基础</strong>。</p>
<hr>
<p>到这里，你可以把 3.3 这一大块理解为：</p>
<blockquote>
<p>我们已经从“相机如何把 3D 看成 2D”一路走到“机器人如何从多视角、多传感器中重建 3D 世界，并识别其中可以抓取的区域、需要避开的障碍物和具有特定语义的区域”。</p>
</blockquote>
<p>接下来 3.4 节会进一步讨论这些视觉能力在真实机器人系统中的工程落地：相机标定、延迟、噪声、帧率等实际问题。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="视觉在机器人中的工程考虑"><a href="#视觉在机器人中的工程考虑" class="header">视觉在机器人中的工程考虑</a></h1>
<h3 id="341-相机标定与外参估计"><a class="header" href="#341-相机标定与外参估计">3.4.1 相机标定与外参估计</a></h3>
<p>机器人要「看得懂世界」，第一步就是让相机的像素坐标与真实世界的几何量建立严格对应关系。这件事在工程上拆成三块：相机<strong>内参标定</strong>、<strong>外参（姿态）估计</strong>，以及对于机载相机尤为关键的<strong>手眼标定</strong>。</p>
<blockquote>
<p>[图 3.4-1：相机坐标系、机器人基座坐标系、末端坐标系以及标定板坐标系的相对位置示意图]</p>
</blockquote>
<hr>
<h4 id="3411-相机内参标定"><a class="header" href="#3411-相机内参标定">3.4.1.1 相机内参标定</a></h4>
<p><strong>1）内参是什么，为什么要标定？</strong></p>
<p>在 3.3 中已经介绍了针孔相机模型，这里从工程角度再做一次简要回顾。理想情况下，3D 点在相机坐标系 ((X, Y, Z)) 下投影到图像平面 ((u, v)) 的关系可写为：</p>
<h1 bmatrix="" id="-s-beginbmatrix-u--v--1-end"><a class="header" href="#-s-beginbmatrix-u--v--1-end">$$
s
\begin{bmatrix}
u \
v \
1
\end</a></h1>
<p>\mathbf{K}
\begin{bmatrix}
\frac{X}{Z} \
\frac{Y}{Z} \
1
\end{bmatrix},
\quad
\mathbf{K} =
\begin{bmatrix}
f_x &amp; 0 &amp; c_x
0 &amp; f_y &amp; c_y
0 &amp; 0 &amp; 1
\end{bmatrix}
$$</p>
<p>这里的 (\mathbf{K}) 就是相机<strong>内参矩阵</strong>：(f_x, f_y) 是横纵向焦距（以像素为单位），(c_x, c_y) 是主点坐标。实际镜头还会引入径向、切向畸变，需要用若干畸变系数 (k_1, k_2, p_1, p_2, \dots) 建模。(<a href="https://cs280-berkeley.github.io/lectures/lect3.pdf?utm_source=chatgpt.com">cs280-berkeley.github.io</a>)</p>
<p>对机器人而言，内参的作用很直接：</p>
<ul>
<li>将像素单位（px）转换成角度和长度的约束；</li>
<li>为后续外参估计、PnP 位姿求解、三角测量提供基础；</li>
<li>畸变校正后，几何关系才严格满足针孔模型假设。</li>
</ul>
<p><strong>2）典型标定方法（以棋盘格 + Zhang 方法为例）</strong></p>
<p>在工程实践中，使用平面棋盘格进行标定是最常见的方案。Zhang 提出的平面标定方法只需要在不同姿态下拍摄若干张棋盘格图像，即可同时估计内参和畸变，被广泛集成到 OpenCV、ROS 等工具中。(<a href="https://www.researchgate.net/publication/303233579_Zhang%27s_Camera_Calibration_Algorithm_In-Depth_Tutorial_and_Implementation?utm_source=chatgpt.com">ResearchGate</a>)</p>
<p>核心流程可以概括为：</p>
<ol>
<li><strong>准备标定板</strong>
<ul>
<li>一块已知尺寸的棋盘格或圆点格（例如 8×6 内角点，每个格子 25 mm）。</li>
<li>在标定程序中配置每个格子的真实尺寸。</li>
</ul>
</li>
<li><strong>采集多视角图像</strong>
<ul>
<li>将棋盘格在相机视野中以不同距离和姿态摆放：近、远；左、右；倾斜、旋转等。</li>
<li>要让角点尽量覆盖整个图像平面，以便估计畸变和主点位置。</li>
<li>一般建议采集 10–20 张以上有代表性的图像。</li>
</ul>
</li>
<li><strong>角点检测与匹配</strong>
<ul>
<li>使用亚像素精度角点检测（如 OpenCV <code>findChessboardCorners</code> 与 <code>cornerSubPix</code>）提取每张图像的角点坐标。</li>
<li>将角点与平面标定板上的 3D 点坐标建立对应（Z=0 的平面）。</li>
</ul>
</li>
<li><strong>线性求解 + 非线性优化</strong>
<ul>
<li>先通过线性方法估计一个初始内参矩阵与畸变参数；</li>
<li>再使用非线性最小二乘（如 Levenberg–Marquardt）优化全部参数，最小化所有图像上角点的重投影误差。</li>
</ul>
</li>
<li><strong>评估与保存结果</strong>
<ul>
<li>查看重投影误差的均值与方差（通常 RMS 在 0.1–0.5 像素级即相当不错）；</li>
<li>将内参、畸变系数存入配置文件或 ROS 参数服务器，供后续去畸变和三角测量使用。</li>
</ul>
</li>
</ol>
<blockquote>
<p>[图 3.4-2：棋盘格标定过程示意，包括多视角图像、角点检测结果和重投影误差可视化]</p>
</blockquote>
<p><strong>3）工程实践中的细节与坑</strong></p>
<ul>
<li><strong>曝光与清晰度</strong>：图像过曝或模糊会严重影响角点检测质量；建议使用自动曝光锁定或手动曝光。</li>
<li><strong>温度与变焦</strong>：变焦镜头在调整焦距/对焦后，内参会明显变化；部分工业相机在温度变化较大时内参也会轻微漂移。需要在最终使用配置（焦距、对焦、安装姿态）下完成标定。(<a href="https://www.mdpi.com/2076-3417/14/19/8687?utm_source=chatgpt.com">MDPI</a>)</li>
<li><strong>分辨率变化</strong>：若相机分辨率配置改变（例如从 1920×1080 改为 1280×720），内参需要按比例缩放或重新标定。</li>
<li><strong>RAW vs ISP 输出</strong>：若直接在 RAW 域上做几何感知，内参应针对 RAW 分辨率标定；若使用 ISP 后的裁剪/缩放输出，则必须在最终输出分辨率下标定。</li>
</ul>
<hr>
<h4 id="3412-外参相机姿态估计"><a class="header" href="#3412-外参相机姿态估计">3.4.1.2 外参（相机姿态）估计</a></h4>
<p><strong>1）外参的定义</strong></p>
<p>相机外参描述的是<strong>相机坐标系</strong>相对于某个参考坐标系（例如世界坐标系、机器人基座坐标系）的位姿，即旋转矩阵 (\mathbf{R}) 与平移向量 (\mathbf{t})。通常用一个齐次变换写成：</p>
<p>$$
\mathbf{T}_{\text{world}}^{\text{cam}} =
\begin{bmatrix}
\mathbf{R} &amp; \mathbf{t}
0 &amp; 1
\end{bmatrix}
$$</p>
<p>有了外参，就可以把图像中的点反投影到世界或机器人坐标系，从而实现「看见桌面上的目标 → 指挥机械臂去抓」。(<a href="https://cs280-berkeley.github.io/lectures/lect3.pdf?utm_source=chatgpt.com">cs280-berkeley.github.io</a>)</p>
<p><strong>2）基于 PnP 的外参求解</strong></p>
<p>在内参已知的情况下，如果我们知道一组 3D 点在世界坐标系中的位置 ({\mathbf{X}_i})，以及这些点在图像中的像素坐标 ({\mathbf{u}_i})，就可以通过**位姿估计（PnP，Perspective-n-Point）**求解相机姿态。
典型工程流程：</p>
<ol>
<li>在世界中固定一个带已知几何结构的标定物体（棋盘格、ArUco 标志板、定制标定架等）；</li>
<li>记录该标定物体在世界坐标系中的 3D 坐标；</li>
<li>拍摄标定物体，提取图像上的角点或标志点像素坐标；</li>
<li>使用如 OpenCV <code>solvePnP</code> 之类的算法求解 (\mathbf{R}, \mathbf{t})。</li>
</ol>
<p>为了提高鲁棒性，常见做法是<strong>采集多张图像</strong>，对每张求得的位姿进行非线性联合优化（bundle adjustment），从而减小噪声影响。</p>
<p><strong>3）固定相机的标定策略</strong></p>
<p>对于安装在环境中的固定相机（如俯视桌面的顶置相机），一般做法是：</p>
<ul>
<li>在机械臂可达区域内放置标定板或精密标记；</li>
<li>使用测量工具确定标定板在机器人基座坐标系中的精确位置；</li>
<li>拍摄多张标定板图像，通过 PnP 估计 (\mathbf{T}_{\text{world}}^{\text{cam}})；</li>
<li>将世界坐标系选为机器人基座坐标系，则可直接得到 (\mathbf{T}_{\text{base}}^{\text{cam}})。</li>
</ul>
<p>这样，后续任何在图像中检测到的 3D 点或平面，都可以转换到机器人基座下，用于规划运动。</p>
<hr>
<h4 id="3413-手眼标定"><a class="header" href="#3413-手眼标定">3.4.1.3 手眼标定</a></h4>
<p><strong>1）Eye-in-hand vs Eye-to-hand</strong></p>
<ul>
<li><strong>Eye-in-hand（手眼相机）</strong>：相机安装在机械臂末端或接近末端的位置，随着机械臂一起运动。</li>
<li><strong>Eye-to-hand（外部相机）</strong>：相机固定在环境中，从外部观察机器人和工作区。(<a href="https://www.cs.jhu.edu/~sleonard/lecture03.pdf?utm_source=chatgpt.com">Department of Computer Science</a>)</li>
</ul>
<p>手眼标定要解决的问题是：</p>
<blockquote>
<p>已知机器人末端在机器人基座坐标系下的位姿、以及相机看到的标定物体在相机坐标系下的位姿，求相机与末端之间的刚体变换。</p>
</blockquote>
<p>简单说，就是求出「相机相对于机械臂手的精确位置和朝向」。</p>
<p><strong>2）AX = XB 形式化</strong></p>
<p>经典手眼标定可写成矩阵方程：</p>
<p>$$
\mathbf{A}_i \mathbf{X} = \mathbf{X} \mathbf{B}_i
$$</p>
<p>其中：</p>
<ul>
<li>(\mathbf{A}_i)：机械臂从姿态 (i) 到姿态 (j) 的运动（末端在基座坐标系下的相对变换）；</li>
<li>(\mathbf{B}_i)：相机从姿态 (i) 到姿态 (j) 的运动（标定物体在相机坐标系下位姿的相对变换）；</li>
<li>(\mathbf{X})：我们要寻找的「手到眼」刚体变换（相机相对于末端的位姿）。(<a href="https://iarjset.com/wp-content/uploads/2020/11/Factura-16.pdf?utm_source=chatgpt.com">IARJSET</a>)</li>
</ul>
<p>通过采集多组不同姿态的 ((\mathbf{A}_i, \mathbf{B}_i)) 对，便可用线性方法求得一个初始解，再用非线性优化细化。</p>
<blockquote>
<p>[图 3.4-3：Eye-in-hand 几何关系示意图，显示基座、末端、相机、标定板四个坐标系，以及 AX = XB 中各矩阵对应的运动箭头]</p>
</blockquote>
<p><strong>3）数据采集与求解流程</strong></p>
<ol>
<li>固定一个标定板或标志（如带 ArUco 的平面板）在世界中不动；</li>
<li>控制机械臂末端携带相机，绕标定板做多次不同姿态的运动（尽量覆盖不同位置和朝向）；</li>
<li>记录每个姿态下：
<ul>
<li>机械臂末端相对于基座的位姿 (\mathbf{T}_{\text{base}}^{\text{ee}})；</li>
<li>标定板相对于相机的位姿 (\mathbf{T}_{\text{cam}}^{\text{target}})；</li>
</ul>
</li>
<li>从这些姿态对构造 (\mathbf{A}_i, \mathbf{B}<em>i)，求解 AX=XB 问题，得到 (\mathbf{X} = \mathbf{T}</em>{\text{ee}}^{\text{cam}})；</li>
<li>可进一步引入非线性最小二乘，最小化所有姿态下标定板重投影误差和几何误差。</li>
</ol>
<p><strong>4）误差评估与常见问题</strong></p>
<ul>
<li><strong>重投影误差</strong>：将世界中已知的标定点，通过「基座 → 末端 → 相机」链路投到图像，再与真实像素位置比较，均方误差越小越好。</li>
<li><strong>抓取精度测试</strong>：在桌面上放置若干已知位置的小目标，让机器人根据视觉估计去抓取，统计抓取位置误差和成功率。(<a href="https://develop.realman-robotics.com/en/AI/developerGuide/hand/?utm_source=chatgpt.com">develop.realman-robotics.com</a>)</li>
</ul>
<p>常见坑包括：</p>
<ul>
<li>姿态采样不够丰富（都在一个平面附近），导致解病态；</li>
<li>相机或末端在采集中产生微小滑动，但未被模型考虑；</li>
<li>标定板精度不足或标记尺寸测量不准。</li>
</ul>
<hr>
<h3 id="342-图像处理链路从传感器到模型输入"><a class="header" href="#342-图像处理链路从传感器到模型输入">3.4.2 图像处理链路：从传感器到模型输入</a></h3>
<p>本小节关注的是「从光子到张量」的工程过程：相机如何把光信号转成数字图像，图像又如何变成深度学习模型可以接受的张量。这条链路任何细节处理不当，都可能直接影响模型在机器人上的表现。</p>
<blockquote>
<p>[图 3.4-4：典型数字相机 ISP + 深度学习预处理的流水线图：光学 → 传感器（RAW）→ ISP（demosaic/降噪/白平衡/gamma）→ RGB 图像 → 尺度调整/裁剪 → 归一化 → Tensor]</p>
</blockquote>
<hr>
<h4 id="3421-传感器输出"><a class="header" href="#3421-传感器输出">3.4.2.1 传感器输出</a></h4>
<p><strong>1）RAW 数据与 Bayer 阵列</strong></p>
<p>大部分 CMOS 图像传感器本质上是<strong>单色传感器</strong>，前面覆盖了一个彩色滤波阵列（CFA），最常见的是 Bayer 模式（RGGB）。每个像素只测量 R、G 或 B 中的一种分量，输出的是一个 RAW 灰度图像，但每个像素有不同颜色含义。(<a href="https://www.e-consystems.com/blog/camera/technology/understanding-bayer-pattern-and-the-significance-of-an-isp-in-image-processing/?utm_source=chatgpt.com">e-con Systems</a>)</p>
<p>RAW 域通常具有以下特点：</p>
<ul>
<li>响应近似线性（曝光强度与数值基本成正比）；</li>
<li>动态范围大，但包含噪声、坏点等；</li>
<li>尚未进行白平衡、降噪、锐化等处理。</li>
</ul>
<p><strong>2）ISP（Image Signal Processing）管线</strong></p>
<p>在绝大多数工业/消费级相机中，RAW 数据会先进入 ISP，再输出常见的 RGB 或 YUV 图像。典型 ISP 包含：(<a href="https://www.researchgate.net/publication/2885663_Color_Image_Processing_Pipeline_in_Digital_Still_Cameras?utm_source=chatgpt.com">ResearchGate</a>)</p>
<ol>
<li>黑电平校正、响应线性化；</li>
<li>白平衡（调整不同颜色通道增益）；</li>
<li><strong>Demosaicing</strong>：从 Bayer CFA 重建完整的 RGB 像素；</li>
<li>降噪、去坏点、锐化；</li>
<li>颜色校正（传感器色域 → 标准 RGB 空间，如 sRGB）；</li>
<li>Gamma 矫正、对比度增强、色调映射等。</li>
</ol>
<p>对于机器人视觉，有两种常见策略：</p>
<ul>
<li>直接使用相机输出的 RGB 图像，让 ISP 完成大部分处理；</li>
<li>利用可编程相机/RAW 接口，手动实现简化 ISP，以获得更稳定、更可控的图像风格，为后续模型训练带来一致性。</li>
</ul>
<p><strong>3）与控制闭环的关系</strong></p>
<p>ISP 的复杂度直接影响<strong>感知延迟</strong>。在一些高帧率、低延迟要求的场景（如高速飞行器避障），会刻意选择简化 ISP，甚至直接使用灰度或近 RAW 数据，以换取更低延迟。(<a href="https://rpg.ifi.uzh.ch/docs/RAL19_Falanga.pdf?utm_source=chatgpt.com">rpg.ifi.uzh.ch</a>)</p>
<hr>
<h4 id="3422-尺度调整与裁剪"><a class="header" href="#3422-尺度调整与裁剪">3.4.2.2 尺度调整与裁剪</a></h4>
<p>大多数视觉模型要求固定大小的输入（例如 224×224 或 480×480）。原始图像往往分辨率较高、纵横比不规则，需要进行<strong>缩放和裁剪</strong>。</p>
<p><strong>1）缩放（Resize）的策略</strong></p>
<ul>
<li><strong>保持纵横比缩放</strong>：按长边或短边缩放到目标尺寸，再在较短边上填充或裁剪。该策略可避免非均匀拉伸，减小几何畸变对检测、位姿估计的影响。</li>
<li><strong>直接拉伸到目标尺寸</strong>：简单粗暴，但会扭曲几何关系，尤其对需要精确几何信息（抓取点预测、姿态估计）任务不利。</li>
<li>插值方式上，常用双线性、双三次插值；过于激进的插值会模糊边缘。</li>
</ul>
<p><strong>2）裁剪（Crop）与 ROI 选择</strong></p>
<ul>
<li>对于固定工作区（如实验桌面），可以直接裁剪出桌面区域，减少无关背景。</li>
<li>对于多任务场景，可以先用轻量级检测网络找出感兴趣区域，再裁剪出 ROI 输入到精细模型。</li>
<li>注意：裁剪会改变对象相对于图像坐标系的位置，对后续几何计算（如像素坐标归一化、PnP）必须做一致处理。</li>
</ul>
<p><strong>3）与内参与外参的一致性</strong></p>
<p>如果标定是在原始全分辨率下完成的，而后续对图像进行缩放或裁剪，则需要对内参进行相同的线性变换：</p>
<ul>
<li>缩放：(f_x, f_y, c_x, c_y) 按比例缩放；</li>
<li>裁剪：主点 (c_x, c_y) 需要减去裁剪偏移。</li>
</ul>
<p>这是很多工程系统中容易忽略但会直接降低精度的细节。</p>
<hr>
<h4 id="3423-归一化与张量转换"><a class="header" href="#3423-归一化与张量转换">3.4.2.3 归一化与张量转换</a></h4>
<p>走到这一步，我们已经有了一张「看着还不错」的 RGB 图像，但深度学习模型需要的是一个数值张量。</p>
<p><strong>1）归一化（Normalization）</strong></p>
<p>典型的预处理包括：</p>
<ul>
<li>将像素从 0–255 线性缩放到 0–1 或 -1–1 区间；</li>
<li>按通道减去均值、除以标准差（例如 ImageNet 标准均值/方差）；</li>
<li>对深度图或灰度图，可能需要做 log 变换或裁剪到物理合理范围。</li>
</ul>
<p>关键要求是：<strong>训练时使用的归一化方式必须在推理时严格一致</strong>。否则模型学到的统计分布会在部署时完全失配，导致性能大幅下降。</p>
<p><strong>2）张量格式与内存布局</strong></p>
<ul>
<li>通常深度学习框架使用 NCHW（batch，通道，高度，宽度）格式；</li>
<li>来自相机或图像库的数据往往是 HWC（高度，宽度，通道）格式，需要转换维度顺序；</li>
<li>对实时系统，数据拷贝和排列本身也会引入延迟，因此实际工程会尽量减少多余格式转换。</li>
</ul>
<p><strong>3）多模态输入的对齐</strong></p>
<p>在机器人场景中，模型输入可能包括：</p>
<ul>
<li>RGB 图像、深度图；</li>
<li>机器人关节状态、末端位姿；</li>
<li>历史动作序列。</li>
</ul>
<p>这些张量需要在<strong>时间戳</strong>上对齐（参见第 7 章的数据采集部分），以免模型把错位的感知和动作拼在一起，导致训练出的策略在真实世界表现异常。</p>
<hr>
<h3 id="343-延迟噪声与帧率对控制的影响"><a class="header" href="#343-延迟噪声与帧率对控制的影响">3.4.3 延迟、噪声与帧率对控制的影响</a></h3>
<p>视觉只是机器人控制闭环中的一环：从场景发生变化，到相机采集、ISP 处理、模型推理，再到控制器下发关节指令，中间会不可避免地引入<strong>时间延迟</strong>；图像本身则存在各种<strong>噪声与不确定性</strong>；而<strong>帧率</strong>则决定了系统感知世界的时间分辨率。这三者直接决定了视觉控制的上限性能。</p>
<blockquote>
<p>[图 3.4-5：视觉控制闭环时间轴示意图，从真实世界事件发生到机器人执行动作的各个延迟环节；附带不同噪声源的示意]</p>
</blockquote>
<hr>
<h4 id="3431-延迟"><a class="header" href="#3431-延迟">3.4.3.1 延迟</a></h4>
<p><strong>1）延迟的类型</strong></p>
<ul>
<li><strong>感知延迟</strong>：从真实场景变化到相机输出图像的时间，包含曝光时间、传感器读出时间、ISP 处理时间、数据传输时间。(<a href="https://www.sciencedirect.com/science/article/abs/pii/S0923596515001289?utm_source=chatgpt.com">ScienceDirect</a>)</li>
<li><strong>计算延迟</strong>：图像预处理、模型推理、后处理（如 NMS、轨迹规划）的时间。</li>
<li><strong>执行延迟</strong>：从控制命令发出到机器人关节产生实际运动的时间，包括通信延迟、电机响应等。</li>
</ul>
<p>整体延迟可简单理解为：<strong>机器人看到的是几帧之前的世界</strong>。在静态环境下这还好，在高速运动场景（如无人机避障）中则非常致命。</p>
<p>研究表明，在给定障碍密度和反应能力的前提下，感知延迟会对可安全行驶的最大速度形成硬性上限。(<a href="https://rpg.ifi.uzh.ch/docs/RAL19_Falanga.pdf?utm_source=chatgpt.com">rpg.ifi.uzh.ch</a>)</p>
<p><strong>2）测量与建模</strong></p>
<ul>
<li>实验上可以通过让场景中出现一个在已知时间变化的视觉事件（如 LED 灯突然点亮），测量从事件发生到控制器检测到的时间，即感知+计算延迟。(<a href="https://www.sciencedirect.com/science/article/abs/pii/S0923596515001289?utm_source=chatgpt.com">ScienceDirect</a>)</li>
<li>在控制算法层面，可以把延迟作为一个固定时滞或随机时滞进行建模，用离散时间视觉伺服控制、预测控制等方法进行补偿。(<a href="https://www.mdpi.com/1424-8220/24/14/4626?utm_source=chatgpt.com">MDPI</a>)</li>
</ul>
<p><strong>3）工程上的缓解策略</strong></p>
<ul>
<li><strong>降低复杂度</strong>：简化图像分辨率、模型大小，牺牲部分精度换取更低延迟；</li>
<li><strong>管线并行</strong>：将图像采集、推理、控制执行做成流水线，而非完全串行；</li>
<li><strong>预测补偿</strong>：用上一时刻速度估计目标或机器人自身在当前时刻的位置，将控制量作用到「预测状态」上；</li>
<li><strong>速度约束</strong>：直接在规划层限制最大线速度和角速度，使系统在给定延迟下仍能保证安全距离。</li>
</ul>
<hr>
<h4 id="3432-噪声"><a class="header" href="#3432-噪声">3.4.3.2 噪声</a></h4>
<p><strong>1）噪声的来源</strong></p>
<ul>
<li>传感器层面：读出噪声、光子噪声（shot noise）、热噪声；</li>
<li>ISP 处理：压缩、锐化、降噪算法可能引入纹理变化和伪影；</li>
<li>环境因素：光照变化、反光、高动态范围场景导致局部过曝或欠曝。(<a href="https://www.researchgate.net/publication/2885663_Color_Image_Processing_Pipeline_in_Digital_Still_Cameras?utm_source=chatgpt.com">ResearchGate</a>)</li>
</ul>
<p>这些噪声会直接影响：</p>
<ul>
<li>特征检测与匹配的稳定性（角点、特征点抖动）；</li>
<li>深度估计与点云的精度（视差误差放大为深度误差）；</li>
<li>物体检测和姿态估计模型的置信度。</li>
</ul>
<p><strong>2）滤波与多帧融合</strong></p>
<p>典型工程手段包括：</p>
<ul>
<li>空间滤波（Gaussian、bilateral filter）去除高频噪声；</li>
<li>时间滤波（指数滑动平均）稳定目标位置估计，但会引入额外滞后；</li>
<li>多帧融合与超分辨技术，利用多帧观测提高信噪比。</li>
</ul>
<p><strong>3）在模型和数据层面的应对</strong></p>
<ul>
<li>数据增强时加入高斯噪声、压缩伪影、光照扰动，使模型对噪声更鲁棒；</li>
<li>通过鲁棒损失（如 Huber loss）减弱少数极端噪声样本对参数估计的影响；</li>
<li>利用原始 RAW 或线性域数据训练模型，避免 ISP 的不可控风格差异。(<a href="https://arxiv.org/pdf/2305.11994?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<hr>
<h4 id="3433-帧率"><a class="header" href="#3433-帧率">3.4.3.3 帧率</a></h4>
<p><strong>1）帧率与时间分辨率</strong></p>
<p>帧率（FPS）决定了系统每秒能够获取多少张新图像。帧率越高，系统对环境变化越敏感，能更快发现和响应变化；帧率越低，则容易错过短暂事件或造成控制指令不连贯。</p>
<p>在视觉伺服中，常见的控制频率是相机帧率的整数倍或约数，例如相机 30 FPS、控制循环 30 Hz 或 60 Hz。若控制频率远高于视觉更新频率，后续控制循环只能基于旧图像反复更新，实际价值有限。(<a href="https://faculty.cc.gatech.edu/~seth/ResPages/pdfs/HutHagCor96.pdf?utm_source=chatgpt.com">faculty.cc.gatech.edu</a>)</p>
<p><strong>2）高帧率的代价</strong></p>
<ul>
<li>采集和传输带宽需求增大（尤其是高分辨率图像）；</li>
<li>ISP 和模型推理要在更短时间内完成，否则会堆积延迟；</li>
<li>嵌入式平台（如 Jetson）上，高帧率往往意味着更高功耗和温度。</li>
</ul>
<p>因此，在工程上通常要做系统级预算：<strong>图像分辨率、帧率、模型大小、硬件性能</strong>必须同时考虑，找到一个满足任务需求的折中点。</p>
<p><strong>3）帧率、延迟与噪声的联合作用</strong></p>
<p>三者之间存在天然的联系：</p>
<ul>
<li>提高帧率需要缩短曝光时间，可能降低信噪比，使图像更暗更「粗糙」；</li>
<li>过强的降噪又可能引入更多处理时间，增加延迟；</li>
<li>降低帧率虽可提高单帧质量，但控制回路响应变慢。</li>
</ul>
<p>在机器人工程中，合理的做法不是单独追求某一指标极致，而是根据任务（慢速操作 vs 高速运动）选取合适的参数组合。</p>
<hr>
<h3 id="344-单目--双目--手眼相机的差异与适用场景"><a class="header" href="#344-单目--双目--手眼相机的差异与适用场景">3.4.4 单目 / 双目 / 手眼相机的差异与适用场景</a></h3>
<p>从「看」这个动作本身来说，相机可以有多种布置方式。不同布置在成本、深度感知能力、遮挡情况和标定复杂度上都有截然不同的特性。本小节主要对比三种典型配置：<strong>单目相机、双目相机、手眼相机与外部固定相机</strong>。</p>
<blockquote>
<p>[图 3.4-6：单目相机、双目相机、Eye-in-hand 与 Eye-to-hand 四种典型配置的示意图，标出各自视野范围和与机器人坐标系的关系]</p>
</blockquote>
<hr>
<h4 id="3441-单目相机"><a class="header" href="#3441-单目相机">3.4.4.1 单目相机</a></h4>
<p><strong>1）特点</strong></p>
<ul>
<li>硬件简单、成本最低，安装灵活（机载、固定、头戴式等均可）；</li>
<li>无法直接从单帧图像恢复真实尺度的深度，只能得到相对结构或借助先验；</li>
<li>适合做 2D 检测、语义分割、场景理解等任务。</li>
</ul>
<p><strong>2）单目深度与结构推理</strong></p>
<p>虽然单目本身不具备几何尺度，但可以利用：</p>
<ul>
<li>相机运动多帧（结构从运动，SfM / VO）；</li>
<li>几何先验（物体尺寸、平面假设）；</li>
<li>学习方法（单目深度估计网络）。</li>
</ul>
<p>这些方法在机器人场景中可以提供「相对深度」或近似距离信息，但其精度与鲁棒性通常不如真正的立体或深度传感器。</p>
<p><strong>3）适用场景</strong></p>
<ul>
<li>低成本移动机器人导航（配合激光雷达或超声波避障）；</li>
<li>对绝对距离要求不高的拾取放置任务（如高度固定的桌面、物体尺寸已知）；</li>
<li>需要利用大视野和语义信息的任务（如房间场景分析、目标搜索）。</li>
</ul>
<hr>
<h4 id="3442-双目相机"><a class="header" href="#3442-双目相机">3.4.4.2 双目相机</a></h4>
<p><strong>1）立体几何与深度</strong></p>
<p>双目相机由两台内参相同、外参已知的相机组成，通过视差恢复深度：</p>
<ul>
<li>同一空间点在左右图像上的像素位置存在水平偏移，称为视差；</li>
<li>视差与深度成反比，基线越大、分辨率越高，估计精度越好。</li>
</ul>
<p>在 3.3 已经介绍过基础三角测量原理，这里强调其工程意义：<strong>双目提供了稠密或半稠密的深度图</strong>，能让机器人在单次观测中获得完整的 3D 信息，而无需相机移动。</p>
<p><strong>2）工程挑战</strong></p>
<ul>
<li>双目标定需要同时估计两台相机的内参和相互外参，对棋盘格姿态和数据质量要求更高；</li>
<li>立体匹配算法复杂度较高，对弱纹理区域、反光面表现不佳；</li>
<li>两路相机需要精确同步，否则会在快速运动时产生伪视差。</li>
</ul>
<p><strong>3）适用场景</strong></p>
<ul>
<li>模拟人眼视觉的服务机器人、移动平台导航；</li>
<li>抓取与操作任务中的深度感知（如堆叠物体高度估计、障碍物高度判断）；</li>
<li>对成本敏感，但又需要一定深度信息的场景，是 RGB-D 相机（结构光/ToF）的一种替代方案。</li>
</ul>
<hr>
<h4 id="3443-手眼相机-vs-外部固定相机"><a class="header" href="#3443-手眼相机-vs-外部固定相机">3.4.4.3 手眼相机 vs 外部固定相机</a></h4>
<p><strong>1）Eye-in-hand（手眼相机）的特点</strong></p>
<ul>
<li>相机固定在末端执行器或机械臂手腕上，视野随机器人运动而改变；</li>
<li>可以近距离观察目标，获得高分辨率局部细节，尤其适合精细操作（插入、拧螺丝、检查焊点等）；</li>
<li>遮挡问题更容易控制：机器人可以主动移动相机绕过遮挡。</li>
</ul>
<p>缺点是：</p>
<ul>
<li>手眼标定较复杂，需要解决 AX=XB 问题并维持长期稳定；(<a href="https://www.cs.jhu.edu/~sleonard/lecture03.pdf?utm_source=chatgpt.com">Department of Computer Science</a>)</li>
<li>视野有限，很难同时观察整个工作区，需要配合路径规划确保相机视线不被自身或环境遮挡；</li>
<li>在机械臂高速运动时，图像更容易模糊，对曝光和帧率要求更高。</li>
</ul>
<p><strong>2）Eye-to-hand（外部固定相机）的特点</strong></p>
<ul>
<li>相机安装在环境中，如俯视工作台的顶置相机、墙角相机；</li>
<li>可以一次性覆盖较大的工作区域，方便做全局任务规划与监控；</li>
<li>外参标定相对简单，只需对固定标定板做 PnP 标定，且只要不移动相机，参数可以长期保持稳定。</li>
</ul>
<p>但它也有明显局限：</p>
<ul>
<li>容易被机械臂本体或其他物体遮挡；</li>
<li>对小物体或精细操作细节分辨率不足，远处目标角度变化导致姿态估计精度下降；</li>
<li>对于多机器人协作，需要复杂的多视角配置和坐标对齐。</li>
</ul>
<p><strong>3）组合使用与趋势</strong></p>
<p>在较复杂的机器人系统中，常见的做法是：</p>
<ul>
<li>使用一到多台外部相机提供<strong>全局感知</strong>（物体分布、障碍物、其它机器人位置）；</li>
<li>使用手眼相机提供<strong>局部精细感知</strong>（抓取对准、接触前微调）；</li>
<li>通过统一的坐标标定（手眼标定、相机间外参）将多视角信息进行融合。(<a href="https://robotics.stackexchange.com/questions/7163/hand-eye-calibration?utm_source=chatgpt.com">Robotics Stack Exchange</a>)</li>
</ul>
<p>这种「全局 + 局部」的配置，也为后续 VLA 模型和世界模型提供了丰富多样的视觉输入基础——在后续章节中，我们会看到如何在这个基础上进一步利用语言、历史轨迹，将几何感知提升为智能行为决策。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="nlp-基础"><a href="#nlp-基础" class="header">NLP 基础</a></h1>
<h3 id="411-语言模型与子词分词bpesentencepiece-等"><a class="header" href="#411-语言模型与子词分词bpesentencepiece-等">4.1.1 语言模型与子词分词（BPE、SentencePiece 等）</a></h3>
<p>这一小节的目标，是把“语言”从符号序列变成可以计算的概率对象，并解释为什么几乎所有现代 NLP/LLM 都离不开子词分词。</p>
<hr>
<h4 id="4111-语言模型"><a class="header" href="#4111-语言模型">4.1.1.1 语言模型</a></h4>
<p>**语言模型（Language Model, LM）**的核心任务：
给定一个词（或 token）序列 (w_1, w_2, \dots, w_T)，估计这整个序列出现的概率
$$
P(w_1, w_2, \dots, w_T)
$$
或更常用的条件形式
$$
P(w_t \mid w_1, \dots, w_{t-1})
$$
即“在前面已经看到的内容条件下，下一个词是什么的概率”。</p>
<p>利用概率论中的<strong>链式法则（chain rule）</strong>，可以把整体概率拆成一连串条件概率的乘积：
$$
P(w_1,\dots,w_T) = \prod_{t=1}^T P(w_t \mid w_1,\dots,w_{t-1})
$$</p>
<p>这就是“预测下一个词”的数学形式。无论是传统 n-gram 模型，还是后面 4.2 节要介绍的大型自回归 Transformer 语言模型，都是在近似和建模这类条件概率。</p>
<p>在工程实践中，语言模型主要用于：</p>
<ul>
<li>评估一句话是否“自然”（概率越大越自然）</li>
<li>生成新文本（按概率采样或取最大概率的下一个词）</li>
<li>作为其它任务（翻译、问答、对话、代码生成、机器人语言理解）的基础模块</li>
</ul>
<p>评价指标上，**困惑度（perplexity）**常被用来衡量语言模型好坏：
直观理解上，它刻画“模型平均每一步在多少个候选 token 之间摇摆”。困惑度越低，说明模型越“不困惑”，预测越准确。</p>
<blockquote>
<p>【图 4-1 占位：语言模型示意图】
建议画一个简单示意：左侧是词序列 “机器人 / 把 / 杯子 / …”，箭头指向右侧一个“softmax 概率分布”柱状图，表示下一个词的概率分布。</p>
</blockquote>
<hr>
<h4 id="4112-n-gram-模型"><a class="header" href="#4112-n-gram-模型">4.1.1.2 N-gram 模型</a></h4>
<p>在真实语言里，(P(w_t \mid w_1,\dots,w_{t-1})) 依赖的上下文可能非常长，直接建模几乎不可能。<strong>N-gram 模型</strong>通过一个强但简单的假设来简化问题：</p>
<blockquote>
<p>第 (t) 个词只依赖前面最近的 (n-1) 个词，而不管更早的历史。</p>
</blockquote>
<p>即 <strong>n 阶马尔可夫假设</strong>：
$$
P(w_t \mid w_1,\dots,w_{t-1}) \approx P(w_t \mid w_{t-n+1},\dots,w_{t-1})
$$</p>
<p>于是整句的概率就变成：
$$
P(w_1,\dots,w_T) \approx \prod_{t=1}^T P(w_t \mid w_{t-n+1},\dots,w_{t-1})
$$</p>
<p>常见的几种 n-gram：</p>
<ul>
<li><strong>Unigram（一元组）</strong>：每个词独立，(P(w_t))</li>
<li><strong>Bigram（二元组）</strong>：只看前一个词，(P(w_t \mid w_{t-1}))</li>
<li><strong>Trigram（三元组）</strong>：看前两个词，(P(w_t \mid w_{t-2}, w_{t-1}))</li>
</ul>
<p>参数估计很直观：
在语料库里数共现次数，比如 bigram：
$$
\hat{P}(w_t \mid w_{t-1}) = \frac{\text{count}(w_{t-1}, w_t)}{\text{count}(w_{t-1})}
$$</p>
<p><strong>数据稀疏和平滑（smoothing）</strong>
即使在很大的语料库里，很多 n-gram 组合仍然<strong>从未出现</strong>，简单的计数估计会得到概率 0，导致整句概率为 0。为此需要平滑技术：</p>
<ul>
<li><strong>加一（Laplace）平滑</strong>：全部计数 +1，避免 0 概率</li>
<li><strong>Kneser–Ney 平滑</strong>：更精细地折扣高频 n-gram，将概率质量分配给低阶模型，是实际应用中非常强大的平滑方法</li>
</ul>
<p>N-gram 模型的优点是直观、易实现、解释性好，但局限也很明显：</p>
<ul>
<li>上下文窗口固定、短（一般 n≤5），难以捕获长距离依赖</li>
<li>高阶 n-gram 参数量膨胀严重，极易稀疏</li>
<li>需要大量人工设计特征和复杂平滑</li>
</ul>
<p>这也为后续的<strong>神经语言模型</strong>和 Transformer-based LLM 铺垫了背景：它们在本质上也是语言模型，但放弃了简单的 n-gram 结构，使用深度网络来拟合长期依赖关系（详见 4.2 节）。</p>
<blockquote>
<p>【图 4-2 占位：N-gram 概率图】
一条横向词序列，画出 bigram 的有向边（从前一个词指向后一个词，边上标概率），旁边再画一个 trigram 概率公式。</p>
</blockquote>
<hr>
<h4 id="4113-子词分词"><a class="header" href="#4113-子词分词">4.1.1.3 子词分词</a></h4>
<p>语言模型需要先把原始文本切成<strong>离散 token</strong>，才能定义上面的概率分布。最朴素的做法是“按空格切词”，但这在很多场景中会出问题：</p>
<ul>
<li>词汇表如果只包含完整单词，<strong>生僻词、人名、技术术语</strong>会变成 OOV（Out-of-Vocabulary）</li>
<li>黏着语、形态丰富的语言（如德语、土耳其语）一个词可以拼成非常长的复合词</li>
<li>对中文、日文等无空格语言，“按词切分”本身就是困难任务</li>
</ul>
<p>**子词分词（subword tokenization）**就是折衷方案：
把词拆成更小的子单元（子词、字块、甚至字节），既比字符更长、表达能力更强，又比完整词更泛化。这样，模型只要掌握有限的子词，就能组合出近乎无限的单词。</p>
<h5 id="byte-pair-encodingbpe"><a class="header" href="#byte-pair-encodingbpe">Byte Pair Encoding（BPE）</a></h5>
<p>BPE 原本是一种数据压缩算法，被 Sennrich 等人改造为子词分词方法，用于机器翻译等任务。 其基本思想：</p>
<ol>
<li>从<strong>字符级</strong>开始，将训练语料中的每个词看作字符序列。</li>
<li>统计所有相邻符号（初始是字符对）的出现频率。</li>
<li>找出<strong>出现频率最高的一对符号</strong>，把它们合并成一个新的符号（子词）。</li>
<li>在整个语料中替换这对符号，更新符号序列。</li>
<li>重复 2–4 步，直到达到预设的词表大小（例如 32k 或 50k 子词）。</li>
</ol>
<p>举个简单例子（极简示意）：</p>
<ul>
<li>初始：<code>l o w</code>, <code>l o w e r</code>, <code>n e w</code>, <code>n e w e r</code></li>
<li>多次合并之后：<code>lo w</code>, <code>lo wer</code>, <code>ne w</code>, <code>ne wer</code>，再进一步可能变成 <code>low</code>, <code>lower</code>, <code>new</code>, <code>newer</code></li>
</ul>
<p>在机器人/多模态场景中，BPE 的优势尤其明显：
当遇到新的对象名（如“电动三轮广告车”）时，模型仍然可以把它拆成若干已知子词组合，而不是完全陌生的一个 token。</p>
<h5 id="sentencepiece-与-unigram-lm"><a class="header" href="#sentencepiece-与-unigram-lm">SentencePiece 与 Unigram LM</a></h5>
<p><strong>SentencePiece</strong> 是 Google 提出的一个子词分词工具，核心特点是：从<strong>原始字符序列</strong>直接训练子词模型，不依赖预先分词。</p>
<p>它支持两类常见的子词模型：</p>
<ul>
<li><strong>BPE 模式</strong>：基本同上，只是集成在统一工具中</li>
<li><strong>Unigram 语言模型（Unigram LM）</strong>：为候选子词集合建立一个概率模型，对一句话所有可能的分词方式求概率，选择整体概率最大的那一种。</li>
</ul>
<p>SentencePiece 还有几个工程上重要的特性：</p>
<ul>
<li><strong>语言无关</strong>：可以直接处理日文、中文、混合语种等，无需先用特定语言的分词器</li>
<li><strong>直接训练与解码</strong>：既提供训练子词词表，也负责编码/解码，方便端到端部署</li>
<li>对空格等也视作普通字符，避免“空格信息丢失”的问题</li>
</ul>
<p>在大模型和 VLA 场景中，我们通常只需要<strong>统一、稳定的 tokenization</strong>（如 BPE/Unigram + SentencePiece 实现），就能在多任务、多语言、多机器人之间共享同一语言模型。</p>
<blockquote>
<p>【图 4-3 占位：BPE/SentencePiece 分词过程示意】
左侧是原始句子，下面列出“字符级表示 → 若干轮合并 → 最终子词序列”的过程，中间可附上合并频率排名的小表格。</p>
</blockquote>
<hr>
<h3 id="412-词向量上下文表示word2vecelmo-等"><a class="header" href="#412-词向量上下文表示word2vecelmo-等">4.1.2 词向量、上下文表示（word2vec、ELMo 等）</a></h3>
<p>这一小节从“离散 token 编号”走向“连续向量空间表示”，是从统计 NLP 过渡到神经表示学习的关键步骤。</p>
<hr>
<h4 id="4121-静态词向量"><a class="header" href="#4121-静态词向量">4.1.2.1 静态词向量</a></h4>
<p>传统做法中，每个单词只是一个 ID，模型无法直接比较“机器人”和“机械臂”的相似程度。**词向量（word embedding）**通过把每个词映射为一个实数向量，能让模型在几何空间中“感受”词义相近性。</p>
<p>背后的直觉是著名的<strong>分布式假设</strong>：</p>
<blockquote>
<p>在相似上下文中出现的词，其语义也相似。</p>
</blockquote>
<h5 id="word2vec"><a class="header" href="#word2vec">word2vec</a></h5>
<p>Mikolov 等人提出的 <strong>word2vec</strong> 模型是静态词向量的代表，使用一个小型神经网络在大规模语料上自监督训练。</p>
<p>两种典型结构：</p>
<ul>
<li><strong>CBOW（Continuous Bag-of-Words）</strong>：给定中心词周围的上下文词，预测中心词</li>
<li><strong>Skip-gram</strong>：给定中心词，预测其左右上下文词；对稀有词效果更好</li>
</ul>
<p>训练时常用的技巧包括：</p>
<ul>
<li><strong>层次 softmax</strong>：用 Huffman 树加速输出层计算</li>
<li><strong>负采样（negative sampling）</strong>：只采样少量“负例”单词来更新参数，大幅加速训练</li>
</ul>
<p>训练结束后，每个词对应一个固定维度的向量（如 100 维、300 维），在这个向量空间里：</p>
<ul>
<li>语义相近的词距离较近（cosine 相似度高）</li>
<li>有时还能观察到线性关系，如
(\text{vec}(\text{“国王”}) - \text{vec}(\text{“男人”}) + \text{vec}(\text{“女人”}) \approx \text{vec}(\text{“女王”}))</li>
</ul>
<p>其他静态词向量方法如 <strong>GloVe</strong>，可以看作对词共现矩阵的某种因子分解，也在许多 NLP 任务中表现良好。</p>
<blockquote>
<p>【图 4-4 占位：词向量空间示意图】
通过二维投影展示若干词（如 “机器人”“机械臂”“猫”“狗”）在平面上的位置，同类词聚在一起。</p>
</blockquote>
<hr>
<h4 id="4122-上下文表示"><a class="header" href="#4122-上下文表示">4.1.2.2 上下文表示</a></h4>
<p>静态词向量有一个致命缺陷：<strong>同一个词在不同语境中的含义不同，但它的向量是固定的。</strong></p>
<p>比如“银行”在中文中可以是“金融机构”也可以是“河岸”；静态 embedding 无法区分这两种含义。为解决多义词问题，研究者提出了<strong>上下文敏感（contextualized）词表示</strong>。</p>
<h5 id="elmo基于双向语言模型的上下文向量"><a class="header" href="#elmo基于双向语言模型的上下文向量">ELMo：基于双向语言模型的上下文向量</a></h5>
<p>ELMo（<em>Embeddings from Language Models</em>）是早期具有代表性的上下文表示方法。它的做法是：先训练一个深层双向语言模型（biLM），然后把每个词的表示定义为这个 biLM 内部隐藏状态的函数（通常是不同层表示的加权和）。</p>
<p>关键特点：</p>
<ul>
<li>模型结构：字符级 CNN + 多层 BiLSTM + 语言模型目标（从左到右和从右到左）</li>
<li>对于句子中的每个词，ELMo 输出一个向量，这个向量<strong>取决于整句上下文</strong></li>
<li>将这些向量作为附加特征喂给下游模型（如问答、自然语言推断、情感分析），能显著提升性能</li>
</ul>
<p>与静态词向量相比，上下文表示有几点明显优势：</p>
<ul>
<li>一词多义：可以根据句子动态区分意义（河边的“银行”和金融“银行”得到不同向量）</li>
<li>表达能力更强：深层网络可以捕获语法、语义乃至一些世界知识</li>
<li>迁移性好：在大语料上预训练，再迁移到各种下游任务</li>
</ul>
<p>ELMo 之后，BERT、GPT 等基于 Transformer 的预训练模型进一步统一了“语言建模 + 上下文表示 + 下游任务微调”的范式（详见 4.2 节），但 ELMo 清晰体现了**“从语言模型内部状态抽取表示”**的思想。</p>
<blockquote>
<p>【图 4-5 占位：静态 vs 上下文词向量对比】
同一个词 “bank” 在两句</p>
<ul>
<li>“I went to the bank to deposit money.”</li>
<li>“He sat on the river bank.”
中的表示：上图静态 embedding 是同一点，下图上下文 embedding 是两处不同的位置。</li>
</ul>
</blockquote>
<hr>
<h4 id="4123-预训练词向量的作用"><a class="header" href="#4123-预训练词向量的作用">4.1.2.3 预训练词向量的作用</a></h4>
<p>无论是静态词向量（word2vec/GloVe），还是上下文表示（ELMo/BERT 系列），共同点是：<strong>可以在海量无标注文本上预训练，然后作为下游任务的“通用特征”。</strong></p>
<p>在工程实践中，这带来几方面好处：</p>
<ol>
<li><strong>更好的初始化</strong>
将下游模型的嵌入层初始化为预训练词向量，而不是随机初始化，用少量标注数据就能达到更高性能，并更快收敛。</li>
<li><strong>显著提升小数据任务的效果</strong>
许多任务（尤其是领域特定任务，比如“机器人操作日志理解”“工业说明书理解”）标注数据很少。预训练词向量可以把互联网大规模语料中学到的语言知识迁移过来，提高泛化能力。</li>
<li><strong>统一多任务、多领域表示空间</strong>
使用同一套预训练向量，多种任务共享一个表示空间，使得跨任务迁移、更大规模的多任务训练更容易实现。这为后续“统一视觉–语言–动作表示”的 VLA 模型打下了先验基础。</li>
<li><strong>在机器人场景中的具体价值</strong>
<ul>
<li>对自然语言指令的理解更鲁棒（可以识别各种同义表达）</li>
<li>可以把人类使用的专业术语、品牌名等编码进机器人可用的向量空间</li>
<li>与视觉、动作表示对齐时，语言侧已经有较好的几何结构，便于跨模态对齐</li>
</ul>
</li>
</ol>
<p>在现代 LLM 中，“预训练 +（可能的）微调”几乎成为默认范式。4.2 节可以被看作是将“预训练词向量”扩展到“预训练整套语言模型”的自然结果。</p>
<hr>
<h3 id="413-常见任务机器翻译问答摘要等"><a class="header" href="#413-常见任务机器翻译问答摘要等">4.1.3 常见任务：机器翻译、问答、摘要等</a></h3>
<p>在掌握语言模型与向量表示之后，最典型的应用场景就是各种“序列到序列”任务。这里简要介绍三类与后续 VLA 特别相关的任务：机器翻译、自动问答和文本摘要。</p>
<hr>
<h4 id="4131-机器翻译"><a class="header" href="#4131-机器翻译">4.1.3.1 机器翻译</a></h4>
<p>**机器翻译（Machine Translation, MT）**的目标是：
给定源语言句子 (\mathbf{x})，生成语义等价的目标语言句子 (\mathbf{y})。</p>
<p>发展脉络（非常简略版）：</p>
<ol>
<li><strong>基于规则 / 统计的传统翻译</strong>
<ul>
<li>基于语法和词典的规则系统</li>
<li>统计机器翻译（SMT）：学习“翻译模型 + 语言模型”，典型如短语翻译 + n-gram 语言模型</li>
</ul>
</li>
<li><strong>神经机器翻译（Neural Machine Translation, NMT）</strong>
使用一个端到端的神经网络直接建模 (P(\mathbf{y} \mid \mathbf{x}))，
<ul>
<li>早期采用 RNN 编码器–解码器结构</li>
<li>Bahdanau 等人引入<strong>注意力机制（attention）</strong>，解码时可以软对齐到源句的不同部分，大幅提升性能</li>
<li>后来 Transformer 架构成为主流翻译模型（与 2.4 节呼应）</li>
</ul>
</li>
<li><strong>子词与开放词汇翻译</strong>
由于翻译需要处理大量人名、地名、新词，NMT 特别依赖子词分词。Sennrich 等工作表明，用 BPE 进行子词分词可以显著改善罕见词和未登录词的翻译质量。</li>
</ol>
<p>机器翻译在具身智能中的作用非常直接：
机器人系统如果希望跨语言工作（例如同时接受中文和英文指令），可以使用统一的多语言表示空间或翻译模块，将不同语言映射到统一的<strong>语义指令表示</strong>，再交给 VLA 模型进行决策。</p>
<blockquote>
<p>【图 4-6 占位：NMT Encoder–Decoder 结构示意】
左边源句 token 序列，经过编码器变成一串向量；右边解码器逐步生成目标句，每一步从注意力层“查看”源句不同位置。</p>
</blockquote>
<hr>
<h4 id="4132-自动问答"><a class="header" href="#4132-自动问答">4.1.3.2 自动问答</a></h4>
<p>**自动问答（Question Answering, QA）**任务要求系统根据输入的问题，返回一个自然语言答案。根据是否给定上下文，可以大致分成：</p>
<ul>
<li><strong>机器阅读理解（Machine Reading Comprehension, MRC）</strong>
给定一段文本（如维基百科文章）和一个问题，从文本中找出答案。
典型数据集如 SQuAD：每个问题的答案是文章中的一个文本片段。</li>
<li><strong>开放域问答（Open-domain QA）</strong>
系统可以检索整个知识库或搜索引擎结果，然后综合得到答案。这里通常需要“检索 + 阅读 + 生成”三段式管线。</li>
<li><strong>封闭书问答（Closed-book QA）</strong>
模型完全依赖参数中“记住”的知识，不提供外部文档。例如直接问 LLM “谁提出了 ELMo”。</li>
</ul>
<p>早期的 QA 系统通常采用“特征工程 + 机器学习”，或者 “检索 + 规则匹配”。现代 QA 系统则多依赖预训练语言模型，通过：</p>
<ul>
<li>编码问题和文档，使用注意力/交互模块找出答案 span</li>
<li>或直接由生成式模型输出答案文本</li>
</ul>
<p>在机器人场景中，自动问答能力可以自然扩展为：</p>
<ul>
<li><strong>解释型问答</strong>：用户询问“你为什么没有抓起杯子？”，机器人根据视觉、状态和任务规划给出语言解释（见 4.4.3）。</li>
<li><strong>知识问答</strong>：机器人可回答“这个零件的材质是什么”“这个操作步骤下一步是什么”，帮助人类在任务中获取信息。</li>
</ul>
<p>这些都依赖足够强的语言理解和生成能力，而这些能力本质上都来自于<strong>强大的语言模型 + 上下文表示</strong>。</p>
<hr>
<h4 id="4133-文本摘要"><a class="header" href="#4133-文本摘要">4.1.3.3 文本摘要</a></h4>
<p>**文本摘要（Text Summarization）**任务希望模型从长文本中压缩出简短而信息密集的摘要。在现代 NLP 中通常分为两大类：</p>
<ol>
<li><strong>抽取式摘要（Extractive Summarization）</strong>
<ul>
<li>从原文中选出若干“重要句子/片段”，按一定顺序拼接成摘要</li>
<li>摘要中的句子是原文的子集，不生成新句子</li>
</ul>
</li>
<li><strong>生成式（抽象式）摘要（Abstractive Summarization）</strong>
<ul>
<li>模型“理解”原文要点后，用自己的语言重新组织句子</li>
<li>可以使用原文中没有出现过的表述，更接近人类写作风格</li>
</ul>
</li>
</ol>
<p>早期抽象式摘要往往采用编码器–解码器结构，结合注意力和指针机制（pointer-generator），既能生成新文本，又能“复制”原文中的关键词语，缓解 OOV 问题。</p>
<p>模型评价上，<strong>ROUGE</strong> 系列指标被广泛使用，通过比较系统摘要和人工摘要之间的 n-gram 重合来评估质量。</p>
<p>在具身智能和机器人系统中，摘要能力的应用场景包括：</p>
<ul>
<li><strong>实验日志与传感器数据的“语言摘要”</strong>：把长时间运行的机器人操作日志自动总结成自然语言报告，帮助研究人员快速了解结果。</li>
<li><strong>环境描述压缩</strong>：将复杂场景感知结果压缩成高层语言描述（如“桌子上有三个杯子，其中一个是红色”），再交给上层规划模块。</li>
<li><strong>人机交互中的简短回顾</strong>：机器人执行一长串动作后，用一两句话向用户简单汇报自己做了什么，有利于建立信任和可解释性。</li>
</ul>
<blockquote>
<p>【图 4-7 占位：抽取式 vs 抽象式摘要对比】
左边：原文多句，系统选出其中几句高亮连接成摘要；右边：模型生成几句新文本，箭头指向原文不同部分，表示它综合了多个来源。</p>
</blockquote>
<hr>
<p>本节从<strong>语言模型 → N-gram → 子词分词 → 词向量与上下文表示 → 典型 NLP 任务</strong>搭建了一个最基础的 NLP 知识框架。后续 4.2 节会在此基础上，引入大规模 Transformer 语言模型及其在多模态、具身智能中的角色，从“会说话的模型”进一步走向“会理解、会行动的机器人大脑”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="大语言模型llm基础"><a href="#大语言模型llm基础" class="header">大语言模型（LLM）基础</a></h1>
<h3 id="421-自回归语言模型与下一个-token-预测"><a class="header" href="#421-自回归语言模型与下一个-token-预测">4.2.1 自回归语言模型与下一个 token 预测</a></h3>
<h4 id="4211-自回归模型"><a class="header" href="#4211-自回归模型">4.2.1.1 自回归模型</a></h4>
<p>在 4.1 节里，我们已经从“语言模型 = 预测下一个词的机器”的角度做过直观介绍。这里开始进入现代大语言模型（LLM）的主流形式：<strong>自回归（autoregressive）语言模型</strong>。</p>
<p>给定一个 token 序列 (x_{1:T} = (x_1, x_2, \dots, x_T))，自回归模型假设整段文本的概率可以被分解为从左到右的一系列条件概率：</p>
<p>$$
p_\theta(x_{1:T}) = \prod_{t=1}^{T} p_\theta(x_t \mid x_{&lt;t})
$$</p>
<p>也就是说，<strong>第 (t) 个 token 的分布，只依赖于它左侧所有已经出现的 token</strong>。这就是“自回归”的含义：用自己过去的输出来回归（预测）未来。</p>
<p>在工程上，主流实现是 <strong>Transformer 的纯 Decoder 结构</strong>（第 2.4.4 节已介绍）：</p>
<ul>
<li>输入是一串 token 的嵌入向量；</li>
<li>自注意力（Self-Attention）使用<strong>因果掩码</strong>（causal mask），只允许每个位置看到自己左边的 token；</li>
<li>最后一层通过一个线性层 + Softmax 输出在整个词表上的概率分布，即“下一个 token 的分布”。</li>
</ul>
<p>生成过程可以用几行伪代码概括：</p>
<pre><code class="language-python">tokens = [BOS]          # 开始符
for t in range(T_max):
    p = model(tokens)   # 得到当前步的下一个 token 概率分布
    x_next = sample(p)  # 采样或取最大概率的 token
    tokens.append(x_next)
    if x_next == EOS:   # 结束符：生成终止
        break
</code></pre>
<p>这里的 <code>sample</code> 可以是贪心（取最大概率）、带温度的采样、top-k / nucleus sampling 等，在 8 章讲到动作 token 生成时还会再次出现。自回归生成的特点是：<strong>一步一步往后写，前文一旦写出就不再修改</strong>。</p>
<blockquote>
<p>【图 4-2-1 插图占位：画出一个 Transformer Decoder，仅向左注意力的掩码示意，并标注从 “我 / 今天 / 去 / 了 / …” 逐步预测下一 token 的流程。】</p>
</blockquote>
<p>对于具身智能，本章暂时先只把“自回归语言模型”当成一个<strong>可以自然生成序列的核心模块</strong>。在第 8 章你会看到，把“token”从纯文本扩展到<strong>视觉 token、动作 token</strong> 后，同样的自回归结构就能统一生成“视觉–语言–动作”序列，为 VLA 打下统一建模的基础。</p>
<hr>
<h4 id="4212-预训练目标"><a class="header" href="#4212-预训练目标">4.2.1.2 预训练目标</a></h4>
<p>大语言模型的预训练阶段，本质上就是在海量文本上，把上面的分解式变成一个优化问题：</p>
<p>$$
\mathcal{L}<em>{\text{LM}}(\theta)
= - \mathbb{E}</em>{x_{1:T} \sim D}
\left[ \sum_{t=1}^{T} \log p_\theta(x_t \mid x_{&lt;t}) \right]
$$</p>
<p>也就是<strong>最小化所有 token 的交叉熵损失</strong>，最大化训练语料在模型下的对数似然。这里的语料库 (D) 通常包括互联网网页、书籍、论文、代码、对话等复杂混合数据。</p>
<p>几个关键点：</p>
<ol>
<li><strong>自监督（self-supervised）</strong>
每个序列本身就自带标签：前缀是输入，当前 token 是要预测的“标签”。不需要额外人工标注，这使得 LLM 可以利用极其巨大的无标注语料进行训练。</li>
<li><strong>Teacher Forcing 训练方式</strong>
训练时第 (t) 步的条件 (x_{&lt;t}) 是<strong>真实文本</strong>，而不是模型上一步生成的 token，这叫 teacher forcing。好处是梯度传播稳定、训练高效；代价是在推理时会出现所谓 <strong>exposure bias</strong>（见 4.2.1.3）。</li>
<li><strong>统一的预训练任务</strong>
不论是翻译、问答、代码补全还是推理题，在预训练阶段统统都被当成“补完一段文本”来处理：
<ul>
<li>输入部分可以是“题目 + 提示”；</li>
<li>输出部分是“答案 + 解释”；</li>
<li>模型完全不知道“现在是在做什么任务”，它只是尽量把“后面的 token 写得像训练数据里的样子”。</li>
</ul>
</li>
</ol>
<p>大量理论与经验研究表明，<strong>单一的“下一个 token 预测”目标，已经足以让模型学会相当复杂的模式</strong>：包括上下文学习（in-context learning）、算术推理等。</p>
<p>从具身智能的角度，可以先把这一步理解为：在预训练阶段，我们只是教会模型**“读写符号序列”**，包括自然语言、代码、数学公式等，还没有加入任何机器人动作或传感信息。后续在第 8、9 章，会把这些新模态也统一成“token 序列”，继续用同一个目标进行训练或微调。</p>
<hr>
<h4 id="4213-优点与局限"><a class="header" href="#4213-优点与局限">4.2.1.3 优点与局限</a></h4>
<p><strong>一、优点</strong></p>
<p>（1）<strong>目标统一、实现简单</strong>
自回归 + 下一个 token 预测，为整个大模型生态提供了一个极其统一的训练目标：</p>
<ul>
<li>不需要为每个任务设计专门的损失函数；</li>
<li>不需要显式区分“分类 / 回归 / 生成”；</li>
<li>所有东西都变成“在某个上下文下继续写 token”。</li>
</ul>
<p>（2）<strong>高效利用无标注数据</strong>
由于是自监督，可以拿几乎任何文本（甚至代码、公式、注释）去训练 LLM，极大提高了参数中的“世界知识密度”，也带来了预训练规模和能力随之扩展的<strong>Scaling Law</strong> 现象：模型变大、数据变多、算力增大，性能往往按幂律提升，并出现新的能力。</p>
<p>（3）<strong>生成能力自然、可扩展到多模态</strong>
自回归模型本来就是生成模型，扩展到多模态时，只需把图像 patch、动作 token 等也视作序列中的元素，让模型继续“从左到右生成序列”即可。这种统一视角是 VLM / VLA 等方向的基础（见第 8 章）。</p>
<p><strong>二、局限</strong></p>
<p>（1）<strong>推理与训练目标的错位</strong>
预训练阶段只关心“像训练语料一样写下一个 token”，<strong>并不直接关心真伪、因果、价值观</strong>。如果训练语料里存在虚假或有害文本，模型也会学到相应模式。在开放式问答时，这直接表现为“看起来很真但其实瞎编”的幻觉（4.2.3、4.2.4 将展开）。</p>
<p>（2）<strong>Exposure Bias 与错误放大</strong>
训练时用真实历史 (x_{&lt;t})，推理时用模型自己生成的历史。一旦前面几步略有偏差，后续条件分布就建立在“错误的历史”之上，错误可能迅速滚雪球。</p>
<p>（3）<strong>上下文有限与生成不可回头</strong>
自回归生成是<strong>单向、不可回退</strong>的：</p>
<ul>
<li>一旦生成了前面的 token，就很难整体重写全部回答；</li>
<li>Transformer 的注意力复杂度是 (O(n^2))，上下文长度有限，长推理链或长对话中的信息很容易被截断。</li>
</ul>
<p>（4）<strong>对具身任务来说缺乏环境闭环</strong>
在机器人场景中，只靠“文本自回归”是远远不够的：</p>
<ul>
<li>现实世界状态随时间变化；</li>
<li>机器人需要根据传感器反馈不断调整动作。
然而自回归语言模型本身只看到“历史 token 序列”，看不到真实物理状态。这就是为什么后文会引入<strong>指令微调、RLHF、工具调用、VLA 架构</strong>等机制，把“预测 token”这套能力嵌入到更大的闭环系统中。</li>
</ul>
<hr>
<h3 id="422-指令微调与对话式模型"><a class="header" href="#422-指令微调与对话式模型">4.2.2 指令微调与对话式模型</a></h3>
<h4 id="4221-指令微调"><a class="header" href="#4221-指令微调">4.2.2.1 指令微调</a></h4>
<p>预训练后的 LLM 更像一个“万能补全引擎”：写小说、续代码、模仿网页风格都没问题，但<strong>并不一定会乖乖按人类给出的“指令”办事</strong>。指令微调（Instruction Tuning）就是要把它从“自动补全器”变成一个“听得懂任务说明的助手”。</p>
<p>典型流程（以 InstructGPT 为例）：</p>
<ol>
<li><strong>构造指令数据集</strong>
收集大量“指令–输入–输出”三元组，例如：
<ul>
<li>指令：<em>“请用一句话总结下列实验结果。”</em></li>
<li>输入：一段论文中的实验部分；</li>
<li>输出：简要总结。
这些样本覆盖分类、翻译、抽取、推理、代码等多种任务，并尽量使用自然语言描述，而不是硬编码任务 ID。</li>
</ul>
</li>
<li><strong>仍然使用下一个 token 预测作为目标</strong>
把“指令 + 输入 + 特殊分隔符”与“期望回答”拼接成一个长序列，继续用交叉熵最小化：
$$
\mathcal{L}<em>{\text{SFT}}(\theta)
= - \sum</em>{t \in \text{answer}} \log p_\theta(x_t \mid x_{&lt;t})
$$
这一步通常被称为 <strong>SFT（Supervised Fine-Tuning）</strong>，从行为上把模型“拉向”人类示范。</li>
<li><strong>指令格式与元信息</strong>
工程上往往约定统一格式，例如：</li>
</ol>
<pre><code class="language-latex">### 指令:
解释下面这段代码的功能。

### 输入:
...

### 回答:
</code></pre>
<p>模型只在“回答”部分计算损失。对于具身任务，这里的“输入”可以扩展为文字描述场景、传感信息摘要等。</p>
<p>指令微调的本质，是把“<strong>任务是什么</strong>”也用自然语言编码进输入，让同一个预训练模型，在见到不同指令时自动切换行为。对 VLA 而言，“把红色方块放进蓝色盒子”也只是另一种指令，后续我们会让模型学会把这种指令翻译成动作序列。</p>
<hr>
<h4 id="4222-chatgpt-风格的对话模型"><a class="header" href="#4222-chatgpt-风格的对话模型">4.2.2.2 ChatGPT 风格的对话模型</a></h4>
<p>在指令微调的基础上，再进一步引入多轮对话数据，就得到 ChatGPT 这类<strong>对话式模型</strong>。典型训练样本不再是单轮的 “指令–回答”，而是一整段带角色的对话：</p>
<pre><code class="language-latex">[system] 你是一个乐于助人的机器人助手。
[user]   我想学一下强化学习，需要什么基础？
[assistant] 你可以从概率论、线性代数和优化方法开始...
[user]   那和监督学习的主要区别是？
[assistant] ...
</code></pre>
<p>训练方式仍然是<strong>自回归下一个 token 预测</strong>：把整段对话视作一个长序列，只对 assistant 角色的 token 计算损失。通过大量此类数据，模型逐渐学会：</p>
<ul>
<li>如何在对话中保持礼貌、连贯；</li>
<li>如何利用历史轮次补全省略信息（如“那这个算法呢？”中的“这个”指代前文）；</li>
<li>如何遵守 system 角色设定（例如保持某种语气、遵守安全规范）。</li>
</ul>
<p>在机器人场景下，ChatGPT 风格的模型承担的是<strong>人类接口</strong>角色：</p>
<ul>
<li>用户用自然语言表达需求、偏好和约束；</li>
<li>对话模型负责解释、澄清、分解任务；</li>
<li>后端再把相对明确的“子任务描述”交给 VLA 或传统规划器去执行（见第 8、10 章）。</li>
</ul>
<blockquote>
<p>【图 4-2-2 插图占位：对话式模型的输入输出示意图，展示 system / user / assistant 三类 role 如何拼接成一个统一的 token 序列。】</p>
</blockquote>
<hr>
<h4 id="4223-对话管理"><a class="header" href="#4223-对话管理">4.2.2.3 对话管理</a></h4>
<p>传统任务型对话系统一般分成四个模块：</p>
<ol>
<li>语义理解（NLU）：把用户话语解析成槽位、意图；</li>
<li>对话状态跟踪（DST）：维护“当前任务进展到哪一步”；</li>
<li>策略（Policy）：根据状态选择下一步系统动作；</li>
<li>自然语言生成（NLG）：把动作转成回复句子。</li>
</ol>
<p>大语言模型出现后，很多系统把这四步合并到一个 LLM 里，让它直接“端到端生成回复”。但在工程实践，尤其是具身机器人领域，<strong>完全端到端的对话管理仍然不够安全与可靠</strong>，通常会采用“LLM + 外部对话管理器”的混合方案。</p>
<p>可以粗略分成三个层次：</p>
<ul>
<li><strong>纯生成式对话管理</strong>
全部状态都以文本形式隐含在对话历史中，由 LLM 自行“脑补”。优点是简单；缺点是难以强约束、安全性难保证。</li>
<li><strong>结构化状态 + LLM</strong>
把关键信息（当前任务、机器人位置、是否抓到物体等）维护在结构化的“世界状态”中，让 LLM 只做两件事：
1）理解用户意图并转换为结构化指令（如调用 API <code>pick(object=red_block)</code>）；
2）在需要时给出自然语言说明。
这类似 Chapter 10 所说的“VLA 与传统规划模块共存”。</li>
<li><strong>LLM 作为高层“对话策略模块”</strong>
高层由 LLM 决定“应该和用户说/问什么”“需要调用哪个工具或子系统”；低层对话轮次管理、日志记录、安全过滤则由传统对话管理框架负责。</li>
</ul>
<p>对机器人而言，对话管理还有一个核心要求：<strong>把“语言状态”与“物理状态”对齐</strong>。例如用户说“再往左一点”，系统需要结合当前相机画面、机器人位姿来解释这个“左”。这要求对话管理器必须同时读懂对话历史和环境状态，而不能只靠语言模型单方面推理；这一点会在第 4.4、10.1 节继续展开。</p>
<hr>
<h3 id="423-rlhf人类反馈强化学习的动机与基本流程"><a class="header" href="#423-rlhf人类反馈强化学习的动机与基本流程">4.2.3 RLHF（人类反馈强化学习）的动机与基本流程</a></h3>
<h4 id="4231-模型幻觉与价值不对齐问题"><a class="header" href="#4231-模型幻觉与价值不对齐问题">4.2.3.1 模型幻觉与价值不对齐问题</a></h4>
<p>从前两小节可以看到：</p>
<ul>
<li>预训练 + 指令微调的模型已经很会“说话”；</li>
<li>但它的优化目标依然是“写出高似然的下一个 token”。</li>
</ul>
<p>结果就是：</p>
<ol>
<li><strong>幻觉（Hallucination）</strong>
LLM 会产生<strong>看起来流畅、逻辑通顺但事实错误</strong>的内容，例如捏造不存在的论文、凭空编造 API 接口等。多篇综述将这种现象统称为“幻觉”，强调其在开放式问答、信息检索等场景中的严重性。近期研究指出，当前评测指标往往鼓励“宁可乱猜也不要说不知道”，这进一步放大了幻觉：模型会被奖励为“好考生”，而不是“诚实的助手”。</li>
<li><strong>价值观与安全的不对齐</strong>
预训练语料包含大量有毒言论、偏见、甚至危险做法。仅靠指令微调，很难保证模型在所有场景下都<strong>避免攻击性语言、尊重隐私、避免提供危险操作建议</strong>。InstructGPT 的工作系统地展示了：仅放大模型规模，不能自动解决“对齐（alignment）”问题。</li>
</ol>
<p>在纯文本助手里，幻觉“顶多说错话”；而在具身机器人中，如果把 LLM 输出直接映射成实际动作，<strong>错误决策可能导致设备损坏甚至安全事故</strong>。这就是引入 RLHF 的直接动机：</p>
<ul>
<li>不再只看“预测下一个 token 的概率”；</li>
<li>而是让人类对模型行为进行打分或排序，用强化学习把这些偏好编码进策略中，使之更“<strong>有用、无害、诚实</strong>”。</li>
</ul>
<hr>
<h4 id="4232-人类反馈数据"><a class="header" href="#4232-人类反馈数据">4.2.3.2 人类反馈数据</a></h4>
<p>RLHF 一般包含两类核心人类数据（在 InstructGPT 与后续工作中已形成“标准三部曲”）：</p>
<ol>
<li><strong>示范数据（Demonstrations）——监督微调阶段</strong>
标注者看到一个 prompt（例如用户问题），直接写出一份他们认为“理想的回答”。这些数据用于 SFT 阶段，把模型从纯 LM 拉到“基本像个助手”的水平。</li>
<li><strong>偏好数据（Preference Data）——奖励模型阶段</strong>
给定同一个 prompt 和多条候选回答（通常来自 SFT 模型采样），标注者只需在其中<strong>排序或选择更喜欢的一条</strong>。</li>
</ol>
<p>训练一个<strong>奖励模型</strong> (r_\phi(x, y))，目标是让其在“好回答”上给出的分数高于“差回答”。典型的损失函数为成对逻辑回归：
$$
\mathcal{L}<em>{\text{RM}}(\phi)
= - \mathbb{E}</em>{(x, y_w, y_l)}
\left[
\log \sigma\big(r_\phi(x, y_w) - r_\phi(x, y_l)\big)
\right]
$$
使得 (r_\phi) 近似“人类偏好函数”。</p>
<pre><code>- 相比绝对打分，成对比较更稳定、简单；
- 采集到的样本形如 ((x, y_{\text{good}}, y_{\text{bad}}))。
</code></pre>
<p>除了文本助手，类似的人类偏好也可以施加在<strong>机器人轨迹</strong>上：例如给两段示教视频打分“哪种抓取更稳定、更安全”。这与 5.3 节的“奖励学习”“逆强化学习”在思想上是一致的，只是对象从“物理轨迹”变成了“文本回答”。</p>
<hr>
<h4 id="4233-强化学习微调"><a class="header" href="#4233-强化学习微调">4.2.3.3 强化学习微调</a></h4>
<p>在拿到 SFT 模型和奖励模型后，RLHF 的第三步才是真正的“强化学习”：<strong>用奖励模型指导策略（LLM）更新</strong>。</p>
<p>典型做法（以 PPO 为例）可简化为：</p>
<ol>
<li><strong>策略初始化</strong>
把指令微调后的模型记为 (\pi_{\text{SFT}})。以其为起点初始化 RL 策略 (\pi_\theta)，这样一开始行为就已经“像个人”。</li>
<li><strong>生成数据并打分</strong>
从真实或合成的 prompt 分布 (x \sim D) 采样，令策略生成回答 (y \sim \pi_\theta(\cdot \mid x))。
<ul>
<li>用奖励模型计算分数 (r_\phi(x, y))；</li>
<li>同时加入一个 KL 惩罚项，限制策略不要偏离初始的 (\pi_{\text{SFT}})。</li>
</ul>
</li>
<li><strong>优化目标</strong>
我们希望最大化期望奖励，同时保持与 SFT 模型接近，可以写成：[
\max_\theta \ \mathbb{E}<em>{x, y \sim \pi</em>\theta}
\big[, r_\phi(x, y) - \beta ,
\mathrm{KL}(\pi_\theta(\cdot|x)\Vert \pi_{\text{SFT}}(\cdot|x)) \big]
]其中 (\beta) 控制“听奖励模型”和“别离谱乱跑”之间的平衡。实际实现中使用 PPO 这样的 <strong>Actor–Critic 算法</strong>，以保证更新稳定（这与第 5 章中的 RL 算法是一脉相承的）。</li>
<li><strong>得到 RLHF 模型</strong>
经过多轮迭代，我们得到一个既继承预训练知识、又更符合人类偏好的新策略。InstructGPT 结果显示，1.3B 参数的 RLHF 模型，在人工偏好评估中甚至可以优于 175B 的原始 GPT-3，可见“对齐”有时比“变大”更重要。</li>
</ol>
<blockquote>
<p>【图 4-2-3 插图占位：RLHF 三阶段流水线示意图——左侧是 SFT，中央是“人类偏好数据 + 奖励模型”，右侧是 PPO 微调策略的循环。】</p>
</blockquote>
<p>在具身智能语境下，可以类比地考虑：</p>
<ul>
<li>策略 (\pi_\theta) 不再输出文本，而是输出动作 token 序列；</li>
<li>奖励模型可以基于人类对轨迹视频的偏好训练；</li>
<li>PPO 之类的 RL 算法同样适用。
不过机器人 RLHF 还需要解决安全约束、样本效率等额外问题，这会在第 5 章和第 9 章进一步探讨。</li>
</ul>
<hr>
<h3 id="424-llm-的推理能力与局限性"><a class="header" href="#424-llm-的推理能力与局限性">4.2.4 LLM 的推理能力与局限性</a></h3>
<h4 id="4241-涌现的推理能力"><a class="header" href="#4241-涌现的推理能力">4.2.4.1 涌现的推理能力</a></h4>
<p>一个看似“魔法”的现象是：<strong>随着参数量、数据量和训练算力的扩大，LLM 会突然表现出一些在小模型中不存在的能力</strong>，例如多步算术推理、链式思维（Chain-of-Thought）推理、复杂代码生成等。Wei 等人将这种现象命名为“涌现能力（emergent abilities）”并进行了系统量化。</p>
<p>典型观察包括：</p>
<ul>
<li>在模型规模较小时，某些任务（如多步骤算术、逻辑组合题）准确率接近随机；</li>
<li>当参数量跨过某个阈值后，性能会突然出现“跳变”；</li>
<li>一些研究从理论上分析了：<strong>单一的下一个 token 预测任务，就足以让模型在上下文中学会“隐式拟合任务”和“算法样式”</strong>，从而表现出 in-context learning、算术等能力。</li>
</ul>
<p>更直观地说，大模型在学习如何“最合理地接龙”时，被迫压缩了大量统计结构和模式，包括：</p>
<ul>
<li>语法、语义模式；</li>
<li>论证结构（先提出假设，再论证，再得结论）；</li>
<li>问题–解题步骤–答案的模板。</li>
</ul>
<p>当我们用“逐步思考一下再回答”的提示（Chain-of-Thought prompting）时，其实是在要求模型显式展开它在内部已经学到的“解题模板”。这并不等价于人类的逻辑推理，但在很多任务上效果非常接近。</p>
<blockquote>
<p>【图 4-2-4 插图占位：横轴为模型规模（log 尺度），纵轴为某推理任务准确率，画出一条在某点附近出现明显“弯折”的曲线，用以说明涌现能力。】</p>
</blockquote>
<p>对具身智能来说，这种涌现能力的意义在于：</p>
<ul>
<li>可以把高层任务分解、策略规划、条件判断等“符号逻辑味很重”的部分交给 LLM；</li>
<li>再由 VLA 或传统控制模块负责把这些高层步骤“编译”成具体的物理动作。
换句话说，LLM 更适合担当<strong>文本世界里的“策士”</strong>，而不是直接作为底层执行器。</li>
</ul>
<hr>
<h4 id="4242-知识局限"><a class="header" href="#4242-知识局限">4.2.4.2 知识局限</a></h4>
<p>尽管 LLM 参数中“存了大量知识”，但它的知识能力有几个根本限制：</p>
<ol>
<li><strong>静态知识：有时间截止</strong>
预训练数据是在某个时间点之前采集的，之后发生的事件、发布的论文、新的 API 等，模型<strong>天然不知道</strong>。要获取最新知识，必须连接检索或工具。</li>
<li><strong>不完整且有偏</strong>
即便在截止时间之前，训练语料也不可能覆盖世界的全部事实，而且采集自互联网势必带来地域、语言、阶层等偏差。这些偏差会被模型放大乃至固化。</li>
<li><strong>“记住在参数里”并不等于“随时取得出”</strong>
即使某个事实确实出现在训练文本中，模型也可能因为 prompt 的写法不同、上下文干扰等原因而给出错误答案。这和人类“记得学过，但一时想不起来”有点类似，但机制完全不同。</li>
</ol>
<p>一种主流缓解方式是 <strong>检索增强生成（Retrieval-Augmented Generation, RAG）</strong>：在推理时先从外部知识库（如 Wikipedia 或公司内网文档）检索相关文段，再把检索结果和用户问题一起喂给 LLM，让它在“外部记忆 + 内部参数”的联合信息上生成答案。RAG 已被证明能显著提高知识密集型任务的准确度和可追溯性。</p>
<p>另一个方向是<strong>工具增强（tool-augmented）语言模型</strong>：让 LLM 学会在需要时调用外部计算器、搜索引擎、数据库查询、代码执行环境等，从而把自己从“单机离线模型”升级为“会使用工具的代理（agent）”。系统性综述表明，这类架构在复杂推理、数值计算、领域专用知识等任务中有显著优势。</p>
<p>对于机器人而言，这种“外部知识源”更加重要：</p>
<ul>
<li>参数里的知识可以告诉机器人“如何一般性地折叠衣服”；</li>
<li>但只有外部传感（相机、力觉）和专用地图/数据库，才能告诉它“这件衣服到底在哪、当前皱成什么样”。
因此，在具身系统中，LLM 的知识局限应该通过<strong>环境感知 + 检索 + 专用知识库</strong>来弥补，而不能被当成“世界真相的唯一来源”。</li>
</ul>
<hr>
<h4 id="4243-错觉与事实性问题"><a class="header" href="#4243-错觉与事实性问题">4.2.4.3 错觉与事实性问题</a></h4>
<p>“幻觉”一词在本书中已经多次出现，这里做一个更系统的整理。大部分研究把 LLM 幻觉定义为：<strong>输出内容在形式上流畅自然，但在事实、逻辑或与上下文一致性上存在错误或捏造</strong>。</p>
<p>常见类型可以粗略分为：</p>
<ul>
<li><strong>上下文外幻觉（extrinsic）</strong>：回答与外部真实世界矛盾，例如捏造不存在的论文、引用虚假的法律条款；</li>
<li><strong>上下文内幻觉（intrinsic）</strong>：回答与输入上下文自身矛盾或逻辑不一致，例如前面说“这是一个 3×3 矩阵”，后面却把它当成 2×2 处理。</li>
</ul>
<p>造成幻觉的根本原因有：</p>
<ol>
<li><strong>目标函数不追求“真”，只追求“像”</strong>
下一个 token 预测 + RLHF（以人类偏好为导向），本质上都鼓励模型产生“看起来像好答案的文本”。只要在训练/偏好数据中，高分回答往往是“自信作答”而不是“诚实地说不知道”，模型就会更倾向于猜测而不是拒答。</li>
<li><strong>训练数据本身包含错误与噪声</strong>
互联网文本并不总是可靠，模型可能正确学习到“错误的事实”。</li>
<li><strong>生成算法放大高概率但错误的“故事”</strong>
为了提高可读性，我们常用温度调节、top-k / nucleus sampling 等采样策略；这些策略会倾向抽取“概率较高的 token”，一旦模型的内部分布略有偏差，就可能生成一条<strong>表面极其合理</strong>的错误叙事。</li>
</ol>
<p>在工程上，人们提出了多种缓解方案：</p>
<ul>
<li><strong>RAG 与知识库 grounding</strong>：在回答前强制检索权威数据源，让模型“围绕检索结果说话”；</li>
<li><strong>自一致性与多次采样交叉验证</strong>：对同一问题生成多份答案，相互比对，选取一致性更高的一份；</li>
<li><strong>显式不确定性表达</strong>：修改训练与评价指标，鼓励模型在不确定时说“我不知道”而不是乱猜；</li>
<li><strong>外部验证器</strong>：用小模型或规则系统对 LLM 输出进行事实核查，例如验证引用是否真实存在。</li>
</ul>
<p>尽管如此，当前共识仍然是：<strong>幻觉无法被完全消除，只能被压低到某个可接受水平</strong>。这在纯文本助手里已经是一个严重问题，在具身机器人系统中更是安全关键：</p>
<ul>
<li>如果 LLM 错把“有水的杯子”当成空杯子去翻转倒置，后果就是一桌水；</li>
<li>如果 LLM 误判危险区域、忽略用户设定的安全约束，会直接演化为物理世界的事故。</li>
</ul>
<p>因此，在本书后续关于 VLA 系统部署与安全性（第 10.3 节）中，我们会坚持一个原则：</p>
<blockquote>
<p><strong>不要把 LLM 的输出当成“事实”，而应当当成“需要验证与约束的建议”</strong>。</p>
</blockquote>
<p>在机器人具身智能的发展路线中，大语言模型提供了强大的知识与推理接口，但它必须始终处在<strong>传感–规划–控制</strong>这一闭环架构之中，被感知模块、控制约束和人类监督共同“托举”，才能真正安全、可靠地发挥价值。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="视觉语言对齐与多模态模型"><a href="#视觉语言对齐与多模态模型" class="header">视觉–语言对齐与多模态模型</a></h1>
<h3 id="431-图文对比学习clip-思路"><a class="header" href="#431-图文对比学习clip-思路">4.3.1 图文对比学习（CLIP 思路）</a></h3>
<p>这一小节的核心，是回答一个问题：**怎样让“看图的网络”和“读字的网络”学会在同一个语义空间里对齐？**CLIP 是目前最经典、也最具工程价值的方案之一。</p>
<hr>
<h4 id="4311-clip-模型"><a class="header" href="#4311-clip-模型">4.3.1.1 CLIP 模型</a></h4>
<p><strong>（1）整体思想：从“标签分类”到“自然语言监督”</strong>
传统视觉模型用“狗 / 猫 / 车”这类固定标签做监督；CLIP（Contrastive Language–Image Pretraining）反其道而行：</p>
<ul>
<li>不再依赖人工标注的有限类别，而是使用海量互联网图像及其自然语言描述（标题、alt 文本等）作为监督信号。</li>
<li>模型的任务不是“这张图是第几类”，而是“在一堆文本说明里，哪一句最有可能描述这张图？”——这是一个<strong>图文对齐问题</strong>。</li>
</ul>
<p><strong>（2）模型结构：双编码器 + 共享嵌入空间</strong>
CLIP 采用一个图像编码器和一个文本编码器，两者结构可以各自选择合适的 backbone：</p>
<ul>
<li><strong>图像编码器（Image Encoder）</strong>
<ul>
<li>典型选择：ResNet 系列或 ViT（Vision Transformer）。</li>
<li>输入图像 → 一系列卷积 / Transformer 层 → 得到一个全局图像向量（通过全局池化或 [CLS] token）。</li>
</ul>
</li>
<li><strong>文本编码器（Text Encoder）</strong>
<ul>
<li>采用 Transformer 结构（与 2.4 节介绍的类似），先做子词分词（如 BPE），再输入到多层 self-attention 中。</li>
<li>使用句子末尾的特殊 token（如 [EOS]）的隐藏状态作为整段文本的向量表示。</li>
</ul>
</li>
<li><strong>投影与归一化</strong>
<ul>
<li>两个编码器最后都接一个线性投影层，将图像和文本映射到同一维度的向量空间（例如 512 维）。</li>
<li>对向量做 L2 归一化，用<strong>余弦相似度</strong>衡量图文之间的语义相似。</li>
</ul>
</li>
</ul>
<blockquote>
<p>【图 4.3-1 占位：CLIP 结构示意图——左边是图像编码器（ResNet/ViT），右边是文本编码器（Transformer），二者输出向量被映射到同一嵌入空间，中间通过相似度矩阵和对比损失训练。】</p>
</blockquote>
<p><strong>（3）零样本分类与“提示工程”</strong>
预训练完成后，CLIP 不需要再单独训练分类头，就能做<strong>零样本图像分类</strong>：</p>
<ul>
<li>给定一个分类任务（如 ImageNet 的 1000 类），先为每个类别写一句自然语言提示，例如“a photo of a dog”，“a photo of a cat”。</li>
<li>用文本编码器编码这些类别描述；用图像编码器编码一张测试图像。</li>
<li>比较图像向量与每个类别文本向量的相似度，选相似度最大的类别作为预测。</li>
</ul>
<p>从机器人角度看，这等价于让机器人用“语言标签”来理解视觉概念：后续在 VLA 模型中，可以通过调整文本提示来改变机器人对环境的“分类方式”，而不必重新训练整个视觉网络。</p>
<hr>
<h4 id="4312-图文对齐训练"><a class="header" href="#4312-图文对齐训练">4.3.1.2 图文对齐训练</a></h4>
<p><strong>（1）对比学习直觉：拉近正样本、推远负样本</strong>
对比学习（contrastive learning）的核心思想很简单：</p>
<ul>
<li>对于一对真实匹配的图像–文本（I, T），希望它们在嵌入空间的距离尽可能近；</li>
<li>对于不匹配的图像–文本对，则希望距离尽可能远。</li>
</ul>
<p>在 CLIP 中，“负样本”来自同一个 mini-batch 内的其它图文对，无需额外标注，这使得训练可以扩展到数亿规模的图文对。</p>
<p><strong>（2）InfoNCE / 对比损失形式</strong>
设一个 batch 内有 (N) 对图文样本 ((I_i, T_i))，记图像 / 文本编码器输出的向量为 (\mathbf{v}_i, \mathbf{u}<em>i)，相似度 (s</em>{ij} = \cos(\mathbf{v}_i, \mathbf{u}_j))。</p>
<ul>
<li><strong>图像→文本方向的对比损失</strong>（每张图必须“认出”自己的文本）：</li>
</ul>
<p>$$
L_{\text{img}} = -\frac{1}{N}\sum_{i=1}^{N} \log \frac{\exp(s_{ii}/\tau)}{\sum_{j=1}^{N}\exp(s_{ij}/\tau)}
$$</p>
<ul>
<li><strong>文本→图像方向的对比损失</strong>（每段文本也必须“认出”自己的图像）：</li>
</ul>
<p>$$
L_{\text{text}} = -\frac{1}{N}\sum_{i=1}^{N} \log \frac{\exp(s_{ii}/\tau)}{\sum_{k=1}^{N}\exp(s_{ki}/\tau)}
$$</p>
<ul>
<li>总损失 (L = \frac{1}{2}(L_{\text{img}} + L_{\text{text}}))，其中 (\tau) 为<strong>温度参数</strong>，控制相似度分布的“尖锐程度”。</li>
</ul>
<p>解释成自然语言就是：<strong>每张图要在所有文本中找到“唯一正确的一句”，每段文本也要在所有图中找到“唯一对应的一张”，并且错配要被严重惩罚。</strong></p>
<p><strong>（3）负样本规模与变体</strong></p>
<ul>
<li>batch 越大，“负样本”越多，对比学习效果越好，因此 CLIP 采用大 batch 训练。</li>
<li>后续工作在 CLIP 基础上加入<strong>检索增强</strong>或<strong>局部区域–文本对齐</strong>，提升精细对齐能力，例如 RA-CLIP 引入在线检索增强特征，CLOC 通过 region-text 对比改善定位能力等。</li>
</ul>
<p>对机器人而言，精细的区域–文本对齐可以帮助模型区分“桌子上的红杯子”和“地板上的红杯子”，为精准操作打基础。</p>
<hr>
<h4 id="4313-用途"><a class="header" href="#4313-用途">4.3.1.3 用途</a></h4>
<p>CLIP 训练出的图文对齐表征，已经成为多模态世界的“通用货币”，下游可以有多种使用方式：</p>
<p><strong>（1）零样本 / 少样本视觉识别</strong></p>
<ul>
<li>通过不同文本提示，实现开放类别分类，例如“一个工业机械臂”“一个吸尘机器人”“一个桌面场景”等。</li>
<li>在机器人应用中，可用自然语言直接定义新类别，而不必收集专门数据集重新训练分类器。</li>
</ul>
<p><strong>（2）跨模态检索与语义搜索</strong></p>
<ul>
<li>以图找文：给一个场景图片，检索最匹配的文本描述或说明文档；</li>
<li>以文找图：给一句指令或描述，检索相应的图像 / 视频片段，例如“人把杯子放进微波炉”的示范视频。
这类检索能力为后续“从视频库中检索相似示教轨迹供机器人模仿”提供了基础。</li>
</ul>
<p><strong>（3）作为下游模型的“语义模块”</strong></p>
<ul>
<li>文本到图像生成模型中，CLIP 可以作为<strong>评估器 / 奖励模型</strong>，引导生成结果与文本更匹配。</li>
<li>在大规模 VLM/VLA 中，CLIP 式图文对齐常被用作预训练第一阶段，为后续更复杂的多模态推理打基础。</li>
</ul>
<p><strong>（4）对机器人具身智能的意义</strong></p>
<ul>
<li>将“看到的像素”映射到与“语言”共享的语义空间，是让机器人理解人类指令和环境语义的第一步。</li>
<li>只要图像与语言在表征空间中可计算相似度，后面就可以自然地加入“动作”这一模态，形成视觉–语言–动作一体的 VLA 模型（第 8 章会展开）。</li>
</ul>
<hr>
<h3 id="432-图文检索vqa图像字幕等任务"><a class="header" href="#432-图文检索vqa图像字幕等任务">4.3.2 图文检索、VQA、图像字幕等任务</a></h3>
<p>在具身智能之前，视觉–语言模型最典型的评测任务主要是三类：<strong>图文检索、视觉问答（VQA）、图像描述（Image Captioning）</strong>。它们覆盖了“检索、理解、生成”三种能力维度，也会在机器人场景中以各种形式出现。</p>
<blockquote>
<p>【图 4.3-2 占位：多模态任务一览图——上：以文找图 / 以图找文；中：VQA（图像 + 问题 → 文本答案）；下：Image Captioning（图像 → 描述句子）。】</p>
</blockquote>
<hr>
<h4 id="4321-图文检索"><a class="header" href="#4321-图文检索">4.3.2.1 图文检索</a></h4>
<p><strong>（1）任务定义</strong>
图文检索（Image–Text Retrieval）包含两个方向：</p>
<ul>
<li><strong>文本检索图像（Text→Image）</strong>：给定一句文本描述，检索与之最匹配的图像（例如在图库中找到“机器人把碗放进柜子”的画面）。</li>
<li><strong>图像检索文本（Image→Text）</strong>：给定一张图像，在文本库中找出最相关的说明文、操作步骤等。</li>
</ul>
<p>在机器人系统中，这可以被用来<strong>从大规模操作视频 / 示教库中检索相似场景与动作脚本</strong>。</p>
<p><strong>（2）实现路径：双编码器 + 相似度搜索</strong></p>
<ul>
<li>使用类似 CLIP 的双编码器结构，将所有图像和文本编码为向量，并归一化。</li>
<li>检索时，仅需计算查询向量与数据库向量的余弦相似度，使用向量检索库（如 FAISS）实现高效近邻搜索。</li>
<li>对需要更精细语义匹配的场景，可先用双编码器快速召回，再用单流或交叉注意力模型重排序（re-ranking）。</li>
</ul>
<p><strong>（3）评价指标与数据集</strong></p>
<ul>
<li>常用指标：Recall@K（R@1/5/10）、mAP 等，与第 3 章目标检测指标类似但针对检索任务。</li>
<li>典型数据集：MS-COCO、Flickr30k 等，提供图像和多句描述，用于训练和评测检索能力。</li>
</ul>
<hr>
<h4 id="4322-vqa视觉问答"><a class="header" href="#4322-vqa视觉问答">4.3.2.2 VQA（视觉问答）</a></h4>
<p><strong>（1）任务定义与特点</strong>
视觉问答（Visual Question Answering, VQA）指：给定一张图像和一个自然语言问题，让模型输出一个自然语言答案。</p>
<ul>
<li>问题可以是<strong>事实类</strong>：“桌子上有几个杯子？”</li>
<li>也可以是<strong>关系类</strong>：“红色杯子在碗的左边还是右边？”</li>
<li>甚至是<strong>知识类</strong>：“这个工具通常用来做什么？”（需要结合外部世界知识，OK-VQA 等数据集便属于此类）。</li>
</ul>
<p><strong>（2）模型结构</strong>
典型 VQA 模型包含三部分：</p>
<ol>
<li><strong>视觉编码</strong>：用 CNN/ViT 把图像编码成特征图或对象级特征（如检测框 + ROI 特征）。</li>
<li><strong>语言编码</strong>：用 RNN/Transformer 编码问题文本。</li>
<li><strong>多模态融合与回答解码</strong>：
<ul>
<li>早期做法：把图像向量和问题向量简单拼接，然后用 MLP 分类固定答案集合。</li>
<li>现代做法：使用单流或带 cross-attention 的 Transformer，在 token 层进行细粒度对齐，最后输出答案 token（可以是分类，也可以自由生成）。</li>
</ul>
</li>
</ol>
<p><strong>（3）与机器人场景的联系</strong>
在具身机器人中，VQA 形式的能力可以用来：</p>
<ul>
<li>做<strong>状态查询</strong>：例如“抽屉现在是开着的还是关着的？”、“桌上还有脏碗吗？”</li>
<li>做<strong>诊断与解释</strong>：机器人执行前，先问自己“目标物体是否可见？”、“是否存在障碍物挡住路径？”让高层策略更稳健。</li>
</ul>
<p>后续在 VLA 章节，可以把 VQA 视为“对当前视觉观测的语言推理子模块”。</p>
<hr>
<h4 id="4323-图像描述image-captioning"><a class="header" href="#4323-图像描述image-captioning">4.3.2.3 图像描述（Image Captioning）</a></h4>
<p><strong>（1）任务定义</strong>
图像描述（Image Captioning）要求模型根据输入图像<strong>生成一段自然语言描述</strong>，既要覆盖主要物体，也要体现关系和场景语义。</p>
<ul>
<li>简单描述： “一个机器人站在桌旁。”</li>
<li>更丰富的描述： “一台白色机械臂正从桌上的蓝色盒子里取出一只杯子。”</li>
</ul>
<p><strong>（2）典型架构：编码器–解码器</strong></p>
<ol>
<li><strong>编码器（视觉）</strong>：CNN 或 ViT，将图像映射为特征向量或特征序列。</li>
<li><strong>解码器（语言）</strong>：RNN 或 Transformer，自回归地逐词生成描述文本。</li>
<li><strong>训练目标</strong>：
<ul>
<li>主流是<strong>序列交叉熵损失</strong>（teacher forcing，下一个词预测）。</li>
<li>有时还会结合 RL 方法，直接优化 BLEU、CIDEr 等评价指标。</li>
</ul>
</li>
</ol>
<p>新近工作还提出“全景式描述（Panoptic Captioning）”，试图用一段文本尽可能完整覆盖图中所有物体、关系和属性，使图像与文本更接近“信息等价”。</p>
<p><strong>（3）在机器人中的作用</strong></p>
<ul>
<li><strong>环境汇报 / 日志生成</strong>：机器人可以用自然语言描述当前看到的场景，为人类提供可读日志，例如“我已经把三个碗放进洗碗机，还剩一个在桌角”。</li>
<li><strong>辅助 VQA 与规划</strong>：先将图像转为文字摘要，再交给强大的文本 LLM 做复杂逻辑推理（这种“先描述再推理”的方案在 OK-VQA 等任务中表现良好）。</li>
</ul>
<blockquote>
<p>【图 4.3-3 占位：图像描述架构示意图——左侧图像编码器输出特征，右侧语言解码器按时间步生成描述 token。】</p>
</blockquote>
<hr>
<h3 id="433-视觉语言大模型vlm的结构联合--解耦"><a class="header" href="#433-视觉语言大模型vlm的结构联合--解耦">4.3.3 视觉–语言大模型（VLM）的结构（联合 / 解耦）</a></h3>
<p>视觉–语言模型（Vision-Language Model, VLM）指能同时理解图像和文本、并在两者之间建立语义联系的模型。它们是后续 VLA（视觉–语言–动作）模型的直接前身。</p>
<p>从结构上看，主流可以概括为两大类：</p>
<ul>
<li><strong>双流结构（解耦）</strong>：视觉与语言各自编码，后期再融合；</li>
<li><strong>单流结构（联合）</strong>：视觉 token 与文本 token 放在一个 Transformer 里统一处理。</li>
</ul>
<hr>
<h4 id="4331-双流结构解耦"><a class="header" href="#4331-双流结构解耦">4.3.3.1 双流结构（解耦）</a></h4>
<p><strong>（1）基本思路</strong>
双流结构通常包含：</p>
<ul>
<li>一个<strong>视觉编码器</strong>（ResNet/ViT 等），输出图像特征向量或 patch 序列；</li>
<li>一个<strong>文本编码器</strong>（BERT/Transformer 等），输出文本向量或 token 序列；</li>
<li>在高层通过相似度（CLIP）、简单拼接或少量 cross-attention 层进行融合。</li>
</ul>
<p>CLIP、ALIGN 等大规模图文对比预训练模型可视为典型的<strong>双编码器式 VLM</strong>。</p>
<p><strong>（2）优点</strong></p>
<ul>
<li><strong>可充分复用单模态预训练模型</strong>：直接加载已有的视觉 backbone 与语言模型权重，只在顶部做少量适配。</li>
<li><strong>检索效率极高</strong>：图像和文本可以分别预计算向量，在线检索只需做向量相似度计算，非常适合大规模检索场景。</li>
<li><strong>工程部署友好</strong>：视觉编码可放在机器人的本地板卡上，文本编码可以在云端共享，一个视觉特征可以支持多种语言任务。</li>
</ul>
<p><strong>（3）局限性</strong></p>
<ul>
<li>视觉和语言交互较“浅”，主要靠全局向量相似度，难以精细理解<strong>局部关系</strong>（例如“左边第二个红杯子”）。</li>
<li>做复杂推理（如长文本问答、推断隐含关系）时，往往需要再叠加更复杂的 Cross-Attention 或 LLM 模块。</li>
</ul>
<p>从具身智能视角看，双流结构很适合做<strong>通用感知模块</strong>：先把图像转为语义向量，再交给高层语言 / 决策模块处理。</p>
<hr>
<h4 id="4332-单流结构联合"><a class="header" href="#4332-单流结构联合">4.3.3.2 单流结构（联合）</a></h4>
<p><strong>（1）基本思路：统一 Transformer</strong>
单流结构假设视觉和语言之间的关系足够复杂，需要在 token 级别完全交织，因此：</p>
<ul>
<li>将图像切成 patch（或用检测器抽取对象特征），把每个 patch 映射为“视觉 token”；</li>
<li>将文本子词映射为“语言 token”；</li>
<li>把两类 token 串接在一起，加入位置编码与模态编码，一并输入单个多层 Transformer，通过自注意力实现全局交互。</li>
</ul>
<p>典型单流模型包括 VisualBERT、VL-BERT、UNITER 等。</p>
<p><strong>（2）优点</strong></p>
<ul>
<li>能在 token 级别学习复杂的跨模态对齐，例如“哪一块图像区域对应文本中的某个词”。</li>
<li>非常适合<strong>VQA、图文推理、细粒度多模态理解</strong>等任务。</li>
<li>也便于在同一结构中同时加入多种预训练目标（ITC、ITM、MLM、Captioning 等）。</li>
</ul>
<p><strong>（3）局限性</strong></p>
<ul>
<li>计算成本较高，无法像双编码器那样方便地离线预计算表示。</li>
<li>图像和文本必须一起送进模型，在线推理时的延迟和显存占用更大，这对实时机器人控制是一个压力。</li>
</ul>
<p>近年来的大型视觉–语言大模型（例如 BLIP 系列、部分 LVLM）一般在双流与单流之间采用<strong>分阶段或混合结构</strong>：先用双流对齐，再用单流精细融合。</p>
<hr>
<h4 id="4333-模型选择"><a class="header" href="#4333-模型选择">4.3.3.3 模型选择</a></h4>
<p>在实际系统中选择哪种结构，取决于任务类型与资源约束，可以从以下维度考虑：</p>
<p><strong>（1）任务类型</strong></p>
<ul>
<li>若以<strong>检索 / 开放词汇识别</strong>为主（例如为机器人查找相关示教视频、做开放类别物体识别），双编码器 + 对比学习往往足够，且高效。</li>
<li>若需要复杂的<strong>图文推理、细粒度问答</strong>（如长文本指令 + 场景理解），则单流或带 cross-attention 的联合结构更合适。</li>
</ul>
<p><strong>（2）计算与部署</strong></p>
<ul>
<li>在<strong>资源受限</strong>的嵌入式机器人平台上，更倾向采用参数较小的双流结构，将重计算（如大语言模型）放在云端。</li>
<li>在离线训练或服务器环境中，可以使用单流结构做重型训练，然后利用蒸馏等手段（见第 10.4 节）将其压缩。</li>
</ul>
<p><strong>（3）与后续动作决策模块的接口</strong></p>
<ul>
<li>如果后续 VLA 模型只需要一个<strong>紧凑的状态向量</strong>（例如“场景的语义 embedding”），双流结构自然输出这种向量。</li>
<li>如果希望在生成动作时直接访问<strong>图像 token 与语言 token 的细粒度交互信息</strong>，单流或混合结构更有优势。</li>
</ul>
<blockquote>
<p>【图 4.3-4 占位：VLM 结构比较图——左：双流（独立图像/文本编码器，顶部用相似度或简易融合）；右：单流（统一 Transformer 处理图像 token + 文本 token）。】</p>
</blockquote>
<hr>
<h3 id="434-多模态预训练目标设计对比匹配生成"><a class="header" href="#434-多模态预训练目标设计对比匹配生成">4.3.4 多模态预训练目标设计（对比、匹配、生成）</a></h3>
<p>从优化目标的角度，看待视觉–语言预训练会更清晰：多数 VLM 都是**对比（contrastive）+ 匹配（matching）+ 生成（generative）**三类目标的组合，只是侧重点不同。</p>
<hr>
<h4 id="4341-对比目标"><a class="header" href="#4341-对比目标">4.3.4.1 对比目标</a></h4>
<p><strong>（1）全局图文对比（Image–Text Contrastive, ITC）</strong></p>
<ul>
<li>典型代表就是 CLIP 的 InfoNCE 损失（见 4.3.1.2），目标是让<strong>全局图像向量</strong>与其对应的<strong>全局文本向量</strong>在嵌入空间中靠近，对其他样本远离。</li>
<li>适合训练<strong>可迁移的全局语义表示</strong>，对检索和零样本分类非常有效。</li>
</ul>
<p><strong>（2）局部对比与细粒度对齐</strong>
为支持更细粒度任务（如区域级定位），一些工作将对比目标拓展到：</p>
<ul>
<li>区域–短语对比：例如让“the red cup on the right”对应图像中的某个局部区域。</li>
<li>token–token 对比：在视觉 token 与文本 token 之间建立一对一或一对多的对齐。</li>
</ul>
<p>这种细粒度对齐对机器人抓取与操作特别重要，因为许多指令会涉及空间关系和对象局部（“把杯子把手朝上”）。</p>
<hr>
<h4 id="4342-匹配目标"><a class="header" href="#4342-匹配目标">4.3.4.2 匹配目标</a></h4>
<p><strong>（1）图文匹配（Image–Text Matching, ITM）</strong>
ITM 通常被定义为一个<strong>二分类任务</strong>：给定一对图像–文本，预测它们是“匹配”还是“不匹配”。</p>
<ul>
<li>正样本：真实图像及其描述。</li>
<li>负样本：随机替换文本或图像得到的错配对，或使用难例挖掘选择“看起来很像但不对的描述”。</li>
</ul>
<p>与对比学习相比，ITM 常在<strong>联合 Transformer</strong>上进行（例如 UNITER、BLIP 中的多模态编码器），要求模型通过 cross-attention 精细判断图文是否一致。</p>
<p><strong>（2）Token 级 / 实例级匹配</strong>
更进一步的工作如 VL-Match，将匹配目标细化到 token 或实例级：</p>
<ul>
<li>Token-level Matching：预测每个文本 token 是否在图像中有对应视觉证据。</li>
<li>Instance-level Matching：对于图像中的每个物体，判断是否在文本中被提及。</li>
</ul>
<p>这类目标能显著增强模型对“描述是否完整 / 是否遗漏关键物体”的判断能力，对于机器人执行安全相关指令（如“不要碰桌子右边的玻璃杯”）尤其重要。</p>
<hr>
<h4 id="4343-生成目标"><a class="header" href="#4343-生成目标">4.3.4.3 生成目标</a></h4>
<p><strong>（1）图像条件下的语言生成（Captioning / MLM）</strong>
生成目标让模型在图像条件下学会“说话”，常见形式包括：</p>
<ul>
<li><strong>图像描述生成</strong>：给定图像，生成完整描述句子（Image Captioning），损失多为自回归的交叉熵。</li>
<li><strong>条件掩码语言建模（Conditional MLM）</strong>：在给定图像和文本上下文的条件下，随机 mask 掉部分词，要求模型重建这些词。</li>
<li><strong>语言模型式预训练</strong>：把图像特征作为“前缀”输入语言模型，使其在多模态提示下完成填空或续写。</li>
</ul>
<p>BLIP 等模型会同时使用 ITC、ITM 和 Captioning 三种目标，使得模型既能对比对齐，又能判别匹配，还能自然生成描述文本。</p>
<p><strong>（2）重建与世界建模</strong>
在更广义的生成目标中，还包括：</p>
<ul>
<li><strong>掩码图像建模（MIM）</strong>：随机遮挡图像部分区域，让模型根据未遮挡区域和文本恢复像素或特征（例如 MAE 类方法的多模态版本）。</li>
<li><strong>视频 / 未来帧预测</strong>：给定当前图像与文本，预测下一帧或未来的视觉变化，为未来的世界模型（第 12 章）打基础。</li>
</ul>
<p><strong>（3）对具身智能的启示</strong>
对于机器人 VLA 模型，生成目标有两个重要作用：</p>
<ul>
<li>让模型具备<strong>用语言解释自己所见所为</strong>的能力，这直接对应 4.4 节中“语言作为解释接口”的需求。</li>
<li>生成式训练与大语言模型的预训练目标兼容，便于将视觉–语言模型进一步扩展为视觉–语言–动作模型，通过“在统一序列上生成 token”的方式一起预测文本和动作。</li>
</ul>
<blockquote>
<p>【图 4.3-5 占位：多任务预训练示意图——同一 VLM 同时优化三种损失：ITC（对比）、ITM（匹配）、Caption（生成），三者用不同颜色标注在同一结构上。】</p>
</blockquote>
<hr>
<p>本节从 CLIP 式图文对比学习出发，介绍了多种视觉–语言任务形式、VLM 的结构设计，以及对比 / 匹配 / 生成三类预训练目标。后续章节将在此基础上进一步引入“动作”这一模态，展示如何把这些视觉–语言能力自然扩展为机器人可以执行的视觉–语言–动作策略。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="语言在机器人中的角色"><a href="#语言在机器人中的角色" class="header">语言在机器人中的角色</a></h1>
<h3 id="44-语言在机器人中的角色本节综述"><a class="header" href="#44-语言在机器人中的角色本节综述">4.4 语言在机器人中的角色（本节综述）</a></h3>
<p>在具身智能中，“语言”不再只是聊天工具，而是贯穿<strong>任务描述、约束与安全、行为解释、规划分解</strong>的统一接口。
本节重点讨论：当机器人已经具备视觉与控制能力之后，如何把“人话”稳健地接到“机器动作”上，并反过来用语言让机器人更可控、更安全、更可理解。</p>
<hr>
<h3 id="441-语言作为任务描述goal-specification"><a class="header" href="#441-语言作为任务描述goal-specification">4.4.1 语言作为任务描述（goal specification）</a></h3>
<h4 id="4411-自然语言指令"><a class="header" href="#4411-自然语言指令">4.4.1.1 自然语言指令</a></h4>
<p>在人机协作场景中，最自然的任务接口就是一句话：</p>
<blockquote>
<p>“把桌上的红色杯子放进水槽左边的碗里。”</p>
</blockquote>
<p>对人类来说，这是一句再日常不过的句子，对机器人来说，这其实隐含了多个层次的信息：</p>
<ul>
<li>任务意图：<strong>搬运（pick-and-place）</strong></li>
<li>目标物体：<strong>红色杯子</strong></li>
<li>目标位置：<strong>水槽左边的碗</strong></li>
<li>关系约束：<strong>从桌子上拿起，再放入碗中</strong></li>
<li>隐含常识：不要打碎杯子，要先清空路径、避免撞到人等</li>
</ul>
<p>典型的自然语言任务接口一般包含以下处理链路：</p>
<ol>
<li><strong>语言输入</strong>
<ul>
<li>文本指令（键盘、APP、手机端）</li>
<li>语音指令 + 语音识别（ASR）转成文本</li>
</ul>
</li>
<li><strong>语义解析 / LLM 理解</strong>
<ul>
<li>使用大语言模型或专门的语义解析器，将指令转为结构化表示，例如：</li>
</ul>
</li>
</ol>
<pre><code class="language-latex">action: place
object: cup(color=red, category=“mug”)
target: bowl(location=left_of(sink))
constraints: gentle, avoid_spill
</code></pre>
<pre><code>- 现代系统常利用语言模型直接对“动作原语库”进行评分，选择适合技能，如 SayCan 框架通过将 LLM 与价值函数组合来选择技能序列，实现“既有用又可行”的行动 ([arXiv](https://arxiv.org/pdf/2204.01691?utm_source=chatgpt.com))
</code></pre>
<ol start="3">
<li><strong>与感知和控制对接</strong>
<ul>
<li>视觉模块在场景中识别“红色杯子”“碗”“水槽”等目标</li>
<li>任务层规划生成抓取、移动、放置的子任务序列</li>
<li>低层控制器生成具体的轨迹和关节控制命令</li>
</ul>
</li>
</ol>
<blockquote>
<p>[图片占位：一张“自然语言指令到机器人执行”的流程图
从左到右依次为：人类口头/文本指令 → 语言模型/解析器 → 结构化任务表示（object / target / constraints）→ 任务规划器 → 运动规划 → 机械臂执行画面。]</p>
</blockquote>
<p>相比传统“按钮 + 工程参数”的交互方式，自然语言有三个优势：</p>
<ul>
<li>接近人类思维，<strong>学习成本低</strong></li>
<li>可以<strong>模糊但正确地</strong>描述任务（“大概放在中间”“尽量轻一点”），由系统再细化</li>
<li>方便表达<strong>组合任务与长时序目标</strong>（“先把桌子收拾干净，再拖地”）</li>
</ul>
<p>语言条件化机器人策略，已经在多种操作基准与真实机器人中被验证可行，如 VIMA 提出用多模态 prompt（语言 + 目标图像）来统一表达多种操作任务，Transformer 模型自回归地产生动作序列 (<a href="https://openreview.net/forum?id=hzjQWjPC04A&amp;utm_source=chatgpt.com">OpenReview</a>)。</p>
<hr>
<h4 id="4412-相比坐标输入"><a class="header" href="#4412-相比坐标输入">4.4.1.2 相比坐标输入</a></h4>
<p>传统机器人更习惯接受这样的命令：</p>
<ul>
<li>“末端移动到 $ (x, y, z, roll, pitch, yaw) $”</li>
<li>“关节角设置为 $ q_1, \dots, q_7 $”</li>
</ul>
<p>这类<strong>坐标/关节指令</strong>有两个显著特征：</p>
<ol>
<li><strong>语义层次低</strong>
<ul>
<li>它只告诉机器人“到哪儿、摆成什么姿态”，而不是“为什么要这样做”</li>
<li>无法直接表达“抓起”“放下”“避开玻璃杯”等任务语义和约束</li>
</ul>
</li>
<li><strong>对使用者要求高</strong>
<ul>
<li>人类需要理解机器人坐标系、DH 参数、工作空间边界等</li>
<li>在非结构化场景（家居、仓库）中，用户难以给出准确坐标，更不可能频繁手动输入</li>
</ul>
</li>
</ol>
<p>语言接口与坐标接口之间的关系可以这样理解：</p>
<ul>
<li><strong>语言：任务层描述</strong>（task-level）
<ul>
<li>“把 A 放到 B”“先做 X 再做 Y”“如果桌子太乱就先整理”</li>
</ul>
</li>
<li><strong>坐标：控制层接口</strong>（motion/control-level）
<ul>
<li>决策好的“抓取 A”最终会被落到一系列笛卡尔位姿或关节轨迹上</li>
</ul>
</li>
</ul>
<p>现代 VLA 系统的典型做法是：</p>
<blockquote>
<p>语言描述 → 抽象任务表示（符号层）→ 运动规划器生成一组几何目标 / 轨迹 → 控制器执行。</p>
</blockquote>
<p>这样既保留了语言的高层表达力，又利用坐标级控制的精确性与可验证性。</p>
<hr>
<h4 id="4413-任务参数提取"><a class="header" href="#4413-任务参数提取">4.4.1.3 任务参数提取</a></h4>
<p>要让语言真正转化为可执行任务，核心是从自然语言中自动提取出<strong>任务参数（task parameters）</strong>，并与环境状态对齐。</p>
<p>常见的任务参数类型包括：</p>
<ul>
<li><strong>对象参数</strong>：类别、颜色、形状、材质、是否易碎</li>
<li><strong>目标位置 / 容器</strong>：桌面某区域、某个容器、某个具体物体附近</li>
<li><strong>空间关系</strong>：左边、右边、前面、背后、堆叠在上方、靠近墙面等</li>
<li><strong>时序结构</strong>：先后顺序、条件执行（“如果 A 不存在就改为 B”）</li>
<li><strong>风格 / 性能要求</strong>：快/慢、轻/重、优先节能/优先速度等</li>
</ul>
<p>在工程上可采用多种方式提取：</p>
<ol>
<li><strong>模板与槽位（slot filling）</strong>
对于结构固定的任务（如装配线操作），可定义模板：</li>
</ol>
<blockquote>
<p>模板：“把 [颜色] 的 [物体] 放到 [目标位置]”
然后用简单的 NLP 或正则匹配来提取槽位。</p>
</blockquote>
<ol start="2">
<li><strong>语义角色标注 / 依存分析</strong>
<ul>
<li>使用语法分析器找出句子中的谓词（谓词：put / move / pick）及其论元（agent, patient, destination）。</li>
<li>如：“把红色杯子放到水槽左边的碗里”中：
<ul>
<li>动作：放</li>
<li>受事（被操作对象）：红色杯子</li>
<li>目标：碗</li>
<li>目标位置修饰：水槽左边</li>
</ul>
</li>
</ul>
</li>
<li><strong>大语言模型 + 结构化输出</strong>
<ul>
<li>直接让 LLM 输出 JSON 或类似结构：</li>
</ul>
</li>
</ol>
<pre><code class="language-json">{
  "high_level_action": "place",
  "object": {"type": "cup", "color": "red"},
  "target": {"type": "bowl", "relation": "left_of", "anchor": "sink"},
  "constraints": ["be_gentle"]
}
</code></pre>
<pre><code>- 这种方式已被广泛用于语言条件化策略学习和多任务操作系统，如多个工作将自然语言指令映射为操作子、技能调用图或 symbolic predicate，用于下游规划器 ([arXiv](https://arxiv.org/html/2412.05313v1?utm_source=chatgpt.com))
</code></pre>
<ol start="4">
<li><strong>“代码即策略”（Code as Policies）</strong>
更进一步，可以直接让 LLM 生成<strong>可执行代码</strong>，代码中显式包含任务参数、条件判断和控制 API 调用。例如 CaP 框架中，大模型从自然语言生成完整的 Python 控制程序，其中对物体、目标、运动参数的解析隐含在生成的函数调用与逻辑结构中 (<a href="https://arxiv.org/abs/2209.07753?utm_source=chatgpt.com">arXiv</a>)。</li>
</ol>
<blockquote>
<p>[图片占位：自然语言 → JSON 任务表示 → 运动规划 → 控制的示意图。
左侧是原始中文指令，中间是结构化参数表，右侧为机械臂在仿真环境中执行抓取/放置动作的帧序列。]</p>
</blockquote>
<p>在本书后续 VLA 架构与训练章节（第 8、9 章）中，可以把“任务参数提取”视作<strong>语言编码器 + 头部预测任务</strong>的一部分，或视作 LLM 通过 few-shot 提示（prompting）自动完成的子功能。</p>
<hr>
<h3 id="442-语言作为约束与安全规范规则禁止项"><a class="header" href="#442-语言作为约束与安全规范规则禁止项">4.4.2 语言作为约束与安全规范（规则、禁止项）</a></h3>
<p>任务描述回答的是“<strong>做什么</strong>”，但对真实机器人系统来说，“<strong>不准做什么</strong>”同样重要，尤其在开放环境中。</p>
<p>语言可以自然地表达：</p>
<ul>
<li>安全边界：“不要靠近人”“不能碰到墙上的名画”</li>
<li>操作限制：“易碎物品都要轻拿轻放”“不要提起超过 5kg 的物体”</li>
<li>个性偏好：“不要在晚上 10 点以后打扫”“不要移动这张桌子上的任何东西”</li>
</ul>
<p>这些信息对 RL 奖励函数或传统代价函数来说很难完整编码，因此自然语言约束逐渐成为安全机器人学习的重要研究方向。Safe RL with Natural Language Constraints 这类工作就专门区分了“指令（做什么）”与“约束（不能做什么）”，并用文本对安全区域进行定义和学习 (<a href="https://proceedings.neurips.cc/paper/2021/file/72f67e70f6b7cdc4cc893edaddf0c4c6-Paper.pdf?utm_source=chatgpt.com">NeurIPS Proceedings</a>)。</p>
<hr>
<h4 id="4421-语言规则示例"><a class="header" href="#4421-语言规则示例">4.4.2.1 语言规则示例</a></h4>
<p>从工程视角看，我们希望把自然语言规则系统化整理为可处理的类型。
可以将常见规则粗略划分为：</p>
<ol>
<li><strong>区域/位置类约束</strong>
<ul>
<li>“不要进入厨房的地毯区域”</li>
<li>“离墙至少 30cm”</li>
<li>“不要在婴儿床 1 米以内移动”</li>
</ul>
</li>
<li><strong>对象/材料类约束</strong>
<ul>
<li>“不要触碰玻璃制品”</li>
<li>“对易碎物体速度要小于 0.1 m/s”</li>
<li>“不要移动这个黑色笔记本电脑”</li>
</ul>
</li>
<li><strong>交互与力学类约束</strong>
<ul>
<li>“人接近时降低速度”</li>
<li>“不要施加超过 10N 的推力”</li>
<li>“搬运液体时避免急加速”</li>
</ul>
</li>
<li><strong>时序类约束</strong>
<ul>
<li>“先确认门关闭再启动机械臂”</li>
<li>“绝对不要在有人进入房间之前开启激光器”</li>
<li>“如果湿滑警示存在，不要进入该区域”</li>
</ul>
</li>
</ol>
<blockquote>
<p>[图片占位：表格形式的“自然语言规则示例汇总图”，左列为中文规则，中列为类别（区域/对象/力学/时序），右列为简要解释。]</p>
</blockquote>
<p>这些规则本身可以由操作员、实验室安全规范、企业 SOP（Standard Operating Procedure）或监管机构标准给出，再通过语言接口实时配置给机器人。</p>
<hr>
<h4 id="4422-将安全规范翻译为可检查条件"><a class="header" href="#4422-将安全规范翻译为可检查条件">4.4.2.2 将安全规范翻译为可检查条件</a></h4>
<p>自然语言规则最终必须变成<strong>可计算、可验证的形式</strong>，才能在规划和控制中生效。典型做法是构建一个“语言 → 形式规范”的翻译模块，然后在控制环路中加入一个**安全过滤器（safety filter）**或“Safety Chip”进行实时约束检查 (<a href="https://h2r.cs.brown.edu/wp-content/uploads/yang24.pdf?utm_source=chatgpt.com">人机实验室</a>)。</p>
<p>可以从三个层次理解这一过程：</p>
<ol>
<li><strong>语义到逻辑/数学形式的映射</strong>举例：</li>
</ol>
<p>更复杂的时序规则（如“先关门再开动机器人”）常被映射为**时序逻辑（如 LTL）**或自动机约束，并在规划或 MPC（Model Predictive Control）中强制满足。部分工作已经实现了从自然语言到 LTL 公式的自动翻译，再用自动机对策略执行过程进行监控 (<a href="https://h2r.cs.brown.edu/wp-content/uploads/yang24.pdf?utm_source=chatgpt.com">人机实验室</a>)。</p>
<pre><code>- 语言规则：
</code></pre>
<blockquote>
<p>“不要靠近人，至少保持 0.8 米距离。”</p>
</blockquote>
<pre><code>- 转换为数学约束：
</code></pre>
<p>$$
\forall t,\ \text{dist}(\text{robot}(t), \text{human}(t)) \ge 0.8\ \text{m}
$$
- 再进一步可转换为运动规划中的线性或非线性不等式约束。
2. <strong>结合感知进行“语义落地”（grounding）</strong></p>
<p>近期工作提出“语言条件化安全过滤”框架：LLM 将自然语言规则翻译为结构化安全规格；感知模块维护对象级 3D 表示；控制模块通过 MPC 或 QP 在实时控制中强制满足语义与几何安全约束 (<a href="https://arxiv.org/abs/2511.05889?utm_source=chatgpt.com">arXiv</a>)。</p>
<pre><code>- “不要压到地上的电源线”需要先通过视觉/点云识别“电源线”，再把其投影到机器人坐标系中，定义避让区域。
- “避免湿滑区域”则需要通过语义分割或人类标注，将地面 patch 标记为“slippery”，再生成约束。
</code></pre>
<ol start="3">
<li><strong>规划与控制中的集成方式</strong>
<ul>
<li>在<strong>任务规划器</strong>中：
将规则编译进规划域（例如 PDDL 中的 precondition / forbidden state），在生成任务序列时就避免违背规则。</li>
<li>在<strong>运动规划器/控制器</strong>中：
使用“安全过滤器”对候选轨迹进行可行性检查，不满足约束的轨迹被丢弃或修正（例如 QP-based Safety Layer，或 Control Barrier Function）。</li>
<li>在<strong>RL 策略</strong>中：
把规则转化为约束集，用于限制策略的动作选择或构造“屏蔽层（shield）”，形成 safe RL。</li>
</ul>
</li>
</ol>
<blockquote>
<p>[图片占位：语言规则 → LTL/数学约束 → 安全过滤器 → 机器人轨迹 的流程示意图；图中包含感知模块将地毯/电源线等标成不同颜色区域。]</p>
</blockquote>
<hr>
<h4 id="4423-人机交互中的纠偏"><a class="header" href="#4423-人机交互中的纠偏">4.4.2.3 人机交互中的纠偏</a></h4>
<p>即便事先定义了大量规则，机器人仍然会犯错或不符合用户偏好。语言在**在线纠偏（on-the-fly correction）**中尤其有用：</p>
<p>典型交互形式：</p>
<ul>
<li>速度或风格纠正：
<ul>
<li>“太快了，慢一点。”</li>
<li>“不要再从桌子这一侧绕了，从后面走。”</li>
</ul>
</li>
<li>安全偏好调整：
<ul>
<li>“这块地毯很贵，不要踩上去。”</li>
<li>“这些纸箱可以随便挪，不用小心。”</li>
</ul>
</li>
<li>目标修正：
<ul>
<li>“不是那个红杯子，是靠近窗户的那个。”</li>
</ul>
</li>
</ul>
<p>研究表明，将语言反馈映射为<strong>代价函数修正</strong>或<strong>轨迹改写</strong>，可以显著提升机器人轨迹质量和用户满意度。比如有工作提出从自然语言反馈中学习“比较偏好”（comparative language feedback），在共享的嵌入空间中对轨迹进行改进和奖励学习，从而迭代优化策略 (<a href="https://arxiv.org/abs/2410.06401?utm_source=chatgpt.com">arXiv</a>)。另一些工作则直接把“不要靠这么近”“往桌子中心一点”这类文本映射为代价函数的参数更改，从而重新规划路径 (<a href="https://research.nvidia.com/publication/2022-06_correcting-robot-plans-natural-language-feedback?utm_source=chatgpt.com">NVIDIA</a>)。</p>
<p>这一方向与第 9 章中 RLHF 和人类偏好学习内容相呼应：
区别在于，这里的人类反馈不是抽象的数值，而是<strong>更具信息量的自然语言</strong>，可同时指出“哪里错了”和“应该如何改”。</p>
<hr>
<h3 id="443-语言作为解释接口机器人行为的可解释性"><a class="header" href="#443-语言作为解释接口机器人行为的可解释性">4.4.3 语言作为解释接口（机器人行为的可解释性）</a></h3>
<p>当机器人通过 VLA 模型自主决策时，人类很容易产生“黑箱恐惧”：
为什么它要绕一大圈？为什么它停在这里不动？是坏了还是在思考？</p>
<p>语言解释接口的目标，就是让机器人在关键时刻<strong>说清楚自己在做什么、为什么这么做、哪里出了问题、下一步会怎样做</strong>，从而提升信任与可调试性。</p>
<hr>
<h4 id="4431-行为解释"><a class="header" href="#4431-行为解释">4.4.3.1 行为解释</a></h4>
<p>可以把行为解释按“深度”分为三层：</p>
<ol>
<li><strong>What：描述正在做什么</strong>
<ul>
<li>“我正在寻找红色杯子。”</li>
<li>“我准备从桌子的右侧绕到水槽前面。”</li>
<li>“我正在缓慢放下杯子，避免倾倒。”</li>
</ul>
</li>
<li><strong>Why：解释决策原因（代价与约束）</strong>
<ul>
<li>“我选择从右侧绕行，因为左侧有地毯区域被标记为禁入。”</li>
<li>“我降低了速度，因为检测到附近有人类在移动。”</li>
<li>“我先收拾桌面，再拖地，因为拖地前需要清空地面。”</li>
</ul>
</li>
<li><strong>What-if：对比和反事实解释</strong>
<ul>
<li>“如果我从左侧走，可能会踩到电源线。”</li>
<li>“如果直接抬起箱子，可能超过负载限制，会造成危险。”</li>
</ul>
</li>
</ol>
<p>在实现上，解释可以来自：</p>
<ul>
<li><strong>显式规划轨迹和代价信息</strong>：
规划器天生就有路径、代价值、约束，LLM 可以根据这些信息生成自然语言说明。</li>
<li><strong>任务层步骤序列</strong>：
像 SayCan 这类系统已经有“技能序列 + 成功概率”的中间表示，可以直接转换成可读的步骤说明（“先打开柜门，再拿出杯子，再关门……”） (<a href="https://arxiv.org/pdf/2204.01691?utm_source=chatgpt.com">arXiv</a>)。</li>
<li><strong>策略内部的中间 token / subgoal</strong>：
多模态 Transformer 产生的中间“子目标 token”也可视为解释线索，经过语言解码头转换成自然语言解释。</li>
</ul>
<blockquote>
<p>[图片占位：左侧为机器人执行某个长时任务的时间轴，右侧对应每个关键时刻的解释气泡；例如“t1：正在寻找杯子”“t2：绕开地毯”“t3：抓取失败，重新尝试”。]</p>
</blockquote>
<hr>
<h4 id="4432-故障诊断"><a class="header" href="#4432-故障诊断">4.4.3.2 故障诊断</a></h4>
<p>当机器人无法完成任务或表现异常时，人类需要知道是<strong>感知出错、规划失败、控制器饱和</strong>，还是“指令不可行”。</p>
<p>语言诊断接口可以做几件事情：</p>
<ol>
<li><strong>明确失败原因类别</strong>
<ul>
<li>感知问题：
“我没有在桌面上找到红色杯子，只找到了蓝色和绿色的杯子。”</li>
<li>几何可达性问题：
“目标位置太靠近墙角，我的机械臂在不碰撞墙的前提下无法到达。”</li>
<li>动力学/负载问题：
“物体重量估计超过 7kg，而我的额定负载为 5kg。”</li>
<li>规则/约束冲突：
“该路径会经过禁止进入的地毯区域，因此被安全规则拒绝。”</li>
</ul>
</li>
<li><strong>反馈给普通用户与开发者不同粒度的信息</strong>
<ul>
<li>对普通用户：用日常语言说明情况并给出建议（“请把杯子放到更靠近桌面中心的位置”）。</li>
<li>对开发者：附带具体错误码、关节、传感器读数等技术信息（供日志分析）。</li>
</ul>
</li>
<li><strong>与调试工具联动</strong>
<ul>
<li>语言解释中可附带“建议收集何种数据”“建议降低某个参数”等，使调试过程更高效。</li>
</ul>
</li>
</ol>
<p>随着 LLM 与机器人控制的结合，越来越多工作尝试用大模型对低层日志进行“文本摘要式诊断”，例如将多轮规划失败记录压缩成一句话：“最近 10 次任务失败大多是由于抓取时末端对准误差过大”。这一方向与第 10 章“系统部署与评测”可以形成上下呼应。</p>
<hr>
<h4 id="4433-学习反馈"><a class="header" href="#4433-学习反馈">4.4.3.3 学习反馈</a></h4>
<p>语言不仅可以解释机器人的行为，也可以<strong>用来总结机器人学到的内容</strong>，形成一种“可对话的学习日志”。</p>
<p>从机器人一侧来看，典型能力包括：</p>
<ul>
<li><strong>任务完成总结</strong>
<ul>
<li>“本次共完成 10 次抓取任务，成功 8 次，失败 2 次（均发生在抓取小物体时）。我发现对小物体使用当前视角难以准确对准。”</li>
</ul>
</li>
<li><strong>策略更新说明</strong>
<ul>
<li>“根据最近的语言反馈‘尽量不要碰到桌上的纸张’，我在路径规划中增加了对纸张区域的避让权重。”</li>
</ul>
</li>
<li><strong>提出澄清问题</strong>
<ul>
<li>“你希望我优先减少耗时还是优先减少能耗？”</li>
<li>“‘把房间收拾干净’是否包括把桌上的书也收进书架？”</li>
</ul>
</li>
</ul>
<p>从人类一侧来看，<strong>自然语言反馈</strong>本身也可以参与学习：</p>
<ul>
<li>作为<strong>奖励模型 / 偏好模型</strong>的训练数据，例如“刚才那条路径太靠近花瓶了”对应一个低评分，反之“这样很好，离人足够远”对应高评分。</li>
<li>作为<strong>策略改进建议</strong>，被自动映射到轨迹修正或约束调整中（参见前面提到的 comparative language feedback 与 preference learning 工作） (<a href="https://arxiv.org/abs/2410.06401?utm_source=chatgpt.com">arXiv</a>)。</li>
</ul>
<p>这一方向在未来有望让机器人拥有更“人性化”的学习接口：
不是只看数字奖励和 loss 曲线，而是能听懂“老板/用户”一句抱怨或鼓励，从中调整行为策略。</p>
<hr>
<h3 id="444-任务层规划与语言层规划的关系"><a class="header" href="#444-任务层规划与语言层规划的关系">4.4.4 任务层规划与语言层规划的关系</a></h3>
<p>在前面的机器人学与控制章节中，我们主要讨论的是<strong>任务/运动规划</strong>：
如何在给定目标状态与环境模型的前提下，找到一条可行又优的轨迹。</p>
<p>而在有了大语言模型之后，出现了一个新层级：<strong>语言层规划（language-level planning）</strong>——用语言或符号步骤来规划“做什么”，再交给传统规划器和控制器决定“怎么做”。</p>
<p>两者的关系类似于：</p>
<blockquote>
<p>人说“先买菜再做饭”，导航和操作模块决定“走哪条路、用哪只手拿菜、锅放在哪个灶眼”。</p>
</blockquote>
<hr>
<h4 id="4441-任务层规划task-level-planning"><a class="header" href="#4441-任务层规划task-level-planning">4.4.4.1 任务层规划（Task-level Planning）</a></h4>
<p>任务层规划传统上指在<strong>符号状态和动作空间</strong>上进行规划，有时也包含几何细节，典型包括：</p>
<ul>
<li>经典 AI 规划（如 PDDL + 规划器）</li>
<li>Task and Motion Planning（TAMP）：同时考虑离散任务结构与连续运动可行性</li>
<li>运动规划与轨迹优化（RRT*, CHOMP, TrajOpt 等）</li>
</ul>
<p>其输入通常是：</p>
<ul>
<li>形式化目标（goal state / goal formula）</li>
<li>任务域模型（动作 precondition / effect）</li>
<li>几何与动力学约束（碰撞、关节限制等）</li>
</ul>
<p>输出则是：</p>
<ul>
<li>一个<strong>可执行的动作序列</strong>或带参数的操作模板：
<ul>
<li><code>pick(obj=RedCup, pose=p1)</code></li>
<li><code>place(obj=RedCup, pose=p2)</code></li>
<li>中间插入 <code>move_base</code>、<code>open_door</code> 等技能调用</li>
</ul>
</li>
</ul>
<p>这一层不关心“指令是用中文、英文还是按钮点击传达的”，它只需要结构化的目标与约束。</p>
<hr>
<h4 id="4442-语言层规划language-level-planning"><a class="header" href="#4442-语言层规划language-level-planning">4.4.4.2 语言层规划（Language-level Planning）</a></h4>
<p>语言层规划利用语言模型强大的<strong>世界知识与组合能力</strong>，在“符号/语言空间”内先做一轮<strong>高层策略推理</strong>，其典型形式包括：</p>
<ol>
<li><strong>把自然语言指令分解为子任务序列</strong>例如指令：“帮我准备一个早餐托盘：一杯咖啡、一片面包和一个苹果。”语言层规划可能生成的步骤：</li>
</ol>
<p>每一步再映射为相应的机器人技能调用。</p>
<pre><code>1. 去厨房找到干净的托盘
2. 把咖啡杯放到托盘左侧
3. 把面包放在托盘中间
4. 把苹果放在托盘右侧
5. 把托盘端到餐桌上
</code></pre>
<ol start="2">
<li>**生成“代码式策略”**Code as Policies 等工作直接让 LLM 生成控制程序，如：</li>
</ol>
<pre><code class="language-python">def make_breakfast_tray():
    tray_pose = find_object("tray")
    move_arm_to(tray_pose)
    # ...
</code></pre>
<p>这段代码中已经内含了子任务结构、条件判断和循环逻辑，语言层规划就是<strong>程序结构</strong>本身 (<a href="https://arxiv.org/abs/2209.07753?utm_source=chatgpt.com">arXiv</a>)。</p>
<ol start="3">
<li><strong>与经典规划器协同</strong>近期大量工作探讨“LLM + 经典规划器”的组合：
<ul>
<li>LLM 负责从自然语言抽象出<strong>符号谓词、操作子、子目标</strong></li>
<li>把这些知识编译成 PDDL 或其他形式，交给经典规划器求解</li>
<li>规划结果再由 LLM 或规则系统转回自然语言解释或技能序列 (<a href="https://www.nature.com/articles/s42256-025-01036-4?utm_source=chatgpt.com">Nature</a>)。</li>
</ul>
</li>
</ol>
<p>在 VLA 框架下，可以把语言层规划看成是“在 token 序列上做规划”：
模型生成一串“子任务 token / 技能 token / 子目标 token”，然后由下游模块执行。</p>
<blockquote>
<p>[图片占位：上半部分为 LLM 生成的“文字/代码形式的步骤计划”，下半部分为每步映射到任务规划器和运动规划器的执行过程。]</p>
</blockquote>
<hr>
<h4 id="4443-协同作用"><a class="header" href="#4443-协同作用">4.4.4.3 协同作用</a></h4>
<p>真正强大的机器人系统，往往不是“纯语言驱动”或者“纯经典规划”，而是两者的协同：</p>
<ol>
<li><strong>语言层：提出“可能的好计划”</strong>
<ul>
<li>借助大模型的常识和抽象能力，快速产生多种候选计划：
<ul>
<li>不同子任务顺序</li>
<li>不同工具/通道选择（从门走还是从另一侧绕行）</li>
</ul>
</li>
<li>考虑用户偏好、安全需求、任务优先级等“软因素”</li>
</ul>
</li>
<li><strong>任务层：验证“这计划在几何和安全上能不能干”</strong>
<ul>
<li>利用精确的几何/动力学模型、环境地图和安全约束，对候选计划进行可行性检查与优化</li>
<li>发现不可行时（如某个抓取姿态在当前场景会碰到墙），反馈给语言层更新计划</li>
</ul>
</li>
<li><strong>安全层：语言约束与形式安全的结合</strong>
<ul>
<li>语言层从自然语言中抽取安全规则（第 4.4.2 节），转换为形式约束</li>
<li>任务层与控制层利用这些约束进行优化与安全过滤</li>
<li>一些工作更进一步，结合 LLM 生成的安全策略与 QP/MPC 安全过滤器，构建“Safety-aware Task Planning”体系，让规划过程同时兼顾任务成功率与安全规避 (<a href="https://arxiv.org/html/2503.15707v1?utm_source=chatgpt.com">arXiv</a>)。</li>
</ul>
</li>
<li><strong>解释与交互闭环</strong>
<ul>
<li>语言层可以<strong>解释</strong>任务层的规划决策（“我选择方案 B，因为方案 A 会违反安全约束 X”）</li>
<li>人类可以通过语言<strong>修改计划或规则</strong>（“允许你临时进入这个区域，但速度必须低于 0.2 m/s”），系统再重新规划</li>
</ul>
</li>
</ol>
<blockquote>
<p>[图片占位：三层结构图：
顶层“语言层规划（LLM）”负责解析指令、分解子任务和规则解释；
中层“任务/运动规划”负责路径和动作的具体计算；
底层“控制与执行”负责实时控制。
左侧有“人类语言输入/反馈”，右侧有“机器人执行 + 语言解释输出”。]</p>
</blockquote>
<p>从长远看，可以把语言看成一种<strong>统一接口</strong>：</p>
<ul>
<li>向上连接人类的任务需求、偏好与安全规范</li>
<li>向下连接机器人的传统规划、控制与感知模块</li>
<li>与多模态表示（视觉、状态、历史轨迹）共同构成具身基础模型的一部分</li>
</ul>
<p>本节讲的是“语言的角色”；在后续章节中，你会看到这些角色如何通过具体的 VLA 架构、训练范式和系统部署，真正落地到一个能听话、会解释、守规矩、敢自主的机器人身上。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="强化学习基本框架"><a href="#强化学习基本框架" class="header">强化学习基本框架</a></h1>
<h3 id="511-马尔可夫决策过程mdp的五元组"><a class="header" href="#511-马尔可夫决策过程mdp的五元组">5.1.1 马尔可夫决策过程（MDP）的五元组</a></h3>
<p>在强化学习中，我们需要一个统一的数学框架来描述“智能体与环境反复交互、在不确定条件下做序贯决策”的问题，这个框架就是马尔可夫决策过程（Markov Decision Process, MDP）。经典定义中，一个离散时间的 MDP 通常用一个五元组表示：
$$
\mathcal{M} = \langle \mathcal{S}, \mathcal{A}, P, R, \gamma \rangle
$$
其中分别对应状态空间、动作空间、转移概率、奖励函数和折扣因子。(<a href="https://en.wikipedia.org/wiki/Markov_decision_process?utm_source=chatgpt.com">维基百科</a>)</p>
<p>在机器人领域中，可以把 MDP 理解为：给定机器人当前“所处情境”（状态），它可以选择某个控制指令（动作），环境根据物理规律和噪声发生变化（转移），机器人会得到一个任务反馈信号（奖励），并持续重复这个过程，目标是让长期奖励最大化。很多移动机器人路径规划、操作抓取等问题都可以用 MDP 或其扩展建模。(<a href="https://www.mdpi.com/2076-0825/12/4/166?utm_source=chatgpt.com">MDPI</a>)</p>
<blockquote>
<p>【图片占位：图 5-1】
内容：经典“智能体–环境交互”示意图。左边是 Agent（机器人），右边是 Environment（环境），中间箭头标注：状态 (s_t)、动作 (a_t)、奖励 (r_{t+1})、下一个状态 (s_{t+1})。</p>
</blockquote>
<hr>
<h4 id="5111-状态state"><a class="header" href="#5111-状态state">5.1.1.1 状态（State）</a></h4>
<p><strong>状态</strong> (s \in \mathcal{S}) 用来描述环境在某一时刻的“信息摘要”，包含做决策所需的关键信息。</p>
<ul>
<li>对机械臂抓取任务：
状态可以包括各关节角度与角速度、末端位姿、目标物体的 6D 位姿、夹爪开合状态等。</li>
<li>对移动机器人导航：
状态可以是机器人在地图中的位姿 ((x, y, \theta))，以及局部局势信息（附近障碍物、目标位置等）。(<a href="https://www.mdpi.com/2076-0825/12/4/166?utm_source=chatgpt.com">MDPI</a>)</li>
</ul>
<p>从数学上，MDP 要求状态满足<strong>马尔可夫性（Markov property）</strong>：
$$
\Pr(s_{t+1} \mid s_0,a_0,\dots,s_t,a_t) = \Pr(s_{t+1} \mid s_t,a_t)
$$
也就是说，<strong>当前状态已经包含了对未来决策有用的全部历史信息</strong>，过去发生了什么只需要通过当前的状态来“折叠表示”。(<a href="https://en.wikipedia.org/wiki/Markov_decision_process?utm_source=chatgpt.com">维基百科</a>)</p>
<p>在机器人具身智能中，原始传感器数据（例如 RGB 图像、深度图、力矩传感器读数）往往不是严格的“马尔可夫状态”，而更接近“观测（observation）”。工程上常见的做法包括：</p>
<ul>
<li>通过滤波器或估计器（如卡尔曼滤波、SLAM）综合历史观测，构造接近马尔可夫的内部状态；</li>
<li>或直接让神经网络（如 RNN、Transformer）在时间维度上“记住”历史，从而在表示空间上逼近马尔可夫性。</li>
</ul>
<blockquote>
<p>【图片占位：图 5-2】
内容：机器人导航示意图：地图上若干位置格子，每个格子标注为一个状态 (s)，机器人当前位置用小车图标表示。</p>
</blockquote>
<hr>
<h4 id="5112-动作action"><a class="header" href="#5112-动作action">5.1.1.2 动作（Action）</a></h4>
<p><strong>动作</strong> (a \in \mathcal{A}) 表示智能体可以施加在环境上的控制信号或高层指令。</p>
<p>在机器人中，动作空间的设计与控制层级密切相关：</p>
<ol>
<li><strong>低层连续控制</strong>
<ul>
<li>关节力矩 (\tau)、关节速度 (\dot{q}) 或末端速度 (\dot{x}) 等连续值；</li>
<li>适合直接基于物理动力学的强化学习算法（如 DDPG、SAC 等在后文介绍）。</li>
</ul>
</li>
<li><strong>中层运动命令</strong>
<ul>
<li>例如“末端向前移动 1 cm”“夹爪闭合 5°”“底盘向左转 10°”；</li>
<li>通常是离散化的 delta pose / delta velocity 命令，与第 6 章的动作表示呼应。</li>
</ul>
</li>
<li><strong>高层动作原语（Skill / Primitive）</strong>
<ul>
<li>例如“抓取桌面上的红色杯子”“打开抽屉”，内部再由一系列底层控制组成；</li>
<li>在具身智能和 VLA 模型中，高层动作常与自然语言指令或技能库对应。</li>
</ul>
</li>
</ol>
<p>理论上，MDP 允许动作空间是离散的、连续的，甚至是混合的；但不同类型的动作会直接影响后续可用的强化学习算法。</p>
<hr>
<h4 id="5113-转移概率transition"><a class="header" href="#5113-转移概率transition">5.1.1.3 转移概率（Transition）</a></h4>
<p><strong>转移概率</strong> (P) 刻画在环境动力学下，执行某个动作后状态如何变化：
$$
P(s’ \mid s, a) = \Pr(s_{t+1} = s’ \mid s_t = s, a_t = a)
$$
这是 MDP 中的“环境模型”。对于给定的 (s) 和 (a)，它告诉我们可能到达哪些 (s’)，以及各自的概率。(<a href="https://en.wikipedia.org/wiki/Markov_decision_process?utm_source=chatgpt.com">维基百科</a>)</p>
<p>在机器人场景中：</p>
<ul>
<li>理论上可以通过动力学方程（第 6 章）精确给出状态转移：
$$
M(q)\ddot{q} + C(q,\dot{q})\dot{q} + G(q) = \tau
$$
这类模型往往是<strong>近似确定性</strong>的。</li>
<li>现实中存在大量非理想因素：摩擦、接触不确定性、传感噪声、人类干预等，使转移过程具有随机性。(<a href="https://www.mdpi.com/2076-0825/12/4/166?utm_source=chatgpt.com">MDPI</a>)</li>
</ul>
<p>在经典动态规划求解 MDP 时，通常假设 (P) 是<strong>已知</strong>的（“有模型”情形）；而在大多数强化学习应用中，我们并不知道显式的 (P)，只能通过与环境交互采样经验来“间接利用”转移结构——后文的 Q-Learning、Actor–Critic 等都属于这种“无模型”方法。</p>
<blockquote>
<p>【图片占位：图 5-3】
内容：从状态 (s) 出发经动作 (a) 指向多个可能的 (s’)，箭头上标注对应概率 (P(s’|s,a)) 和奖励 (R(s,a,s’))。</p>
</blockquote>
<hr>
<h4 id="5114-奖励函数reward"><a class="header" href="#5114-奖励函数reward">5.1.1.4 奖励函数（Reward）</a></h4>
<p><strong>奖励函数</strong> (R) 定义为在状态–动作–下一状态三元组上的即时反馈：
$$
R(s,a,s’) = \mathbb{E}[r_{t+1} \mid s_t = s, a_t = a, s_{t+1} = s’]
$$
有时也简写为 (R(s)) 或 (R(s,a))，取决于具体建模习惯。(<a href="https://en.wikipedia.org/wiki/Markov_decision_process?utm_source=chatgpt.com">维基百科</a>)</p>
<p>奖励的作用是<strong>编码任务目标</strong>：</p>
<ul>
<li><strong>任务成功 / 失败</strong>
<ul>
<li>如抓取任务中，成功抓起目标物体给 +1，失败给 0 或负值；</li>
<li>导航任务中，到达目标格子给高奖励，碰撞障碍物给负奖励。</li>
</ul>
</li>
<li><strong>过程成本</strong>
<ul>
<li>每一步运动消耗一点负奖励（-0.01），促使策略尽可能快速完成任务；</li>
<li>转弯次数过多、路径过长都可用额外负奖励约束。</li>
</ul>
</li>
</ul>
<p>奖励设计是机器人强化学习中非常关键的工程问题。奖励过于稀疏（只有成功才给奖励）时，智能体很难通过随机探索“发现”有用信号；通常需要合理的奖励塑形（reward shaping），例如为“接近目标”“抓取姿态更对齐”等中间阶段提供一些中间奖励，以提高学习效率。</p>
<hr>
<h4 id="5115-折扣因子discount-factor"><a class="header" href="#5115-折扣因子discount-factor">5.1.1.5 折扣因子（Discount factor）</a></h4>
<p><strong>折扣因子</strong> (\gamma \in (0,1]) 用于平衡“当前奖励”和“未来奖励”的相对重要性。给定未来奖励序列 ({r_{t+1}, r_{t+2}, \dots})，从时间步 (t) 起的<strong>折扣回报</strong>定义为：
$$
G_t = \sum_{k=0}^{\infty} \gamma^{k} r_{t+k+1}
$$
当 (\gamma &lt; 1) 时，这个无穷级数在期望意义下是有界的，适合描述无限时域任务；当任务是有限长的一个 episode 时，往往也可以取 (\gamma \approx 1) 或者直接令 (\gamma = 1)。(<a href="https://en.wikipedia.org/wiki/Markov_decision_process?utm_source=chatgpt.com">维基百科</a>)</p>
<p>直观理解：</p>
<ul>
<li>(\gamma) 越接近 0：
<ul>
<li>智能体越“短视”，只关心眼前的即时回报；</li>
<li>对机器人来说，更像是贪图眼前便利，例如只在当前局部寻找最短路径而忽略远处的大障碍。</li>
</ul>
</li>
<li>(\gamma) 越接近 1：
<ul>
<li>智能体越“远视”，会为长远利益做规划；</li>
<li>例如家务机器人为长期整理房间布局付出短期代价，以换取未来更高效率。</li>
</ul>
</li>
</ul>
<p>折扣因子不仅有行为学上的意义，更是很多理论结果（如贝尔曼方程收敛性）的关键条件。</p>
<hr>
<h3 id="512-回报折扣因子与价值函数概念"><a class="header" href="#512-回报折扣因子与价值函数概念">5.1.2 回报、折扣因子与价值函数概念</a></h3>
<p>在有了 MDP 的五元组之后，我们还需要一个量化“好状态、好动作”的核心工具，这就是<strong>价值函数（value function）</strong>。价值函数并不是额外增加一个元素，而是基于 MDP 与策略 (\pi) 定义的一族函数，它将“长期回报”的概念形式化。</p>
<hr>
<h4 id="5121-回报return"><a class="header" href="#5121-回报return">5.1.2.1 回报（Return）</a></h4>
<p>前面已经给出折扣回报的定义：
$$
G_t = \sum_{k=0}^{\infty} \gamma^{k} r_{t+k+1}
$$
注意两点：</p>
<ol>
<li><strong>回报是随机量</strong>：
奖励 (r_{t+1}, r_{t+2}, \dots) 由随机的转移和可能的随机策略决定，因此 (G_t) 也是随机变量。</li>
<li><strong>我们关心的是期望回报</strong>：
对机器人策略的评估通常是“长期平均表现”，而不是某一次执行的偶然好坏。(<a href="https://ralasun.github.io/reinforcement%20learning/2020/07/12/mdp/?utm_source=chatgpt.com">ralasun.github.io</a>)</li>
</ol>
<p>在具身智能场景中，可以把回报理解成：当你在某个状态开始执行当前策略，让机器人长期运行下去，它<strong>平均</strong>能在任务上做得多好。</p>
<hr>
<h4 id="5122-状态价值函数-vs"><a class="header" href="#5122-状态价值函数-vs">5.1.2.2 状态价值函数 (V(s))</a></h4>
<p>给定一个策略 (\pi)，<strong>状态价值函数</strong>定义为：
$$
V^{\pi}(s) = \mathbb{E}_\pi \big[ G_t \mid s_t = s \big]
$$
即“从状态 (s) 出发，之后按照策略 (\pi) 行事，所能获得的期望回报”。</p>
<p>经典结果表明，(V^{\pi}(s)) 满足<strong>贝尔曼期望方程（Bellman expectation equation）</strong>：
$$
V^{\pi}(s) = \sum_{a} \pi(a \mid s) \sum_{s’} P(s’ \mid s,a) \Big[ R(s,a,s’) + \gamma V^{\pi}(s’) \Big]
$$
这只是对“回报定义”的递推展开：从当前状态的价值等于当前一步期望奖励加上下一状态价值的折扣期望。(<a href="https://sumniya.tistory.com/5?utm_source=chatgpt.com">숨니의 무작정 따라하기</a>)</p>
<p>在机器人导航中，可以将 (V^{\pi}(s)) 想象为地图上每个格子的“热度”：值高的状态意味着从那里出发，按照当前策略，最终到达目标的概率高、成本低。</p>
<blockquote>
<p>【图片占位：图 5-4】
内容：2D 网格地图，每个格子用颜色表示 (V^{\pi}(s)) 的大小（越接近目标值越高），展示价值函数的空间分布。</p>
</blockquote>
<hr>
<h4 id="5123-动作价值函数-qsa"><a class="header" href="#5123-动作价值函数-qsa">5.1.2.3 动作价值函数 (Q(s,a))</a></h4>
<p>与只关心“当前状态”不同，<strong>动作价值函数</strong>（state–action value function）还区分了当前动作：
$$
Q^{\pi}(s,a) = \mathbb{E}_\pi \big[ G_t \mid s_t = s, a_t = a \big]
$$
表示“在状态 (s) 下<strong>先执行</strong>动作 (a)，然后再一直遵循策略 (\pi)，所能得到的期望回报”。</p>
<p>它的贝尔曼期望方程为：
$$
Q^{\pi}(s,a) = \sum_{s’} P(s’ \mid s,a)
\Big[ R(s,a,s’) + \gamma \sum_{a’} \pi(a’ \mid s’) Q^{\pi}(s’,a’) \Big]
$$
(<a href="https://gurpreet-ai.github.io/reinforcement-learning/">参考</a>)</p>
<p>两个价值函数的关系可以写成：
$$
V^{\pi}(s)
= \sum_{a} \pi(a \mid s) Q^{\pi}(s,a)
$$
因此可以把 (Q^{\pi}) 看作是“比 (V^{\pi}) 细一层”的对象。</p>
<p>在很多强化学习算法（如 Q-Learning、DQN）中，策略不再单独存储，而是<strong>通过 (Q) 函数的贪婪选择</strong>隐式给出：
$$
\pi(s) = \arg\max_{a} Q(s,a)
$$
这使得我们可以只专注于估计 (Q) 函数，而不必单独存储整张策略表。</p>
<hr>
<h4 id="5124-最优价值函数"><a class="header" href="#5124-最优价值函数">5.1.2.4 最优价值函数</a></h4>
<p>对于给定的 MDP，存在一族可能的策略集合 (\Pi)。在所有策略中，我们关心的是<strong>最优策略</strong> (\pi^<em>)，以及对应的最优价值函数：
$$
V^</em>(s) = \max_{\pi \in \Pi} V^{\pi}(s), \qquad
Q^<em>(s,a) = \max_{\pi \in \Pi} Q^{\pi}(s,a)
$$
它们满足<strong>贝尔曼最优性方程（Bellman optimality equation）</strong>：
$$
V^</em>(s) = \max_{a} \sum_{s’} P(s’ \mid s,a)
\Big[ R(s,a,s’) + \gamma V^<em>(s’) \Big]
$$
$$
Q^</em>(s,a) = \sum_{s’} P(s’ \mid s,a)
\Big[ R(s,a,s’) + \gamma \max_{a’} Q^*(s’,a’) \Big]
$$
(<a href="https://smj990203.tistory.com/4?utm_source=chatgpt.com">参考</a>)</p>
<p>一旦我们“知道”了 (Q^<em>)，最优策略可以简单地由<strong>逐状态贪婪</strong>给出：
$$
\pi^</em>(s) = \arg\max_{a} Q^<em>(s,a)
$$
这就是很多强化学习算法背后的思想：通过样本或模型逼近 (Q^</em>)，然后对其取贪婪即可控制机器人。后续章节的值函数法（DQN 等）与策略梯度法都可以视作在不同条件下对这些最优函数的近似求解。</p>
<hr>
<h3 id="513-策略价值迭代的直觉"><a class="header" href="#513-策略价值迭代的直觉">5.1.3 策略、价值迭代的直觉</a></h3>
<p>到目前为止，我们只是定义了策略、价值和最优性的概念。本小节进一步给出<strong>如何利用已知模型求解最优策略</strong>的直觉：当环境转移 (P) 与奖励 (R) 已知时，可以通过<strong>动态规划（Dynamic Programming）<strong><strong>类方法求解 MDP，其中最经典的就是</strong></strong>策略迭代（Policy Iteration）<strong><strong>和</strong></strong>价值迭代（Value Iteration）</strong>。(<a href="https://ralasun.github.io/reinforcement%20learning/2020/07/12/mdp/?utm_source=chatgpt.com">ralasun.github.io</a>)</p>
<p>需要强调的是，在真实机器人系统中，我们往往<strong>不知道精确的 (P) 和 (R)</strong>，只能通过仿真或真实交互采样近似，这就引出了后续的强化学习算法。但理解这两种理想化的“规划”方法，有助于把 RL 看成是“在有限数据下逼近 DP 解”的过程。</p>
<hr>
<h4 id="5131-策略policy"><a class="header" href="#5131-策略policy">5.1.3.1 策略（Policy）</a></h4>
<p>在 MDP 中，<strong>策略</strong> (\pi) 给出了智能体在每个状态下选择动作的规则：</p>
<ul>
<li><strong>确定性策略</strong>：
$$
\pi(s) = a \quad \text{或记作} \quad \pi(a \mid s) = 1
$$</li>
<li><strong>随机策略</strong>：
$$
\pi(a \mid s) = \Pr(a_t = a \mid s_t = s)
$$</li>
</ul>
<p>价值函数总是“附着在某个策略上”的：在前面我们写 (V^{\pi}(s))、(Q^{\pi}(s,a))，强调给定策略后才谈得上“好坏评估”。</p>
<p>在机器人具身智能中，策略可以有多种实现形式：</p>
<ul>
<li>手写规则（if–else 控制器、有限状态机）；</li>
<li>传统控制/规划算法（如 DWA 导航、RRT* 路径规划）可以看作特殊形式的策略；</li>
<li>神经网络策略（后续章节重点），输入状态特征，输出动作或动作分布。</li>
</ul>
<p>强化学习的目标，就是在策略空间中找到一个尽可能接近 (\pi^*) 的策略。</p>
<hr>
<h4 id="5132-策略迭代policy-iteration的直觉"><a class="header" href="#5132-策略迭代policy-iteration的直觉">5.1.3.2 策略迭代（Policy Iteration）的直觉</a></h4>
<p>策略迭代可视作“<strong>先思考，再行动</strong>”的流程：给定完整环境模型，通过不停地<strong>评估当前策略</strong>并<strong>改进策略</strong>来逐步逼近最优策略。经典教科书指出，当状态空间有限、折扣因子 (0&lt;\gamma&lt;1) 时，策略迭代会在有限轮次内收敛到最优策略。(<a href="https://en.wikipedia.org/wiki/Markov_decision_process?utm_source=chatgpt.com">维基百科</a>)</p>
<p>整体循环可以概括为两步：</p>
<ol>
<li><strong>策略评估（Policy Evaluation）</strong>
<ul>
<li>固定现有策略 (\pi_k)，求解对应的 (V^{\pi_k})（或 (Q^{\pi_k})）；</li>
<li>在有模型的情况下，可以通过迭代应用贝尔曼期望方程来收敛到真实值：
$$
V_{k+1}(s) \leftarrow \sum_{a} \pi_k(a \mid s)
\sum_{s’} P(s’ \mid s,a) \big[ R(s,a,s’) + \gamma V_k(s’) \big]
$$</li>
<li>直观上是“在整张状态空间上模拟当前策略长期表现”。</li>
</ul>
</li>
<li><strong>策略改进（Policy Improvement）</strong>
<ul>
<li>有了 (V^{\pi_k}) 或 (Q^{\pi_k}) 的估计后，在每个状态上选择“更优”的动作：
$$
\pi_{k+1}(s) = \arg\max_{a} Q^{\pi_k}(s,a)
$$</li>
<li>这一步是局部的“贪婪改进”：在当前对未来的评估下，换一个更好的动作。</li>
</ul>
</li>
</ol>
<p>策略迭代不断在“评估–改进”之间往复，策略性能单调提升，直到某一轮改进后策略不再变化，得到的就是<strong>最优策略</strong>。</p>
<p>把它放在机器人场景来看，可以理解为：</p>
<ul>
<li>首先固定一个控制器，让机器人在所有可能状态下“试想一下”或在仿真中验证其效果（评估）；</li>
<li>然后根据评估结果，在每个状态上对控制器做一点点优化（改进）；</li>
<li>重复这个过程，最终得到在整个状态空间上表现最好的控制策略。</li>
</ul>
<hr>
<h4 id="5133-价值迭代value-iteration的直觉"><a class="header" href="#5133-价值迭代value-iteration的直觉">5.1.3.3 价值迭代（Value Iteration）的直觉</a></h4>
<p>策略迭代的“评估”步骤代价较高（要精确地求整个 (V^{\pi})），在状态空间较大时不够高效。<strong>价值迭代</strong>可以看作一种融合了“评估”和“改进”的更紧凑做法：</p>
<p>其核心迭代为<strong>贝尔曼最优性更新</strong>：
$$
V_{k+1}(s) \leftarrow \max_{a} \sum_{s’} P(s’ \mid s,a)
\big[ R(s,a,s’) + \gamma V_k(s’) \big]
$$
每一步更新就是一次“局部规划”：假设我们已经有了对未来价值 (V_k(s’)) 的估计，那么在当前状态 (s) 上，只需向前“看一步”，考虑所有动作的即时奖励加上折扣后的未来价值，取其中最大的作为新的估计。(<a href="https://sumniya.tistory.com/5?utm_source=chatgpt.com">숨니의 무작정 따라하기</a>)</p>
<p>这可以理解为：</p>
<ul>
<li>策略迭代：<strong>先完整评估当前策略，再一次性改进策略</strong>；</li>
<li>价值迭代：在<strong>每一次局部更新时就已经做了“潜在的策略改进”</strong>，因此无需显式存储每轮策略。</li>
</ul>
<p>当价值迭代收敛到 (V^<em>) 时，我们可以再通过
$$
\pi^</em>(s) = \arg\max_{a} \sum_{s’} P(s’ \mid s,a)
\big[ R(s,a,s’) + \gamma V^*(s’) \big]
$$
一次性导出最优策略。</p>
<p>在机器人导航这类经典问题中，价值迭代与网格地图规划关系非常紧密：</p>
<ul>
<li>把每个栅格当作一个状态；</li>
<li>动作为“向上/下/左/右移动”；</li>
<li>奖励设为每走一步 -1，到终点给 0；</li>
<li>使用价值迭代可以得到每个格子的最优价值，再通过“朝价值更高的邻居移动”导出最短路径策略，这与很多动态规划式路径规划算法本质相同。(<a href="https://www.mdpi.com/2076-0825/12/4/166?utm_source=chatgpt.com">MDPI</a>)</li>
</ul>
<blockquote>
<p>【图片占位：图 5-5】
内容：左图为网格地图；右图为价值迭代过程中数次迭代的 (V_k(s)) 伪彩图（颜色逐步向最终最优价值分布收敛），箭头从低价值区指向高价值区，说明贪婪策略方向。</p>
</blockquote>
<hr>
<p>本小节通过 MDP 五元组、回报与价值函数、以及策略迭代/价值迭代的直觉，给出了强化学习的“数学语言”。后续 5.2 节将在此基础上介绍 Q-Learning、策略梯度、Actor–Critic 等具体算法，并进一步讨论如何在机器人具身智能场景中，从“理论上的 MDP 求解”过渡到“基于真实交互和数据驱动的策略学习”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="经典-rl-算法"><a href="#经典-rl-算法" class="header">经典 RL 算法</a></h1>
<h3 id="521-值函数法q-learningdqn"><a class="header" href="#521-值函数法q-learningdqn">5.2.1 值函数法（Q-Learning、DQN）</a></h3>
<p>值函数法的核心思想是：<strong>先学会“这个状态–动作有多值钱”（Q 值），再用“选最值钱的动作”得到策略</strong>。这类方法通常假设动作空间是离散的，非常适合作为强化学习入门。</p>
<hr>
<h4 id="5211-q-learning"><a class="header" href="#5211-q-learning">5.2.1.1 Q-Learning</a></h4>
<p><strong>Q-Learning</strong> 是最经典、最基础的值函数控制算法之一，由 Watkins 在 1989 年提出，是一种<strong>离线策略（off-policy）的时序差分（TD）控制方法</strong>。(<a href="https://apxml.com/courses/intro-to-reinforcement-learning/chapter-5-temporal-difference-learning/q-learning-off-policy-td-control?utm_source=chatgpt.com">ApX Machine Learning</a>)</p>
<ol>
<li><strong>目标：学习最优动作价值函数</strong>
我们希望学到最优 Q 函数：
$$
Q^<em>(s,a) = \mathbb{E}\Big[ \sum_{k=0}^{\infty}\gamma^k r_{t+1+k} ,\Big|, s_t=s, a_t=a,\ \pi = \pi^</em> \Big]
$$
一旦知道了 (Q^<em>(s,a))，就可以用<strong>贪心策略</strong>：
$$
\pi^</em>(s) = \arg\max_a Q^*(s,a)
$$
在“纸面上”把所有状态的最佳动作都写出来。</li>
<li><strong>更新规则：基于贝尔曼最优方程的 TD 更新</strong>
Q-Learning 的核心更新：
$$
Q_{\text{new}}(s_t,a_t) \leftarrow Q(s_t,a_t)
<ul>
<li>\alpha \Big[ r_{t+1} + \gamma \max_{a’} Q(s_{t+1},a’) - Q(s_t,a_t) \Big]
$$</li>
<li>方括号内是 <strong>TD 误差（temporal-difference error）</strong>：
$$
\delta_t = r_{t+1} + \gamma \max_{a’} Q(s_{t+1},a’) - Q(s_t,a_t)
$$</li>
<li>直觉：
<ul>
<li>“当前对 Q(s,a) 的认识” 是旧值；</li>
<li>“基于下一步最优动作的估计” 给出新的目标；</li>
<li>用学习率 (\alpha) 在两者之间做插值。</li>
</ul>
</li>
</ul>
</li>
<li><strong>离线策略（Off-policy）的含义</strong>
<ul>
<li><strong>行为策略（behavior policy）</strong>：实际与环境交互的策略，通常是 (\epsilon)-greedy：
绝大多数时候选 (\arg\max_a Q(s,a))，偶尔随机探索。</li>
<li><strong>目标策略（target policy）</strong>：更新时用到的，是对 (\max_a Q(s,a)) 的贪心策略。</li>
<li>行为策略可以和目标策略不同，这就是 off-policy 的特点，允许我们在探索时做一些“奇怪动作”，但更新时仍朝着“最终想用的最优贪心策略”学习。</li>
</ul>
</li>
<li><strong>收敛性（在表格情形）</strong>
在有限状态–动作空间、每对 (s,a) 被无穷次访问，且学习率满足 (\sum_t \alpha_t = \infty, \sum_t \alpha_t^2 &lt; \infty) 的条件下，Q-Learning 收敛到 (Q^*)。(<a href="https://apxml.com/courses/intro-to-reinforcement-learning/chapter-5-temporal-difference-learning/q-learning-off-policy-td-control?utm_source=chatgpt.com">ApX Machine Learning</a>)</li>
<li><strong>简单示例：网格世界 / 移动机器人导航</strong>
<ul>
<li>状态：机器人在网格中的位置；</li>
<li>动作：上、下、左、右；</li>
<li>奖励：到达目标 +1，其他为 0 或小负数；
Q-Learning 会通过不断试探，逐渐学到每个格子上朝哪走未来回报最大。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-1 占位：二维网格世界 + Q 表示意图。左侧是网格和机器人、目标位置；右侧是状态-动作 Q 表的一个片段。】</p>
</blockquote>
<hr>
<h4 id="5212-深度-q-网络dqn"><a class="header" href="#5212-深度-q-网络dqn">5.2.1.2 深度 Q 网络（DQN）</a></h4>
<p>当状态是高维连续空间（如图像、机器人状态向量）时，显然不可能再用一张表来存所有 Q 值。<strong>DQN（Deep Q-Network）</strong> 将 Q 函数用深度神经网络来近似，是“深度强化学习”真正起飞的关键工作之一。(<a href="https://www.nature.com/articles/nature14236?utm_source=chatgpt.com">Nature</a>)</p>
<ol>
<li><strong>基本思想：用神经网络近似 Q 函数</strong>
<ul>
<li>设网络参数为 (\theta)，网络输入状态 (s)，输出一个向量 ((Q(s,a_1;\theta), \dots, Q(s,a_{|\mathcal{A}|};\theta)))；</li>
<li>对于 Atari 游戏，网络输入为若干帧堆叠的灰度图像，输出每个离散动作的 Q 值。</li>
</ul>
</li>
<li><strong>损失函数与目标值</strong>
对于一条经验 ((s_t,a_t,r_{t+1},s_{t+1}))，定义目标：
$$
y_t = r_{t+1} + \gamma \max_{a’} Q(s_{t+1},a’;\theta^-)
$$
其中 (\theta^-) 是<strong>目标网络</strong>参数（后面介绍）。
然后最小化平方误差：
$$
L(\theta) = \mathbb{E}_{(s,a,r,s’) \sim \mathcal{D}}
\big[ ( y_t - Q(s_t,a_t;\theta) )^2 \big]
$$</li>
<li><strong>经验回放（Experience Replay）</strong>
<ul>
<li>与环境交互时，将每步经历 ((s,a,r,s’)) 存入回放池 (\mathcal{D})；</li>
<li>训练时<strong>随机采样小批量</strong>数据更新网络。
作用：</li>
<li>打破连续样本之间的相关性；</li>
<li>提高数据利用率（每条经验可被多次采样使用）。</li>
</ul>
</li>
<li><strong>目标网络（Target Network）</strong>
直接用当前网络参数 (\theta) 去计算目标中的 (\max_{a’} Q(s’,a’;\theta)) 会导致更新目标跟随网络频繁变化，训练不稳定。
DQN 使用一个**“慢更新”的目标网络** (Q(s,a;\theta^-))，参数 (\theta^-) 每隔固定步数从 (\theta) 拷贝一次。(<a href="https://www.nature.com/articles/nature14236?utm_source=chatgpt.com">Nature</a>)</li>
<li><strong>整体训练流程（概略）</strong>
<ul>
<li>初始化 Q 网络参数 (\theta) 和目标网络参数 (\theta^- = \theta)；</li>
<li>重复：
<ol>
<li>用 (\epsilon)-greedy 策略与环境交互，存经验到回放池；</li>
<li>从回放池随机采样一个 batch；</li>
<li>用目标网络计算 y；</li>
<li>对在线网络参数 (\theta) 做一次梯度下降；</li>
<li>每 N 步同步目标网络：(\theta^- \leftarrow \theta)。</li>
</ol>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-2 占位：DQN 结构示意图。左边是 Atari 图像帧，经过 CNN 提取特征，右侧输出每个离散动作的 Q 值；旁边画出经验回放池和目标网络的关系。】</p>
</blockquote>
<hr>
<h4 id="5213-dqn-技巧"><a class="header" href="#5213-dqn-技巧">5.2.1.3 DQN 技巧</a></h4>
<p>在基础 DQN 之后，大量工作围绕“<strong>如何让值函数法更稳定、更高效</strong>”展开，形成了一整套 “DQN 家族” 技巧。(<a href="https://www.researchgate.net/publication/334070121_Deep_Q_Network_DQN_Double_DQN_and_Dueling_DQN_A_Step_Towards_General_Artificial_Intelligence?utm_source=chatgpt.com">ResearchGate</a>)</p>
<p>常见改进可以按以下几类理解：</p>
<ol>
<li><strong>减小过估计偏差：Double DQN</strong>
标准 DQN 中的 (\max_{a’}Q(s’,a’)) 容易产生<strong>系统性过估计</strong>，即对所有动作的价值略微偏乐观。
<ul>
<li>Double DQN 的做法是“<strong>由一个网络选动作，另一个网络估值</strong>”：
$$
a^* = \arg\max_{a’} Q(s’,a’;\theta)
$$
$$
y = r + \gamma Q(s’, a^*; \theta^-)
$$</li>
<li>直觉：
<ul>
<li>在线网络负责“挑动作”；</li>
<li>目标网络负责“打分”；</li>
<li>这样减少了单一网络的乐观偏差。</li>
</ul>
</li>
</ul>
</li>
<li><strong>网络结构改进：Dueling Network</strong>
dueling 架构将 Q 分解为<strong>状态价值 V</strong> 与<strong>优势函数 A</strong>：
$$
Q(s,a) = V(s) + A(s,a) - \frac{1}{|\mathcal{A}|}\sum_{a’} A(s,a’)
$$
<ul>
<li>对于很多状态，<strong>“当前状态好不好”比“具体动作差异”更重要</strong>（例如四面都是墙）；</li>
<li>Dueling 结构先学习一个共享的表示，再分别输出 V 和 A，有利于在很多动作“差不多”的状态下更稳定地估计价值。(<a href="https://www.researchgate.net/publication/334070121_Deep_Q_Network_DQN_Double_DQN_and_Dueling_DQN_A_Step_Towards_General_Artificial_Intelligence?utm_source=chatgpt.com">ResearchGate</a>)</li>
</ul>
</li>
<li><strong>经验回放的改进：优先经验回放（PER）</strong>
<ul>
<li>标准回放是均匀采样，但有些 transition 比另一些更“关键”；</li>
<li>PER 根据 TD 误差大小给样本分配优先级，误差大的样本被采到的概率更高，以更快修正错误估计。(<a href="https://www.researchgate.net/publication/334070121_Deep_Q_Network_DQN_Double_DQN_and_Dueling_DQN_A_Step_Towards_General_Artificial_Intelligence?utm_source=chatgpt.com">ResearchGate</a>)</li>
</ul>
</li>
<li><strong>多步回报与分布式值函数</strong>
<ul>
<li><strong>多步回报（n-step return）</strong>：
用 (r_t + \gamma r_{t+1} + \dots + \gamma^{n-1} r_{t+n-1} + \gamma^n \max_a Q(s_{t+n},a)) 替代一步 TD 目标，在偏差与方差之间取得更好平衡。</li>
<li><strong>分布式 Q 学习（Distributional RL）</strong>：
不只预测期望回报 (\mathbb{E}[G])，而是预测<strong>回报的整个分布</strong>，在风险敏感决策等场景中更有用。</li>
</ul>
</li>
<li><strong>探索策略改进</strong>
<ul>
<li>从简单的 (\epsilon)-greedy 发展到：
<ul>
<li>Boltzmann / softmax 探索；</li>
<li>参数噪声（noisy nets）；</li>
<li>基于不确定性或预测误差的探索（如随机网络蒸馏 RND，后续章节会提）。(<a href="https://apxml.com/courses/advanced-reinforcement-learning/chapter-3-advanced-policy-gradients-actor-critic/a2c-a3c?utm_source=chatgpt.com">ApX Machine Learning</a>)</li>
</ul>
</li>
<li>对于机器人具身智能，探索必须与<strong>安全约束</strong>结合，这在后面章节（5.4、10.3）会进一步讨论。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-3 占位：DQN 改进家族示意图：从基础 DQN 出发，分叉出 Double DQN、Dueling DQN、PER、Distributional RL 等分支，形成“演化树”。】</p>
</blockquote>
<hr>
<h3 id="522-策略梯度与-reinforce"><a class="header" href="#522-策略梯度与-reinforce">5.2.2 策略梯度与 REINFORCE</a></h3>
<p>值函数法从“<strong>状态–动作值</strong>”间接得到策略，而**策略梯度（Policy Gradient）**则是“<strong>直接把策略当成一个可微函数，显式对它做梯度上升</strong>”。这在连续动作空间或需要随机策略时尤为重要。(<a href="https://en.wikipedia.org/wiki/Policy_gradient_method?utm_source=chatgpt.com">维基百科</a>)</p>
<hr>
<h4 id="5221-策略直接优化"><a class="header" href="#5221-策略直接优化">5.2.2.1 策略直接优化</a></h4>
<ol>
<li><strong>策略参数化</strong>
用参数 (\theta) 表示一个可微的随机策略：
$$
\pi_\theta(a|s)
$$
例如：
<ul>
<li>离散动作：(\pi_\theta(a|s)) 是 softmax 输出的类别分布；</li>
<li>连续动作：(\pi_\theta(\cdot|s)) 是高斯分布 (\mathcal{N}(\mu_\theta(s), \Sigma_\theta(s)))。</li>
</ul>
</li>
<li><strong>目标函数：最大化期望回报</strong>
$$
J(\theta) = \mathbb{E}<em>{\tau \sim \pi</em>\theta}\Big[ \sum_{t=0}^{T-1} \gamma^t r_{t+1} \Big]
$$
其中 (\tau) 是一条由策略 (\pi_\theta) 生成的轨迹。</li>
<li><strong>策略梯度定理（Policy Gradient Theorem）</strong>
可证明：
$$
\nabla_\theta J(\theta) =
\mathbb{E}<em>{\pi</em>\theta}\bigg[
\sum_{t=0}^{T-1} \nabla_\theta \log \pi_\theta(a_t|s_t), G_t
\bigg]
$$
其中 (G_t) 是从 t 时刻开始的回报。
<ul>
<li>直觉：
<ul>
<li>(\nabla_\theta \log \pi_\theta(a_t|s_t)) 表示“<strong>如何调整参数以增加该动作概率</strong>”；</li>
<li>(G_t) 表示“<strong>这次选择的长期收益</strong>”；</li>
<li>两者相乘，相当于：<strong>如果某个动作带来高回报，就把它在该状态的概率往上推；如果回报差，就往下拉</strong>。</li>
</ul>
</li>
</ul>
</li>
<li><strong>优点与缺点</strong>
<ul>
<li>优点：
<ul>
<li>可以自然处理连续动作和复杂策略结构；</li>
<li>可以直接优化“想要的指标”（期望回报）。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>梯度估计通常方差较大；</li>
<li>需要大量样本，往往是<strong>on-policy</strong>（每次更新都要采集新数据）。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5222-reinforce-算法"><a class="header" href="#5222-reinforce-算法">5.2.2.2 REINFORCE 算法</a></h4>
<p><strong>REINFORCE</strong> 是最经典、最直接的 Monte Carlo 策略梯度算法，由 Williams 在 1992 年提出。(<a href="https://en.wikipedia.org/wiki/Policy_gradient_method?utm_source=chatgpt.com">维基百科</a>)</p>
<ol>
<li><strong>算法核心公式</strong>
对于一条完整轨迹 (\tau)，REINFORCE 使用：
$$
\nabla_\theta J(\theta) \approx
\sum_{t=0}^{T-1} \nabla_\theta \log \pi_\theta(a_t|s_t), G_t
$$
<ul>
<li>其中 (G_t = \sum_{k=t}^{T-1} \gamma^{k-t} r_{k+1}) 为<strong>从 t 时刻开始的总回报</strong>。</li>
</ul>
</li>
<li><strong>基本算法流程（单策略网络）</strong>
<ul>
<li>初始化策略参数 (\theta)；</li>
<li>循环直到收敛：
<ol>
<li>在当前策略 (\pi_\theta) 下采样若干条完整轨迹；</li>
<li>对每条轨迹、每个时间步计算回报 (G_t)；(<a href="https://wikidocs.net/164397?utm_source=chatgpt.com">wikidocs.net</a>)</li>
<li>聚合梯度：
$$
g = \frac{1}{N}\sum_{\tau}\sum_t \nabla_\theta \log \pi_\theta(a_t|s_t), G_t
$$</li>
<li>沿梯度上升：(\theta \leftarrow \theta + \alpha g)。</li>
</ol>
</li>
</ul>
</li>
<li><strong>特点与局限</strong>
<ul>
<li>优点：
<ul>
<li>推导简单、实现方便，是理解策略梯度的最好入口；</li>
<li>不依赖价值函数估计，适用于任意可微策略参数化。</li>
</ul>
</li>
<li>缺点：
<ul>
<li>需要完整轨迹（Monte Carlo），不能实时更新；</li>
<li>梯度估计方差非常大，收敛通常较慢；</li>
<li>对机器人任务（特别是长时间操作）来说，样本效率偏低。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="5223-减少方差"><a class="header" href="#5223-减少方差">5.2.2.3 减少方差</a></h4>
<p>策略梯度的一个核心实际问题是<strong>梯度估计方差太大</strong>，会导致训练过程震荡、收敛缓慢。以下是最常用的方差减少技巧。</p>
<ol>
<li><strong>基线（Baseline）思想</strong>
在公式
$$
\nabla_\theta J(\theta) =
\mathbb{E}<em>{\pi</em>\theta}\big[
\nabla_\theta \log \pi_\theta(a_t|s_t), G_t
\big]
$$
中，我们可以减去一个<strong>与动作无关的基线 (b(s_t))</strong>：
$$
\nabla_\theta J(\theta) =
\mathbb{E}<em>{\pi</em>\theta}\big[
\nabla_\theta \log \pi_\theta(a_t|s_t), (G_t - b(s_t))
\big]
$$
只要 (b(s_t)) 不依赖于 (a_t)，这个变换不会引入偏差。
<ul>
<li>直观理解：
<ul>
<li>(G_t) 是“这次做完之后的实际成绩”；</li>
<li>(b(s_t)) 是“在当前状态下的平均水平”；</li>
<li>只对“高于平均水平的行动”强烈鼓励，对“低于平均水平的行动”强烈惩罚，自然而然减小波动。</li>
</ul>
</li>
<li>最理想的基线是状态价值函数 (V^\pi(s_t))，这在 5.2.3 中会系统化为优势函数。</li>
</ul>
</li>
<li><strong>Reward-to-go 与截断回报</strong>
<ul>
<li>原始 REINFORCE 若用整条轨迹总回报 (G_0) 作为每一个时间步的权重，会引入不必要的噪声；</li>
<li>更常见做法是<strong>reward-to-go</strong>：每个时间步只用从该步往后的回报 (G_t)，已经是对方差的一种显著减少。(<a href="https://en.wikipedia.org/wiki/Policy_gradient_method?utm_source=chatgpt.com">维基百科</a>)</li>
</ul>
</li>
<li><strong>回报 / 优势的归一化</strong>
在实践中，人们常对每个 batch 内的 (G_t) 或优势 (A_t) 做：
<ul>
<li>减去均值；</li>
<li>除以标准差。
这样能使梯度步长更稳定，也算一种简单的“数值层面”降方差策略。</li>
</ul>
</li>
<li><strong>广义优势估计（GAE，概念直觉）</strong>
GAE（Generalized Advantage Estimation）将多个 n-step TD 误差按指数权重混合，形成一个<strong>在偏差与方差之间可调的优势估计</strong>：(<a href="https://medium.com/%40hsinhungw/intro-to-reinforcement-learning-monte-carlo-to-policy-gradient-1c7ede4eed6e?utm_source=chatgpt.com">Medium</a>)
$$
\hat{A}<em>t^{\text{GAE}(\gamma,\lambda)} =
\sum</em>{l=0}^{\infty} (\gamma\lambda)^l \delta_{t+l}
$$
其中 (\delta_t) 是 TD 误差。
<ul>
<li>(\lambda \to 1)：更接近 Monte Carlo，方差大但无偏；</li>
<li>(\lambda \to 0)：更接近一步 TD，方差小但偏差大。
GAE 在后面 PPO 等算法中将经常出现，是现代策略梯度方法的标配组件。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-4 占位：示意图对比三种估计：纯 MC G、一步 TD 估计、GAE 估计在方差和偏差上的折衷。】</p>
</blockquote>
<hr>
<h3 id="523-actorcritic-框架"><a class="header" href="#523-actorcritic-框架">5.2.3 Actor–Critic 框架</a></h3>
<p><strong>Actor–Critic</strong> 方法可以视作“<strong>值函数法（Critic）＋策略梯度法（Actor）</strong> 的融合”，同时利用值函数的低方差估计和策略梯度的灵活表达能力，是现代强化学习的主力架构。(<a href="https://en.wikipedia.org/wiki/Actor-critic_algorithm?utm_source=chatgpt.com">维基百科</a>)</p>
<hr>
<h4 id="5231-actorcritic"><a class="header" href="#5231-actorcritic">5.2.3.1 Actor–Critic</a></h4>
<ol>
<li><strong>核心构成</strong>
<ul>
<li><strong>Actor（策略网络）</strong>：参数 (\theta)，输出 (\pi_\theta(a|s)) 或确定性动作 (\mu_\theta(s))；</li>
<li><strong>Critic（价值网络）</strong>：参数 (w)，估计 (V_w(s)) 或 (Q_w(s,a))。</li>
</ul>
</li>
<li><strong>基本思想</strong>
<ul>
<li>Critic 根据环境给出的奖励和下一个状态，使用 TD 方法学习“这个状态/动作的好坏”；</li>
<li>Actor 使用 Critic 给出的信号（通常是优势或 TD 误差）更新策略参数，让“好动作的概率变大，坏动作的概率变小”。</li>
</ul>
</li>
<li><strong>典型 on-policy Actor–Critic 更新</strong>
以状态价值 Critic 为例（估计 (V(s))）：
<ul>
<li>收到奖励和下一个状态后计算 TD 误差：
$$
\delta_t = r_{t+1} + \gamma V_w(s_{t+1}) - V_w(s_t)
$$</li>
<li>Critic 更新：
$$
w \leftarrow w + \beta, \delta_t \nabla_w V_w(s_t)
$$</li>
<li>Actor 更新（策略梯度）：
$$
\theta \leftarrow \theta + \alpha, \delta_t \nabla_\theta \log \pi_\theta(a_t|s_t)
$$
这里 (\delta_t) 可以理解为“<strong>当前动作的即时优势估计</strong>”。</li>
</ul>
</li>
<li><strong>与纯 REINFORCE 的区别</strong>
<ul>
<li>REINFORCE 使用完整回报 (G_t)，高方差；</li>
<li>Actor–Critic 使用 TD 误差（或价值函数/优势函数），可以边交互边更新，<strong>更样本高效，方差更小</strong>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-5 占位：Actor-Critic 结构图：左侧环境，右侧两张网络：Actor 输出动作，Critic 评估状态或动作价值；Critic 的评估结果反馈给 Actor 更新策略。】</p>
</blockquote>
<hr>
<h4 id="5232-优势函数"><a class="header" href="#5232-优势函数">5.2.3.2 优势函数</a></h4>
<p>优势函数在策略梯度与 Actor–Critic 中扮演统一角色，是理解“<strong>为什么要减 baseline</strong>”的标准形式。</p>
<ol>
<li><strong>定义</strong>
在策略 (\pi) 下：
$$
Q^\pi(s,a) = \mathbb{E}[G_t|s_t=s,a_t=a],\quad
V^\pi(s) = \mathbb{E}_{a \sim \pi}[Q^\pi(s,a)]
$$
<strong>优势函数</strong>：
$$
A^\pi(s,a) = Q^\pi(s,a) - V^\pi(s)
$$
<ul>
<li>如果 (A^\pi(s,a) &gt; 0)：说明“<strong>这次选的动作比平均水平好</strong>”；</li>
<li>如果 (A^\pi(s,a) &lt; 0)：说明“<strong>比平均水平差</strong>”。</li>
</ul>
</li>
<li><strong>优势函数与策略梯度</strong>
策略梯度理论告诉我们：
$$
\nabla_\theta J(\theta) =
\mathbb{E}<em>{\pi</em>\theta}[
\nabla_\theta \log \pi_\theta(a|s), A^{\pi_\theta}(s,a)
$$
$$
优势函数自然地出现在理论公式里，相当于<strong>自动选择了最优基线 (b(s) = V^\pi(s))</strong>，从而在不引入偏差的前提下降低方差。(<a href="https://en.wikipedia.org/wiki/Policy_gradient_method?utm_source=chatgpt.com">维基百科</a>)</li>
<li><strong>优势函数的近似方式</strong>
在实际算法中，我们无法精确求得 (A^\pi)，通常采用近似：
<ul>
<li><strong>一步 TD 误差</strong>：
$$
\hat{A}<em>t = r</em>{t+1} + \gamma V_w(s_{t+1}) - V_w(s_t) = \delta_t
$$</li>
<li><strong>n-step 回报</strong>：
$$
\hat{A}<em>t^{(n)} =
\big( r</em>{t+1} + \dots + \gamma^{n-1} r_{t+n} + \gamma^n V_w(s_{t+n}) \big)</li>
</ul>
</li>
</ol>
<ul>
<li>V_w(s_t)
$$
<ul>
<li><strong>GAE</strong>：用指数衰减平均多个 TD 误差，前面已给出形式。(<a href="https://apxml.com/courses/advanced-reinforcement-learning/chapter-3-advanced-policy-gradients-actor-critic/a2c-a3c?utm_source=chatgpt.com">ApX Machine Learning</a>)</li>
</ul>
</li>
</ul>
<hr>
<h4 id="5233-算法示例"><a class="header" href="#5233-算法示例">5.2.3.3 算法示例</a></h4>
<p>在 Actor–Critic 框架下，众多具体算法可以看作“<strong>在 Actor–Critic 模板上添加不同的估计方式、并行方式或约束方式</strong>”。</p>
<ol>
<li><strong>同步优势 Actor–Critic（A2C）</strong>
<ul>
<li>多个并行环境同时使用同一策略 (\pi_\theta) 采集数据；</li>
<li>每隔若干步把所有环境的数据合并起来，计算优势（通常用 GAE）；</li>
<li>使用统一的 Critic 和 Actor 做一次同步更新；</li>
<li>A2C 通过并行环境降低样本方差、提高训练利用率。(<a href="https://apxml.com/courses/advanced-reinforcement-learning/chapter-3-advanced-policy-gradients-actor-critic/a2c-a3c?utm_source=chatgpt.com">ApX Machine Learning</a>)</li>
</ul>
</li>
<li><strong>异步优势 Actor–Critic（A3C）</strong>
<ul>
<li>多个线程（或进程）各自与环境交互，维护本地网络副本；</li>
<li>每个线程定期将本地梯度推送到全局网络，异步更新参数；</li>
<li>异步探索可以自然增加策略多样性，同时减少样本间相关性。(<a href="https://medium.com/%40hsinhungw/intro-to-reinforcement-learning-monte-carlo-to-policy-gradient-1c7ede4eed6e?utm_source=chatgpt.com">Medium</a>)</li>
</ul>
</li>
<li><strong>TRPO / PPO：在 Actor–Critic 上加入“安全步长约束”</strong>
<ul>
<li>朴素策略梯度/Actor–Critic 容易因为一步更新过大而“策略崩溃”；</li>
<li><strong>TRPO（Trust Region Policy Optimization）</strong> 显式约束新旧策略的 KL 距离不超过某个阈值；</li>
<li><strong>PPO</strong> 用更简单的“剪切（clipping）”目标近似 TRPO 的信任域思想（PPO 在 5.2.4.3 专门详述）。(<a href="https://arxiv.org/abs/1707.06347?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>值函数型与策略型 Critic 的选择</strong>
<ul>
<li>部分 Actor–Critic 只用 (V(s)) 作为 Critic（比如 A2C/A3C、PPO）；</li>
<li>另一些（如 DDPG、SAC）使用 (Q(s,a)) 作为 Critic，更适合与<strong>确定性或连续动作策略</strong>结合（5.2.4 将重点讨论）。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-6 占位：A2C / A3C 示意图：多环境并行生成轨迹，统一送入 Actor–Critic 更新；下方标注 TRPO/PPO 在更新时对策略变化施加约束。】</p>
</blockquote>
<hr>
<h3 id="524-连续控制算法ddpgsacppo-的核心思想"><a class="header" href="#524-连续控制算法ddpgsacppo-的核心思想">5.2.4 连续控制算法（DDPG、SAC、PPO 的核心思想）</a></h3>
<p>前面介绍的 Q-Learning、DQN 主要针对<strong>离散动作空间</strong>。而在机器人具身智能中，关节位置、速度、扭矩等往往是<strong>连续控制量</strong>。DDPG、SAC、PPO 等算法正是为连续控制而设计或在连续控制上效果优异的代表。</p>
<hr>
<h4 id="5241-ddpg深度确定性策略梯度"><a class="header" href="#5241-ddpg深度确定性策略梯度">5.2.4.1 DDPG：深度确定性策略梯度</a></h4>
<p><strong>DDPG（Deep Deterministic Policy Gradient）</strong> 将 DQN 的经验回放与目标网络与<strong>确定性策略梯度</strong>结合，构建了一个适用于<strong>连续动作空间的 off-policy Actor–Critic 算法</strong>。(<a href="https://arxiv.org/abs/1509.02971?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>策略与 Critic 的形式</strong>
<ul>
<li>Actor：确定性策略 (\mu_\theta(s))，直接输出连续动作，如关节角速度向量；</li>
<li>Critic：Q 网络 (Q_w(s,a))，输入状态和动作，输出对应的 Q 值。</li>
</ul>
</li>
<li><strong>Critic 更新</strong>
与 DQN 类似，对每条经验 ((s,a,r,s’))，构造目标：
$$
y = r + \gamma Q_{w^-}(s’, \mu_{\theta^-}(s’))
$$
<ul>
<li>(w^-, \theta^-) 是目标网络参数，缓慢跟随在线网络更新；</li>
<li>最小化 ((y - Q_w(s,a))^2) 更新 Critic。</li>
</ul>
</li>
<li><strong>Actor 更新：确定性策略梯度</strong>
对连续动作的确定性策略，可以推导得到：(<a href="https://arxiv.org/abs/1509.02971?utm_source=chatgpt.com">arXiv</a>)
$$
\nabla_\theta J(\theta) \approx
\mathbb{E}<em>{s \sim \mathcal{D}}
\big[ \nabla_a Q_w(s,a)|</em>{a=\mu_\theta(s)} \cdot \nabla_\theta \mu_\theta(s) \big]
$$
即：
<ul>
<li>用 Critic 告诉 Actor：在当前状态下，往哪个方向改变动作可以增加 Q 值；</li>
<li>Actor 再通过链式法则更新参数，使输出动作朝“价值更高的方向”变化。</li>
</ul>
</li>
<li><strong>探索策略：动作空间加噪声</strong>
因为 Actor 输出的是确定性动作，探索需要通过在执行时加入噪声：
$$
a_t = \mu_\theta(s_t) + \mathcal{N}_t
$$
<ul>
<li>经典做法使用 Ornstein–Uhlenbeck 过程噪声，模拟物理系统中带惯性的随机扰动。(<a href="https://arxiv.org/abs/1509.02971?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>特点与局限</strong>
<ul>
<li>优点：
<ul>
<li>可以利用 off-policy + Replay Buffer，样本效率比 on-policy 更好；</li>
<li>适用于复杂连续控制任务，在早期连续控制基准上表现优异。</li>
</ul>
</li>
<li>局限：
<ul>
<li>对超参数、网络初始化等较敏感；</li>
<li>易出现训练不稳定、发散，探索也可能不充分；</li>
</ul>
</li>
<li>实践中经常配合更多技巧，如双 Q 网络（TD3）、延迟更新等加强稳定性。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-7 占位：DDPG 框架示意图：Actor 输出连续动作，执行时加噪声；Critic 评估 Q 值；Replay Buffer + 目标网络的结构与 DQN 类似。】</p>
</blockquote>
<hr>
<h4 id="5242-sac软-actorcritic-与最大熵强化学习"><a class="header" href="#5242-sac软-actorcritic-与最大熵强化学习">5.2.4.2 SAC：软 Actor–Critic 与最大熵强化学习</a></h4>
<p><strong>SAC（Soft Actor–Critic）</strong> 是近几年连续控制领域非常流行的算法之一，基于**最大熵强化学习（maximum entropy RL）**思想：</p>
<blockquote>
<p>不仅要获得高回报，还要让策略尽可能“随机”一些，以鼓励探索和鲁棒性。(<a href="https://arxiv.org/abs/1801.01290?utm_source=chatgpt.com">arXiv</a>)</p>
</blockquote>
<ol>
<li><strong>最大熵目标</strong>
标准 RL 只最大化回报：
$$
J(\pi) = \mathbb{E}\Big[\sum_t \gamma^t r_t\Big]
$$
SAC 引入熵正则项：
$$
J_{\text{soft}}(\pi) =
\mathbb{E}\Big[\sum_t \gamma^t (r_t + \alpha \mathcal{H}(\pi(\cdot|s_t)))\Big]
$$
<ul>
<li>(\mathcal{H}) 是策略的熵，(\alpha) 是温度系数；</li>
<li>直觉：在获得类似回报的策略中，更偏好“动作更随机”的策略，因为它们通常<strong>探索更充分、对模型误差更鲁棒</strong>。</li>
</ul>
</li>
<li><strong>结构：随机 Actor + 双 Q Critic</strong>
<ul>
<li>Actor：随机策略 (\pi_\theta(a|s))，通常为高斯分布经过 (\tanh) 压缩到动作范围；</li>
<li>Critic：两个 Q 网络 (Q_{w_1}, Q_{w_2}) 来减轻过估计偏差；</li>
<li>目标值使用“软”备份：
$$
y = r + \gamma
\big( \min_{i=1,2} Q_{w_i^-}(s’,a’) - \alpha \log \pi_\theta(a’|s’) \big)
$$
其中 (a’ \sim \pi_\theta(\cdot|s’))。</li>
</ul>
</li>
<li><strong>Actor 更新：最小化“soft Q - entropy”目标</strong>
Actor 更新等价于最小化：
$$
J_\pi(\theta) =
\mathbb{E}<em>{s \sim \mathcal{D}, a \sim \pi</em>\theta}
\big[ \alpha \log \pi_\theta(a|s) - Q_w(s,a) \big]
$$
<ul>
<li>如果对某个 (s,a) 的 Q 值较高，梯度会推动策略提高该动作概率；</li>
<li>同时 (\alpha \log \pi) 项推动策略保持一定随机性。</li>
</ul>
</li>
<li><strong>温度 (\alpha) 的自动调节</strong>
实践中，SAC 通常<strong>自动学习 (\alpha)</strong>，使策略的熵接近一个目标值（例如期望熵）。
<ul>
<li>这避免了人工手动调温度的困难，使算法更加稳健。(<a href="https://arxiv.org/abs/1801.01290?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>SAC 的优势</strong>
<ul>
<li>Off-policy，样本效率高；</li>
<li>训练稳定性好，对超参数不那么敏感；</li>
<li>在 Mujoco 等连续控制基准上表现强劲，已成为真实机器人实验中常用的 RL 算法之一。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-8 占位：SAC 结构图：随机策略输出高斯参数，经 Tanh 得到动作；双 Q 网络估计 soft Q；目标中含有熵项，旁边用文字标出“高回报 + 高熵”。】</p>
</blockquote>
<hr>
<h4 id="5243-ppo近端策略优化"><a class="header" href="#5243-ppo近端策略优化">5.2.4.3 PPO：近端策略优化</a></h4>
<p><strong>PPO（Proximal Policy Optimization）</strong> 是一种<strong>on-policy Actor–Critic 算法</strong>，以其<strong>实现简单、性能稳定</strong>而被广泛采用，尤其是在连续控制任务中。(<a href="https://arxiv.org/abs/1707.06347?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>问题：普通策略梯度更新太“凶猛”</strong>
<ul>
<li>Vanilla Policy Gradient 或基础 Actor–Critic 在一次更新中如果步长过大，可能导致新策略与旧策略差别过大，性能骤降；</li>
<li>TRPO 通过显式 KL 约束解决，但实现复杂、计算开销较高。</li>
</ul>
</li>
<li><strong>PPO 的核心：剪切（Clipped）目标函数</strong>
设旧策略参数为 (\theta_{\text{old}})，新策略为 (\theta)，定义概率比：
$$
r_t(\theta) =
\frac{\pi_\theta(a_t|s_t)}{\pi_{\theta_{\text{old}}}(a_t|s_t)}
$$
以及优势估计 (\hat{A}_t)（例如用 GAE）。
<ul>
<li>未剪切的策略梯度目标：
$$
L^{\text{PG}}(\theta) =
\mathbb{E}[ r_t(\theta), \hat{A}_t ]
$$</li>
<li>PPO 的剪切目标：
$$
L^{\text{CLIP}}(\theta) =
\mathbb{E}\big[
\min\big(
r_t(\theta)\hat{A}_t,
\text{clip}(r_t(\theta),1-\epsilon,1+\epsilon)\hat{A}_t
\big)
\big]
$$
含义：</li>
<li>如果新旧策略差别不大（(r_t) 在 ([1-\epsilon, 1+\epsilon]) 内），目标与普通 PG 相同；</li>
<li>一旦 (r_t) 试图偏离这个区间，(\text{clip}) 会“拉回”，使得 <strong>过大的变化不会继续被鼓励</strong>。</li>
</ul>
</li>
<li><strong>完整损失函数</strong>
实际上，PPO 一般同时优化三部分：(<a href="https://arxiv.org/pdf/1707.06347?utm_source=chatgpt.com">arXiv</a>)
$$
L(\theta) =
\mathbb{E}\big[
L^{\text{CLIP}}(\theta)
<ul>
<li>c_1 (V_\theta(s_t) - V^{\text{target}}_t)^2</li>
<li>c_2 \mathcal{H}(\pi_\theta(\cdot|s_t))
\big]
$$</li>
<li>第一项：策略更新（剪切目标）；</li>
<li>第二项：价值函数回归损失；</li>
<li>第三项：熵正则（鼓励一定探索）。</li>
</ul>
</li>
<li><strong>训练流程特点</strong>
<ul>
<li>与 vanilla PG 不同，PPO 会对同一批轨迹做<strong>多轮小批量梯度更新</strong>，提高样本利用率；</li>
<li>常搭配 GAE 估计优势；</li>
<li>一般使用并行环境（多进程采样）提升效率。</li>
</ul>
</li>
<li><strong>在机器人任务中的角色</strong>
<ul>
<li>优点：
<ul>
<li>实现简单、稳定性好，成为许多 RL 库的默认连续控制算法（如 OpenAI Baselines、RLlib 等）；</li>
<li>对超参数较为宽容，适合做研究原型和仿真实验。</li>
</ul>
</li>
<li>局限：
<ul>
<li>on-policy，样本利用率低，相比 SAC 等 off-policy 算法，在真实机器人上成本较高；</li>
</ul>
</li>
<li>实践中常见模式：
<ul>
<li>在大规模仿真中先用 PPO 训练一个合理策略，再在真实机器人上用 SAC 或离线 RL 进行精调。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-9 占位：PPO 训练循环示意图：并行环境生成轨迹 → 计算 GAE 优势 → 使用 CLIP 目标做多轮梯度更新；在图中标出 r(θ)、clip(·) 和 KL 限制直观关系。】</p>
</blockquote>
<hr>
<p>本节从 <strong>值函数法（Q-Learning/DQN）</strong> 出发，逐步过渡到 <strong>策略梯度与 REINFORCE</strong>，再走向 <strong>Actor–Critic 框架</strong>，最终落到在机器人连续控制中最常用的三类算法 DDPG、SAC、PPO。后续章节将以这些算法为“工具箱”，结合模仿学习、VLA 预训练等内容，构建真正能在现实世界中“看、听、动”的具身智能系统。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="模仿学习与行为克隆"><a href="#模仿学习与行为克隆" class="header">模仿学习与行为克隆</a></h1>
<h3 id="531-行为克隆behavior-cloningbc问题设定"><a class="header" href="#531-行为克隆behavior-cloningbc问题设定">5.3.1 行为克隆（Behavior Cloning，BC）问题设定</a></h3>
<h4 id="5311-模仿学习"><a class="header" href="#5311-模仿学习">5.3.1.1 模仿学习</a></h4>
<p>在前面的强化学习部分，我们假设智能体可以与环境“自己玩”，通过试错不断积累经验；而在很多真实机器人场景中，这样做要么太慢，要么太危险——机械臂乱挥可能砸坏设备，无人车乱试可能直接上墙。</p>
<p><strong>模仿学习（Imitation Learning, IL）****就是在这样的背景下提出的：
<strong><strong>给定</strong></strong>专家示范（demonstrations）</strong>，希望训练一个策略来“学会像专家那样做”，尽量少或者不与环境进行额外交互。直观地说，就是：</p>
<blockquote>
<p>不让机器人自己闯祸，而是先让它“看高手怎么玩”，然后学着照做。</p>
</blockquote>
<p>更形式一点，可以把模仿学习看成：在一个已知或未知的 MDP 环境中，给定若干专家轨迹
$$
\tau_i = (s_0^i, a_0^i, s_1^i, a_1^i, \dots, s_{T_i}^i),
$$
这些轨迹由某个专家策略 (\pi^<em>) 生成，我们希望学得一个策略 (\hat\pi)，其表现尽量接近甚至优于 (\pi^</em>)。系统性的综述指出，模仿学习已经在自动驾驶、机器人抓取与操作等领域得到广泛应用。(<a href="https://arxiv.org/pdf/2106.12177?utm_source=chatgpt.com">arXiv</a>)</p>
<p>从方法上看，大部分模仿学习可以粗略分为两类：</p>
<ol>
<li><strong>直接模仿专家策略</strong>
<ul>
<li>典型代表就是行为克隆（Behavior Cloning），把模仿学习问题转化为一个标准的监督学习问题；</li>
</ul>
</li>
<li><strong>“反推”专家在优化什么</strong>
<ul>
<li>即逆强化学习（IRL），先根据示范恢复一个奖励函数，再在该奖励下做强化学习。</li>
</ul>
</li>
</ol>
<p>本节的 5.3.1–5.3.2 主要关注第一类（直接模仿策略），5.3.3 再转向 IRL 与奖励学习。</p>
<p>在机器人具身智能场景中，示范往往来自：</p>
<ul>
<li>人类遥操作（teleoperation）生成的轨迹；</li>
<li>人手带动机械臂的 kinesthetic teaching；</li>
<li>规划器、控制器在仿真中执行任务得到的自动演示。</li>
</ul>
<p>这些在第 7 章会展开，这里先把它们当作“已经有了一堆轨迹数据”的前提。</p>
<hr>
<h4 id="5312-行为克隆"><a class="header" href="#5312-行为克隆">5.3.1.2 行为克隆</a></h4>
<p>**行为克隆（Behavior Cloning, BC）**是最直接的模仿学习形式：</p>
<blockquote>
<p>把“观察状态→输出动作”当成一个监督学习任务，拿专家动作当标签，训练一个函数拟合器。</p>
</blockquote>
<p>具体设定如下：</p>
<ul>
<li>通过专家与环境交互，收集一个数据集
$$
\mathcal D = {(s_t^i, a_t^i)}_{i,t},
$$
其中 (s_t^i) 是第 (i) 条轨迹在时刻 (t) 的状态，(a_t^i) 是专家在该状态下执行的动作；</li>
<li>选取一个参数化策略 (\pi_\theta(a|s))（例如深度神经网络），</li>
<li>通过最小化监督学习损失来拟合专家：
$$
\min_\theta ; \mathbb E_{(s,a)\sim \mathcal D}\big[l\big(\pi_\theta(\cdot|s), a\big)\big],
$$
<ul>
<li>离散动作：(l) 通常是交叉熵损失；</li>
<li>连续动作：(l) 可以是均方误差（MSE），或者假设高斯策略用负对数似然。</li>
</ul>
</li>
</ul>
<p>早在 1980s 的 ALVINN 无人车项目中，就已经使用行为克隆将前视相机图像直接映射到方向盘角度，实现端到端的道路跟随，可视为模仿学习最早的成功案例之一。(<a href="https://papers.neurips.cc/paper_files/paper/1988/file/812b4ba287f5ee0bc9d43bbf5bbe87fb-Paper.pdf?utm_source=chatgpt.com">NeurIPS论文</a>)</p>
<p>在具身机器人中，行为克隆的典型用法包括：</p>
<ul>
<li><strong>机械臂抓取与放置</strong>
<ul>
<li>输入：当前 RGB-D 图像 + 机械臂末端位姿；</li>
<li>输出：末端位姿增量或关节增量；</li>
</ul>
</li>
<li><strong>移动机器人导航</strong>
<ul>
<li>输入：前视摄像头图像 / 激光雷达扫描；</li>
<li>输出：线速度、角速度命令。</li>
</ul>
</li>
</ul>
<blockquote>
<p>【图 5-3-1 占位】
建议插图：示意“行为克隆管线”：左侧是专家示范的图像与动作序列，中间是一个神经网络，右侧是克隆后的策略在相似场景中输出动作。</p>
</blockquote>
<p>在实现上，行为克隆几乎和训练一个普通分类 / 回归模型没有区别：
只要能把状态编码为特征，把动作编码为标签，就可以用任意深度学习框架进行训练，这也是它在工程实践中被广泛采用的原因。</p>
<hr>
<h4 id="5313-前提假设"><a class="header" href="#5313-前提假设">5.3.1.3 前提假设</a></h4>
<p>行为克隆之所以“好用”，背后有几条往往被忽略但非常关键的<strong>前提假设</strong>：</p>
<ol>
<li><strong>专家接近最优</strong>（Optimality assumption）
<ul>
<li>假设示范来自一个接近任务最优或至少“足够好”的策略；</li>
<li>若专家本身就经常犯错（例如人类新手操作），BC 只会稳定地学会“错误的习惯”；</li>
<li>后续很多工作研究如何从<strong>非最优示范</strong>中学习，这在 IRL 与奖励学习里尤为重要。(<a href="https://www.robots.ox.ac.uk/~bdemoss/research_notes/ImitationLearning.pdf?utm_source=chatgpt.com">牛津大学机器人研究所</a>)</li>
</ul>
</li>
<li><strong>示范覆盖测试时会遇到的状态分布</strong>（Coverage assumption）
<ul>
<li>训练时，状态是从专家策略诱导的分布 (d_{\pi^*}(s)) 中采样的；</li>
<li>测试时，机器人按自己的策略 (\hat\pi) 行动，状态分布变为 (d_{\hat\pi}(s))；</li>
<li>BC 隐含假设：(d_{\hat\pi} \approx d_{\pi^*})，也就是机器人不会走到专家“没去过”的地方；</li>
<li>实际上只要策略略有偏差，就可能逐步偏离专家轨迹，进入数据集外的状态，带来严重问题（下一小节的“分布偏移”）。</li>
</ul>
</li>
<li><strong>观测与动作标注准确</strong>
<ul>
<li>假设传感器标定正确、时间同步良好，状态–动作对 ((s_t, a_t)) 没有系统偏差；</li>
<li>在真实机器人系统中，延迟、丢帧、标定误差会导致“错误配对”（比如相机图像实际上对应的是 100 ms 前的动作）；</li>
<li>这类误差会直接体现在监督信号中，使得 BC 很难学到稳定策略。</li>
</ul>
</li>
<li><strong>具身配置一致</strong>
<ul>
<li>假设专家和学习者的身体（embodiment）相同或足够接近，如同一型号的机械臂；</li>
<li>若专家是人类的手，而学习者是 7 自由度机械臂，则需要解决“动作空间映射”问题，单纯行为克隆就不够。</li>
</ul>
</li>
</ol>
<p>这些假设在实验室简单任务中勉强成立，但在开放环境、长时间操作的具身智能场景下往往会被打破。
其中<strong>状态分布覆盖问题</strong>最为致命，它直接导致了行为克隆中经常出现的“开始很像专家，过一会儿就崩掉”的现象——这就是 5.3.2 要讨论的核心：<strong>分布偏移与 DAgger</strong>。</p>
<hr>
<h3 id="532-分布偏移与-dagger-思想"><a class="header" href="#532-分布偏移与-dagger-思想">5.3.2 分布偏移与 DAgger 思想</a></h3>
<h4 id="5321-分布偏移"><a class="header" href="#5321-分布偏移">5.3.2.1 分布偏移</a></h4>
<p>在监督学习中，通常假设<strong>训练集和测试集来自同一分布</strong>。
行为克隆却非常“狡猾”地违反了这个假设：</p>
<ul>
<li>训练阶段：
<ul>
<li>状态来自专家策略 (\pi^<em>) 的轨迹，分布记为 (d_{\pi^</em>}(s))；</li>
</ul>
</li>
<li>测试阶段：
<ul>
<li>机器人执行的是自己学到的策略 (\hat\pi)，状态分布变为 (d_{\hat\pi}(s))。</li>
</ul>
</li>
</ul>
<p>只要 (\hat\pi) 和 (\pi^*) 不完全相同，两者的分布就会有差异，这种差异随着时间步数增长会<strong>不断放大</strong>：</p>
<ul>
<li>在每一步，策略以概率 (\varepsilon) 选错动作；</li>
<li>一次小小的偏差可能把系统带到新的状态区域，在那里策略从未见过数据；</li>
<li>在这个新区域里错误率往往更高，于是进一步走向更“奇怪”的状态……</li>
</ul>
<p>这是经典的<strong>误差累积问题（compounding error）</strong>：
理论分析表明，在行为克隆中，某些任务下最终性能损失可以和时间跨度 (T) 的<strong>平方</strong>成正比（(O(T^2 \varepsilon))），这意味着<strong>长时任务在 BC 中特别容易崩坏</strong>。(<a href="https://web.stanford.edu/class/cs237b/pdfs/lecture/lecture_10111213.pdf?utm_source=chatgpt.com">Stanford University</a>)</p>
<p>在具身机器人场景中，具体表现例如：</p>
<ul>
<li>移动机器人学会跟随走廊中线，刚开始几米看起来很稳，一旦稍微偏离，之后误差越积越大，最终撞墙；</li>
<li>机械臂在抓取任务中，只要一次对准偏差，之后的抓取、提起、放置动作都会在“错误位姿”附近执行，导致任务失败。</li>
</ul>
<blockquote>
<p>【图 5-3-2 占位】
建议插图：横轴为时间步，纵轴为轨迹偏离量；画出“专家轨迹”与“BC 策略轨迹”的对比，展示误差如何随时间累积。</p>
</blockquote>
<p>解决分布偏移问题的关键思路就是：<strong>让训练中看到的状态，尽可能接近自己将来真正会遇到的状态</strong>，这就引出了 DAgger。</p>
<hr>
<h4 id="5322-dagger-算法"><a class="header" href="#5322-dagger-算法">5.3.2.2 DAgger 算法</a></h4>
<p>DAgger（Dataset Aggregation）是 Ross 等人提出的一类<strong>交互式模仿学习算法</strong>，其核心思想可以用一句话概括：</p>
<blockquote>
<p>不再只在专家访问的状态上训练，而是在<strong>当前学到的策略会访问到的状态</strong>上，请专家标注动作，并不断把这些新样本加入训练集。(<a href="https://www.cs.cmu.edu/~sross1/publications/Ross-AIStats11-NoRegret.pdf?utm_source=chatgpt.com">cs.cmu.edu</a>)</p>
</blockquote>
<p>用更程序化的方式描述 DAgger：</p>
<ol>
<li><strong>初始化</strong>
<ul>
<li>用纯专家示范数据 (\mathcal D_0) 做一次行为克隆，得到初始策略 (\pi_1)。</li>
</ul>
</li>
<li><strong>第 (k) 次迭代（交互与标注）</strong>
<ol>
<li>用当前策略 (\pi_k) 与环境交互，收集新的状态序列
$$
\tau^{(k)} = (s_0^{(k)}, s_1^{(k)}, \dots, s_T^{(k)}),
$$
此时状态分布是 (d_{\pi_k}(s))；</li>
<li>对这些状态，请专家给出“正确动作” (a_t^{(k,<em>)})，得到新数据集
$$
\mathcal D_k = {(s_t^{(k)}, a_t^{(k,</em>)})}_t
$$</li>
<li>数据聚合：(\mathcal D \leftarrow \mathcal D \cup \mathcal D_k)；</li>
<li>在新的聚合数据集 (\mathcal D) 上重新训练策略，得到 (\pi_{k+1})。</li>
</ol>
</li>
<li><strong>停止条件</strong>
<ul>
<li>当策略性能收敛、或者达到预定迭代轮数时停止，</li>
<li>最终可使用最后一次策略 (\pi_K)，或某种平均策略。</li>
</ul>
</li>
</ol>
<p>相对行为克隆，DAgger 有几个关键特征：</p>
<ul>
<li><strong>训练分布匹配测试分布</strong>
<ul>
<li>每一轮训练都在更接近 (\pi_k) 自己将会访问的状态分布上进行，避免了“只在专家访问区域表现好”；</li>
</ul>
</li>
<li><strong>理论保证更强</strong>
<ul>
<li>在一定条件下，如果用于监督学习的基础算法具备“无遗憾（no-regret）”性质，则 DAgger 可以将性能损失从 (O(T^2\varepsilon)) 改善到 (O(T\varepsilon))；</li>
</ul>
</li>
<li><strong>工程直觉：不断在线纠偏</strong>
<ul>
<li>机器人在自己“犯错”的状态下会收到专家纠正，这类似于人类教练随时在旁边拉一把。</li>
</ul>
</li>
</ul>
<blockquote>
<p>【图 5-3-3 占位】
建议插图：画出 DAgger 的循环流程图：
「当前策略执行 → 产生新状态 → 专家标注动作 → 数据聚合 → 重新训练策略」，形成闭环。</p>
</blockquote>
<p>在机器人实验中，DAgger 通常通过遥操作界面实现：
机器人执行自己的策略，人类在旁边监控，一旦发现动作不合理，就接管并给出“应当采取的动作”，系统则记录下“状态–专家动作对”，用于后续训练。</p>
<hr>
<h4 id="5323-反复迭代"><a class="header" href="#5323-反复迭代">5.3.2.3 反复迭代</a></h4>
<p>从实现角度看，DAgger 不是“只多了一轮训练”，而是<strong>设计一个长期人机协作的训练流程</strong>：</p>
<ul>
<li><strong>迭代次数的权衡</strong>
<ul>
<li>迭代太少，策略仍然对自身造成的状态分布偏移不够鲁棒；</li>
<li>迭代太多，人类标注成本和机器人运行时间会很高；</li>
<li>实际工程中常采用：先用 BC 预训练，再做有限轮 DAgger（例如 3–5 轮），即可显著提升性能。</li>
</ul>
</li>
<li><strong>安全与交互方式</strong>
<ul>
<li>在真实机器人上执行 DAgger 时，必须保证人类可以随时接管或触发急停；</li>
<li>一种常见做法是：机器人处于“半自动模式”，每步先给出自己的动作建议，人类有机会审批 / 修改，系统记录最终执行的“专家版本”动作；</li>
</ul>
</li>
<li><strong>主动查询与不确定性</strong>
<ul>
<li>后续许多工作扩展了 DAgger，只在“模型不自信”的状态上向专家询问动作，从而减少标注负担；</li>
<li>对具身智能系统来说，这类“有选择地向人类提问”的机制尤为重要，因为真实实验成本极高。(<a href="https://wensun.github.io/CS6789_data/Interactive_IL_pdf.pdf?utm_source=chatgpt.com">wensun.github.io</a>)</li>
</ul>
</li>
</ul>
<p>从全书结构上看，BC 与 DAgger 提供了一套<strong>纯基于示范的数据驱动建模方式</strong>，
在第 9 章中我们会看到，BC 也可以被视作“最简单的离线 RL 方法”，而 DAgger 则是走向“交互式模仿 + 在线纠错”的第一步。</p>
<hr>
<h3 id="533-逆强化学习与奖励学习的基本概念"><a class="header" href="#533-逆强化学习与奖励学习的基本概念">5.3.3 逆强化学习与奖励学习的基本概念</a></h3>
<h4 id="5331-逆强化学习irl"><a class="header" href="#5331-逆强化学习irl">5.3.3.1 逆强化学习（IRL）</a></h4>
<p>行为克隆的思路是：<strong>直接学“怎么做”</strong>；
逆强化学习（Inverse Reinforcement Learning, IRL）的思路则是：</p>
<blockquote>
<p>先学“专家在乎什么”（奖励函数），再让强化学习去自己发现“怎么做”。</p>
</blockquote>
<p>经典定义是：给定一个 MDP 的状态空间、动作空间和转移动力学，以及一组由专家策略产生的行为轨迹，求解一个奖励函数 (r(s,a))，使得专家策略在该奖励下是最优或近似最优。(<a href="https://ai.stanford.edu/~ang/papers/icml00-irl.pdf?utm_source=chatgpt.com">ai.stanford.edu</a>)</p>
<p>形式上可以写成：</p>
<ul>
<li>已知：((\mathcal S, \mathcal A, P, \gamma)) 和专家轨迹集合 ({\tau_i})；</li>
<li>未知：奖励函数 (r_\theta(s,a))；</li>
<li>目标：找到某个 (r_\theta)，使得在 MDP ((\mathcal S,\mathcal A,P,r_\theta,\gamma)) 上求解得到的最优策略 (\pi^*_\theta) 与专家行为尽量一致。</li>
</ul>
<p>IRL 的直觉在机器人中非常自然：</p>
<ul>
<li>行为只是表象，<strong>奖励才是“偏好”</strong>；</li>
<li>一旦学得了“偏好”，可以在<strong>新环境、不同初始条件</strong>下重新规划，而不必局限在原有示范分布内；</li>
<li>例如：
<ul>
<li>学习自动驾驶中“安全、平稳、尽量快速”的组合偏好，</li>
<li>学习机械臂装配任务中“避免碰撞、保证插入成功”的综合奖励。</li>
</ul>
</li>
</ul>
<p>IRL 的典型算法包括最大间隔 IRL、最大熵 IRL 等，它们通常需要在“内层”反复调用 RL 算法来评估一个候选奖励函数有多“好”，因此计算开销相对行为克隆要大得多。(<a href="https://ai.stanford.edu/~ang/papers/icml00-irl.pdf?utm_source=chatgpt.com">ai.stanford.edu</a>)</p>
<blockquote>
<p>【图 5-3-4 占位】
建议插图：对比“正向 RL”与“逆向 RL”的流程：</p>
<ul>
<li>RL：已知奖励 → 求策略；</li>
<li>IRL：观察策略（示范） → 反推奖励。</li>
</ul>
</blockquote>
<hr>
<h4 id="5332-奖励建模"><a class="header" href="#5332-奖励建模">5.3.3.2 奖励建模</a></h4>
<p>在更广义的视角下，**奖励学习 / 奖励建模（reward learning / reward modeling）**指的是：</p>
<blockquote>
<p>通过数据（示范、偏好、规则等）来学习一个奖励模型 (\hat r_\phi)，
在此基础上再用 RL 优化策略。</p>
</blockquote>
<p>相对于“严格的 IRL”，实际系统中的奖励建模往往更“务实”：</p>
<ol>
<li><strong>输入形式更灵活</strong>
<ul>
<li>不仅可以使用专家轨迹；</li>
<li>还可以使用人类对机器人行为的<strong>打分 / 排序</strong>、语言评价，甚至环境中的自动指标（例如任务是否完成）。</li>
</ul>
</li>
<li><strong>输出形式多样</strong>
<ul>
<li>状态–动作级别奖励 (\hat r_\phi(s,a))；</li>
<li>整条轨迹级别评分 (\hat r_\phi(\tau))；</li>
<li>分段的子任务奖励（例如“抓取成功”“姿态舒适”“能量消耗少”）。</li>
</ul>
</li>
<li><strong>训练方式灵活</strong>
<ul>
<li>可以做二分类（好 vs 坏行为）、回归（连续评分）、排序学习（偏好建模）；</li>
<li>LLM 的 RLHF（人类反馈强化学习）就是一个著名的奖励建模实例：从人类对多个回答的排序中学一个奖励函数，然后用 RL 调整语言模型。</li>
</ul>
</li>
</ol>
<p>在机器人具身任务中，奖励建模尤其适用于那些<strong>难以手工写出奖励函数</strong>的目标，例如：</p>
<ul>
<li>“端杯子走路时既不洒水，又看起来自然不抖”；</li>
<li>“整理桌面时，既要完成用户指令，又要保持整体美观、避免过度移动无关物体”。</li>
</ul>
<p>此时直接对奖励建模，比尝试写一大堆手工 reward term 更现实。</p>
<hr>
<h4 id="5333-优缺点"><a class="header" href="#5333-优缺点">5.3.3.3 优缺点</a></h4>
<p>把行为克隆、IRL 和更广义的奖励建模放在一起，可以看到它们各有优势与短板：(<a href="https://www.sciencedirect.com/science/article/pii/S0004370221000515?utm_source=chatgpt.com">ScienceDirect</a>)</p>
<ol>
<li><strong>行为克隆（BC）</strong>
<ul>
<li><strong>优点</strong>：
<ul>
<li>算法与实现极其简单，可直接复用监督学习工具链；</li>
<li>不依赖环境奖励信号，适合“只有示范、没有 reward”的场景；</li>
<li>训练速度快，工程上容易部署。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>严重依赖示范质量与覆盖范围，分布偏移导致长时任务表现差；</li>
<li>无法超越专家，理论性能上限受示范策略限制；</li>
<li>没有显式奖励函数，不利于解释与迁移到新环境。</li>
</ul>
</li>
</ul>
</li>
<li><strong>逆强化学习（IRL）</strong>
<ul>
<li><strong>优点</strong>：
<ul>
<li>得到的是奖励函数而非单个策略，天然更易迁移到新环境、新约束；</li>
<li>奖励具有一定可解释性，有助于理解专家偏好与安全约束；</li>
<li>在示范较有限、但动力学可知的场景中（如模拟器）具有潜在优势。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>问题本身是“不适定”的：许多不同的奖励函数都可能解释同样的行为；</li>
<li>算法通常需要“外层学奖励 + 内层跑 RL”的双层优化，计算和样本成本高；</li>
<li>在高维连续机器人场景中，稳定且可扩展的 IRL 算法仍是研究热点。</li>
</ul>
</li>
</ul>
</li>
<li><strong>奖励建模 / 偏好学习</strong>
<ul>
<li><strong>优点</strong>：
<ul>
<li>可以利用丰富的人类反馈（打分、对比、语言描述），不局限于轨迹本身；</li>
<li>适合描述复杂、模糊、难以形式化的目标（“自然”“舒适”“礼貌”）；</li>
<li>奠定了像 RLHF 这样“对齐”技术的基础，可用于具身机器人的安全约束学习。</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>奖励模型有可能被策略“利用”（reward hacking），表现看似好，实际行为不符合人类期待；</li>
<li>需要持续维护奖励模型与策略之间的一致性，否则训练后期策略会“偏离标尺”；</li>
<li>人类偏好本身存在噪声和主观性，建模难度较大。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>从本书的长远视角看：</p>
<ul>
<li>BC 适合作为<strong>快速启蒙</strong>方法，为机器人提供一个能“基本完成任务”的起点；</li>
<li>IRL 与奖励建模则更像是在搭建机器人“价值观”的框架，</li>
<li>它们与下一节的<strong>离线 RL</strong>一起，构成从纯示范走向“数据 + 偏好 + 自主优化”的通路。</li>
</ul>
<hr>
<h3 id="534-离线数据与离线-rl-的简单认识"><a class="header" href="#534-离线数据与离线-rl-的简单认识">5.3.4 离线数据与离线 RL 的简单认识</a></h3>
<h4 id="5341-离线-rl"><a class="header" href="#5341-离线-rl">5.3.4.1 离线 RL</a></h4>
<p>在前文的强化学习章节中，我们默认智能体在训练时可以不断与环境交互、采样新数据；
但在真实系统中，这种“在线试错”往往成本高昂乃至不可行：</p>
<ul>
<li>真实机器人磨损、耗材严重；</li>
<li>某些操作具有安全风险（自动驾驶、手术机器人等）；</li>
<li>有时我们手上已经有大量历史日志数据，却无法再轻松重复采集。</li>
</ul>
<p>**离线强化学习（Offline RL，亦称 Batch RL）**正是针对这一需求提出的：</p>
<blockquote>
<p>在训练期间，算法只能访问一个<strong>固定的、预先收集好的数据集</strong>，
不允许再与环境进行额外交互，从而学习一个能够在环境中执行的策略。(<a href="https://arxiv.org/pdf/2203.01387?utm_source=chatgpt.com">arXiv</a>)</p>
</blockquote>
<p>形式化地说，离线 RL 给定的是一个静态数据集
$$
\mathcal D = {(s_t, a_t, r_t, s_{t+1})},
$$
这些数据由某个（可能未知的）行为策略 (\mu(a|s)) 产生。
目标是在<strong>只使用 (\mathcal D)</strong> 的前提下，学习一个新的策略 (\pi(a|s))，
在真实环境中执行时获得尽可能高的回报。</p>
<p>与模仿学习相比：</p>
<ul>
<li>BC / IL 通常只用到 ((s_t, a_t))，不关心 (r_t)；</li>
<li>离线 RL 则以奖励为核心，会尝试“重新优化”策略，甚至超越原数据中的行为策略；</li>
<li>在具身机器人背景下，离线 RL 希望把已有的遥操作日志、历史任务执行轨迹，变成一个<strong>可以泛化到新情形的决策引擎</strong>。</li>
</ul>
<hr>
<h4 id="5342-挑战"><a class="header" href="#5342-挑战">5.3.4.2 挑战</a></h4>
<p>离线 RL 看起来像是“把 RL 变成监督学习”，实则难度颇高。
核心困难来自于：<strong>我们在训练时看不到策略在“新状态–动作”上的真实后果，却又必须对它们做出估计</strong>。</p>
<p>主要挑战包括：(<a href="https://arxiv.org/abs/2005.01643?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>分布外行动与外推误差（Extrapolation Error）</strong>
<ul>
<li>标准的 Q-learning 等方法会估计 (Q(s,a))，并通过
$$
Q(s,a) \leftarrow r + \gamma \max_{a’} Q(s’, a’)
$$
来更新；</li>
<li>在离线设置中，如果某个动作 (a) 在状态 (s) 上几乎从未在数据集中出现，
则 (Q(s,a)) 完全来自函数逼近的“外推”——既没有真实经验支撑，又被“max”操作放大；</li>
<li>结果是算法可能对数据集中<strong>从未出现过的动作</strong>估计出很高的 Q 值，
导致最终策略在真实环境中选择这些“虚假的高价值动作”，表现极差。</li>
</ul>
</li>
<li><strong>数据覆盖度与行为策略偏差</strong>
<ul>
<li>如果离线数据只覆盖了极少量任务情形（例如机械臂只在桌子中央抓取某个物体），
那么离线 RL 几乎无法学到在其他场景下的合理策略；</li>
<li>行为策略若过于保守（例如人类操作非常谨慎，只在安全区域活动），
离线 RL 想要学习“更激进、更高回报”的策略，就会严重依赖外推，风险更高。</li>
</ul>
</li>
<li><strong>离线策略评估困难（Offline Policy Evaluation）</strong>
<ul>
<li>在没有新交互的前提下，我们只能通过已有数据间接估计一个新策略的性能，</li>
<li>这需要重要性采样、模型估计或其它复杂技术，且方差通常很大；</li>
<li>对机器人任务来说，这直接影响到“什么时候敢在真实机器人上部署”这一关键决策。</li>
</ul>
</li>
<li><strong>真实机器人系统的高维与噪声</strong>
<ul>
<li>视觉输入、高维连续动作、噪声传感器等因素，使得函数逼近更困难，</li>
<li>任何小的外推错误都可能被放大成物理世界中的灾难性行为。</li>
</ul>
</li>
</ol>
<p>这些挑战意味着：</p>
<blockquote>
<p>“把在线 RL 代码里采样环境的那几行换成读数据集”，并不能自动得到一个可用的离线 RL 算法。</p>
</blockquote>
<p>需要专门的离线方法来控制外推范围、正则化策略，保证学习过程的保守性。</p>
<hr>
<h4 id="5343-方法概览"><a class="header" href="#5343-方法概览">5.3.4.3 方法概览</a></h4>
<p>针对上述挑战，近年来离线 RL 形成了几条主要思路（在第 9 章会以更系统方式展开，此处只做概览）：(<a href="https://arxiv.org/abs/2005.01643?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>保守 / 约束型值函数方法</strong>
<ul>
<li>核心思想：<strong>惩罚那些远离数据分布的状态–动作</strong>，
让 Q 函数在数据支持不足的地方更保守，避免虚假的高估；</li>
<li>代表性做法：
<ul>
<li>BCQ（Batch-Constrained Q-learning）：限制策略选择动作时，只从“看起来像是数据中出现过的动作”中采样；</li>
<li>CQL（Conservative Q-Learning）：在目标中加入正则项，使得数据集外动作的 Q 值被压低；</li>
<li>各类行为正则化方法（如在策略更新时约束 (\pi) 与行为策略 (\mu) 的 KL 距离）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>策略约束与行为克隆正则（Behavior Regularization）</strong>
<ul>
<li>将行为克隆与 RL 目标结合：
<ul>
<li>一方面最大化估计回报；</li>
<li>另一方面保持策略不要偏离数据中行为太远；</li>
</ul>
</li>
<li>直觉：
<ul>
<li>只在“稍微改善”行为的局部空间内优化，</li>
<li>不要一下子跳到数据集中从未尝试过的极端动作。</li>
</ul>
</li>
</ul>
</li>
<li><strong>模型化离线 RL（Model-based Offline RL）</strong>
<ul>
<li>先用离线数据学习一个环境动力学模型 (\hat P(s’|s,a)) 和奖励模型 (\hat r(s,a))；</li>
<li>再在这个“学得的模型”里进行规划或 RL；</li>
<li>同样需要通过不确定性估计（例如对模型输出方差建模）来避免在模型不可信区域过度使用外推。</li>
</ul>
</li>
<li><strong>BC 与离线 RL 的组合</strong>
<ul>
<li>行为克隆本质上可以看作一种极端保守的离线 RL：
<ul>
<li>完全不尝试优化超越行为策略，只在数据分布上拟合专家动作；</li>
</ul>
</li>
<li>最近一些工作指出，在许多实际任务中，<strong>简单 BC + 适当数据清洗</strong>
就能达到甚至接近更复杂离线 RL 算法的性能；</li>
<li>对机器人来说，常见的实践策略是：
<ul>
<li>先用 BC 得到一个可靠、稳定的初始策略；</li>
<li>再在此基础上使用保守的离线 RL 微调，希望在安全范围内挖掘额外性能。</li>
</ul>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-3-5 占位】
建议插图：对比“在线 RL”与“离线 RL”的示意图：</p>
<ul>
<li>在线 RL：策略 ↔ 环境，有交互箭头；</li>
<li>离线 RL：策略只连接到一个“固定数据集”方框，箭头从历史日志指向学习算法。</li>
</ul>
</blockquote>
<p>从具身智能的视角看，离线 RL 提供了一条把<strong>已有的模仿示范、运行日志、互联网视频</strong>
都转化为“可用于决策优化的经验”的路径。
在后续章节中，我们会多次看到模仿学习、奖励学习和离线 RL 如何交织在一起：</p>
<ul>
<li>用 BC 和 IRL 从示范中挖掘初始策略与价值观，</li>
<li>再用离线 RL 在庞大异质数据上做统一提升，</li>
<li>最终形成可泛化、多任务、可部署的机器人 VLA 模型。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="机器人学习中的实践要点"><a href="#机器人学习中的实践要点" class="header">机器人学习中的实践要点</a></h1>
<h3 id="541-样本效率与真实机器人数据的昂贵性"><a class="header" href="#541-样本效率与真实机器人数据的昂贵性">5.4.1 样本效率与真实机器人数据的昂贵性</a></h3>
<h4 id="5411-样本效率"><a class="header" href="#5411-样本效率">5.4.1.1 样本效率</a></h4>
<p>在纯模拟的强化学习论文里，经常可以看到“训练 5e7 step 后收敛”之类的描述。对于 Atari 或 MuJoCo 虚拟环境，这只是几小时到几天的 GPU 时间；但如果每一步都是一个真实机器人动作，这个数量级就完全不可接受了。大量调研都指出，<strong>深度强化学习在机器人上的一个核心瓶颈就是样本效率过低</strong>。(<a href="https://www.annualreviews.org/content/journals/10.1146/annurev-control-030323-022510?utm_source=chatgpt.com">年评审</a>)</p>
<p>导致样本效率低的典型原因包括：</p>
<ul>
<li><strong>高维连续状态与动作空间</strong>
机械臂、移动平台往往有十几个自由度，每一步决策都在高维连续空间中“摸索”，需要大量试错才能找到高回报区域。</li>
<li><strong>稀疏奖励与长时间尺度</strong>
把物体从桌上抓起再放入盒子，可能需要几十上百步，只有最后一步才有“成功/失败”奖励，前面的动作很难精确归因（credit assignment），导致学习过程需要更多数据来估计价值函数。</li>
<li><strong>策略分布随训练不断变化</strong>
策略更新会改变数据分布，旧数据迅速“过时”，大量交互样本很快失效，只能不断采集新数据，这进一步放大了对真实交互的需求。</li>
</ul>
<p>在真实机器人实验中，为了避免损坏设备和占用实验平台，研究者通常只能使用 <strong>几十到几百小时</strong> 的机器人交互数据，这和许多仿真 RL 工作动辄数千万步的规模相比差了几个数量级。(<a href="https://www.annualreviews.org/content/journals/10.1146/annurev-control-030323-022510?utm_source=chatgpt.com">年评审</a>)</p>
<blockquote>
<p>【图 5-4-1 占位】对比示意图：左边是游戏/仿真 RL 常用的“1e7–1e8 step”训练曲线，右边是真实机器人实验可承受的“1e4–1e6 step”范围，用条形图或对数坐标展示数量级差异。</p>
</blockquote>
<h4 id="5412-数据收集成本"><a class="header" href="#5412-数据收集成本">5.4.1.2 数据收集成本</a></h4>
<p>真实机器人数据的“贵”，不仅仅是时间长，还体现在多维度的实际成本上：(<a href="https://www.annualreviews.org/content/journals/10.1146/annurev-control-030323-022510?utm_source=chatgpt.com">年评审</a>)</p>
<ol>
<li><strong>硬件磨损与维护成本</strong>
<ul>
<li>关节减速器、丝杠、力传感器都有寿命，频繁的高频动作会加速老化。</li>
<li>一次碰撞可能带来昂贵的维修费用，尤其是高端协作机械臂或移动平台。</li>
</ul>
</li>
<li><strong>人力与场地成本</strong>
<ul>
<li>真实机器人 RL 通常需要人值守：重置场景、拾起摔落的物体、处理急停。</li>
<li>实验室场地有限，一套机器人往往同时服务多个课题，长时间“刷数据”会挤占其他实验。</li>
</ul>
</li>
<li><strong>任务物料与布景成本</strong>
<ul>
<li>抓取易碎物体（玻璃、电子元件）可能导致物品损耗。</li>
<li>复杂场景（例如厨房、仓储）搭建与维护本身就需要资源。</li>
</ul>
</li>
<li><strong>数据工程成本</strong>
<ul>
<li>多模态数据（图像、深度、关节状态、力矩、语言指令）需要同步、存储与管理。</li>
<li>为 RL/模仿学习准备“可复现、可回放”的轨迹格式，并进行清洗、标注，也是大量工程工作（第 7 章会展开）。</li>
</ul>
</li>
</ol>
<p>因此，真实机器人上的“再多收一点数据试试”并不是一个轻松的选项，<strong>算法层面的样本效率提升几乎是刚需</strong>。</p>
<h4 id="5413-提高效率"><a class="header" href="#5413-提高效率">5.4.1.3 提高效率</a></h4>
<p>为了在现实硬件约束下仍然能训练出足够好的策略，近年的研究主要从以下几个方向提升样本效率：(<a href="https://www.annualreviews.org/content/journals/10.1146/annurev-control-030323-022510?utm_source=chatgpt.com">年评审</a>)</p>
<ol>
<li><strong>更高效的强化学习算法设计</strong>
<ul>
<li><strong>离线 / 离策略（off-policy）RL</strong>：充分复用已有轨迹（包括旧策略数据、人类示教数据），减少必须在线收集的步数。</li>
<li><strong>模型式 RL / 世界模型（world model）</strong>：先学习环境动力学，再在“心智仿真”中大量滚动策略，真实机器人上只需少量校正数据。</li>
<li><strong>改进探索策略</strong>：如熵正则、乐观初始化、基于不确定性的探索，使每一步交互更“有价值”。</li>
</ul>
</li>
<li><strong>利用模仿学习和离线演示数据</strong>
<ul>
<li>先用人类示教数据进行行为克隆（BC），得到一个尚可的初始策略，再用 RL 进行小步微调，这类“先模仿后强化”的范式显著减少了探索期的“瞎摸索”。(<a href="https://www.jenskober.de/publications/Kober2010RAM.pdf?utm_source=chatgpt.com">jenskober.de</a>)</li>
<li>利用开放数据集（如 Open X-Embodiment）上汇集的多机器人演示，为策略预训练提供大规模数据基础。(<a href="https://arxiv.org/abs/2406.09246?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>视觉 / 表示的预训练与迁移</strong>
<ul>
<li>使用大规模图文数据预训练视觉–语言模型，再迁移到机器人任务，使机器人在视觉理解和语言理解上“开箱即用”。(<a href="https://en.wikipedia.org/wiki/Vision-language-action_model?utm_source=chatgpt.com">维基百科</a>)</li>
<li>预训练好的视觉 backbone（如自监督 ViT）能在少量机器人数据上快速适应，从而减少为“看清世界”而付出的额外交互样本。</li>
</ul>
</li>
<li><strong>任务与课程设计</strong>
<ul>
<li>采用从易到难的课程学习（curriculum learning），先在简单任务或低难度配置上训练，再逐步提升难度，可以减少在“几乎不可能完成”的早期阶段浪费的尝试。</li>
<li>利用规划器生成高质量轨迹，作为“教师”，把 RL 策略学习限制在较优的状态–动作子空间中。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-4-2 占位】流程图：展示“预训练表示 → 行为克隆获得初始策略 → 在仿真中 RL 微调 → 少量真实机器人 fine-tune”的多阶段样本高效 pipeline。</p>
</blockquote>
<hr>
<h3 id="542-仿真现实sim2real差距"><a class="header" href="#542-仿真现实sim2real差距">5.4.2 仿真–现实（Sim2Real）差距</a></h3>
<h4 id="5421-仿真逼真度限制"><a class="header" href="#5421-仿真逼真度限制">5.4.2.1 仿真逼真度限制</a></h4>
<p>仿真器的角色是“便宜的现实世界”，但它永远不是现实本身。大量工作系统性地总结了仿真与现实之间的差异来源：(<a href="https://arxiv.org/abs/2009.13303?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>动力学建模误差</strong>
<ul>
<li>摩擦系数、刚度、阻尼、关节间背隙等参数很难精确标定，只能近似。</li>
<li>接触与碰撞建模往往简化为“刚体 + 接触模型”，而真实世界中存在弹性、微滑、粘滞等复杂现象。</li>
<li>控制延迟、电机饱和、传感器滤波等在仿真中通常被弱化或忽略。</li>
</ul>
</li>
<li><strong>视觉渲染差异</strong>
<ul>
<li>材质、纹理、光照、阴影、反射等真实世界非常复杂，仿真很难完全还原。</li>
<li>真实相机有噪声、曝光变化、失焦、污渍遮挡，而仿真相机通常“干净又高清”。</li>
</ul>
</li>
<li><strong>环境与任务建模不完备</strong>
<ul>
<li>仿真往往只建模任务相关物体，忽略线缆、地面摩擦不均、桌面杂物等“细节”。</li>
<li>人类的干预和意外情况（误碰、临时移动物体）也难以在仿真中全面覆盖。</li>
</ul>
</li>
</ol>
<p>这些差异综合起来，就形成了所谓的 <strong>Sim2Real gap（仿真–现实差距）</strong>：模型在仿真中表现优秀，一旦上到真实机器人就“水土不服”。</p>
<blockquote>
<p>【图 5-4-3 占位】示意图：左侧为理想化仿真场景（光照均匀、物体简化），右侧为真实实验室照片（杂物、光照不均、线缆等），中间用箭头标记“Sim2Real gap”。</p>
</blockquote>
<h4 id="5422-差距带来的问题"><a class="header" href="#5422-差距带来的问题">5.4.2.2 差距带来的问题</a></h4>
<p>仿真–现实差距主要在几个层面上影响机器人学习与部署：(<a href="https://arxiv.org/abs/2009.13303?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>策略性能大幅下降</strong>
<ul>
<li>在仿真中成功率 90% 的抓取策略，上机器人可能只有 20–30% 成功率。</li>
<li>常见现象包括：抓取抓不牢、轨迹在真实世界会发生轻微碰撞、移动底盘在不同地面材质上打滑等。</li>
</ul>
</li>
<li><strong>策略学到“仿真特有技巧”</strong>
<ul>
<li>策略可能利用仿真的物理漏洞（例如物体间穿透、不合理的反弹）完成任务，一旦换成真实物理，行为就完全不可行。</li>
<li>这本质上是策略对仿真模型过拟合。</li>
</ul>
</li>
<li><strong>价值估计与不确定性偏差</strong>
<ul>
<li>RL 策略在仿真中学到的价值函数（Q 值）是针对“仿真 MDP”的，转移到真实 MDP 后，若状态–转移的统计特性变化，价值估计就会系统性偏差。</li>
<li>在安全敏感任务中，这种偏差可能导致策略 <strong>高估</strong> 某些危险动作的安全性。</li>
</ul>
</li>
<li><strong>调试成本转移到现实</strong>
<ul>
<li>若在仿真中只关注“任务是否完成”，而不关注姿态 margin、接触力等安全指标，那么把策略上到机器人后，故障诊断大部分还是得在现实世界进行，抵消了部分仿真收益。</li>
</ul>
</li>
</ol>
<h4 id="5423-弥合差距方法"><a class="header" href="#5423-弥合差距方法">5.4.2.3 弥合差距方法</a></h4>
<p>为缩小 Sim2Real gap，研究者提出了多种互补策略，大致可以分为“<strong>改仿真</strong>”“<strong>改策略</strong>”和“<strong>用真实数据矫正</strong>”三条线：(<a href="https://arxiv.org/abs/2009.13303?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>域随机化（Domain Randomization）</strong>
<ul>
<li>核心思想：不要企图做一个完全准确的仿真器，而是 <strong>在仿真参数空间中广泛随机</strong>，让策略在大量“略有不同”的环境中都能成功。</li>
<li>在视觉上随机光照、纹理、噪声；在动力学上随机质量、摩擦、关节阻尼等。</li>
<li>理论与实证结果表明，在一定条件下，基于域随机化训练的策略可以在现实环境中获得良好表现，且无需大量真实微调。(<a href="https://arxiv.org/abs/2110.03239?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>仿真参数标定与离线域优化</strong>
<ul>
<li>利用少量真实数据进行系统辨识，估计更接近现实的物理参数，使仿真器更加“贴脸”。</li>
<li>进一步的工作（如 Offline Domain Randomization）通过优化随机化分布本身，让样本集中在更现实、同时又能促进策略泛化的参数区域。(<a href="https://www.sciencedirect.com/science/article/pii/S0921889023000714?utm_source=chatgpt.com">ScienceDirect</a>)</li>
</ul>
</li>
<li><strong>视觉域自适应与风格迁移</strong>
<ul>
<li>利用风格迁移网络或对抗学习，将仿真图像映射到“更像真实相机”的风格，或反过来把真实图像映射到仿真风格，减少视觉分布差异。</li>
<li>再配合多域训练，使视觉编码器对纹理/光照变化不敏感，只关注几何与语义结构。</li>
</ul>
</li>
<li><strong>在真实环境中进行微调（Real-world fine-tuning）</strong>
<ul>
<li>通常的做法是在仿真中预训练策略，然后用 <strong>极少量</strong> 真实交互数据进行 RL 或行为克隆微调，对残余差异进行修正。</li>
<li>由于初始策略已经“八九不离十”，微调阶段可以采用更保守的、安全约束更强的 RL 算法，减少安全风险。</li>
</ul>
</li>
<li><strong>残差学习（Residual Learning）与混合控制</strong>
<ul>
<li>把传统基于模型或规划的控制当作“基线”，RL 策略只学习一个 <strong>残差控制项</strong>，在基线轨迹附近做小幅调整。</li>
<li>这样，仿真–现实差距主要通过残差来矫正，整个系统既继承模型控制的可解释性，也具备学习的灵活性。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-4-4 占位】结构示意图：展示 Sim2Real pipeline：左侧“仿真训练 + 域随机化”，中间“参数辨识 / 视觉域适配”，右侧“少量真实微调 + 残差控制”。</p>
</blockquote>
<hr>
<h3 id="543-稳定训练与安全探索的需求"><a class="header" href="#543-稳定训练与安全探索的需求">5.4.3 稳定训练与安全探索的需求</a></h3>
<h4 id="5431-训练稳定性"><a class="header" href="#5431-训练稳定性">5.4.3.1 训练稳定性</a></h4>
<p>在仿真中，训练不稳定最多是 loss 爆炸、策略崩掉，重启即可；在真实机器人上，训练不稳定可能直接演化为“机械臂乱甩”“底盘冲出安全区”。最新的机器人 RL 调研一直强调：<strong>稳定性是现实部署的前提，而不是锦上添花的优化项</strong>。(<a href="https://www.annualreviews.org/content/journals/10.1146/annurev-control-030323-022510?utm_source=chatgpt.com">年评审</a>)</p>
<p>影响训练稳定性的典型因素包括：</p>
<ol>
<li><strong>价值估计和梯度估计的高方差</strong>
<ul>
<li>稀疏奖励、多步回报导致价值估计噪声大，策略更新往往“忽左忽右”；</li>
<li>在机器人连续控制任务中，这种震荡会反映为策略不断输出风格截然不同的动作模式，给硬件带来冲击。</li>
</ul>
</li>
<li><strong>策略更新步长过大</strong>
<ul>
<li>若每次参数更新导致策略分布大幅变化，可能出现“上一轮学会抓，下一轮又忘了”的现象。</li>
<li>像 PPO 这类限制策略变化幅度的算法，就是在稳定性与学习速度之间寻求折中。(<a href="https://arxiv.org/abs/2408.03539?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>多组件系统的耦合与非平稳性</strong>
<ul>
<li>机器人系统往往包含低层 PID、阻抗控制、传感器滤波等模块，这些模块本身就是一个动态系统。</li>
<li>RL 策略在这个“黑箱控制栈”上再加一层决策，会形成高度耦合的闭环，训练中小小的参数变化都可能放大为真实运动的大幅改变。</li>
</ul>
</li>
</ol>
<p>工程上常见的稳健策略包括：</p>
<ul>
<li>使用 <strong>固定的回放缓冲区容量和采样策略</strong>，避免数据分布剧烈震荡。</li>
<li>保守的学习率和梯度裁剪，配合周期性评估与“最优 checkpoint 回滚”。</li>
<li>将 RL 策略限定为输出相对增量（Delta Pose / 小速度），把绝对稳定性交给底层控制器。</li>
</ul>
<h4 id="5432-安全探索"><a class="header" href="#5432-安全探索">5.4.3.2 安全探索</a></h4>
<p>安全强化学习（Safe RL）明确提出：在许多现实场景中，目标不是“在长期回报意义上平均安全”，而是 <strong>在整个训练和部署过程中尽量避免违反安全约束</strong>。(<a href="https://www.jmlr.org/papers/volume16/garcia15a/garcia15a.pdf?utm_source=chatgpt.com">机器学习研究杂志</a>)</p>
<p>典型安全约束包括：关节角/力矩限制、最大速度、禁止进入的空间区域、与人保持安全距离等。围绕这些约束，已有大量 Safe RL 工作总结出几类主流方法：(<a href="https://cmp.felk.cvut.cz/~peckama2/papers/safe_exploration_overview_lncs.pdf?utm_source=chatgpt.com">cmp.felk.cvut.cz</a>)</p>
<ol>
<li><strong>约束优化 / CMDP 方法</strong>
<ul>
<li>将问题建模为有约束的 MDP（Constrained MDP），目标是在满足约束期望值不超过阈值的前提下最大化回报。</li>
<li>典型算法如拉格朗日法、CPO（Constrained Policy Optimization）等，通过在优化目标中加入约束代价或拉格朗日乘子，实现“奖励–安全”的双目标平衡。</li>
</ul>
</li>
<li><strong>安全屏蔽（Shielding）与监督控制</strong>
<ul>
<li>在 RL 策略外面再包一层“安全过滤器”：
<ul>
<li>策略提出候选动作；</li>
<li>安全模块检查该动作是否可能导致违反约束；</li>
<li>若不安全，则投影到最近的安全动作或直接替换为安全备份策略。</li>
</ul>
</li>
<li>这类方法往往借鉴控制理论（如控制 barrier 函数）或形式化验证结果，为安全性提供一定的理论保证。</li>
</ul>
</li>
<li><strong>基于模型的安全探索</strong>
<ul>
<li>先学习环境的不确定模型，再在“乐观但带约束”的未来预测中选择探索动作，尽量避免进入模型不确定但高风险的区域。</li>
<li>一些新工作试图统一各类安全探索问题，提出“广义安全探索”的统一框架和元算法。(<a href="https://proceedings.neurips.cc/paper_files/paper/2023/file/5d4cd12ef6efedbf26b69b410f1f7d67-Paper-Conference.pdf?utm_source=chatgpt.com">NeurIPS 会议论文集</a>)</li>
</ul>
</li>
</ol>
<p>在机器人实践中，除了算法层面，还会配合大量“工程安全措施”，例如：</p>
<ul>
<li>设置物理限位、软限位和软件安全边界；</li>
<li>初期训练时限制运动速度与操作区域；</li>
<li>对明显危险的动作（例如大幅挥臂、靠近人脸）在动作空间中直接屏蔽。</li>
</ul>
<h4 id="5433-监控与恢复"><a class="header" href="#5433-监控与恢复">5.4.3.3 监控与恢复</a></h4>
<p>即使采用了安全 RL 算法，真实世界仍然不可避免地会出现异常行为。因此，一个可行的机器人学习系统通常需要设计 <strong>监控–诊断–恢复</strong> 的完整闭环：</p>
<ol>
<li><strong>多层次监控</strong>
<ul>
<li>低层：驱动器电流、关节力矩、速度、温度等硬件状态；</li>
<li>中层：机器人姿态、与障碍物的距离、接触力；</li>
<li>高层：任务进展（是否卡在某步）、策略输出是否异常（例如突然跳到极端动作）。</li>
</ul>
</li>
<li><strong>异常检测与应急策略</strong>
<ul>
<li>通过阈值检测、统计异常检测或学习到的异常识别模型，识别“违背常规”的状态和动作模式；</li>
<li>一旦触发异常，立即执行预定义应急策略：比如急停、关节回缩到安全姿态、底盘减速并保持静止等。</li>
</ul>
</li>
<li><strong>安全恢复与环境重置</strong>
<ul>
<li>在不损害安全的前提下，尽可能自动恢复到可继续训练的初始或中间状态，减少人力干预。</li>
<li>对于长期学习系统，可以加入“自我诊断日志”：出错时详细记录传感器、动作、指令等信息，方便后续分析与算法改进。</li>
</ul>
</li>
<li><strong>人类在环（Human-in-the-Loop）监督</strong>
<ul>
<li>对于高风险操作场景，通常要求有人类在场监督，并为系统提供“最终仲裁权”；</li>
<li>在训练早期，可以通过人类“批准/否决”某些策略行为的方式，给策略附加一层基于人类偏好的安全约束（与第 9 章的 RLHF 有天然联系）。(<a href="https://arxiv.org/html/2205.10330v5?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-4-5 占位】系统结构图：从 RL 策略输出到机器人执行之间，插入“安全过滤器”“监控模块”“紧急停止/E-stop”几个方框，箭头表示信息流和控制流。</p>
</blockquote>
<hr>
<h3 id="544-ilrl-与-vla-预训练的组合方式概览"><a class="header" href="#544-ilrl-与-vla-预训练的组合方式概览">5.4.4 IL、RL 与 VLA 预训练的组合方式概览</a></h3>
<p>这一小节从更宏观的角度总结：在现代机器人系统中，<strong>模仿学习（IL）、强化学习（RL）和大规模 VLA 预训练</strong> 往往不是互斥的，而是通过合理编排形成一个分阶段的训练流水线。</p>
<h4 id="5441-先模仿后强化"><a class="header" href="#5441-先模仿后强化">5.4.4.1 先模仿后强化</a></h4>
<p>“先模仿再强化”是机器人学习中最常见、也最符合直觉的一种范式：先让机器人“看人怎么做”，再让它在安全范围内自己试着“做得更好”。大量综述与具体工作都验证了这种组合的有效性。(<a href="https://www.jenskober.de/publications/Kober2010RAM.pdf?utm_source=chatgpt.com">jenskober.de</a>)</p>
<p>典型流程可以概括为：</p>
<ol>
<li><strong>收集专家示范</strong>
<ul>
<li>通过遥操作、示教等方式采集高质量轨迹（第 7 章已详细讨论）。</li>
<li>每条轨迹包含：视觉、机器人状态、动作序列、任务成功标记等。</li>
</ul>
</li>
<li><strong>行为克隆（BC）预训练策略</strong>
<ul>
<li>将模仿学习视为监督学习：给定状态（视觉 + 机器人状态 + 语言指令），预测专家动作。</li>
<li>得到一个 <strong>初始策略</strong>，已经能在大部分示范场景中较好完成任务，避免 RL 初期完全随机探索。</li>
</ul>
</li>
<li><strong>在仿真/现实中进行 RL 微调</strong>
<ul>
<li>以 BC 策略为初始化，用 RL 在仿真或真实环境中进一步优化，以任务成功率或长期回报为目标。</li>
<li>RL 阶段可以纠正示范中的系统性偏差（人类操作未必最优），并适应新的环境变化。</li>
<li>为了稳定性和安全性，常会加入 KL 正则或行为克隆辅助损失，防止策略偏离示范分布过远。</li>
</ul>
</li>
<li><strong>分层组合与技能复用</strong>
<ul>
<li>在一些工作中，模仿学习先学出若干“技能原语”（例如抓取、推、开门），RL 在更高层面利用这些技能进行任务规划和组合，从而降低 RL 的搜索空间。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 5-4-6 占位】两阶段训练示意图：左侧块为“IL / BC 预训练策略”，右侧块为“RL 微调”，中间箭头表示以 BC 策略作为 RL 初始点。</p>
</blockquote>
<h4 id="5442-自监督预训练"><a class="header" href="#5442-自监督预训练">5.4.4.2 自监督预训练</a></h4>
<p>在 VLA 模型兴起之前，机器人学习中的预训练主要发生在视觉 backbone 上；而现在，<strong>更大尺度的自监督和多模态预训练已经延伸到“视觉–语言–动作统一表征”层面</strong>。(<a href="https://arxiv.org/abs/2406.09246?utm_source=chatgpt.com">arXiv</a>)</p>
<p>几种典型的自监督 / 预训练方式包括：</p>
<ol>
<li><strong>视觉与语言的跨模态预训练</strong>
<ul>
<li>先在互联网图文数据上进行 CLIP 风格的对比学习，或者在图文上训练视觉–语言模型，获得强大的语义理解能力（第 4 章已展开）。</li>
<li>代表性工作如 DINOv2、CLIP 等，被直接用作 VLA 的视觉与语言 backbone。(<a href="https://en.wikipedia.org/wiki/Vision-language-action_model?utm_source=chatgpt.com">维基百科</a>)</li>
</ul>
</li>
<li><strong>基于机器人数据的“掩码建模 / 未来预测”</strong>
<ul>
<li>利用大量无标签机器人视频和传感器数据，通过掩码帧重建、未来帧/未来状态预测等自监督任务，学习机器人特定的世界模型和时序表征。</li>
<li>这类预训练使得模型对接触、物体运动等物理规律有更好的内在理解。</li>
</ul>
</li>
<li><strong>大规模 VLA 预训练</strong>
<ul>
<li>例如 OpenVLA 在 Open X-Embodiment 汇集的约百万条跨机器人演示上进行预训练，使用预训练视觉和语言 backbone，将动作离散化为 token，在“视觉–语言–动作”统一 Transformer 中学习通用策略表示。(<a href="https://arxiv.org/abs/2406.09246?utm_source=chatgpt.com">arXiv</a>)</li>
<li>预训练后，只需在新机器人或新任务上进行少量参数高效微调（如 LoRA），就能快速适应。</li>
</ul>
</li>
<li><strong>结合 RL 的自监督表示学习</strong>
<ul>
<li>在仿真中一边用 RL 学策略，一边用自监督目标（如对比学习、动态预测）训练中间表示，使得策略在样本有限时仍能获益于更好的特征。</li>
</ul>
</li>
</ol>
<p>在这样的大背景下，<strong>IL 和 RL 不再孤立地直接操作原始图像和原始动作，而是建立在一个规模更大的预训练 VLA 表征之上</strong>，从而显著提升样本效率与泛化能力。</p>
<h4 id="5443-多范式结合"><a class="header" href="#5443-多范式结合">5.4.4.3 多范式结合</a></h4>
<p>在前两小节的基础上，可以把现代机器人学习系统理解为一个“多层、多范式协同”的结构：</p>
<ol>
<li><strong>表征层：VLA / 世界模型预训练</strong>
<ul>
<li>目标：学习一个对视觉、语言、机器人状态和动作都具有良好表达能力的“基础模型”。</li>
<li>数据：互联网图文 + 多机器人示教轨迹 + 未标注视频。</li>
<li>方法：自监督、对比学习、多任务预训练。</li>
</ul>
</li>
<li><strong>行为层：模仿学习整合人类经验</strong>
<ul>
<li>目标：在给定基础表征的前提下，通过行为克隆让机器人直接“复制”人类或其他机器人在特定任务上的表现。</li>
<li>数据：高质量示教轨迹。</li>
<li>作用：迅速获得可用策略，覆盖常见工作模式，减少 RL 早期的危险探索。</li>
</ul>
</li>
<li><strong>优化层：强化学习与人类反馈微调</strong>
<ul>
<li>目标：在安全约束下进一步提升策略性能、提高鲁棒性与泛化能力。</li>
<li>方法：在仿真或现实环境中使用 PPO 等算法进行 RL 微调；结合人类偏好数据进行 RLHF，使策略在“好用”与“安全”之间达成平衡。(<a href="https://www.annualreviews.org/content/journals/10.1146/annurev-control-030323-022510?utm_source=chatgpt.com">年评审</a>)</li>
</ul>
</li>
<li><strong>系统层：与控制、规划模块协同</strong>
<ul>
<li>VLA 模型可以作为高层决策“脑”，与传统的运动规划、低层控制协同工作。</li>
<li>多范式学习的结果最终要通过这一层与真实硬件对接，以满足实时性与可靠性要求（第 10 章会展开）。</li>
</ul>
</li>
</ol>
<p>整理成一句话：</p>
<blockquote>
<p><strong>预训练负责“看懂世界、听懂人话”，模仿学习负责“先做到及格”，强化学习负责“在安全边界内追求更优”。</strong></p>
</blockquote>
<blockquote>
<p>【图 5-4-7 占位】三层结构示意图：底层为“表征预训练（VLA / 世界模型）”，中层为“模仿学习（BC/IL）”，顶层为“RL &amp; 人类反馈微调”，箭头注明数据与梯度流向，并在顶端连到“真实机器人系统”。</p>
</blockquote>
<p>这一节到这里为止，基本勾勒出了真实机器人学习面对的三大现实约束：数据成本、Sim2Real 差距和安全稳定性，同时给出了一套兼顾 IL、RL 与 VLA 预训练的综合解法，为后续关于具体 VLA 架构和训练细节的章节打下工程与方法论层面的基调。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="机器人运动学"><a href="#机器人运动学" class="header">机器人运动学</a></h1>
<h3 id="61-机器人运动学概述局部节选"><a class="header" href="#61-机器人运动学概述局部节选">6.1 机器人运动学概述（局部节选）</a></h3>
<p>本节从<strong>坐标系与齐次变换</strong>出发，逐步推导到<strong>DH 建模、正运动学与逆运动学</strong>，最后引出<strong>冗余度、多解与奇异位形</strong>这些在具身智能机器人中绕不过去的概念。你可以把它理解为：从“如何描述机器人在空间里的姿势”，一路走到“如何让它伸手拿起桌上的杯子”。</p>
<hr>
<h3 id="611-坐标系与齐次变换矩阵"><a class="header" href="#611-坐标系与齐次变换矩阵">6.1.1 坐标系与齐次变换矩阵</a></h3>
<h4 id="6111-坐标系给机器人一个参考视角"><a class="header" href="#6111-坐标系给机器人一个参考视角">6.1.1.1 坐标系：给机器人一个“参考视角”</a></h4>
<p>在 1.1 中，我们已经把向量和线性变换当成了熟悉的老朋友。机器人学里，我们把这些朋友包装成一个又一个<strong>坐标系（reference frame）</strong>。</p>
<p>典型的坐标系包括：</p>
<ul>
<li><strong>世界 / 实验室坐标系</strong>：记作 $ {W} $，通常固定在地面或工作台上，是“上帝视角”。</li>
<li><strong>基座坐标系</strong>：记作 $ {0} $，固定在机械臂底座上，是后续连杆坐标系的起点。</li>
<li><strong>连杆坐标系</strong>：记作 $ {1},{2},\dots,{n} $，分别固定在各个连杆或关节处。</li>
<li><strong>末端执行器（工具）坐标系</strong>：记作 $ {E} $ 或 $ {T} $，固定在手爪或工具法兰盘上。</li>
<li><strong>相机 / 物体坐标系</strong>：在视觉部分我们已经见过，便于把感知结果映射到机器人可用的形式。</li>
</ul>
<p><strong>同一个三维点在不同坐标系下的坐标一般不同</strong>。例如，杯子在基座坐标系下的坐标是 $ ^{0}\mathbf{p} $，在世界坐标系下是 $ ^{W}\mathbf{p} $，二者之间通过一个坐标变换联系起来。</p>
<blockquote>
<p>【图 6.1-1 占位】
画一台 6 轴机械臂，标出世界坐标系 $ {W} $、基座 $ {0} $、中间某个关节坐标系 $ {2} $ 和末端坐标系 $ {E} $，每个坐标系用右手坐标轴 $ (x,y,z) $ 表示，示意它们在空间中的相对姿态。</p>
</blockquote>
<p>我们默认采用<strong>右手坐标系</strong>：右手拇指、食指、中指分别代表 $ x,y,z $ 轴方向，满足 $ x\times y = z $。这与后续旋转矩阵、叉乘方向统一。</p>
<hr>
<h4 id="6112-齐次变换矩阵把旋转和平移装进一个-44-盒子"><a class="header" href="#6112-齐次变换矩阵把旋转和平移装进一个-44-盒子">6.1.1.2 齐次变换矩阵：把旋转和平移装进一个 4×4 盒子</a></h4>
<p>在 3D 空间里，<strong>一个刚体相对于另一个坐标系的“姿态”包含两部分</strong>：</p>
<ul>
<li>旋转：$ 3\times 3 $ 正交矩阵 $ R $，满足 $ R^\top R = I,\ \det R = 1 $；</li>
<li>平移：$ 3\times 1 $ 向量 $ \mathbf{p} $。</li>
</ul>
<p>为了统一处理旋转和平移，机器人学中引入了<strong>齐次变换矩阵（homogeneous transformation matrix）</strong>。它是一个 $ 4\times 4 $ 矩阵：
$$
{}^{A}T_B=
\begin{bmatrix}
R_{AB} &amp; \mathbf{p}<em>{AB} \
\mathbf{0}^\top &amp; 1
\end{bmatrix}
$$
其中 $R</em>{AB}$ 表示坐标系 ${B}$ 相对于 ${A}$  的旋转， $\mathbf{p}_{AB}$ 表示 ${B}$ 的原点在 ${A}$ 中的坐标。(<a href="https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters?utm_source=chatgpt.com">维基百科</a>)</p>
<p>我们把三维点写成齐次坐标 $ \tilde{\mathbf{x}} = [x\ y\ z\ 1]^\top $，则有
$$
\tilde{\mathbf{x}}_A = {}^{A}T_B\ \tilde{\mathbf{x}}_B
$$
这一步本质上就是把“在 $ B $ 中的坐标”变换为“在 $ A $ 中的坐标”。</p>
<p><strong>变换的串联</strong>非常自然：如果我们已知
$$
{}^{0}T_1,\quad {}^{1}T_2,\quad \dots,\quad {}^{n-1}T_n
$$
那么基座到第 $ n $ 节坐标系的总变换为
$$
{}^{0}T_n = {}^{0}T_1\ {}^{1}T_2 \cdots {}^{n-1}T_n
$$
这正是后面正运动学的核心公式。</p>
<p>齐次变换矩阵的逆也很简单：
$$
({}^{A}T_B)^{-1} =
\begin{bmatrix}
R_{AB}^\top &amp; -R_{AB}^\top \mathbf{p}_{AB}
\mathbf{0}^\top &amp; 1
\end{bmatrix}
$$
这里利用了旋转矩阵正交的性质 $ R^{-1}=R^\top $。(<a href="https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters?utm_source=chatgpt.com">维基百科</a>)</p>
<blockquote>
<p>【图 6.1-2 占位】
左侧画出两个坐标系 $ {A} $、$ {B} $ 及平移向量 $ \mathbf{p}_{AB} $，右侧写出对应的 $ 4\times 4 $ 齐次变换矩阵结构，用不同颜色标注旋转子矩阵和平移列向量。</p>
</blockquote>
<hr>
<h4 id="6113-位姿表示位置--姿态"><a class="header" href="#6113-位姿表示位置--姿态">6.1.1.3 位姿表示：位置 + 姿态</a></h4>
<p><strong>位姿（pose）</strong> = <strong>位置（position） + 姿态（orientation）</strong>。</p>
<ul>
<li>位置：通常用 $ 3 $ 维向量 $ \mathbf{p} = [x,y,z]^\top $ 表示；</li>
<li>姿态：有多种常见表示方法：
<ul>
<li><strong>旋转矩阵</strong> $ R $：直观、便于与齐次矩阵结合，但有 9 个参数且有正交约束；</li>
<li><strong>欧拉角 / RPY 角</strong>：三个角度表示三次旋转，直观但存在万向节死锁（gimbal lock）；</li>
<li><strong>轴–角（axis–angle）</strong>：用单位旋转轴 $ \mathbf{u} $ 和旋转角 $ \theta $ 表示；</li>
<li><strong>四元数（quaternion）</strong>：4 个实数 $ (w,x,y,z) $ 表示单位四元数，避免万向节死锁，常用于插值与控制。(<a href="https://www.academia.edu/93645828/Siciliano_2009_Robotics_Modelling_Planning_and_Control?utm_source=chatgpt.com">Academia</a>)</li>
</ul>
</li>
</ul>
<p>在工程实践中，常见的位姿表示有两种：</p>
<ol>
<li><strong>齐次变换矩阵</strong> $ T=[R,\mathbf{p};\ 0^\top,1] $：在机器人运动学推导中最常用，可直接参与矩阵连乘；</li>
<li><strong>“平移向量 + 四元数”</strong> $ (\mathbf{p},q) $：在 ROS、仿真器和优化求解器中非常流行，占用参数少、插值方便。</li>
</ol>
<p>本书中，在<strong>推导运动学时</strong>主要使用齐次矩阵；在<strong>与优化、学习算法接口时</strong>，会经常切换到“平移 + 四元数”的形式，你需要熟悉二者之间的概念联系。</p>
<blockquote>
<p>【图 6.1-3 占位】
画三个小框：左边是 3×3 旋转矩阵 $ R $，中间是欧拉角 $ (\phi,\theta,\psi) $，右边是四元数 $ (w,x,y,z) $，用箭头表示它们之间可以互相转换。</p>
</blockquote>
<hr>
<h3 id="612-dh-参数与刚体链建模"><a class="header" href="#612-dh-参数与刚体链建模">6.1.2 DH 参数与刚体链建模</a></h3>
<h4 id="6121-dh-参数用四个数刻画一节机械臂"><a class="header" href="#6121-dh-参数用四个数刻画一节机械臂">6.1.2.1 DH 参数：用四个数刻画一节机械臂</a></h4>
<p>一个串联机械臂可以看作若干刚体（连杆）通过关节串起来的<strong>刚体链</strong>。为了系统地描述每两节之间的几何关系，机器人学界广泛使用 <strong>Denavit–Hartenberg（DH）参数</strong>。(<a href="https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters?utm_source=chatgpt.com">维基百科</a>)</p>
<p>经典 DH 约定中，每一关节（或连杆）用四个参数描述：</p>
<ul>
<li>$ \theta_i $：<strong>关节角</strong>，绕 $ z_{i-1} $ 轴的旋转量（对转动关节是变量）；</li>
<li>$ d_i $：<strong>关节距</strong>，沿 $ z_{i-1} $ 轴的平移；</li>
<li>$ a_i $：<strong>连杆长</strong>，沿 $ x_i $ 轴的平移；</li>
<li>$ \alpha_i $：<strong>连杆扭转角</strong>，绕 $ x_i $ 轴的旋转量。</li>
</ul>
<p>这四个参数对应一个从坐标系 $ {i-1} $ 到 $ {i} $ 的齐次变换：
$$
{}^{i-1}T_i =
\operatorname{Rot}_z(\theta_i)\operatorname{Trans}_z(d_i)
\operatorname{Trans}_x(a_i)\operatorname{Rot}_x(\alpha_i)
$$
展开后得到标准形式（这里只给出结构）：
$$
{}^{i-1}T_i =
\begin{bmatrix}
\cos\theta_i &amp; -\sin\theta_i\cos\alpha_i &amp; \sin\theta_i\sin\alpha_i &amp; a_i\cos\theta_i
\sin\theta_i &amp; \cos\theta_i\cos\alpha_i &amp; -\cos\theta_i\sin\alpha_i &amp; a_i\sin\theta_i
0 &amp; \sin\alpha_i &amp; \cos\alpha_i &amp; d_i
0 &amp; 0 &amp; 0 &amp; 1
\end{bmatrix}
$$</p>
<blockquote>
<p>【图 6.1-4 占位】
画出两节连杆之间的 DH 几何：标出连续的关节轴 $ z_{i-1} $、$ z_i $，它们之间的公共法线（连杆长 $ a_i $），以及扭转角 $ \alpha_i $，同时在图旁标注 $ \theta_i,d_i,a_i,\alpha_i $ 的几何含义。</p>
</blockquote>
<p>注意：在部分教材和工业手册中，会使用<strong>修改 DH（modified DH）</strong> 约定，参数定义顺序略有差异。本书采用经典 DH 记号为主，在使用修改 DH 的地方会特别说明。(<a href="https://en.wikipedia.org/wiki/Denavit%E2%80%93Hartenberg_parameters?utm_source=chatgpt.com">维基百科</a>)</p>
<hr>
<h4 id="6122-刚体链用一串齐次矩阵拼出整条机械臂"><a class="header" href="#6122-刚体链用一串齐次矩阵拼出整条机械臂">6.1.2.2 刚体链：用一串齐次矩阵拼出整条机械臂</a></h4>
<p>考虑一个有 $ n $ 个关节的串联机械臂，它有 $ n+1 $ 节连杆（从基座连杆 0 到连杆 $ n $）。我们为每节连杆依次建立坐标系 $ {0},{1},\dots,{n} $，并为每个关节写出对应的 DH 变换矩阵 $ ^{i-1}T_i $。(<a href="https://users.cs.duke.edu/~brd/Teaching/Bio/asmb/current/Papers/chap3-forward-kinematics.pdf?utm_source=chatgpt.com">users.cs.duke.edu</a>)</p>
<p>则基座到末端的总变换为：
$$
{}^{0}T_n(q) = {}^{0}T_1(q_1)\ {}^{1}T_2(q_2)\ \cdots\ {}^{n-1}T_n(q_n)
$$
其中 $ q_i $ 是第 $ i $ 个关节的变量（转动关节为角度、移动关节为位移）。这就是把整条刚体链的<strong>几何关系</strong>编码为一串矩阵连乘。</p>
<p>从结构上看：</p>
<ul>
<li>每个 $ ^{i-1}T_i $ 编码了“连杆 $ i $ 相对连杆 $ i-1 $ 如何旋转和平移”；</li>
<li>整个连乘编码了“末端相对于基座的姿态”。</li>
</ul>
<p>这条链就是我们在学习强化学习 / 控制策略时所依赖的<strong>几何骨架</strong>——策略输出的是关节角 $ q $，而真正落在物理世界的是通过这条链计算出来的末端位姿。</p>
<blockquote>
<p>【图 6.1-5 占位】
画一个 3 关节机械臂，标出 $ {0},{1},{2},{3} $ 四个坐标系，并在旁边画出 $ ^{0}T_1 $、$ ^{1}T_2 $、$ ^{2}T_3 $ 三个矩阵连乘得到 $ ^{0}T_3 $ 的示意箭头。</p>
</blockquote>
<hr>
<h4 id="6123-建模步骤从几何结构到-dh-表格"><a class="header" href="#6123-建模步骤从几何结构到-dh-表格">6.1.2.3 建模步骤：从几何结构到 DH 表格</a></h4>
<p>实际给一台机械臂，你可以按以下流程进行 DH 建模（以经典 DH 为例）：</p>
<ol>
<li><strong>确定关节类型与顺序</strong>
标明每个关节是转动（R）还是移动（P），按从基座到末端的顺序编号 $ 1,\dots,n $。</li>
<li>**指定基座坐标系 <strong>$ {0} $</strong> 和末端坐标系 **$ {n} $
<ul>
<li>$ {0} $ 一般与工程图纸中的基坐标一致；</li>
<li>$ {n} $ 固定在工具法兰盘或末端执行器上，便于后续抓取 / 操作任务定义。</li>
</ul>
</li>
<li><strong>为每个关节轴定义 <strong>$ z_i $</strong> 方向</strong>
<ul>
<li>对转动关节：$ z_i $ 与旋转轴方向一致；</li>
<li>对移动关节：$ z_i $ 与滑动方向一致。</li>
</ul>
</li>
<li><strong>确定相邻关节轴的公共法线，定义 <strong>$ x_i $</strong> 轴</strong>
<ul>
<li>若 $ z_{i-1} $ 与 $ z_i $ 不平行：$ x_i $ 沿两轴的<strong>最短连线方向</strong>；</li>
<li>若平行：$ x_i $ 可任意选择一个垂直于轴的方向；</li>
<li>$ y_i $ 按右手定则补齐。</li>
</ul>
</li>
<li>**从几何关系读出 DH 参数 **$ (\theta_i, d_i, a_i, \alpha_i) $
<ul>
<li>$ d_i $：沿 $ z_{i-1} $ 从原点 $ {i-1} $ 到公共法线的距离；</li>
<li>$ a_i $：公共法线的长度，即沿 $ x_i $ 的距离；</li>
<li>$ \alpha_i $：$ z_{i-1} $ 绕 $ x_i $ 转到 $ z_i $ 的角度；</li>
<li>$ \theta_i $：$ x_{i-1} $ 绕 $ z_{i-1} $ 转到 $ x_i $ 的角度。对转动关节，这是关节变量。</li>
</ul>
</li>
<li><strong>写出每一节的 <strong>$ ^{i-1}T_i $</strong>，整理成 DH 表格</strong>
通常整理为一张 $ n\times 4 $ 的表格，列为 $ a_i,\alpha_i,d_i,\theta_i $，方便实现和检查。</li>
<li><strong>验证模型</strong>
<ul>
<li>检查在“所有关节为零位”的情况下，$ ^{0}T_n $ 是否与机械臂实际“零姿态”一致；</li>
<li>如有偏差，通常说明某个轴方向或角度符号选反了。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 6.1-6 占位】
左边画一个 2R 平面机械臂（在 $ x\text{-}y $ 平面），标出两节连杆长度 $ l_1,l_2 $ 和关节角 $ \theta_1,\theta_2 $；右边给出对应的 DH 表格（两行四列），展示一次完整的建模示例。</p>
</blockquote>
<hr>
<h3 id="613-正运动学fk关节空间到笛卡尔空间"><a class="header" href="#613-正运动学fk关节空间到笛卡尔空间">6.1.3 正运动学（FK）：关节空间到笛卡尔空间</a></h3>
<h4 id="6131-定义给定关节角算末端在哪里"><a class="header" href="#6131-定义给定关节角算末端在哪里">6.1.3.1 定义：给定关节角，算末端在哪里</a></h4>
<p>**正运动学（Forward Kinematics, FK）**回答的问题是：</p>
<blockquote>
<p>已知关节变量 $ q = [q_1,\dots,q_n]^\top $，求末端执行器相对于基座的位姿 $ T(q) $。</p>
</blockquote>
<p>把数学上抽象一下，就是一个从关节空间到任务空间的映射：
$$
F:\ \mathbb{R}^n \to SE(3),\quad T(q)=F(q)
$$
其中 $ SE(3) $ 是三维刚体运动群，包含所有合法的旋转 + 平移组合。</p>
<p>对给定的机械臂，FK 映射是<strong>确定且单值</strong>的：同一组关节角只对应一个末端位姿。这是控制和仿真中最基本的几何模块。(<a href="https://www.academia.edu/93645828/Siciliano_2009_Robotics_Modelling_Planning_and_Control?utm_source=chatgpt.com">Academia</a>)</p>
<hr>
<h4 id="6132-矩阵计算把-dh-连乘到底"><a class="header" href="#6132-矩阵计算把-dh-连乘到底">6.1.3.2 矩阵计算：把 DH 连乘到底</a></h4>
<p>利用上一小节得到的 DH 参数，我们可以将 FK 写为：</p>
<p>$$
{}^{0}T_n(q) = {}^{0}T_1(q_1)\ {}^{1}T_2(q_2)\ \cdots\ {}^{n-1}T_n(q_n)
$$</p>
<p>其中每个 $ ^{i-1}T_i $ 都是 $ q_i $ 的显函数（对转动关节是关于 $ \cos q_i,\sin q_i $ 的三角函数）。通过矩阵连乘，就可以求出末端相对于基座的旋转矩阵 $ R(q) $ 和位移向量 $ \mathbf{p}(q) $：</p>
<p>$$
{}^{0}T_n(q) =
\begin{bmatrix}
R(q) &amp; \mathbf{p}(q)
\mathbf{0}^\top &amp; 1
\end{bmatrix}
$$</p>
<p>作为一个简单的二维例子，考虑平面 2R 机械臂，连杆长度为 $ l_1,l_2 $，关节角为 $ \theta_1,\theta_2 $。其末端位置 $ (x,y) $ 满足：
$$
x = l_1\cos\theta_1 + l_2\cos(\theta_1 + \theta_2),\quad
y = l_1\sin\theta_1 + l_2\sin(\theta_1 + \theta_2)
$$
这就是 FK 的显式形式，直接由几何相加得到。</p>
<p>在实际程序中，你通常会：</p>
<ol>
<li>根据当前关节角 $ q $，构造所有 $ ^{i-1}T_i(q_i) $；</li>
<li>从 $ i=1 $ 循环到 $ n $ 做矩阵连乘；</li>
<li>从最终的 $ T $ 中读出末端位置 $ \mathbf{p} $ 和姿态 $ R $ 或四元数。</li>
</ol>
<blockquote>
<p>【图 6.1-7 占位】
展示平面 2R 机械臂的几何图和对应的 $ (x,y) $ 公式，标注每一项来自哪一节连杆长度和角度之和。</p>
</blockquote>
<hr>
<h4 id="6133-正运动学的特点与作用"><a class="header" href="#6133-正运动学的特点与作用">6.1.3.3 正运动学的特点与作用</a></h4>
<p>正运动学有几个重要特点：</p>
<ul>
<li><strong>对任意合法的 <strong>$ q $</strong> 总是可解且唯一</strong>：不需要迭代或优化；</li>
<li>**计算复杂度线性于关节数 **$ n $：只是一串矩阵乘法，在实时控制中非常可行；</li>
<li><strong>是许多上层任务的“查询接口”</strong>：
<ul>
<li>动态方程 $ M(q)\ddot{q} + \dots $ 中需要用到几何量；</li>
<li>碰撞检测需要知道连杆和末端的空间位置；</li>
<li>视觉–手眼标定中要把相机检测到的物体位置映射到机器人基座坐标系。</li>
</ul>
</li>
</ul>
<p>在具身智能场景下，你可以把 FK 看成“世界坐标模拟器”：RL / VLA 策略输出的是关节动作，而环境和相机看到的是末端和连杆在笛卡尔空间的位置，二者之间全靠 FK 连接。</p>
<hr>
<h3 id="614-逆运动学ik笛卡尔空间到关节空间"><a class="header" href="#614-逆运动学ik笛卡尔空间到关节空间">6.1.4 逆运动学（IK）：笛卡尔空间到关节空间</a></h3>
<h4 id="6141-定义指定一个末端位姿问关节该如何摆"><a class="header" href="#6141-定义指定一个末端位姿问关节该如何摆">6.1.4.1 定义：指定一个末端位姿，问关节该如何摆</a></h4>
<p>**逆运动学（Inverse Kinematics, IK）**解决的是与 FK 相反的问题：</p>
<blockquote>
<p>给定期望的末端位姿 $ T_d $（或期望位置 $ \mathbf{p}_d $ 和姿态 $ R_d $），求关节变量 $ q $，使得
$$
F(q) = T_d
$$</p>
</blockquote>
<p>与 FK 不同，IK 一般<strong>既不保证唯一解，也不保证总有解</strong>：</p>
<ul>
<li>可能无解：目标太远或超出机械臂可达工作空间；</li>
<li>可能多解：存在多个关节配置实现同一末端位姿（如肘上 / 肘下）；</li>
<li>冗余机械臂（自由度大于任务维度）会有无穷多组解。</li>
</ul>
<p>IK 是机器人规划、抓取、避障等任务的核心子问题，本书后续多处会在 IK 之上叠加优化、学习和语言条件。</p>
<hr>
<h4 id="6142-解析解能写成公式的-ik"><a class="header" href="#6142-解析解能写成公式的-ik">6.1.4.2 解析解：能写成公式的 IK</a></h4>
<p>在一些结构比较规则的机械臂上，可以推导出<strong>解析解（closed-form solution）</strong>：用有限次代数、三角运算直接给出 $ q $ 的表达式，不需要迭代求解。(<a href="https://www.academia.edu/93645828/Siciliano_2009_Robotics_Modelling_Planning_and_Control?utm_source=chatgpt.com">Academia</a>)</p>
<p>继续以平面 2R 机械臂为例，给定目标点 $ (x_d, y_d) $，连杆长度 $ l_1, l_2 $，则由余弦定理可得：
$$
\cos\theta_2 = \frac{x_d^2 + y_d^2 - l_1^2 - l_2^2}{2 l_1 l_2}
$$
从而
$$
\theta_2 = \arctan2\big(\pm\sqrt{1-\cos^2\theta_2},\ \cos\theta_2\big)
$$
这里 $ \pm $ 对应<strong>肘上 / 肘下</strong>两种构型（多解现象的一个具体体现）。然后可以再由几何关系求出 $ \theta_1 $。</p>
<p>对于常见的 6 自由度工业机械臂，如果后三个关节形成所谓“球腕（spherical wrist）”，也可以分解为<strong>位姿分离</strong>问题，采用解析方法求解。这类解析 IK 在工业控制器中非常普遍，因为它计算快、确定性强。</p>
<hr>
<h4 id="6143-数值解用迭代逼近-ik"><a class="header" href="#6143-数值解用迭代逼近-ik">6.1.4.3 数值解：用迭代逼近 IK</a></h4>
<p>大多数复杂结构或冗余机械臂（例如 7 自由度人形手臂）不再容易写出解析 IK，需要求助于<strong>数值方法</strong>。典型做法是把 IK 看成求解非线性方程
$$
F(q) = T_d
$$
或在位置空间写成
$$
\mathbf{f}(q) = \mathbf{x}_d
$$
然后使用类似牛顿–拉弗森（Newton–Raphson）的迭代方法。其关键工具是<strong>雅可比矩阵（Jacobian）</strong> $ J(q) $，它描述关节速度与末端线速度 / 角速度的线性关系：(<a href="https://wanxinjin.github.io/asu-robotics/lec13/singularity.html?utm_source=chatgpt.com">wanxinjin.github.io</a>)</p>
<p>$$
\dot{\mathbf{x}} = J(q)\ \dot{q}
$$</p>
<p>在数值 IK 中，我们可以通过线性化把“位置误差”转化为“关节增量”：
$$
\Delta q \approx J(q)^\dagger\ \Delta \mathbf{x}
$$
其中 $ J^\dagger $ 是雅可比的广义逆或阻尼广义逆。迭代过程如下：</p>
<ol>
<li>从一个初始猜测 $ q^{(0)} $ 开始；</li>
<li>每步计算当前末端位姿 $ T(q^{(k)}) $，得到任务空间误差 $ \Delta \mathbf{x} $；</li>
<li>计算（或近似）雅可比 $ J(q^{(k)}) $，求出 $ \Delta q = J^\dagger \Delta \mathbf{x} $；</li>
<li>更新 $ q^{(k+1)} = q^{(k)} + \Delta q $；</li>
<li>直到误差足够小或达到迭代上限。</li>
</ol>
<p>数值 IK 的特点：</p>
<ul>
<li>需要<strong>初始值</strong>，不同初始值可能收敛到不同的解（多解）；</li>
<li>在<strong>奇异位形附近</strong>，$ J $ 接近退化，数值 IK 会变得不稳定或需要非常大的关节变化；</li>
<li>易于加入额外约束（如关节限位、避障项），可以通过优化框架统一处理。</li>
</ul>
<p>后文在介绍雅可比和冗余度时，我们会进一步展开基于雅可比伪逆和 null space 的 IK 规划思想。(<a href="https://modernrobotics.northwestern.edu/nu-gm-book-resource/5-3-singularities/?utm_source=chatgpt.com">现代机器人学</a>)</p>
<blockquote>
<p>【图 6.1-8 占位】
画出数值 IK 的迭代示意：任务空间中目标点 $ \mathbf{x}_d $ 和当前末端位置 $ \mathbf{x} $，用箭头表示通过雅可比线性化后的一步更新，展示逐步逼近目标的过程。</p>
</blockquote>
<hr>
<h3 id="615-冗余度与多解奇异位形的概念"><a class="header" href="#615-冗余度与多解奇异位形的概念">6.1.5 冗余度与多解、奇异位形的概念</a></h3>
<h4 id="6151-冗余机械臂多出来的自由度用来耍花活"><a class="header" href="#6151-冗余机械臂多出来的自由度用来耍花活">6.1.5.1 冗余机械臂：多出来的自由度用来“耍花活”</a></h4>
<p>我们用 $ n $ 表示机械臂的<strong>关节自由度（DOF）</strong>：</p>
<ul>
<li>如果任务只要求末端位置（3 维），理论上需要至少 3 个自由度；</li>
<li>如果要求完整的 6 维位姿（3 位置 + 3 姿态），理论上至少需要 6 个自由度。</li>
</ul>
<p>当
$$
n &gt; m
$$
其中 $ m $ 是任务空间维度（如 $ m=3 $ 或 $ m=6 $）时，我们称机械臂在该任务上是<strong>冗余的（redundant）</strong>。典型例子是 7 自由度机械臂执行 6 维位姿控制，冗余 1 个自由度。(<a href="https://www.academia.edu/93645828/Siciliano_2009_Robotics_Modelling_Planning_and_Control?utm_source=chatgpt.com">Academia</a>)</p>
<p>冗余的好处是：</p>
<ul>
<li>可以在不改变末端任务的前提下，调整身体姿态来<strong>避障、躲关节限位</strong>；</li>
<li>可以优化<strong>二级目标</strong>，比如“离奇异位形远一点”、“让重心更稳定”等；</li>
<li>为人形 / 服务机器人提供更“自然”的动作风格（看起来更像人）。</li>
</ul>
<p>数学上，冗余带来的结果是：任务空间方程 $ F(q)=T_d $ 的解集从“离散点”变成一条或多条连续的曲线 / 曲面。</p>
<hr>
<h4 id="6152-多解现象即使不冗余也可能同一个末端多种姿势"><a class="header" href="#6152-多解现象即使不冗余也可能同一个末端多种姿势">6.1.5.2 多解现象：即使不冗余，也可能“同一个末端，多种姿势”</a></h4>
<p>即便在<strong>非冗余</strong>（$ n=m $）情况下，IK 也不一定只有一个解。原因在于三角函数的周期性和空间几何的镜像对称。例如：</p>
<ul>
<li>平面 2R 机械臂到达同一个目标点 $ (x_d,y_d) $，通常有**肘上（elbow-up）<strong>和</strong>肘下（elbow-down）**两种解，对应 $ \theta_2 $ 两个不同分支；</li>
<li>三维 6R 机械臂经常有“<strong>腕翻转（wrist flip）</strong>”多解，末端姿态相同，但前臂 / 腕部呈现不同的卷曲方式。</li>
</ul>
<p>更一般地，对于复杂的非线性方程 $ F(q)=T_d $，可能存在多个相互独立的实根，每一个对应机器人在工作空间内的一个“构型分支”。</p>
<p>在工程上，这意味着：</p>
<ul>
<li>IK 求解时需要<strong>选择</strong>一个构型（例如偏好“肘下”，以免打到周围物体）；</li>
<li>数值方法探索的解往往与初始值所在的构型连通区域有关；</li>
<li>VLA / RL 策略在学习时，可能在不同次试验中收敛到不同构型，对数据分布和泛化有影响。</li>
</ul>
<blockquote>
<p>【图 6.1-9 占位】
同一个目标点，两幅图分别画出平面 2R 机械臂的肘上、肘下两种姿态，用相同颜色标出末端位置一致但中间关节角不同。</p>
</blockquote>
<hr>
<h4 id="6153-奇异位形雅可比退化导致这个方向动不了了"><a class="header" href="#6153-奇异位形雅可比退化导致这个方向动不了了">6.1.5.3 奇异位形：雅可比退化导致“这个方向动不了了”</a></h4>
<p>要理解<strong>奇异位形（singularity）</strong>，需要回忆雅可比矩阵 $ J(q) $ 的角色：它把关节速度映射为末端速度，
$$
\dot{\mathbf{x}} = J(q)\ \dot{q}
$$
其中 $ \dot{\mathbf{x}} $ 通常是 6 维的<strong>空间速度（linear + angular velocity）</strong>，$ \dot{q} $ 是 $ n $ 维关节速度。</p>
<p>在一般构型下，$ J $ 的秩等于任务空间维度（例如 $ 6 $ 或 $ 3 $），这说明机器人在局部可以沿所有任务空间方向自由运动。而当某个构型 $ q_s $ 处，$ J(q_s) $ 的秩降到低于最大值时，我们称 $ q_s $ 为一个<strong>运动学奇异位形</strong>：(<a href="https://modernrobotics.northwestern.edu/nu-gm-book-resource/5-3-singularities/?utm_source=chatgpt.com">现代机器人学</a>)</p>
<ul>
<li>物理直觉：末端<strong>在某些方向上失去了局部自由度</strong>，不再能“随便小幅动一动”；</li>
<li>数学表现：某些任务空间方向的速度无法通过任何有限的关节速度组合得到；</li>
<li>FK 仍然是光滑的，但 IK 的局部线性近似失效。</li>
</ul>
<p>典型例子包括：</p>
<ol>
<li><strong>完全伸直的手臂</strong>
当几节连杆共线伸直时，末端在某个方向的运动能力会消失。例如，直臂状态下很难绕“手臂自身轴线”做小幅绕圈。</li>
<li><strong>腕部关节轴对齐</strong>
在 6R 机械臂中，如果三个腕关节的轴线对齐，关于某些转轴的旋转变得与其他运动方向线性相关，雅可比秩降低。</li>
</ol>
<p>在数值计算层面，奇异位形带来的问题包括：</p>
<ul>
<li><strong>关节速度发散</strong>：为了产生一个有限的末端速度，$ J^\dagger $ 中某些元素需要变得非常大；</li>
<li><strong>数值不稳定</strong>：IK 迭代在奇异附近震荡或陷入很差的局部解；</li>
<li><strong>操纵能力下降</strong>：微小扰动难以被末端动作有效补偿。</li>
</ul>
<p>因此，在轨迹规划和学习控制中，通常会：</p>
<ul>
<li>设计<strong>奇异性度量</strong>（如 manipulability），通过二级优化目标远离奇异区域；</li>
<li>在 IK 中使用<strong>阻尼伪逆</strong>等数值技巧，缓解奇异附近的尖锐不适定性；</li>
<li>在策略训练数据中避免长时间停留在极端伸展等奇异构型。</li>
</ul>
<blockquote>
<p>【图 6.1-10 占位】
画一个 3R 平面机械臂：左边是正常弯曲状态，末端可以向多个方向小幅移动；右边是完全伸直状态，用箭头表示“沿某个方向几乎不能再前进”，并在旁边标注“Jacobian 秩降低”。</p>
</blockquote>
<hr>
<p>本节从<strong>坐标系与齐次变换</strong>出发，通过 <strong>DH 参数</strong>搭建了机械臂的刚体链模型，进一步引入了<strong>正运动学</strong>与<strong>逆运动学</strong>，最后讨论了<strong>冗余度、多解和奇异位形</strong>这些在后续控制与学习中反复出现的几何现象。在接下来的 6.2 节中，我们会在这些几何关系之上叠加质量、惯量和外力，引出机械臂的<strong>动力学方程与控制律</strong>，完成从“几何骨架”到“力学行为”的过渡。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="机器人动力学与控制"><a href="#机器人动力学与控制" class="header">机器人动力学与控制</a></h1>
<p>下面是对 6.2.1–6.2.4 的一版“书稿级”展开，你可以直接并入整本书的 LaTeX / Markdown 中使用。图片处我用占位说明好了，方便你后期统一风格。</p>
<hr>
<h2 id="62-机器人动力学与控制概述承上启下小节"><a class="header" href="#62-机器人动力学与控制概述承上启下小节">6.2 机器人动力学与控制概述（承上启下小节）</a></h2>
<p>在 6.1 中，我们已经从<strong>几何层面</strong>刻画了机器人：给定关节角 $ q $，通过正运动学就能算出末端位姿；给定末端目标位姿，通过逆运动学就能求出一组关节角解。
这些内容只回答了一个问题：</p>
<blockquote>
<p>“关节角度和末端位姿之间是什么几何关系？”</p>
</blockquote>
<p>真正让机器人动起来，必须回答第二个问题：</p>
<blockquote>
<p>“在有质量、惯性和重力的真实世界中，要产生这些运动，需要**多大的关节力矩 **$ \tau $？”</p>
</blockquote>
<p>这一问题的答案，就是<strong>机器人动力学方程</strong>。在此基础上，我们才能讨论 PID 控制、阻抗控制以及高层策略如何与低层伺服环协同工作。</p>
<p>本节从关节空间动力学方程出发，逐步过渡到典型的低层控制方法（PID、位置/速度/力矩模式），再介绍与人类交互密切相关的阻抗/顺应控制，最后给出“低层控制器–高层策略”的分层结构视角，为 6.3 的任务建模与动作表示埋下伏笔。</p>
<hr>
<h3 id="621-关节空间动力学方程的基本形式"><a class="header" href="#621-关节空间动力学方程的基本形式">6.2.1 关节空间动力学方程的基本形式</a></h3>
<h4 id="6211-关节空间动力学方程的标准形式"><a class="header" href="#6211-关节空间动力学方程的标准形式">6.2.1.1 关节空间动力学方程的标准形式</a></h4>
<p>对于一个 $ n $ 自由度的刚体串联机械臂，在假设各连杆刚体、关节理想（摩擦单独建模）的条件下，其关节空间动力学可以写成如下标准形式：(<a href="https://www.diag.uniroma1.it/~deluca/rob2_en/03_LagrangianDynamics_1.pdf?utm_source=chatgpt.com">罗马大学诊断中心</a>)</p>
<p>$$
M(q)\ddot{q} + C(q,\dot{q})\dot{q} + G(q) = \tau
$$</p>
<p>其中：</p>
<ul>
<li>$ q \in \mathbb{R}^n $：关节位置（角度或位移）向量；</li>
<li>$ \dot{q}, \ddot{q} $：关节速度、加速度；</li>
<li>$ M(q) \in \mathbb{R}^{n\times n} $：<strong>惯量矩阵（inertia matrix）</strong>，描述系统在配置 $ q $ 下的“有效质量”分布；</li>
<li>$ C(q,\dot{q})\dot{q} $：<strong>科里奥利/离心项（Coriolis and centrifugal terms）</strong>，与 $ \dot{q} $ 线性相关，反映关节相互耦合带来的“速度相关”惯性效应；</li>
<li>$ G(q) $：<strong>重力项（gravity term）</strong>，只与姿态 $ q $ 有关，表示为了平衡重力所需的关节力矩；</li>
<li>$ \tau \in \mathbb{R}^n $：各关节执行器产生的总力/力矩（control input）。</li>
</ul>
<p>在更完整的工程模型中，常常把关节摩擦、外界扰动和末端外力也显式纳入，比如写成：</p>
<p>$$
M(q)\ddot{q} + C(q,\dot{q})\dot{q} + G(q) + \tau_{\text{fric}}(\dot{q}) + \tau_{\text{ext}} = \tau
$$</p>
<ul>
<li>$ \tau_{\text{fric}} $：粘性摩擦 + 底摩擦等；</li>
<li>$ \tau_{\text{ext}} $：末端或连杆受到外力（例如人拉动机械臂）通过雅可比 $ J(q) $ 映射到关节空间的力矩：$ \tau_{\text{ext}} = J(q)^\top F_{\text{ext}} $。</li>
</ul>
<p><strong>重要性质</strong>（后续控制设计会频繁用到）：(<a href="https://www.diag.uniroma1.it/~deluca/rob2_en/03_LagrangianDynamics_1.pdf?utm_source=chatgpt.com">罗马大学诊断中心</a>)</p>
<ol>
<li>$ M(q) $ 对称且正定：
对任意非零向量 $ x $，有 $ x^\top M(q) x &gt; 0 $，这反映了系统动能总是正的。</li>
<li>$ M(q) $ 与 $ C(q,\dot{q}) $ 满足能量守恒相关的结构性质：
对任意向量 $ x $，有
$$
x^\top \big(\dot{M}(q) - 2C(q,\dot{q})\big) x = 0,
$$
这个反对称性质在证明控制器稳定性（Lyapunov 分析、被动性）时很有用。</li>
</ol>
<blockquote>
<p><strong>图 6.2-1 占位</strong>：
建议放一张“机械臂 + 动力学方程结构”的示意图：左侧是多关节机械臂，右侧是框图，标出 $ M(q) $、$ C(q,\dot{q}) $、$ G(q) $ 分支，显示 $ \ddot{q}, \dot{q}, q $ 进入这些模块，再汇总为关节力矩 $ \tau $。</p>
</blockquote>
<hr>
<h4 id="6212-与单自由度系统的类比各项物理含义"><a class="header" href="#6212-与单自由度系统的类比各项物理含义">6.2.1.2 与单自由度系统的类比：各项物理含义</a></h4>
<p>如果只看一个单自由度转动关节，忽略耦合，可以写成熟悉的形式：</p>
<p>$$
I \ddot{\theta} + b \dot{\theta} + \tau_g(\theta) = \tau
$$</p>
<ul>
<li>$ I $：转动惯量；</li>
<li>$ b\dot{\theta} $：粘性阻尼；</li>
<li>$ \tau_g(\theta) $：重力产生的力矩。</li>
</ul>
<p>这与高等物理中常见的“<strong>质量–阻尼–弹簧</strong>”系统 $ m\ddot{x}+b\dot{x}+kx = u $ 完全同构。
多自由度机械臂的动力学方程可以看作是这一单输入单输出系统在高维空间中的推广：</p>
<ul>
<li>$ M(q)\ddot{q} $：像“多维质量项”，不仅数值随姿态变化，而且不同关节之间有耦合（非对角元素）；</li>
<li>$ C(q,\dot{q})\dot{q} $：类似“速度相关的耦合阻尼”，在某些姿态下甚至会产生向心力矩（例如手臂挥动时需要额外力矩抵消离心效应）；</li>
<li>$ G(q) $：重力引起的静态偏置力矩，机械臂抬高越高，重力力矩越大。</li>
</ul>
<p>用这种类比，初学者可以先在“一维弹簧–阻尼–质量”直觉上建立感觉，再推广到关节空间的矩阵形式。</p>
<hr>
<h4 id="6213-拉格朗日法推导思路"><a class="header" href="#6213-拉格朗日法推导思路">6.2.1.3 拉格朗日法推导思路</a></h4>
<p>如果要系统地从机械臂结构推导出 $ M, C, G $ 的具体表达，常用的是<strong>拉格朗日法</strong>（Euler–Lagrange formulation）。(<a href="https://www.diag.uniroma1.it/~deluca/rob2_en/03_LagrangianDynamics_1.pdf?utm_source=chatgpt.com">罗马大学诊断中心</a>)</p>
<p>基本步骤如下（这里是“看懂思路版”，详细推导可以放在附录或练习中）：</p>
<ol>
<li><strong>选择广义坐标</strong> $ q $
对串联机械臂而言，关节角/位移正好就是约束完好的广义坐标。</li>
<li><strong>写出动能</strong> $ T(q,\dot{q}) $
<ul>
<li>对每个连杆，考虑其质心速度和转动速度；</li>
<li>将线速度、角速度表示为 $ q $ 和 $ \dot{q} $ 的函数；</li>
<li>整个机械臂的动能为各连杆动能之和：
$$
T(q,\dot{q}) = \frac{1}{2}\dot{q}^\top M(q)\dot{q}.
$$</li>
</ul>
</li>
<li>**写出势能 **$ V(q) $
<ul>
<li>通常是重力势能之和；</li>
<li>若存在弹簧等，还可加入其他势能项。</li>
</ul>
</li>
<li><strong>构造拉格朗日函数</strong>
$$
L(q,\dot{q}) = T(q,\dot{q}) - V(q).
$$</li>
<li><strong>套用 Euler–Lagrange 方程</strong>
$$
\frac{d}{dt}\left(\frac{\partial L}{\partial \dot{q}}\right) - \frac{\partial L}{\partial q} = \tau.
$$
展开、整理后，自然得到
$$
M(q)\ddot{q} + C(q,\dot{q})\dot{q} + G(q) = \tau.
$$</li>
</ol>
<p>拉格朗日法的特点：</p>
<ul>
<li>得到的是<strong>解析的符号表达式</strong>，便于分析系统性质（对称性、能量守恒、被动性等）；</li>
<li>适合用来设计基于模型的控制器，如计算力矩控制（computed torque）、反馈线性化、阻抗控制等。</li>
</ul>
<blockquote>
<p><strong>图 6.2-2 占位</strong>：
“能量视角的动力学推导”示意图：上半部分是机械臂连杆示意，下半部分写出动能 $ T $ 和势能 $ V $ 的表达式，再用箭头指向 Euler–Lagrange 方程，最后得到 $ M(q), C(q,\dot{q}), G(q) $。</p>
</blockquote>
<hr>
<h4 id="6214-牛顿欧拉法推导思路"><a class="header" href="#6214-牛顿欧拉法推导思路">6.2.1.4 牛顿–欧拉法推导思路</a></h4>
<p>另一条常被工程使用的路径是<strong>牛顿–欧拉法（Newton–Euler formulation）</strong>。它直接基于牛顿第二定律（线加速度与力）、欧拉方程（角加速度与力矩）来做<strong>递推计算</strong>。(<a href="https://tomgra.folk.ntnu.no/Diplomer/Hoifodt.pdf?utm_source=chatgpt.com">tomgra.folk.ntnu.no</a>)</p>
<p>典型流程：</p>
<ol>
<li><strong>前向递推（forward recursion）</strong>
从基座开始，沿着机械臂链路递推每个连杆的：
<ul>
<li>角速度、角加速度；</li>
<li>质心线速度、线加速度。</li>
</ul>
</li>
<li><strong>后向递推（backward recursion）</strong>
从末端开始，按反方向递推每个连杆：
<ul>
<li>合力、力矩；</li>
<li>计算出作用在每个关节的反作用力矩，即所需的关节力矩贡献。</li>
</ul>
</li>
<li>将所有链接递推结果综合起来，得到与拉格朗日法等价的动力学方程。</li>
</ol>
<p>与拉格朗日法相比：</p>
<ul>
<li>牛顿–欧拉法倾向于给<strong>数值形式（recursive numeric form）</strong>，方便实时计算“给定 $ q,\dot{q},\ddot{q} $，求所需 $ \tau $”（即<strong>逆动力学</strong>），在实际控制与仿真中非常常用；</li>
<li>拉格朗日法则更偏向于理论分析和求解系统整体性质。</li>
</ul>
<p>在现代机器人软件栈中，诸如 RBDL、Pinocchio 等动力学库一般都基于牛顿–欧拉递推及其拓展版本实现。</p>
<hr>
<h4 id="6215-一个二维双连杆机械臂示例直觉版"><a class="header" href="#6215-一个二维双连杆机械臂示例直觉版">6.2.1.5 一个二维双连杆机械臂示例（直觉版）</a></h4>
<p>考虑一个二维平面内的 2-link 机械臂（上臂 + 前臂），关节为肩、肘两个转动自由度 $ q_1, q_2 $，各连杆质量为 $ m_1, m_2 $，长度 $ l_1, l_2 $。
在忽略摩擦的情况下，其动力学可写成：</p>
<p>$$
M(q)\ddot{q} + C(q,\dot{q})\dot{q} + G(q) = \tau,\quad q = \begin{bmatrix}q_1 \ q_2\end{bmatrix}
$$</p>
<p>其中：</p>
<ul>
<li>$ M(q) $ 包含：
<ul>
<li>自身转动惯量 $ I_1, I_2 $；</li>
<li>由第二连杆质量引起的耦合项（比如当肘关节转动时对肩部力矩的影响）；</li>
</ul>
</li>
<li>$ C(q,\dot{q}) $ 包含与 $ \dot{q}_1\dot{q}_2 $、$ \dot{q}_2^2 $ 等项相关的科里奥利和离心力；</li>
<li>$ G(q) $ 则是两节手臂在重力场中形成的力矩，例如当 $ q_1 $ 抬高时肩关节需要更大的力矩支撑整条手臂。</li>
</ul>
<p>你可以把这个系统想象成“<strong>两个相连的摆锤</strong>”，只不过质量分布和惯性更复杂而已。</p>
<blockquote>
<p><strong>图 6.2-3 占位</strong>：
画一个平面 2-link 机械臂，在每个关节标出角度 $ q_1, q_2 $，在各连杆标出质心、重力方向，并在关节标注 $ \tau_1, \tau_2 $，帮助读者把公式与具体物理形象对应起来。</p>
</blockquote>
<hr>
<h3 id="622-pid-控制与位置--速度--力矩控制模式"><a class="header" href="#622-pid-控制与位置--速度--力矩控制模式">6.2.2 PID 控制与位置 / 速度 / 力矩控制模式</a></h3>
<p>在有了动力学模型之后，一个自然的问题是：<strong>如何根据期望的轨迹 <strong>$ q_d(t) $</strong> 生成关节力矩 <strong>$ \tau(t) $</strong>？</strong></p>
<p>最经典、也最广泛落地的做法，就是以 PID（比例–积分–微分）为核心的闭环控制结构。这一节先给出 PID 的直观解释，再说明工业机器人中常见的三种低层控制模式：<strong>位置控制、速度控制、力矩控制</strong>，以及它们的存在意义和适用场景。(<a href="https://mclab-me.pusan.ac.kr/bbs/mclab/5077/637766/download.do?utm_source=chatgpt.com">mclab-me.pusan.ac.kr</a>)</p>
<hr>
<h4 id="6221-pid-控制的基本形式与直觉"><a class="header" href="#6221-pid-控制的基本形式与直觉">6.2.2.1 PID 控制的基本形式与直觉</a></h4>
<p>对一个单关节来说，假设目标是跟踪期望角度 $ q_d(t) $，定义误差：</p>
<p>$$
e(t) = q_d(t) - q(t).
$$</p>
<p>连续时间 PID 控制律可写为：</p>
<p>$$
u(t) = K_p e(t) + K_i \int_0^t e(\tau),d\tau + K_d \frac{de(t)}{dt}.
$$</p>
<ul>
<li><strong>比例项（P）</strong>：$ K_p e(t) $
当前误差越大，输出越大，可以快速推动系统朝目标移动。$ K_p $ 越大，响应越快，但过大可能导致严重超调或震荡。</li>
<li><strong>积分项（I）</strong>：$ K_i \int e(\tau)d\tau $
积累历史误差。若系统存在稳态偏差（例如重力或摩擦导致的恒定偏差），积分项能够自动“补偿”，把误差逼向 0。但积分过强会导致响应变慢甚至“积分饱和”（出现大幅超调）。</li>
<li><strong>微分项（D）</strong>：$ K_d \dot{e}(t) $
对误差变化速度作出反应，有点类似预测未来趋势。误差变化快时，D 项会“刹车”，帮助抑制超调和震荡。但 D 项对噪声敏感，实际实现时常加入滤波。</li>
</ul>
<p>在数字控制器中，PID 通常以<strong>离散形式</strong>实现，比如用差分近似微分和积分，或者采用“增量式”PID 以避免积分漂移。</p>
<hr>
<h4 id="6222-三种低层控制模式位置速度力矩"><a class="header" href="#6222-三种低层控制模式位置速度力矩">6.2.2.2 三种低层控制模式：位置、速度、力矩</a></h4>
<p>在工业和服务机器人产品中，控制接口往往抽象为三种模式：</p>
<ol>
<li>**位置控制模式（Position Control）**控制器的输入：期望关节角 $ q_d $（或轨迹 $ q_d(t) $）；
内部：每个关节驱动器自带位置环（通常还有更内层的速度、电流环），通过 PID 等方法让实际角度 $ q $ 跟踪 $ q_d $；
输出给电机的是电流/电压，但对上层来说是透明的。特点：
<ul>
<li>对上层开发者非常友好，只需给出目标角度；</li>
<li>高度稳定、安全，一般具有软限位和速度限制；</li>
<li>但无法灵活控制关节施加的力，只能“尽力跟踪角度”。</li>
</ul>
</li>
<li>**速度控制模式（Velocity Control）**控制器的输入：期望关节速度 $ \dot{q}_d $；
内部：驱动器保证实际速度 $ \dot{q} $ 跟踪 $ \dot{q}_d $，位置不直接受控。应用：</li>
</ol>
<p>特点：</p>
<pre><code>- 移动机器人底盘（差速轮、全向轮）：给定线速度/角速度；
- 连续旋转任务（如输送带驱动电机）。
- 适合“持续运动”的场景；
- 上层需要自己积分速度生成位置，对轨迹规划负责。
</code></pre>
<ol start="3">
<li>**力矩（或电流）控制模式（Torque / Current Control）**控制器的输入：期望关节力矩 $ \tau_d $（或等价的电机电流）；
内部：只做电流/力矩闭环控制，基本不对位置/速度做显式闭环（当然也有安全限幅）。优点：</li>
</ol>
<p>缺点：</p>
<pre><code>- 给予上层最大自由度，可直接利用动力学模型设计精细的控制律（计算力矩控制、阻抗控制等）；
- 可实现柔顺控制、人机交互等高级行为。
- 上层必须承担更多稳定性和安全性可靠性责任；
- 对模型精度和控制频率要求较高。
</code></pre>
<blockquote>
<p><strong>图 6.2-4 占位</strong>：
用层次框图展示“电流环（力矩）→ 速度环 → 位置环”三层结构，并用箭头说明：上层如果用位置控制，则实际上是通过嵌套的 PID 环间接控制电流；如果选用力矩模式，则直接绕过外层，站到最内层。</p>
</blockquote>
<hr>
<h4 id="6223-控制模式的适用场景与与动力学前馈的结合"><a class="header" href="#6223-控制模式的适用场景与与动力学前馈的结合">6.2.2.3 控制模式的适用场景与与动力学前馈的结合</a></h4>
<p>综合来看，三种模式可以这样理解：</p>
<ul>
<li><strong>位置控制</strong>：
“尽量把关节拉到这儿来”，对<strong>高精度定点、重复性轨迹</strong>非常合适（典型工业机械臂焊接、搬运等）。</li>
<li><strong>速度控制</strong>：
“保持这样的速度走/转”，对<strong>导航、持续旋转设备、轮式机器人驱动</strong>非常合适。</li>
<li><strong>力矩控制</strong>：
“产生这样大小的力矩/力”，适合<strong>需要与环境互动、需要柔顺性</strong>的任务，例如协作机械臂、人机共抓重物、装配插销、打磨等。(<a href="https://www.mathworks.com/company/technical-articles/enhancing-robot-precision-and-safety-with-impedance-control.html?utm_source=chatgpt.com">MathWorks</a>)</li>
</ul>
<p>在力矩控制模式下，我们可以直接利用动力学方程设计所谓的<strong>计算力矩控制（Computed Torque Control）或反馈线性化控制</strong>：(<a href="https://mclab-me.pusan.ac.kr/bbs/mclab/5077/637766/download.do?utm_source=chatgpt.com">mclab-me.pusan.ac.kr</a>)</p>
<p>$$
\tau = M(q)v + C(q,\dot{q})\dot{q} + G(q),
$$
其中 $ v $ 是一个新的“虚拟加速度”控制量，例如：</p>
<p>$$
v = \ddot{q}_d + K_v(\dot{q}_d - \dot{q}) + K_p(q_d - q),
$$</p>
<p>代入动力学方程后，系统在理想模型下可化为：</p>
<p>$$
\ddot{q} = \ddot{q}_d + K_v(\dot{q}_d - \dot{q}) + K_p(q_d - q),
$$</p>
<p>变成一组解耦的二阶线性系统，调 $ K_p, K_v $ 即可获得类似“二阶系统”的响应。这种“<strong>模型前馈 + PID 反馈</strong>”结构在理论上优雅，在工程上也十分常见。</p>
<hr>
<h3 id="623-阻抗控制与顺应性控制的直觉"><a class="header" href="#623-阻抗控制与顺应性控制的直觉">6.2.3 阻抗控制与顺应性控制的直觉</a></h3>
<p>单纯的“把手臂拉到某个位置”在许多任务中是不够的。比如：</p>
<ul>
<li>把插头插入插座，需要在碰撞到边缘时<strong>让一点</strong>，而不是死命顶上去；</li>
<li>人推一下协作机器人手臂，希望它像一个带弹簧的物体那样略微退让，而不是僵硬不动或狂抖。</li>
</ul>
<p>这类任务要求机器人不仅要<strong>跟踪轨迹</strong>，还要在碰到环境或人时呈现某种“机械特性”——像软弹簧？像硬杆？像带阻尼的弹簧？</p>
<p><strong>阻抗控制（Impedance Control）<strong><strong>和</strong></strong>顺应控制（Admittance Control）<strong><strong>正是为此而提出的</strong></strong>交互控制</strong>策略。它们都是从虚拟的“质量–弹簧–阻尼”模型出发，让机器人在接触中表现出可调的“硬/软”特性。(<a href="https://www.sciencedirect.com/science/article/abs/pii/073658458490084X?utm_source=chatgpt.com">ScienceDirect</a>)</p>
<hr>
<h4 id="6231-阻抗控制让末端表现成弹簧阻尼系统"><a class="header" href="#6231-阻抗控制让末端表现成弹簧阻尼系统">6.2.3.1 阻抗控制：让末端“表现成弹簧–阻尼系统”</a></h4>
<p>在力学中，“<strong>阻抗（impedance）</strong>”描述的是<strong>力–运动</strong>之间的关系，例如力与速度、加速度的关系。对机器人末端（任务空间）坐标 $ x $ 来说，一个典型的二阶阻抗模型是：</p>
<p>$$
M_d(\ddot{x} - \ddot{x}_d) + D_d(\dot{x} - \dot{x}<em>d) + K_d(x - x_d) = F</em>{\text{ext}},
$$</p>
<p>其中：</p>
<ul>
<li>$ x, \dot{x}, \ddot{x} $：末端实际位置、速度、加速度；</li>
<li>$ x_d, \dot{x}_d, \ddot{x}_d $：期望末端轨迹；</li>
<li>$ F_{\text{ext}} $：环境对末端施加的外力（通过力/力矩传感器测得）；</li>
<li>$ M_d, D_d, K_d $：期望的虚拟质量、阻尼、刚度矩阵（通常设计为对角阵）。</li>
</ul>
<p>含义可以这样理解：</p>
<ul>
<li>没有外力时（$ F_{\text{ext}} = 0 $），末端会尽量跟踪 $ x_d $，偏差满足一个“虚拟质量–弹簧–阻尼”系统；</li>
<li>当环境施加外力时，末端偏离期望轨迹的程度由 $ M_d, D_d, K_d $ 决定：
<ul>
<li>$ K_d $ 大 → 刚度高 → 末端更“硬”；</li>
<li>$ K_d $ 小、$ D_d $ 足够 → 末端更“软”，容易在外力作用下产生位移但不会长时间震荡。</li>
</ul>
</li>
</ul>
<p>在实现上，阻抗控制通常在<strong>力矩控制模式</strong>下工作：</p>
<ol>
<li>用传感器测得 $ F_{\text{ext}} $；</li>
<li>在任务空间按上述方程计算期望的末端加速度/力；</li>
<li>通过雅可比 $ J(q) $ 把期望末端力转换成关节力矩命令：
$$
\tau = J(q)^\top F_{\text{cmd}} + \text{（可能的重力补偿等项）}.
$$</li>
</ol>
<p>很多关于“操作空间控制（operational space control）”的工作，都是在此基础上进一步通过 $ M(q) $ 和 $ J(q) $ 引入任务空间惯量，从而直接在末端空间设计控制律。(<a href="https://journals.sagepub.com/doi/10.1177/0278364908091463?utm_source=chatgpt.com">SAGE Journals</a>)</p>
<blockquote>
<p><strong>图 6.2-5 占位</strong>：
画一个机械臂末端与环境接触的示意图，在末端画一个“虚拟弹簧–阻尼器”与环境相连，用箭头标注 $ K_d $、$ D_d $，并用文本说明：“通过调节 $ K_d, D_d $，机器人末端的软硬度可调”。</p>
</blockquote>
<hr>
<h4 id="6232-顺应控制admittance-control把力当作输入输出运动"><a class="header" href="#6232-顺应控制admittance-control把力当作输入输出运动">6.2.3.2 顺应控制（Admittance Control）：把力当作输入，输出运动</a></h4>
<p>与阻抗控制相对的是<strong>顺应控制（Admittance Control）</strong>。在电路类比中，阻抗是 $ V/I $，顺应（admittance）是其倒数 $ I/V $；在机器人里可以粗略地理解为：</p>
<ul>
<li>阻抗控制：输入是位移/速度，输出是力（“不让你随便推”）；</li>
<li>顺应控制：输入是外力，输出是位移/速度（“你推我我就动”）。(<a href="https://ris.utwente.nl/ws/files/29087621/admittance.pdf?utm_source=chatgpt.com">Ris</a>)</li>
</ul>
<p>典型的顺应控制结构如下：</p>
<ol>
<li><strong>力输入</strong>
由末端力/力矩传感器测到 $ F_{\text{ext}} $。</li>
<li><strong>虚拟质量–阻尼–刚度模型</strong>
在控制器中模拟一个虚拟物体，其动力学为：[
M_v \ddot{x}<em>{\text{cmd}} + D_v \dot{x}</em>{\text{cmd}} + K_v (x_{\text{cmd}} - x_d) = F_{\text{ext}}.
$$
<ul>
<li>$ x_{\text{cmd}} $：由控制器生成的“命令位置”；</li>
<li>上层位置/速度控制器把 $ x_{\text{cmd}} $ 作为目标。</li>
</ul>
</li>
<li><strong>位置/速度环执行</strong>
将 $ x_{\text{cmd}}(t) $ 转换为关节空间轨迹或速度命令，由底层位置/速度控制器（而非力矩控制器）执行。</li>
</ol>
<p>顺应控制的优势在于：</p>
<ul>
<li>适用于<strong>刚性很高、内环位置/速度控制较成熟的机器人</strong>（无需原生力矩控制接口）；</li>
<li>在人机交互场景中，可以通过调节虚拟参数 $ M_v, D_v, K_v $ 轻松改变顺应性——例如让机械臂在被人牵引时表现得更轻、更柔软；</li>
<li>在工业中已有大量应用，例如外力协助的示教、协作手臂、康复机器人等。</li>
</ul>
<hr>
<h4 id="6233-阻抗-vs-顺应物理直觉与应用场景"><a class="header" href="#6233-阻抗-vs-顺应物理直觉与应用场景">6.2.3.3 阻抗 vs 顺应：物理直觉与应用场景</a></h4>
<p>阻抗控制与顺应控制本质上都是在“<strong>形塑（shape）机器人与环境的交互动力学</strong>”。两者区别主要体现在实现方式和对硬件的要求上：(<a href="https://www.mathworks.com/company/technical-articles/enhancing-robot-precision-and-safety-with-impedance-control.html?utm_source=chatgpt.com">MathWorks</a>)</p>
<ul>
<li><strong>阻抗控制（Impedance）</strong>
<ul>
<li>更自然搭配 <strong>力矩控制模式</strong>；</li>
<li>控制器直接输出期望力/力矩；</li>
<li>适合机器人本体柔软/关节具有一定顺应性的场景；</li>
<li>在<strong>硬环境</strong>（刚性治具、刚性工件）接触时表现更稳健。</li>
</ul>
</li>
<li><strong>顺应控制（Admittance）</strong>
<ul>
<li>更自然搭配 <strong>位置/速度控制模式</strong>；</li>
<li>控制器根据测得的外力计算期望位移/速度；</li>
<li>适合机器人本体刚度较高，但配有准确力传感器；</li>
<li>在<strong>与人或软体环境交互</strong>时表现出良好的顺应性和安全性。</li>
</ul>
</li>
</ul>
<p>典型应用包括：</p>
<ul>
<li><strong>打磨/抛光</strong>：需要沿着工件表面以一定压力滑动，常采用阻抗控制来维持稳定接触力。</li>
<li><strong>插接/装配</strong>：如插销入孔、插线、插 USB，阻抗/顺应控制允许末端在插入时自动“找孔”，而不是完全依赖几何精度。</li>
<li><strong>人机协作</strong>：人牵着协作机器人手臂做示教，或人直接推机器人改变其轨迹，顺应控制可以让机器人像一个“有弹簧的助手”而不是一个“刚性机器”。</li>
</ul>
<p>这一节中的思想，在后续更高级的 VLA 控制中仍然适用：高层策略可以输出期望的刚度/阻尼参数，而低层控制器（阻抗或顺应控制）负责把这些“行为风格”体现在物理交互中。</p>
<hr>
<h3 id="624-低层控制器-vs-高层策略的分层结构"><a class="header" href="#624-低层控制器-vs-高层策略的分层结构">6.2.4 低层控制器 vs 高层策略的分层结构</a></h3>
<p>至此，我们已经有了：</p>
<ul>
<li>动力学模型 $ M(q), C(q,\dot{q}), G(q) $；</li>
<li>经典低层控制方法：PID、位置/速度/力矩模式；</li>
<li>交互控制方法：阻抗控制与顺应控制。</li>
</ul>
<p>然而，一个完整的具身智能系统从<strong>感知–决策–控制</strong>到执行往往结构复杂。实践中，人们通常采用一种<strong>分层控制架构</strong>：(<a href="https://www.mdpi.com/1424-8220/23/2/1014?utm_source=chatgpt.com">MDPI</a>)</p>
<ul>
<li><strong>低层控制器（Low-Level Controller）</strong>：负责毫秒级的伺服、稳定性和安全；</li>
<li><strong>高层策略（High-Level Policy/Planner）</strong>：负责秒级甚至更长时间尺度的任务规划、策略决策——包括传统规划算法和基于 RL / VLA 的策略。</li>
</ul>
<hr>
<h4 id="6241-低层控制高速伺服与安全守门员"><a class="header" href="#6241-低层控制高速伺服与安全守门员">6.2.4.1 低层控制：高速伺服与安全守门员</a></h4>
<p>低层控制通常包含以下内容：</p>
<ol>
<li><strong>电流/力矩环（kHz 级）</strong>
<ul>
<li>硬件驱动器内部，基于电流传感器调整 PWM；</li>
<li>实际频率可达几 kHz，用于精确实现力矩命令、快速抑制电机扰动。</li>
</ul>
</li>
<li><strong>速度环（几百 Hz）</strong>
<ul>
<li>计算当前速度误差 $ \dot{q}_d - \dot{q} $；</li>
<li>输出期望电流/力矩给电流环；</li>
<li>保证速度响应平滑，限制最大速度、加速度。</li>
</ul>
</li>
<li><strong>位置环（几十到几百 Hz）</strong>
<ul>
<li>计算位置误差 $ q_d - q $；</li>
<li>输出速度或力矩命令；</li>
<li>确保轨迹跟踪、软限位、安全停止。</li>
</ul>
</li>
</ol>
<p>这三层可以由同一控制器分时执行，也可以分布在驱动器 MCU 和主控工控机/嵌入式 CPU 上。它们共同的特点是：</p>
<blockquote>
<p><strong>高频率（例如 100–1000 Hz）、低延时、强安全约束。</strong></p>
</blockquote>
<p>无论高层算法是什么样（RL policy、VLA 模型、传统规划器），只要通过这些低层接口下发命令，就能在一定程度上保证机器人在物理层面不会“发疯”。</p>
<hr>
<h4 id="6242-高层策略任务规划与智能决策"><a class="header" href="#6242-高层策略任务规划与智能决策">6.2.4.2 高层策略：任务规划与智能决策</a></h4>
<p>高层策略可以来自多种来源：</p>
<ul>
<li>传统的<strong>路径规划与轨迹优化</strong>算法（RRT*, CHOMP、MPC 等），输出末端或关节轨迹；</li>
<li>任务级规划器（Task Planner），基于符号状态和动作描述生成“拿起 → 移动 → 放下”的高层动作序列；</li>
<li>深度强化学习策略（RL Policy），以状态（视觉 + 机器人状态）为输入，输出高层动作（如期望末端速度、期望关节速度，甚至期望阻抗参数）；</li>
<li>VLA 模型，将视觉 + 语言 + 动作建模在统一 Transformer 中，直接输出高层动作 token。</li>
</ul>
<p>它们的共同点是：</p>
<ul>
<li><strong>决策频率较低</strong>，通常在 $ 5 $–$ 50 $ Hz；</li>
<li>输出的是更“抽象”的控制接口，如期望末端 pose、短时序列动作、目标轨迹片段等，而不是直接 PWM。</li>
</ul>
<blockquote>
<p><strong>图 6.2-6 占位</strong>：
画一个“分层控制”框图：最上层是“语言指令 / 任务规划 / VLA 策略”，中间是“高层动作接口（末端目标、delta pose、速度命令、阻抗参数）”，最下层是“关节级伺服（PID、电流环） + 动力学模型”。用不同时间尺度标注各层频率（例如 10 Hz / 100 Hz / 1 kHz）。</p>
</blockquote>
<hr>
<h4 id="6243-分层结构的优势与与后续章节的衔接"><a class="header" href="#6243-分层结构的优势与与后续章节的衔接">6.2.4.3 分层结构的优势与与后续章节的衔接</a></h4>
<p>采用分层结构有几个关键好处：(<a href="https://www.mdpi.com/1424-8220/23/2/1014?utm_source=chatgpt.com">MDPI</a>)</p>
<ol>
<li><strong>稳定性与安全性可控</strong>低层控制闭环总是存在，并且由可靠的模型和经验设计保证稳定。高层策略即使有波动或短暂不稳定，低层也可以通过限幅、饱和、阻抗/顺应控制等手段进行“缓冲”。</li>
<li><strong>复用性强</strong>同一套低层控制器可以服务于不同高层算法：</li>
</ol>
<p>只要接口一致，高层算法可以独立演化。</p>
<pre><code>- 今天用传统规划；
- 明天换成 RL 策略；
- 后天接入 VLA 模型。
</code></pre>
<ol start="3">
<li><strong>易于工程调试与分工</strong>控制工程师可以专注于低层伺服和安全，AI/学习方向的研究者可以专注于高层策略和模型结构，两边通过清晰接口协作。</li>
<li><strong>自然承接到 VLA 模型</strong>在本书后续章节（尤其是第 8、9、10 章），VLA 模型通常扮演“<strong>高层策略</strong>”的角色：
<ul>
<li>输入：视觉观测、语言指令、机器人状态；</li>
<li>输出：末端位姿增量（Delta Pose）、关节速度命令、抓取/释放指令，甚至期望阻抗参数；</li>
<li>然后通过第 6 章介绍的低层控制与动力学执行到真实机器人上。</li>
</ul>
</li>
</ol>
<p>而第 6.3 节“任务建模与动作表示”会进一步细化高层策略输出的形式，比如关节空间轨迹 vs 末端轨迹、delta pose / velocity 命令、动作原语等，使“VLA 输出的动作”与“第 6.2 节介绍的低层控制接口”在概念上严丝合缝地对接起来。</p>
<hr>
<p>这一整节从动力学方程到 PID、再到阻抗/顺应控制和分层结构，基本构成了“机器人低层控制”的核心框架。读者在掌握这些内容后，就可以比较从容地理解后面章节中 VLA 模型如何“站在低层控制肩膀上”，把高维感知和语言理解转化为可靠的物理行为。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="任务建模与动作表示"><a href="#任务建模与动作表示" class="header">任务建模与动作表示</a></h1>
<h3 id="631-关节空间轨迹-vs-末端位姿轨迹"><a class="header" href="#631-关节空间轨迹-vs-末端位姿轨迹">6.3.1 关节空间轨迹 vs 末端位姿轨迹</a></h3>
<p>在上一节中，我们已经从动力学和低层控制的角度讨论了机器人“怎么动得稳”。本节开始从<strong>任务层</strong>出发，讨论“应该规划一条什么样的动作轨迹”，以及这些轨迹如何被编码为适合学习和控制的表示。</p>
<p>从本质上看，轨迹规划可以在两种空间中进行：</p>
<ul>
<li>关节空间（joint space）：直接对各个关节角度随时间的变化进行规划；</li>
<li>笛卡尔空间 / 操作空间（Cartesian / task space）：对末端执行器的空间位姿进行规划。(<a href="https://mclab-me.pusan.ac.kr/bbs/mclab/5077/637676/download.do?utm_source=chatgpt.com">mclab-me.pusan.ac.kr</a>)</li>
</ul>
<p>理解这两种描述方式及它们的折中，是后续设计 VLA 模型动作表示的基础。</p>
<hr>
<h4 id="6311-关节空间轨迹直接在关节角度上规划"><a class="header" href="#6311-关节空间轨迹直接在关节角度上规划">6.3.1.1 关节空间轨迹：直接在关节角度上规划</a></h4>
<p><strong>定义与表示形式</strong>
设机器人有 (n) 个关节，关节向量记为
$$
q(t) = [q_1(t), q_2(t), \dots, q_n(t)]^\top
$$
关节空间轨迹就是在给定时间区间内，为每个关节规划一条随时间变化的函数 (q_i(t))，通常要求这些轨迹在位置、速度、加速度上都是连续且平滑的（例如多项式插值、样条插值）。(<a href="https://www.cs.columbia.edu/~allen/F15/NOTES/trajectory.pdf?utm_source=chatgpt.com">哥伦比亚大学计算机学院</a>)</p>
<p><strong>优点：天然满足关节约束与动力学约束</strong></p>
<ul>
<li><strong>易于施加关节限制</strong>：关节速度、加速度、力矩等限制天然定义在关节空间中，因此通过限制 (q(t)、\dot q(t)、\ddot q(t)) 的边界可以直接保证不超限。</li>
<li><strong>与低层控制匹配</strong>：大多数工业机器人伺服控制器的内部接口本来就是“期望关节角/关节速度”，因此规划出的关节轨迹可以几乎直接下发。(<a href="https://for-a.seoultech.ac.kr/FileUploader?downloadFileNm=Joint_Space_Trajectory_Planning_Considering_Physical_Limits_with_Convolution_Operator_for_Mobile_Robots.pdf&amp;fileName=1311189.pdf&amp;mode=downloadWeb&amp;subDir=%2FADMI%2FTCAP%2FRA&amp;utm_source=chatgpt.com">首尔科技大学</a>)</li>
<li><strong>数值稳定</strong>：在关节空间进行插值，可以避免在接近奇异位形时末端轨迹出现过大的速度或加速度。</li>
</ul>
<p><strong>缺点：在任务空间不直观</strong></p>
<ul>
<li><strong>路径形状“不可见”</strong>：给定两个关节配置 (q_\text{start}) 和 (q_\text{goal})，在关节空间做一条看似平滑的插值，映射到末端的路径可能会绕远路、穿过障碍物，甚至在某些姿态下关节严重弯折，这在规划时并不直观。(<a href="https://www.researchgate.net/publication/311545312_Comparative_Study_between_Joint_Space_and_Cartesian_Space_Path_Planning_for_Two-Link_Robot_Manipulator_using_Fuzzy_Logic?utm_source=chatgpt.com">ResearchGate</a>)</li>
<li><strong>难以精确约束末端行为</strong>：比如“末端保持竖直、沿直线从 A 移到 B”，关节空间轨迹很难直接表达这样的几何约束。</li>
</ul>
<p><strong>典型使用场景</strong></p>
<ul>
<li>无人协作、环境比较空旷的工业场景（如点到点搬运），只要末端在起点和终点准确即可，中间路径没那么重要；</li>
<li>对动力学和关节力矩有严格要求的高速运动（如喷涂、高速搬运），需要在轨迹规划阶段就考虑关节加速度和力矩极限。</li>
</ul>
<blockquote>
<p>【图 6-3-1 占位：二维平面 2 自由度机械臂，从同一个起点到终点，展示“关节空间线性插值”和“末端空间直线轨迹”在工作空间中的路径差异。】</p>
</blockquote>
<hr>
<h4 id="6312-末端位姿轨迹在笛卡尔空间中规划路径"><a class="header" href="#6312-末端位姿轨迹在笛卡尔空间中规划路径">6.3.1.2 末端位姿轨迹：在笛卡尔空间中规划路径</a></h4>
<p><strong>定义与表示形式</strong>
末端执行器的位姿通常记为
$$
x(t) = {p(t), R(t)}
$$
其中 (p(t)) 为位置，(R(t)) 为姿态（可用旋转矩阵、欧拉角或四元数等表示）。笛卡尔空间轨迹就是为 (p(t)、R(t)) 直接规划一条路径，例如“末端沿直线或圆弧移动，同时保持某个方向”。(<a href="https://www.diag.uniroma1.it/~deluca/rob1_en/14_TrajectoryPlanningCartesian.pdf?utm_source=chatgpt.com">diag.uniroma1.it</a>)</p>
<p>规划完成后，需要通过**逆运动学（IK）**将每个时间步的末端位姿 (x(t)) 转换为关节配置 (q(t))，再交由低层控制器执行（对应 6.1.4 中的 IK 内容在任务层的应用）。</p>
<p><strong>优点：直观且易于表达几何约束</strong></p>
<ul>
<li><strong>路径可视化清晰</strong>：工程师可以直接在工作空间中画出“末端从桌面上方某点沿直线插入盒子内”的轨迹，便于人类理解与调试。</li>
<li><strong>易于避障与安全约束</strong>：障碍物、禁行区域等都自然定义在工作空间中，在笛卡尔空间规划路径更便于保证末端不穿透桌面、不碰撞墙体。</li>
<li><strong>方便与视觉/语言对齐</strong>：视觉识别得到的是物体在相机或世界坐标系下的位置，语言指令也常以“把某物移动到某处”表述，从末端位姿出发可以减少表示上的跨度，这一点与后续 VLA 模型中的“操作空间动作 token”有很好呼应。</li>
</ul>
<p><strong>缺点：需要逆运动学与奇异性处理</strong></p>
<ul>
<li><strong>需要 IK 求解</strong>：对于高自由度或构型复杂的机械臂，解析 IK 不一定存在，只能用数值迭代，可能出现收敛失败或多解选择问题。(<a href="https://doc.aldebaran.com/2-8/naoqi/motion/control-cartesian.html?utm_source=chatgpt.com">doc.aldebaran.com</a>)</li>
<li><strong>奇异位形与关节极限问题</strong>：规划在笛卡尔空间是连续的，但映射到关节空间时可能经过奇异位形或导致某些关节角接近极限，因此必须在 IK 与轨迹生成中额外检查。</li>
<li><strong>动力学约束不显式</strong>：末端路径看起来很好，但对应的关节加速度和力矩不一定在安全范围内，通常需要额外的时间尺度调整或再优化。</li>
</ul>
<p><strong>典型使用场景</strong></p>
<ul>
<li>需要严格控制末端路径形状的任务：例如“沿直线插入孔内”、“沿焊缝轨迹焊接”、“沿边缘擦拭”。</li>
<li>对“对人安全”和“可解释路径”有要求的人机协作场景：操作员希望看到末端的动作是可理解、可预期的。</li>
</ul>
<hr>
<h4 id="6313-混合规划在笛卡尔空间设关键节点在关节空间生成可执行轨迹"><a class="header" href="#6313-混合规划在笛卡尔空间设关键节点在关节空间生成可执行轨迹">6.3.1.3 混合规划：在笛卡尔空间设关键节点，在关节空间生成可执行轨迹</a></h4>
<p>实际系统中，常用的并不是“纯关节空间”或“纯笛卡尔空间”两极，而是两者的<strong>混合策略</strong>：</p>
<ol>
<li><strong>在笛卡尔空间指定关键路径点（waypoints）</strong>
<ul>
<li>例如抓取任务中：
<ul>
<li>远离物体的“预抓取位姿”；</li>
<li>靠近物体表面的“接近位姿”；</li>
<li>真正抓取时的“抓取位姿”；</li>
<li>抬起后的“撤离位姿”。(<a href="https://moveit.picknik.ai/main/doc/examples/moveit_grasps/moveit_grasps_tutorial.html?utm_source=chatgpt.com">MoveIt</a>)</li>
</ul>
</li>
<li>这些关键位姿由感知模块（视觉、力觉）和任务规划模块共同产生，与 8 章中的高层规划输出一致。</li>
</ul>
</li>
<li><strong>对关键点之间进行插值</strong>
<ul>
<li>在笛卡尔空间做位置和姿态插值（直线、样条），得到一串更密的末端位姿样本。</li>
</ul>
</li>
<li><strong>调用 IK 生成关节轨迹</strong>
<ul>
<li>对每个插值后的末端位姿调用 IK 求解得关节角；</li>
<li>在关节空间对这些离散点再次进行平滑（如时间重分配、多项式拟合），保证速度、加速度连续，最终获得可执行的关节轨迹。(<a href="https://www.cs.columbia.edu/~allen/F15/NOTES/trajectory.pdf?utm_source=chatgpt.com">哥伦比亚大学计算机学院</a>)</li>
</ul>
</li>
</ol>
<p>这种“<strong>笛卡尔空间规划 + 关节空间执行</strong>”的混合方式，既保留了末端路径的直观性，又充分利用了关节级限幅与动力学约束的优势，是工程实践和现代机器人学习系统里最常见的做法。后续在讨论“动作原语”和“抓取模式”时，可以把每个原语理解为：在笛卡尔空间定义了一些关键位姿和运动形状，再自动转化为底层关节轨迹。</p>
<blockquote>
<p>【图 6-3-2 占位：展示一个抓取任务的关键笛卡尔路径点（预抓取、接近、抓取、撤离）以及这些点通过 IK 映射到关节空间轨迹的示意图。】</p>
</blockquote>
<hr>
<h3 id="632-delta-pose--velocity-命令的含义"><a class="header" href="#632-delta-pose--velocity-命令的含义">6.3.2 Delta Pose / Velocity 命令的含义</a></h3>
<p>在具身智能与 VLA 模型中，一个常见的设计是<strong>让策略网络直接输出“增量位姿”或“末端速度”命令</strong>，而不是最终轨迹。这类命令与 6.2 中的低层控制接口紧密相连：高层在较低频率上输出 delta/速度，低层控制器在高频率上进行插值和闭环控制。</p>
<hr>
<h4 id="6321-增量位姿命令delta-pose"><a class="header" href="#6321-增量位姿命令delta-pose">6.3.2.1 增量位姿命令（Delta Pose）</a></h4>
<p><strong>基本形式</strong>
若当前末端位姿为 (x_t = {p_t, R_t})，高层策略输出一个增量位姿
$$
\Delta x_t = {\Delta p_t, \Delta R_t}
$$
则下一步目标位姿为
$$
x_{t+1} = x_t \oplus \Delta x_t
$$
其中 (\oplus) 表示位姿的组合（位置相加、姿态用旋转复合，例如四元数相乘）。</p>
<p>在实现上，这通常表现为：</p>
<ul>
<li>高层每隔 (20 \sim 100) ms 计算一次较小的位姿增量（单位可以是 m、rad 或归一化后的步长）；</li>
<li>低层控制器将 (x_{t+1}) 作为当前位置的<strong>短距离目标</strong>，通过 IK + 关节控制使末端快速靠近该目标；</li>
<li>连续叠加这些小增量，就形成了一条平滑轨迹。</li>
</ul>
<p><strong>优点与直觉</strong></p>
<ul>
<li><strong>相对命令，更适合闭环调整</strong>：策略只需要“往前挪一点”、“向左偏一点”，对环境变化的响应更自然；</li>
<li><strong>数值平稳</strong>：每一步增量较小，降低了策略输出突然大幅跳变的风险，对强化学习和模仿学习都更友好；</li>
<li><strong>和视觉伺服自然结合</strong>：可将视觉误差（例如末端与目标的偏差）直接映射为下一步的增量位姿，实现“看到一点，改一点”的控制模式。(<a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC9198459/?utm_source=chatgpt.com">PMC</a>)</li>
</ul>
<p>在 VLA 实现中，Delta Pose 往往被离散化成若干 token（例如“x 方向 +1 单位格”、“z 方向 -1 单位格”、“绕 z 轴旋转 +5°”），从而可以由 Transformer 等序列模型输出。</p>
<hr>
<h4 id="6322-速度命令velocity-command"><a class="header" href="#6322-速度命令velocity-command">6.3.2.2 速度命令（Velocity Command）</a></h4>
<p>另一种常见方式是直接在操作空间输出末端<strong>线速度 + 角速度</strong>：
$$
v_t = [v_x, v_y, v_z, \omega_x, \omega_y, \omega_z]^\top
$$
在时间步长 (\Delta t) 下，末端位姿的更新可近似为
$$
p_{t+1} \approx p_t + v_{lin,t} \cdot \Delta t,\quad
R_{t+1} \approx R_t \cdot \exp(\hat\omega_t \Delta t)
$$
低层控制器在更高频率下根据这些速度设定关节速度，积分得到真实轨迹。</p>
<p><strong>特点</strong></p>
<ul>
<li><strong>连续控制感更强</strong>：在时间上看，机器人“持续地朝某个方向运动”，非常适合描述平滑运动、推拽、擦拭等操作；</li>
<li><strong>方便施加速度上限</strong>：在接口层限制 (|v_t|) 即可保证安全，不会出现瞬时大位移；</li>
<li><strong>与动力学控制兼容</strong>：在力控或阻抗控制框架下，期望速度往往是控制方程中的显式变量，用速度命令更易结合。</li>
</ul>
<p>速度命令在工业控制与视觉伺服中应用广泛，例如通过图像误差生成运动速度，确保末端在摄像机视野中按照一定速率收敛到目标。(<a href="https://doc.aldebaran.com/2-8/naoqi/motion/control-cartesian.html?utm_source=chatgpt.com">doc.aldebaran.com</a>)</p>
<hr>
<h4 id="6323-相对命令-vs-绝对命令何时用哪一种"><a class="header" href="#6323-相对命令-vs-绝对命令何时用哪一种">6.3.2.3 相对命令 vs 绝对命令：何时用哪一种？</a></h4>
<p>从抽象上看，可以把控制命令分成两类：</p>
<ul>
<li><strong>绝对命令（absolute command）</strong>
<ul>
<li>直接给出目标关节位置 (q^<em>) 或目标末端位姿 (x^</em>)；</li>
<li>控制器的任务是“尽快把机器人从当前状态拉到目标”，典型于点到点快速定位、搬运。</li>
</ul>
</li>
<li><strong>相对命令（relative command）</strong>
<ul>
<li>Delta Pose、速度命令都属于“相对控制”：每一步都在当前状态的基础上做一个小改动；</li>
<li>更适合连续跟踪、细致操作，以及在执行过程中不断根据传感反馈修正轨迹。</li>
</ul>
</li>
</ul>
<p><strong>如何选择？可以粗略遵循以下原则：</strong></p>
<ul>
<li>任务几何结构简单、只需要把物体“从 A 搬到 B”，且环境基本静态 → 用绝对命令更简单，和关节空间轨迹规划相似；</li>
<li>任务需要<strong>持续闭环调整</strong>，例如抓取时对准物体、旋转瓶盖、插销入孔等 → 用相对命令更合适，控制策略学到的是“误差→修正”的局部规则；</li>
<li>在 VLA 中，绝对命令更像“规划一个目标位姿”，相对命令更像“一步一步执行策略”；两者在 8 章中会分别对应“高层子目标输出”和“低层连续控制输出”。</li>
</ul>
<hr>
<h3 id="633-动作原语skill-primitives--motion-primitives"><a class="header" href="#633-动作原语skill-primitives--motion-primitives">6.3.3 动作原语（skill primitives / motion primitives）</a></h3>
<p>有了轨迹与命令的基本概念，下一步是建立<strong>更高层的动作抽象</strong>。
如果把“Delta Pose / Velocity 命令”看作机器人控制的“字母”，那么<strong>动作原语</strong>就对应“单词”或“短语”：在一个较长时间窗口内实现一个相对完整的小目标，例如“抓起桌上的杯子”、“沿边缘推一段距离”。(<a href="https://arxiv.org/html/2407.08585v1?utm_source=chatgpt.com">arXiv</a>)</p>
<hr>
<h4 id="6331-概念常用子动作的封装"><a class="header" href="#6331-概念常用子动作的封装">6.3.3.1 概念：常用子动作的封装</a></h4>
<p>**动作原语（motion / skill primitive）**通常具有以下几个特征：</p>
<ol>
<li><strong>时间上有限、空间上局部</strong>
<ul>
<li>原语持续一段有限时间（例如 0.5–3 秒），在一个局部区域内完成特定动作。</li>
</ul>
</li>
<li><strong>内部包含固定的控制逻辑或轨迹模板</strong>
<ul>
<li>例如“抓取”原语内部可能包含：接近、闭合手爪、检测抓取成功、微调姿态等一整套控制流程；</li>
<li>这些流程可以直接由规则 + 控制算法手写，也可以由学习得到的策略来实现。(<a href="https://www.ri.cmu.edu/pub_files/2012/7/RSS2012_Final_Compliant_Grasp.pdf?utm_source=chatgpt.com">CMU Robotics Institute</a>)</li>
</ul>
</li>
<li><strong>参数化</strong>
<ul>
<li>一个原语往往带有少量参数，如目标位置、目标朝向、接近方向等；</li>
<li>同一个“抓取”原语，通过不同参数化就能抓取桌上不同位置、不同朝向的物体。(<a href="https://arxiv.org/html/2407.08585v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ol>
<p>典型原语包括：<strong>抓取（grasp）</strong>、<strong>放置（place）</strong>、<strong>推动（push）</strong>、<strong>拉动（pull）</strong>、<strong>擦拭（wipe）</strong>、<strong>开门（open-door）</strong> 等。很多近期的机器人强化学习和终身学习工作，都是在这些原语上进行组合和参数学习。(<a href="https://openaccess.thecvf.com/content/CVPR2025/papers/Yao_Think_Small_Act_Big_Primitive_Prompt_Learning_for_Lifelong_Robot_CVPR_2025_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</p>
<hr>
<h4 id="6332-组合复杂任务从原语库到任务脚本"><a class="header" href="#6332-组合复杂任务从原语库到任务脚本">6.3.3.2 组合复杂任务：从“原语库”到“任务脚本”</a></h4>
<p>引入动作原语的直接收益，是能够从<strong>离散层次</strong>上拼装复杂任务：</p>
<ul>
<li>对于“收拾桌面”这样的复杂任务，可以粗略写成：
<ul>
<li>重复执行：{找到一个物体 → 抓取 → 搬运 → 放置到收纳盒}；</li>
</ul>
</li>
<li>对于“装配任务”，可以组合：
<ul>
<li>{抓起零件 → 插入槽位 → 施加压力到底 → 松开 → 撤离}。</li>
</ul>
</li>
</ul>
<p>在系统架构上，常见做法是：</p>
<ol>
<li><strong>高层任务规划器（symbolic planner / LLM / VLA 高层）</strong>
<ul>
<li>在符号或语言层面决定原语序列：
$$
\text{Plan} = [\text{Grasp}(obj_1),\ \text{Place}(obj_1,\ box),\ \text{Grasp}(obj_2), \dots]
$$</li>
</ul>
</li>
<li><strong>原语调度与参数选择</strong>
<ul>
<li>对每个原语，基于当前视觉和状态选择参数：目标位置、方向、力阈值等。</li>
</ul>
</li>
<li><strong>原语内部控制与反馈</strong>
<ul>
<li>原语内部运行自己的轨迹规划与闭环控制，一旦完成或失败，向上层报告结果。</li>
</ul>
</li>
</ol>
<p>这种层次结构使得系统更易解释、调试和扩展：</p>
<ul>
<li>如果“抓取”失败，多半可以定位到“抓取原语”的实现或参数，而不是整条长链条；</li>
<li>对 VLA 模型而言，也可以设计成“预测下一步应该调用哪个原语，以及原语参数”，而不是直接在连续控制空间中长时间滚动控制。</li>
</ul>
<hr>
<h4 id="6333-学习动作原语从示教到强化学习"><a class="header" href="#6333-学习动作原语从示教到强化学习">6.3.3.3 学习动作原语：从示教到强化学习</a></h4>
<p>动作原语可以由工程师手工设计，但随着任务增多和环境复杂，完全手工定义会变得困难，因此研究界大量工作关注<strong>从数据中学习动作原语</strong>。(<a href="https://www.dfki.de/fileadmin/user_upload/import/7056_131009_Towards_Learning_of_Generic_Skills_for_Robotic_Manipulation_KI_Metzen.pdf?utm_source=chatgpt.com">dfki.de</a>)</p>
<p>常见思路包括：</p>
<ol>
<li><strong>示教学习（Learning from Demonstration）</strong>
<ul>
<li>从人类示范中分割出若干“重复出现的子动作片段”，通过聚类或序列建模发现潜在原语；</li>
<li>为每个原语学习一个条件策略：输入局部观测 → 输出 Delta Pose / 速度命令；</li>
<li>原语的参数来自于示范中的“接触点、目标位姿”等。</li>
</ul>
</li>
<li><strong>基于强化学习的原语优化</strong>
<ul>
<li>先指定一个粗略的原语模板（例如“向目标点接近→闭手爪→抬起”），再用强化学习在模拟或现实中微调内部控制策略，以提高成功率、鲁棒性和效率。(<a href="https://arxiv.org/html/2407.08585v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>多任务共享的原语</strong>
<ul>
<li>不同技能（“抓香蕉”、“放锅”、“推门”）在空间上往往共享一些底层动作模式（如“从侧面接近并闭手爪”），可以用<strong>共享原语库</strong>建模，再针对不同任务学习高层组合和参数调节。(<a href="https://openaccess.thecvf.com/content/CVPR2025/papers/Yao_Think_Small_Act_Big_Primitive_Prompt_Learning_for_Lifelong_Robot_CVPR_2025_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</li>
</ul>
</li>
</ol>
<p>在 VLA 框架中，这些学得的原语可以进一步被“语言化”：</p>
<ul>
<li>用自然语言描述原语的语义（如“轻轻抓起杯子”、“沿边缘推到尽头”），</li>
<li>让大语言模型理解和调用这些原语，为“从语言到动作”的桥接提供更结构化的中间层。</li>
</ul>
<hr>
<h3 id="634-抓取与操作任务的典型动作模式"><a class="header" href="#634-抓取与操作任务的典型动作模式">6.3.4 抓取与操作任务的典型动作模式</a></h3>
<p>最后，我们用“抓取”和“放置”等常见操作任务，具体展示一个动作从<strong>任务层描述 → 轨迹表示 → 控制执行</strong>的大致模版。这些典型模式也可以直接对应到上一节的动作原语。</p>
<hr>
<h4 id="6341-抓取动作分解接近对准抓紧提起"><a class="header" href="#6341-抓取动作分解接近对准抓紧提起">6.3.4.1 抓取动作分解：接近、对准、抓紧、提起</a></h4>
<p>一个看似简单的“抓起物体”动作，实际可以拆分为以下阶段：(<a href="https://moveit.picknik.ai/main/doc/examples/moveit_grasps/moveit_grasps_tutorial.html?utm_source=chatgpt.com">MoveIt</a>)</p>
<ol>
<li><strong>接近（approach）</strong>
<ul>
<li>从安全距离上的“预抓取位姿”开始，沿着设计好的路径接近物体附近；</li>
<li>通常要求路径避开障碍，并保持手爪朝向大致合理，以便后续微调。</li>
</ul>
</li>
<li><strong>对准（align）</strong>
<ul>
<li>利用视觉或力觉反馈，逐渐修正末端位姿，使手爪与物体表面或主轴线对齐；(<a href="https://www.mdpi.com/1424-8220/24/2/618?utm_source=chatgpt.com">MDPI</a>)</li>
<li>对准过程往往使用 Delta Pose 或速度命令实现小幅调整，可能包含：
<ul>
<li>平移到物体中心上方或侧面；</li>
<li>旋转使夹爪面与物体抓取面平行；</li>
<li>通过轻触桌面、检测力变化确认高度。</li>
</ul>
</li>
</ul>
</li>
<li><strong>抓紧（grasp）</strong>
<ul>
<li>在对准后缓慢闭合夹爪，监控力传感器或夹爪开合位置，确认物体已被稳定夹持；</li>
<li>一些研究提出<strong>顺应性抓取原语</strong>，通过控制手指与支撑面的柔顺接触，显著提高抓取成功率。(<a href="https://www.ri.cmu.edu/pub_files/2012/7/RSS2012_Final_Compliant_Grasp.pdf?utm_source=chatgpt.com">CMU Robotics Institute</a>)</li>
</ul>
</li>
<li><strong>提起（lift）</strong>
<ul>
<li>在确认抓取成功后，沿着安全方向（通常是竖直向上）抬起物体，避免与周围物体碰撞；</li>
<li>这一阶段结束时，机器人进入“携带物体”的状态，为后续放置或操作做好准备。</li>
</ul>
</li>
</ol>
<p>在具身智能系统中，<strong>每个阶段都可以被视作一个原语</strong>（“ApproachPrimitive”、“AlignPrimitive”、“GraspPrimitive”、“LiftPrimitive”），高层策略只需决定何时切换阶段及其参数。</p>
<blockquote>
<p>【图 6-3-3 占位：抓取动作四阶段序列示意图，每个阶段配一帧图片（接近、对准、闭合、提起），并用箭头标注末端运动方向。】</p>
</blockquote>
<hr>
<h4 id="6342-放置动作分解移动接触松开撤离"><a class="header" href="#6342-放置动作分解移动接触松开撤离">6.3.4.2 放置动作分解：移动、接触、松开、撤离</a></h4>
<p>与抓取相对的“放置（place）”动作，同样可以拆成多个阶段，且要求在接触与松开过程中保持物体的稳定和姿态正确。(<a href="https://moveit.picknik.ai/main/doc/examples/moveit_grasps/moveit_grasps_tutorial.html?utm_source=chatgpt.com">MoveIt</a>)</p>
<ol>
<li><strong>移动到目标位置附近</strong>
<ul>
<li>根据任务指令（如“将杯子放到托盘中央”）与感知信息，规划一条轨迹，将物体移动到目标区域上方一定高度的“预放置位姿”；</li>
<li>此阶段仍然以末端位姿轨迹规划和避障为主。</li>
</ul>
</li>
<li><strong>接触（place down）</strong>
<ul>
<li>缓慢沿法向方向下降末端，使物体与目标表面接触；</li>
<li>可以通过力传感器检测接触力是否在合理范围内，避免砸下去或悬空。</li>
</ul>
</li>
<li><strong>松开夹爪</strong>
<ul>
<li>在物体已被支撑面稳定支撑的前提下，缓慢松开夹爪，并监控物体在图像或力觉上的反馈，确保未被带动滑动或翻倒；</li>
<li>某些精密装配任务中，会引入“推压/微调”原语，在松开前先用小力将物体推至定位边缘。(<a href="https://www.mdpi.com/2076-3417/15/1/387?utm_source=chatgpt.com">MDPI</a>)</li>
</ul>
</li>
<li><strong>撤离（retreat）</strong>
<ul>
<li>松开后沿着安全路径撤回末端，避免带动周围物体或重新碰撞刚刚放置的物体；</li>
<li>撤离路径常设计为先沿法向抬高，再在远离目标的方向移动。</li>
</ul>
</li>
</ol>
<p>在 MoveIt 等机器人软件中，完整的 “pick-and-place” pipeline 通常就是：</p>
<ul>
<li>抓取阶段：approach → grasp → lift；</li>
<li>放置阶段：move → place down → release → retreat。(<a href="https://moveit.picknik.ai/main/doc/examples/moveit_grasps/moveit_grasps_tutorial.html?utm_source=chatgpt.com">MoveIt</a>)</li>
</ul>
<hr>
<h4 id="6343-其他操作模式旋转插入与高要求操作"><a class="header" href="#6343-其他操作模式旋转插入与高要求操作">6.3.4.3 其他操作模式：旋转、插入与高要求操作</a></h4>
<p>除了抓取与放置，还有一类对对准和力控要求更高的操作任务，例如：</p>
<ol>
<li><strong>旋转（如旋开瓶盖、拧螺丝、扭门把）</strong>
<ul>
<li>通常需要：
<ul>
<li>抓取并固定物体本体（瓶身、螺母等）；</li>
<li>控制末端绕特定轴施加旋转位姿或扭矩；</li>
<li>监控旋转角度与力矩变化，判断是否已经旋开或拧紧。</li>
</ul>
</li>
<li>这里，轨迹表示不仅包括位置和姿态，还需要显式地考虑力/扭矩限幅与顺应性控制。(<a href="https://www.ri.cmu.edu/app/uploads/2019/11/Efort_Grasping__IROS_2019.pdf?utm_source=chatgpt.com">CMU Robotics Institute</a>)</li>
</ul>
</li>
<li><strong>插入（如插销入孔、插拔插头、装配轴–孔结构）</strong>
<ul>
<li>对<strong>几何对准精度</strong>要求高，误差容易导致卡死；</li>
<li>常见模式是：
<ul>
<li>在远处通过视觉对准，规划大致插入方向；</li>
<li>靠近后使用小步长 Delta Pose + 力控，边轻触边调整姿态；</li>
<li>在检测到插入深度或力反馈满足条件后，进入完全插入阶段。(<a href="https://www.mdpi.com/2076-3417/15/1/387?utm_source=chatgpt.com">MDPI</a>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>推 / 拉 / 调整位置</strong>
<ul>
<li>与抓取不同，推/拉往往利用环境约束（桌面边缘、槽口等）辅助定位，如通过推到边缘确保物体位置准确；</li>
<li>典型做法是设计“推拽原语”，内部控制末端施加持续速度和限定力，并用视觉或位姿反馈判断是否到达目标。(<a href="https://www.mdpi.com/2076-3417/15/1/387?utm_source=chatgpt.com">MDPI</a>)</li>
</ul>
</li>
</ol>
<p>这些高要求操作的共同特点是：</p>
<ul>
<li>对<strong>轨迹局部形状</strong>和<strong>接触力</strong>非常敏感；</li>
<li>通常配合<strong>相对命令（Delta Pose / 速度）<strong><strong>和</strong></strong>阻抗/顺应控制</strong>实现细颗粒度的调整；</li>
<li>很适合作为独立的动作原语，通过示教和强化学习进行专门训练。</li>
</ul>
<blockquote>
<p>【图 6-3-4 占位：展示三类操作模式的典型示意：
（a）旋开瓶盖：夹持瓶身 + 绕 z 轴旋转；
（b）插销入孔：先对准、再沿孔轴缓慢插入；
（c）利用环境约束的推拽：沿桌面边缘推动物体到定位位置。】</p>
</blockquote>
<hr>
<p>本小节到此为止，你可以把 6.3.1–6.3.4 看作是从“连续控制信号”上升到“任务动作单元”的第一层抽象：</p>
<ul>
<li>关节空间 vs 末端位姿轨迹明确了“在哪个空间里描述运动”；</li>
<li>Delta Pose / 速度命令是“步进式”的控制接口；</li>
<li>动作原语和典型抓取/操作模式则为后续 VLA 模型提供了“结构化动作词汇表”。</li>
</ul>
<p>在第 8 章中，我们会进一步看到，这些概念如何被编码为 token、序列和模块，使得视觉–语言–动作模型能在统一的框架下学习和调用这些动作能力。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="机器人操作系统与开发环境"><a href="#机器人操作系统与开发环境" class="header">机器人操作系统与开发环境</a></h1>
<h3 id="64-机器人操作系统与开发环境节选"><a class="header" href="#64-机器人操作系统与开发环境节选">6.4 机器人操作系统与开发环境（节选）</a></h3>
<p>本小节聚焦<strong>如何把前面学到的运动学、控制理论真正“落在地上”</strong>：在实际机器人系统里，感知、决策和控制通常通过 ROS / ROS 2 串起来，并通过一套相对统一的接口与机械臂、移动底盘和传感器交互。本节从三个角度展开：</p>
<ul>
<li>ROS / ROS 2 的基本概念</li>
<li>常见机器人硬件接口</li>
<li>实验室环境下的安全规范与调试流程</li>
</ul>
<hr>
<h3 id="641-ros--ros2-基本概念节点话题服务"><a class="header" href="#641-ros--ros2-基本概念节点话题服务">6.4.1 ROS / ROS2 基本概念（节点、话题、服务）</a></h3>
<p>在机器人社区里，“会用 ROS”几乎已经成为基础技能。需要先澄清一点：<strong>ROS 并不是传统意义上的操作系统</strong>，而是一个面向机器人的中间件与工具生态 —— 它提供了一套标准的通信机制、工具链和约定，用来连接不同的程序、驱动和算法。ROS2 在此基础上重构了通信层，采用 DDS（Data Distribution Service）作为默认中间件，具备更好的实时性与可靠性配置能力。(<a href="https://docs.ros.org/en/iron/Concepts/Basic.html?utm_source=chatgpt.com">ROS Documentation</a>)</p>
<h4 id="6411-ros-架构节点与-ros-图"><a class="header" href="#6411-ros-架构节点与-ros-图">6.4.1.1 ROS 架构：节点与 ROS 图</a></h4>
<p>在 ROS / ROS 2 里，每一个独立的程序进程都叫做一个 <strong>节点（Node）</strong>。可以把节点想象成“机器人神经系统”里的一个小功能模块：</p>
<ul>
<li>有的节点负责读相机、雷达等传感器；</li>
<li>有的节点负责路径规划或强化学习策略推理；</li>
<li>有的节点负责直接控制电机驱动。</li>
</ul>
<p>所有节点之间通过 ROS 提供的几种通信接口相互连接，形成一个 <strong>ROS 图（ROS Graph）</strong>：节点是图中的点，节点之间的各种连接（话题、服务、动作等）是边。ROS2 官方文档将其概括为“基于强类型匿名发布/订阅机制的消息传递系统”。(<a href="https://docs.ros.org/en/iron/Concepts/Basic.html?utm_source=chatgpt.com">ROS Documentation</a>)</p>
<p>这种设计的关键特性是<strong>松耦合</strong>：</p>
<ul>
<li>发布者（Publisher）只负责往某个<strong>话题名</strong>发送消息，不关心谁在订阅；</li>
<li>订阅者（Subscriber）只声明自己想订阅哪个话题、哪种消息类型，不需要知道消息来自哪个具体节点；</li>
<li>节点可以在运行时加入或离开，只要遵守同样的接口约定，整套系统仍然可以协同工作。</li>
</ul>
<blockquote>
<p>【图片占位】
建议插图：一个 ROS 图示意图：若干节点（camera_node、perception_node、policy_node、arm_controller 等）通过不同颜色箭头连接，标注 Topic（/camera/image、/joint_states）、Service（/compute_ik）、Action（/arm_controller/follow_joint_trajectory）等，帮助读者整体理解。</p>
</blockquote>
<p>在 ROS1 中，节点通过 master 做名称解析与发现；在 ROS2 中，节点发现由 DDS 的对等网络负责，拓展到多机、多网络场景更加自然，这对未来大规模具身智能系统（多机器人协作等）尤为重要。(<a href="https://docs.ros.org/en/iron/Concepts/Basic.html?utm_source=chatgpt.com">ROS Documentation</a>)</p>
<h4 id="6412-话题与消息持续数据流"><a class="header" href="#6412-话题与消息持续数据流">6.4.1.2 话题与消息：持续数据流</a></h4>
<p><strong>话题（Topic）<strong><strong>是 ROS 中最基础也最常用的一种通信方式，可以理解为“有名字的消息管道”。节点之间通过发布/订阅话题来传递</strong></strong>持续的数据流</strong>，例如：</p>
<ul>
<li>相机驱动节点持续在 <code>/camera/image_raw</code> 上发布图像帧（<code>sensor_msgs/Image</code>）；(<a href="https://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/Image.html?utm_source=chatgpt.com">ROS Documentation</a>)</li>
<li>激光雷达节点在 <code>/scan</code> 上发布激光扫描数据（<code>sensor_msgs/LaserScan</code>）；(<a href="https://docs.ros.org/jade/api/sensor_msgs/html/msg/LaserScan.html?utm_source=chatgpt.com">ROS Documentation</a>)</li>
<li>里程计或 joint_state 发布当前关节状态（<code>sensor_msgs/JointState</code>）。(<a href="https://emanual.robotis.com/docs/en/platform/openmanipulator_x/ros_controller_msg/?utm_source=chatgpt.com">ROBOTIS e-Manual</a>)</li>
</ul>
<p>每个话题都同时绑定了一个 <strong>消息类型（Message Type）</strong>。消息类型是一种强类型的数据结构，有类似 C 语言 struct 的字段定义，例如移动底盘常用的速度控制消息 <code>geometry_msgs/Twist</code>：</p>
<pre><code class="language-latex"># This expresses velocity in free space broken into its linear and angular parts.
Vector3 linear
Vector3 angular
</code></pre>
<p>(<a href="https://docs.ros.org/en/noetic/api/geometry_msgs/html/msg/Twist.html?utm_source=chatgpt.com">ROS Documentation</a>)</p>
<p>在差动轮或全向轮移动机器人中，通常使用：</p>
<ul>
<li><code>linear.x</code>：沿机器人前进方向的线速度（m/s）；</li>
<li><code>angular.z</code>：绕垂直于地面的 z 轴旋转角速度（rad/s）。(<a href="https://stackoverflow.com/questions/50976281/what-do-x-y-and-z-mean-in-geometry-msgs-twist-message-in-ros?utm_source=chatgpt.com">Stack Overflow</a>)</li>
</ul>
<p>同一个话题的所有发布者和订阅者必须使用<strong>完全一致</strong>的消息类型，这使得跨语言（C++/Python）、跨平台节点之间仍能可靠通信。</p>
<p>在 ROS2 中，话题通信的底层由 DDS 实现，用户可以为不同话题配置 <strong>QoS（Quality of Service）策略</strong>，例如：</p>
<ul>
<li>对控制命令话题使用可靠传输，确保每条命令都送达；</li>
<li>对高帧率图像话题使用 best-effort，允许少量丢帧以减少带宽和延迟。(<a href="https://docs.ros.org/en/rolling/Concepts/Intermediate/About-Quality-of-Service-Settings.html?utm_source=chatgpt.com">ROS Documentation</a>)</li>
</ul>
<blockquote>
<p>【图片占位】
建议插图：<code>Twist</code> 消息在 <code>base_link</code> 坐标系中的含义示意图，对 x/y/z 线速度与绕 x/y/z 角速度的方向进行三维箭头标注。</p>
</blockquote>
<h4 id="6413-服务与动作请求-响应与长时任务"><a class="header" href="#6413-服务与动作请求-响应与长时任务">6.4.1.3 服务与动作：请求-响应与长时任务</a></h4>
<p>仅靠话题的“单向数据流”无法很好地表达<strong>请求-响应式</strong>的交互。例如：</p>
<ul>
<li>“请帮我算一下某个末端位姿对应的逆运动学解”；</li>
<li>“请保存当前地图到磁盘”；</li>
</ul>
<p>这种场景适合使用 <strong>服务（Service）</strong>。服务是 ROS 中的同步 RPC 机制，其通信模式是<strong>一次请求 – 一次响应</strong>：客户端发送请求消息，服务器处理后返回响应消息。ROS2 官方文档强调，服务适合处理<strong>短时间内可以完成的操作</strong>，不适用于需要长时间执行、可能需要随时取消的任务。(<a href="https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Services/Understanding-ROS2-Services.html?utm_source=chatgpt.com">ROS Documentation</a>)</p>
<p>对于“移动到某个目标点”“执行一条机械臂轨迹”这类<strong>长时任务</strong>，ROS 提供了更高级的 <strong>动作（Action）</strong> 接口，尤其在 ROS2 中已经成为推荐做法。动作的特点是：(<a href="https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Understanding-ROS2-Actions/Understanding-ROS2-Actions.html?utm_source=chatgpt.com">ROS Documentation</a>)</p>
<ul>
<li>客户端发送一个 <strong>目标（Goal）</strong>；</li>
<li>服务器在执行过程中不断通过 <strong>反馈（Feedback）</strong> 通道汇报进度（例如当前轨迹进度、剩余距离）；</li>
<li>执行结束后发送 <strong>结果（Result）</strong>（成功、失败或被取消）；</li>
<li>客户端可以在过程中发送取消（cancel）请求，实现<strong>可抢占</strong>。</li>
</ul>
<p>动作本质上是基于话题和服务组合出来的更高层抽象，既保留了服务的“明确开始/结束”，又具备流式反馈的能力，在机器人导航、机械臂轨迹跟踪等场景中极其常见。</p>
<blockquote>
<p>【图片占位】
建议插图：一个动作交互时序图：Client 发送 Goal，Action Server 发送一系列 Feedback，最后返回 Result，并标出中途 Cancel 的处理流程。</p>
</blockquote>
<p>在后文 6.4.2 中会看到：基础机械臂控制通常通过 <code>FollowJointTrajectory</code> 动作接口，移动机器人则常通过 <code>cmd_vel</code> 话题来接收底盘速度命令，这些都是“上层算法 → ROS 接口 → 低层控制器”的典型组合。</p>
<hr>
<h3 id="642-常见机械臂--移动平台接口"><a class="header" href="#642-常见机械臂--移动平台接口">6.4.2 常见机械臂 / 移动平台接口</a></h3>
<p>虽然不同厂商的机器人在硬件和驱动上差异很大，但 ROS 社区逐渐形成了一套<strong>事实标准接口</strong>，使得上层算法（规划器、VLA 模型、RL 策略等）可以在不同机器人之间复用。</p>
<p>这一节只关心“接口长什么样”，而不再重复前面章节中关于运动学、动力学和控制律的推导。</p>
<h4 id="6421-机械臂接口followjointtrajectory-动作"><a class="header" href="#6421-机械臂接口followjointtrajectory-动作">6.4.2.1 机械臂接口：FollowJointTrajectory 动作</a></h4>
<p>在 ROS / ROS2 中，机械臂关节空间控制最常见的接口是 <code>control_msgs/FollowJointTrajectory</code> 动作。其定义大致如下：(<a href="https://docs.ros.org/jade/api/control_msgs/html/action/FollowJointTrajectory.html?utm_source=chatgpt.com">ROS Documentation</a>)</p>
<ul>
<li>动作目标（goal）里包含一条 <code>trajectory_msgs/JointTrajectory</code>：
<ul>
<li><code>joint_names</code>：关节名称数组，例如 <code>["shoulder_pan", "shoulder_lift", ...]</code>；</li>
<li><code>points</code>：多个时间点的轨迹，每个点包含 <code>positions</code>（必选）以及可选的 <code>velocities</code>、<code>accelerations</code>、<code>effort</code> 等，以及 <code>time_from_start</code>。</li>
</ul>
</li>
<li>执行反馈（feedback）常包含当前轨迹执行进度、误差等；</li>
<li>执行结果（result）包含成功/失败状态及错误原因。</li>
</ul>
<p>典型的使用方式是：</p>
<ol>
<li>上层规划器（例如 MoveIt 或自定义轨迹优化器）在关节空间规划出一条时间标定的轨迹；(<a href="https://moveit.picknik.ai/humble/doc/examples/controller_configuration/controller_configuration_tutorial.html?utm_source=chatgpt.com">MoveIt</a>)</li>
<li>将轨迹封装为 <code>FollowJointTrajectory</code> 的 goal 发送给控制器动作服务器（例如 <code>/arm_controller/follow_joint_trajectory</code>）；</li>
<li>控制器节点在内部以高频率运行（100–1000 Hz），对每个关节进行 PID 或更复杂的力矩控制，平滑跟踪整条轨迹；</li>
<li>上层仅需监控反馈和结果，不必关心控制细节。</li>
</ol>
<blockquote>
<p>【图片占位】
建议插图：</p>
<ul>
<li>上半部分：关节角度随时间变化的曲线（多条曲线），表示 <code>JointTrajectory</code>；</li>
<li>下半部分：<code>FollowJointTrajectory</code> Action 的数据结构示意，标注 <code>goal → trajectory → points</code> 的层级关系。</li>
</ul>
</blockquote>
<p>这种“轨迹作为目标、低层负责跟踪”的模式与 6.3 节的任务建模是自然衔接的：高层可以在末端空间规划轨迹，再用逆运动学转换为关节空间轨迹，最后交给 <code>FollowJointTrajectory</code> 执行。</p>
<h4 id="6422-移动底盘接口geometry_msgstwist-与-cmd_vel"><a class="header" href="#6422-移动底盘接口geometry_msgstwist-与-cmd_vel">6.4.2.2 移动底盘接口：geometry_msgs/Twist 与 /cmd_vel</a></h4>
<p>大多数差动轮或全向轮底盘在 ROS 中都会实现一个 <code>geometry_msgs/Twist</code> 话题接口，一般命名为 <code>/cmd_vel</code> 或类似名称。(<a href="https://docs.ros.org/diamondback/api/geometry_msgs/html/msg/Twist.html?utm_source=chatgpt.com">ROS Documentation</a>)</p>
<p><code>Twist</code> 的语义是“在某一坐标系下的线速度与角速度”：</p>
<ul>
<li><code>linear.x, linear.y, linear.z</code>：沿三个轴方向的线速度（单位 m/s）；</li>
<li><code>angular.x, angular.y, angular.z</code>：绕三个轴的角速度（单位 rad/s）。</li>
</ul>
<p>在常见的平面移动机器人中，通常只使用：(<a href="https://stackoverflow.com/questions/50976281/what-do-x-y-and-z-mean-in-geometry-msgs-twist-message-in-ros?utm_source=chatgpt.com">Stack Overflow</a>)</p>
<ul>
<li><code>linear.x</code>：前进/后退速度；</li>
<li><code>angular.z</code>：绕竖直 z 轴的旋转速度；</li>
<li>其余维度设置为 0。</li>
</ul>
<p>上层导航或 RL 策略节点只需要在固定频率（例如 10–20 Hz）上发布 <code>Twist</code> 消息，底盘驱动节点会将其转换为轮子的转速命令并执行。很多开源机器人平台（如多代 TurtleBot）都采用 <code>/cmd_vel</code> + <code>Twist</code> 作为默认接口。(<a href="https://kasimov.korea.ac.kr/wiki/doku.php/activity/public/2021/ros/6?utm_source=chatgpt.com">Kasimov</a>)</p>
<p>在工程实践中，通常需要注意几件事：</p>
<ul>
<li>为 <code>/cmd_vel</code> 话题设置<strong>超时机制</strong>：一段时间（如 0.5 s）没有新的命令则自动刹车，防止“僵尸速度命令”；</li>
<li>对线速度和角速度做<strong>饱和限制</strong>，避免策略输出异常值导致危险运动；</li>
<li>保证坐标系约定和前面 6.1 节中的位姿表示一致，例如 <code>base_link</code> 前方为 x 轴正方向。</li>
</ul>
<blockquote>
<p>【图片占位】
建议插图：一个差动轮机器人示意，标出 <code>linear.x</code> 指向前方、<code>angular.z</code> 绕竖直轴旋转的方向，使读者将 <code>Twist</code> 与物理运动对应起来。</p>
</blockquote>
<h4 id="6423-传感器与手爪接口标准消息与专用动作"><a class="header" href="#6423-传感器与手爪接口标准消息与专用动作">6.4.2.3 传感器与手爪接口：标准消息与专用动作</a></h4>
<p><strong>传感器接口</strong>方面，ROS 提供了 <code>sensor_msgs</code> 包，定义了常用传感器的标准消息，包括：(<a href="https://wiki.ros.org/sensor_msgs?utm_source=chatgpt.com">ROS Wiki</a>)</p>
<ul>
<li>相机：<code>sensor_msgs/Image</code>（原始图）、<code>sensor_msgs/CompressedImage</code>（压缩图）、<code>sensor_msgs/CameraInfo</code>（相机内参与畸变系数）；(<a href="https://docs.ros.org/en/noetic/api/sensor_msgs/html/msg/Image.html?utm_source=chatgpt.com">ROS Documentation</a>)</li>
<li>激光雷达：<code>sensor_msgs/LaserScan</code>（平面雷达）、<code>sensor_msgs/PointCloud</code> / <code>PointCloud2</code>（三维点云）；(<a href="https://docs.ros.org/jade/api/sensor_msgs/html/msg/LaserScan.html?utm_source=chatgpt.com">ROS Documentation</a>)</li>
<li>距离传感器：<code>sensor_msgs/Range</code>；(<a href="https://docs.ros2.org/foxy/api/sensor_msgs/msg/Range.html?utm_source=chatgpt.com">ROS 2 文档</a>)</li>
<li>关节状态：<code>sensor_msgs/JointState</code>（所有关节角度、速度、扭矩/电流等）。(<a href="https://emanual.robotis.com/docs/en/platform/openmanipulator_x/ros_controller_msg/?utm_source=chatgpt.com">ROBOTIS e-Manual</a>)</li>
</ul>
<p>实际使用时，通常由<strong>驱动节点</strong>（driver node）直接与硬件通信，并向这些标准话题发布消息。算法与 VLA 模型只需订阅标准化消息，而不必关心具体传感器品牌与通信协议，大幅提升了可移植性。</p>
<p><strong>机器人手爪（Gripper）接口</strong>通常有两类做法：</p>
<ol>
<li>将手爪视作“额外的关节”，使用 <code>sensor_msgs/JointState</code> 发布状态，再通过 <code>FollowJointTrajectory</code> 或 <code>JointTrajectoryController</code> 控制开合，如部分机械臂或仿真系统所采用的做法；(<a href="https://docs.ros.org/en/ros2_packages/rolling/api/control_msgs/action/ParallelGripperCommand.html?utm_source=chatgpt.com">ROS Documentation</a>)</li>
<li>使用专门的控制消息或动作，例如 <code>control_msgs/ParallelGripperCommand</code> 动作，其 goal 部分就是一个 <code>sensor_msgs/JointState</code>，包含期望的手爪开合位置和速度上限等参数。(<a href="https://docs.ros.org/en/ros2_packages/rolling/api/control_msgs/action/ParallelGripperCommand.html?utm_source=chatgpt.com">ROS Documentation</a>)</li>
</ol>
<blockquote>
<p>【图片占位】
建议插图：</p>
<ul>
<li>左：相机驱动节点发布 <code>Image</code> 和 <code>CameraInfo</code> 的话题结构；</li>
<li>右：机械臂末端手爪的关节示意图，标出 <code>JointState</code> 中 position/velocity/effort 的含义，以及 <code>ParallelGripperCommand</code> 要求的目标。</li>
</ul>
</blockquote>
<p>在实际 VLA 系统中，上层模型最好只依赖这些<strong>抽象接口</strong>（例如“可抓取区域 → 抓取姿态 → 转换成 <code>FollowJointTrajectory</code> + 手爪动作”）。这样，当更换机械臂或手爪时，只需要替换下层驱动与 ROS 接口，而无需重写上层策略。</p>
<hr>
<h3 id="643-实际实验室环境中的安全规范与调试流程"><a class="header" href="#643-实际实验室环境中的安全规范与调试流程">6.4.3 实际实验室环境中的安全规范与调试流程</a></h3>
<p>具身智能研究与纯软件实验相比，最重要的差异就是：<strong>机器人真能撞东西（包括人）</strong>。因此，在具身智能实验室中，安全与调试流程必须被视为系统设计的一部分，而不是“最后再补几条规则”。</p>
<p>国际标准（如工业机器人安全标准 ISO 10218 系列以及协作机器人标准 ISO/TS 15066）不断强调：应通过风险评估、急停装置、安全距离和限速等手段，将机器人对人和环境的风险降到可接受范围。(<a href="https://www.iso.org/obp/ui/en/?utm_source=chatgpt.com">国际标准化组织</a>)</p>
<h4 id="6431-安全第一硬件急停与工作空间管理"><a class="header" href="#6431-安全第一硬件急停与工作空间管理">6.4.3.1 安全第一：硬件急停与工作空间管理</a></h4>
<p>在进行任何机器人实验之前，建议首先检查<strong>硬件层面的安全功能</strong>：</p>
<ol>
<li><strong>急停按钮（Emergency Stop）</strong>
<ul>
<li>工业与协作机器人安全标准都明确要求必须配备可靠的急停装置，一旦触发可以立即切断电机驱动或进入安全刹车状态。(<a href="https://www.iso.org/obp/ui/en/?utm_source=chatgpt.com">国际标准化组织</a>)</li>
<li>每次实验开始前，应人为按下急停按钮进行功能测试（确认机器人确实停止，并记录指示灯状态）。</li>
</ul>
</li>
<li><strong>安全工作空间与隔离</strong>
<ul>
<li>对于桌面机械臂，可在地面或桌面划出<strong>安全区域</strong>和<strong>危险区域</strong>：例如用胶带在地上圈出机械臂可能扫过的最大范围。</li>
<li>对于高速或大负载机器人，建议使用 <strong>物理安全围栏</strong> 或光栅、扫描式安全传感器，确保非授权人员无法进入危险区域。(<a href="https://robotnik.eu/safety-requirements-for-industrial-robots-guarantee-of-collaboration-and-efficiency/?utm_source=chatgpt.com">robotnik.eu</a>)</li>
<li>在学生实验环境中，可以采用“只允许操作者在机器人后方操作终端，前方区域严禁站人”的简单规则。</li>
</ul>
</li>
<li><strong>软急停与软件安全约束</strong>
<ul>
<li>除硬件急停外，系统中要提供软件级“急停服务”，上一章提到的高层策略可以通过调用服务让底层立即停止轨迹或清空速度命令。</li>
<li>在 ROS 层面，可以设计一个统一的“安全监控节点”，订阅关节状态、力/扭矩传感器、距离传感器等，一旦发现异常（速度过高、接触力超限、传感器失效），立即发布刹车命令或触发停机动作。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图片占位】
建议插图：</p>
<ul>
<li>实验室平面示意：标出机器人、操作台、安全围栏、急停按钮的位置；</li>
<li>用不同颜色区分“安全观察区”“操作区”“禁止进入区”。</li>
</ul>
</blockquote>
<p>在具身智能研究中，机器人经常执行由学习策略生成的动作，<strong>其行为可能超出开发者预期</strong>，因此“默认安全、逐步放权”的原则尤为重要。</p>
<h4 id="6432-调试步骤从仿真到真实以低速单步推进"><a class="header" href="#6432-调试步骤从仿真到真实以低速单步推进">6.4.3.2 调试步骤：从仿真到真实，以低速单步推进</a></h4>
<p>为了避免对设备和环境造成不可逆的损伤，通常推荐采用如下渐进式调试流程：</p>
<ol>
<li><strong>仿真验证优先</strong>
<ul>
<li>在第 7 章将详细介绍各类仿真平台（Gazebo、Isaac Sim、MuJoCo 等），在这里只强调原则：</li>
<li>所有涉及运动规划、策略学习的算法，应当先在仿真环境中完成<strong>基本正确性和稳定性验证</strong>，例如路径是否自洽、关节限位是否被尊重、是否存在明显碰撞等。</li>
</ul>
</li>
<li><strong>上电后的人机共存检查</strong>
<ul>
<li>首次在真实机器人上运行新软件前，先在“零速度/零力矩”模式下检查：
<ul>
<li>关节编码器读数是否合理；</li>
<li>力矩/电流是否在安全范围内；</li>
<li>各类传感器（相机、激光雷达、IMU）数据是否正常更新。</li>
</ul>
</li>
</ul>
</li>
<li><strong>低速、单步模式调试</strong>
<ul>
<li><strong>机械臂</strong>：
<ul>
<li>先用手动示教器或简短 ROS 程序测试单个关节小幅运动；</li>
<li>再在小速度限制下执行简单点到点运动（例如 <code>FollowJointTrajectory</code> 仅包含两个点）；</li>
<li>在此过程中，观察机器人是否存在异常振动、末端路径是否与预期一致。(<a href="https://wiki.ros.org/joint_trajectory_action?utm_source=chatgpt.com">ROS Wiki</a>)</li>
</ul>
</li>
<li><strong>移动底盘</strong>：
<ul>
<li>首先在开阔空间，以极低线速度和角速度通过 <code>/cmd_vel</code> 指令测试前进、后退、左右旋转，确认速度尺度与方向正确；(<a href="https://kasimov.korea.ac.kr/wiki/doku.php/activity/public/2021/ros/6?utm_source=chatgpt.com">Kasimov</a>)</li>
<li>然后再加入避障逻辑和更复杂的导航。</li>
</ul>
</li>
</ul>
</li>
<li><strong>逐步提高自动化程度</strong>
<ul>
<li>初期阶段，由人工在终端发出简单命令、逐条执行动作；</li>
<li>随着系统稳定性提升，可以让机器人自动执行一段短轨迹或短任务，并在任务间隙让人复查状态；</li>
<li>最终才允许机器人在较大范围、较长时间内完全自动运行，同时需要配套安全监控与急停方案。</li>
</ul>
</li>
</ol>
<p>在 ROS / ROS2 中，有一些调试工具非常有用，但细节会在实践章节展开，这里只简单列举以便形成概念：</p>
<ul>
<li><code>rviz</code> / <code>rviz2</code>：可视化机器人模型、传感器数据（点云、图像）和规划轨迹；</li>
<li><code>rqt_graph</code>：可视化当前 ROS 图，帮助理解各节点和话题的连接关系；</li>
<li><code>rqt_plot</code>：绘制某个话题字段（如关节角度、控制误差）随时间的曲线；</li>
<li><code>rosbag</code> / <code>rosbag2</code>：录制与回放话题数据，是调试与数据分析的核心工具。(<a href="https://robertchoi.gitbook.io/ros2/02-ros2?utm_source=chatgpt.com">robertchoi.gitbook.io</a>)</li>
</ul>
<blockquote>
<p>【图片占位】
建议插图：</p>
<ul>
<li>一个“调试流程”流程图：从“仿真验证 → 真实机器人低速单步 → 自动执行短任务 → 长时间自动运行”的递进关系；</li>
<li>旁边标注每个阶段建议使用的 ROS 工具（rviz、rqt_plot、rosbag 等）。</li>
</ul>
</blockquote>
<h4 id="6433-日志与录像为错误留证据"><a class="header" href="#6433-日志与录像为错误留证据">6.4.3.3 日志与录像：为错误“留证据”</a></h4>
<p>在具身智能实验中，不可避免会出现各种“奇怪行为”：抓取失误、导航绕圈、机械臂突然震荡等。要想分析原因、改进系统，关键是<strong>在出问题之前就有足够的记录</strong>。</p>
<p>一般建议从三个层面进行记录：</p>
<ol>
<li><strong>传感器和控制数据日志（ROS bag）</strong>
<ul>
<li>使用 <code>rosbag</code>（ROS1）或 <code>rosbag2</code>（ROS2）录制关键话题，如：
<ul>
<li><code>/joint_states</code>、<code>/tf</code>（关节与坐标变换）；</li>
<li><code>/camera/image_raw</code>、<code>/scan</code> 或点云话题；</li>
<li><code>/cmd_vel</code>、<code>/arm_controller/follow_joint_trajectory/goal</code> 等控制命令。(<a href="https://robertchoi.gitbook.io/ros2/02-ros2?utm_source=chatgpt.com">robertchoi.gitbook.io</a>)</li>
</ul>
</li>
<li>日志文件可以在离线时回放，用于：
<ul>
<li>重现实验情景，调试算法；</li>
<li>离线训练或验证模型（与第 7 章的数据采集紧密相关，但这里重点仍在“调试用途”）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>关键变量与错误日志</strong>
<ul>
<li>在控制节点和策略节点中，为关键变量（如代价函数、RL 奖励、规划失败原因）添加日志输出，并通过 ROS 日志系统（<code>rosconsole</code> / <code>rclcpp</code> logging）集中管理。</li>
<li>对于容易出现数值问题的部分（优化器、神经网络推理）可以增加断言与异常捕获，一旦出错立即记录当前状态和输入。</li>
</ul>
</li>
<li><strong>视频录像与外部观察</strong>
<ul>
<li>使用固定位置的相机（俯视或侧视）录制实验过程，与 ROS bag 的时间戳对齐。</li>
<li>很多“看起来是感知问题”的错误，实际上可能是环境布置或机械结构问题，视频往往能给出关键线索。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图片占位】
建议插图：</p>
<ul>
<li>一条时间轴，上面标出“ROS bag 数据流”“控制变量曲线”“外部视频帧”；</li>
<li>示意如何将三者在时间戳上对齐，从而复现并分析一次失败的抓取或导航尝试。</li>
</ul>
</blockquote>
<p>在工程实践中，建议为每次重要实验赋予一个唯一的 <strong>实验 ID</strong>，并将以下信息统一关联：</p>
<ul>
<li>实验 ID；</li>
<li>使用的数据集版本、机器人配置（如机械臂型号、末端工具、传感器安装方式）；</li>
<li>所用代码的 Git 提交号；</li>
<li>对应的 rosbag 文件名与录像文件名；</li>
<li>实验简要备注（任务描述、是否成功）。</li>
</ul>
<p>这套“为错误留证据”的习惯，既是面向科研复现的基本要求，也将直接影响你在后续调试 VLA 模型时的效率。在更大的系统层面，这与第 9.4 节的 MLOps 与数据工程实践是相互呼应的：<strong>机器人系统的稳定性，往往取决于你能多快定位并修复 bug，而不是单次跑通的精彩 demo。</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="仿真平台"><a href="#仿真平台" class="header">仿真平台</a></h1>
<h3 id="711-常见仿真引擎mujocoisaac-gymgazebo-等"><a class="header" href="#711-常见仿真引擎mujocoisaac-gymgazebo-等">7.1.1 常见仿真引擎（MuJoCo、Isaac Gym、Gazebo 等）</a></h3>
<blockquote>
<p>【建议插图】图 7-1：三个典型仿真平台界面截图对比（MuJoCo 操作任务、Gazebo 移动机器人场景、Isaac Gym 并行训练示意），帮助读者直观认识它们的风格与定位。</p>
</blockquote>
<p>在具身智能和强化学习中，“仿真引擎 = 虚拟世界中的物理定律 + 传感器 + 机器人模型”。选择什么仿真平台，直接决定你能多快收集数据、物理是否可信、和实际机器人接口是否顺滑。</p>
<p>这里重点介绍三个在机器人和 RL 社区使用非常广泛的引擎 / 框架：MuJoCo、Gazebo 和 Isaac Gym（及其后继者）。</p>
<hr>
<h4 id="7111-mujoco"><a class="header" href="#7111-mujoco">7.1.1.1 MuJoCo</a></h4>
<p>MuJoCo（Multi-Joint dynamics with Contact）是 Google DeepMind 维护的开源物理引擎，专门面向机器人学、生物力学和机器学习。(<a href="https://mujoco.org/?utm_source=chatgpt.com">mujoco.org</a>)
它的特点可以概括为：<strong>高精度刚体动力学 + 强力接触模型 + 良好数学结构</strong>。</p>
<ol>
<li><strong>定位与典型用途</strong>
<ul>
<li>主要用于：机械臂操作、腿足机器人、各类连续控制基准环境（如 Gymnasium/MuJoCo 里的半倒立摆、Hopper、Walker2d、Humanoid 等）。(<a href="https://farama.org/Gymnasium-MuJoCo-v5_Environments?utm_source=chatgpt.com">The Farama Foundation</a>)</li>
<li>在强化学习社区非常流行，很多 RL 算法（DQN 之后的一大批连续控制算法）都是先在 MuJoCo 环境上做基准实验。(<a href="https://arxiv.org/html/2407.08590v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>建模方式与文件格式</strong></li>
</ol>
<p>这使得 MuJoCo 非常适合严肃的动力学研究与机器人控制算法验证。</p>
<pre><code>- MuJoCo 支持自有的 **MJCF（XML）模型格式**，也支持从 URDF 导入机器人模型。
- 在 MJCF 中可以精细指定：
    * 刚体的质量、惯量张量、几何形状；
    * 关节类型（转动、滑动、球铰等）和限制；
    * 摩擦参数（滑动、滚动、扭转摩擦）；
    * 执行器（电机、力控制、位置控制等）。([mujoco.org](https://mujoco.org/?utm_source=chatgpt.com))
</code></pre>
<ol start="3">
<li><strong>数值特点：快速而稳定</strong>
<ul>
<li>MuJoCo 使用基于约束优化的接触求解与高效的隐式积分方法，能在保持较高精度的同时支持较大的时间步长。(<a href="https://arxiv.org/html/2407.08590v1?utm_source=chatgpt.com">arXiv</a>)</li>
<li>对 RL 来说，这意味着：在不牺牲太多物理精度的前提下，能以较快的仿真速度收集大量交互数据。</li>
</ul>
</li>
<li><strong>MuJoCo + GPU：MJX 的出现</strong>
<ul>
<li>在新版本中，MuJoCo 提供了 <strong>MJX</strong> 模块，基于 XLA 在 GPU/TPU 上对一大批并行环境进行向量化仿真，专门为大规模强化学习优化。(<a href="https://mujoco.readthedocs.io/en/stable/mjx.html?utm_source=chatgpt.com">mujoco.readthedocs.io</a>)</li>
<li>适用场景：需要像 Isaac Gym 那样同时跑成百上千个环境，但希望保持 MuJoCo 的接触精度和建模灵活性。</li>
</ul>
</li>
<li><strong>适合什么读者 / 项目？</strong>
<ul>
<li>如果你：
<ul>
<li>更关心<strong>单个机器人动作的精细动力学</strong>（例如操作、腿足）；</li>
<li>主要在 <strong>Python + RL 框架</strong>（Gymnasium、Stable-Baselines3 等）中工作；</li>
<li>不太需要复杂、精美的 3D 渲染和多机器人城市级场景；</li>
</ul>
</li>
<li>那么 MuJoCo 通常是一个非常合适的仿真“底座”。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="7112-gazebo"><a class="header" href="#7112-gazebo">7.1.1.2 Gazebo</a></h4>
<p>Gazebo 是由 Open Robotics 社区维护的开源 3D 机器人模拟器，是 ROS/ROS2 生态中事实上的“官方”仿真标准之一。(<a href="https://gazebosim.org/?utm_source=chatgpt.com">gazebosim.org</a>)</p>
<ol>
<li><strong>Gazebo Classic 与 Gazebo Sim 的演化</strong>
<ul>
<li>早期版本被称为 <strong>Gazebo Classic</strong>，集成了 ODE 等物理引擎、OpenGL 渲染以及丰富的传感器模型。(<a href="https://classic.gazebosim.org/?utm_source=chatgpt.com">classic.gazebosim.org</a>)</li>
<li>之后社区推出了模块化的 <strong>Ignition Gazebo</strong>，后来由于商标问题又统一改名为 <strong>Gazebo（Gazebo Sim）</strong>，而原先旧版本则称为 Gazebo Classic。(<a href="https://en.wikipedia.org/wiki/Gazebo_%28simulator%29?utm_source=chatgpt.com">维基百科</a>)</li>
<li>当前推荐在 ROS2 + Ubuntu 新版本上使用的是现代的 Gazebo Sim。(<a href="https://docs.px4.io/main/en/sim_gazebo_gz/?utm_source=chatgpt.com">PX4 文档</a>)</li>
</ul>
</li>
<li><strong>Gazebo 的核心能力</strong>
<ul>
<li><strong>复杂场景建模</strong>：室内、室外、城市级别环境，支持多机器人、多传感器、天气和光照等。(<a href="https://gazebosim.org/?utm_source=chatgpt.com">gazebosim.org</a>)</li>
<li><strong>多物理引擎支持</strong>：可以切换 ODE、Bullet、DART 等物理后端（不同引擎在接触、稳定性和速度上表现略有不同）。(<a href="https://classic.gazebosim.org/?utm_source=chatgpt.com">classic.gazebosim.org</a>)</li>
<li><strong>丰富传感器</strong>：RGB/深度相机、激光雷达、IMU、GPS 等，都有内置插件和噪声建模。(<a href="https://www.theconstruct.ai/robotigniteacademy_learnros/ros-courses-library/introduction-to-gazebo-sim-with-ros2-online-course/?utm_source=chatgpt.com">theconstruct.ai</a>)</li>
<li><strong>与 ROS 深度集成</strong>：Gazebo 中的机器人通常通过 ROS topic/service/action 对接到控制和感知节点，是实验室中调试移动机器人、无人机的标准工具链。(<a href="https://gazebosim.org/docs/latest/ros_installation/?utm_source=chatgpt.com">gazebosim.org</a>)</li>
</ul>
</li>
<li><strong>典型使用场景</strong>
<ul>
<li>移动机器人导航、SLAM、编队控制；</li>
<li>服务机器人在家庭、仓储、工厂等环境中的任务验证；</li>
<li>将真实系统的 ROS 节点“直接接到仿真上”，实现软硬件在环（HIL）测试。</li>
</ul>
</li>
<li><strong>优势与局限</strong>
<ul>
<li>优点：
<ul>
<li>场景、传感器、ROS 接口非常成熟，适合**“真实机器人系统”级**的仿真；</li>
<li>图形界面友好，新手易上手。(<a href="https://www.theconstruct.ai/robotigniteacademy_learnros/ros-courses-library/introduction-to-gazebo-sim-with-ros2-online-course/?utm_source=chatgpt.com">theconstruct.ai</a>)</li>
</ul>
</li>
<li>局限：
<ul>
<li>主要在 CPU 上运行，在需要百万级时间步的强化学习训练时，速度往往远不如 GPU 并行仿真框架；</li>
<li>物理精度足以满足多数工程应用，但在细致接触建模上不如 MuJoCo 等专门引擎灵活。</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<h4 id="7113-isaac-gym及-isaac-sim--isaac-lab"><a class="header" href="#7113-isaac-gym及-isaac-sim--isaac-lab">7.1.1.3 Isaac Gym（及 Isaac Sim / Isaac Lab）</a></h4>
<p>Isaac Gym 是 NVIDIA 发布的一款面向强化学习的 GPU 加速仿真框架，可将<strong>物理仿真 + RL 计算</strong>都放在 GPU 上执行，从而获得 2–3 个数量级的加速。(<a href="https://medium.com/syncedreview/nvidias-isaac-gym-end-to-end-gpu-accelerated-physics-simulation-expedites-robot-learning-by-2-3-d94d2d2c3a8?utm_source=chatgpt.com">Medium</a>)</p>
<ol>
<li><strong>核心思想：端到端 GPU 仿真</strong>
<ul>
<li>传统做法：仿真在 CPU，神经网络在 GPU，中间需要大量数据在 CPU/GPU 间来回拷贝。</li>
<li>Isaac Gym：仿真由 GPU 驱动，物理结果直接以 Torch/Tensor 形式保存在显存中，RL 的状态、奖励计算也在 GPU 完成。(<a href="https://docs.robotsfan.com/isaacgym/about_gym.html?utm_source=chatgpt.com">docs.robotsfan.com</a>)</li>
<li>实际效果：在典型连续控制任务上能比传统 CPU 仿真 + GPU 学习快 100–1000 倍。(<a href="https://medium.com/syncedreview/nvidias-isaac-gym-end-to-end-gpu-accelerated-physics-simulation-expedites-robot-learning-by-2-3-d94d2d2c3a8?utm_source=chatgpt.com">Medium</a>)</li>
</ul>
</li>
<li><strong>与 PhysX / Isaac Sim / Isaac Lab 的关系</strong>
<ul>
<li>Isaac Gym 使用 NVIDIA <strong>PhysX</strong> 作为物理后端，与基于 Omniverse 的 <strong>Isaac Sim</strong> 在物理实现上逐渐对齐，以便未来迁移策略到 Isaac Sim。(<a href="https://developer.nvidia.com/isaac-gym?utm_source=chatgpt.com">NVIDIA Developer</a>)</li>
<li>目前 Isaac Gym 已被官方标记为 <strong>deprecated（不再维护）</strong>，推荐迁移到基于 Isaac Sim 的开源框架 <strong>Isaac Lab</strong>。(<a href="https://forums.developer.nvidia.com/c/robotics-edge-computing/isaac/isaac-gym/322?utm_source=chatgpt.com">NVIDIA Developer Forums</a>)</li>
<li>Isaac Lab 延续了 Isaac Gym 的 GPU-native 并行仿真思路，但利用 Omniverse/Isaac Sim 提供的高保真渲染、USD 场景描述等能力，用于大规模多模态学习。(<a href="https://arxiv.org/html/2511.04831v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>典型使用方式</strong>
<ul>
<li>编写 Python 环境（IsaacGymEnvs / Isaac Lab），一次性创建上千个并行环境；</li>
<li>每次仿真 step，返回 GPU 上的张量：观测、奖励、done 标志等；</li>
<li>直接在同一块 GPU 上运行 RL 算法（如 PPO/SAC），实现极高吞吐量的数据收集。(<a href="https://docs.robotsfan.com/isaacgym/about_gym.html?utm_source=chatgpt.com">docs.robotsfan.com</a>)</li>
</ul>
</li>
<li><strong>趋势：统一物理引擎与开源生态</strong>
<ul>
<li>NVIDIA、Google DeepMind 等机构正在联合开发新的开源物理引擎 Newton，使其可与 MuJoCo、Isaac Lab 等框架配合使用，目标是统一高精度物理仿真与机器人学习生态。(<a href="https://developer.nvidia.com/blog/announcing-newton-an-open-source-physics-engine-for-robotics-simulation/?utm_source=chatgpt.com">NVIDIA Developer</a>)</li>
</ul>
</li>
</ol>
<p>对初学者来说：如果你计划做大量仿真-强化学习实验，而实验室已有 NVIDIA GPU 硬件，那么学习 Isaac Sim / Isaac Lab 的工作流会是非常现实的选择；而理论上讲，MuJoCo + MJX 也在向类似方向发展。</p>
<hr>
<h3 id="712-物理仿真中的关键参数摩擦接触时间步长"><a class="header" href="#712-物理仿真中的关键参数摩擦接触时间步长">7.1.2 物理仿真中的关键参数（摩擦、接触、时间步长）</a></h3>
<blockquote>
<p>【建议插图】图 7-2：一个方块在桌面上被推动的示意图，分别标注法向力、摩擦力、接触点和时间离散步长，帮助读者把抽象参数与直觉联系起来。</p>
</blockquote>
<p>物理引擎的任务是数值求解“机器人 + 环境”的动力学方程。对于具身智能来说，三类参数尤为关键：</p>
<ul>
<li>摩擦（决定“滑不滑”）</li>
<li>接触模型（决定“撞上去是弹开、卡住，还是穿透”）</li>
<li>时间步长（决定“算得稳不稳、快不快”）</li>
</ul>
<p>理解这些参数的意义与调节方法，是从“会跑 demo”走向“能做严肃仿真研究”的第一步。</p>
<hr>
<h4 id="7121-摩擦系数"><a class="header" href="#7121-摩擦系数">7.1.2.1 摩擦系数</a></h4>
<p>在简化模型中，摩擦力大小通常近似为
$$
F_{\text{friction}} = \mu F_N
$$
其中 (F_N) 是法向支撑力，(\mu) 是摩擦系数（无量纲）。</p>
<ol>
<li><strong>静摩擦 vs 动摩擦</strong>
<ul>
<li><strong>静摩擦系数</strong> (\mu_s)：物体刚要滑动前的摩擦，决定“起滑难度”。</li>
<li><strong>动摩擦系数</strong> (\mu_k)：物体已经滑动时的摩擦，一般略小于静摩擦。</li>
<li>许多仿真引擎用统一的“滑动摩擦系数”来近似上述效果，也有引擎提供更细致区分。(<a href="https://arxiv.org/html/2407.08590v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>摩擦在机器人任务中的影响</strong>
<ul>
<li>抓取：摩擦过小，物体一夹就滑走；摩擦过大，仿真中可以“粘”住物体，现实中却会掉落。</li>
<li>推动：摩擦决定推手与物体之间的“咬合”程度，直接影响最优策略（推还是抬）。</li>
<li>行走：腿足机器人或轮式机器人需要足够摩擦才能产生牵引力，摩擦过小仿真中会频繁打滑。</li>
</ul>
</li>
<li><strong>实际建模建议</strong>
<ul>
<li><strong>从真实材料参数起步</strong>：查表或测量典型材料组合（橡胶-木板、金属-塑料等）的摩擦系数范围，在仿真中设定相近值。(<a href="https://www.sciencedirect.com/science/article/pii/S2212827123006170?utm_source=chatgpt.com">科学直通车</a>)</li>
<li><strong>仿真-现实对齐</strong>：在真实平台上做简单实验（推箱子、抓取同一物体），调整摩擦参数直到仿真和现实的行为相似。</li>
<li><strong>避免极端取值</strong>：(\mu) 过大可能导致数值不稳定或不自然“粘连”；过小则动作普遍打滑，策略学习难度急剧上升。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="7122-接触模型"><a class="header" href="#7122-接触模型">7.1.2.2 接触模型</a></h4>
<p>现实世界中，物体接触本质上是弹性变形、微观粗糙度和材料内部结构的复杂结果。仿真中通常用简化模型来近似：</p>
<ol>
<li><strong>接触检测（collision detection）</strong>
<ul>
<li>判断两个几何体是否相交，并找出接触点、接触法向量和穿透深度。</li>
<li>不同引擎支持的几何体种类不同（球、盒、圆柱、网格等），复杂网格模型虽然真实但会增加计算成本。(<a href="https://classic.gazebosim.org/?utm_source=chatgpt.com">classic.gazebosim.org</a>)</li>
</ul>
</li>
<li>**接触响应（contact resolution）**常见的两大类方法：</li>
</ol>
<p>典型参数包括：</p>
<pre><code>- **惩罚法（penalty method）**
</code></pre>
<p>将穿透看作弹簧压缩，引入法向弹簧刚度 (k) 和阻尼 (d)，产生恢复力和阻尼力；再叠加摩擦模型。
* 优点：实现简单、计算快；
* 缺点：刚度过大时数值刚性强，容易发散，只能用很小的时间步长。
- <strong>约束法（constraint-based）</strong>
通过求解线性互补问题（LCP）或二次规划（QP），显式施加“不能穿透”约束，对法向力和切向摩擦进行联合求解。MuJoCo、某些 PhysX 配置属于这一类。(<a href="https://arxiv.org/html/2407.08590v1?utm_source=chatgpt.com">arXiv</a>)
- 法向刚度 / 阻尼：决定“撞上去”是软弹还是硬碰；
- 恢复系数（restitution）：决定反弹高度（0 代表完全不弹，1 接近完美弹性）；
- 最大摩擦力 / 摩擦锥近似的细节。
3. <strong>数值问题与调参</strong>
- 接触参数不合理时，仿真中常见“物体抖动”“轻微穿透”“叠放物体慢慢滑走”等现象；
- 在 PhysX/Isaac 中，还可以调整 <code>rest_offset</code> 和 <code>contact_offset</code> 这类参数控制接触启发式，平衡精度和稳定性。(<a href="https://developer.nvidia.com/isaac-gym?utm_source=chatgpt.com">NVIDIA Developer</a>)
- 建议做“小测试场景”：两个盒子叠放、物体落地弹跳等，用于观察接触参数改变的效果。</p>
<hr>
<h4 id="7123-时间步长time-step"><a class="header" href="#7123-时间步长time-step">7.1.2.3 时间步长（time step）</a></h4>
<p>时间步长 (\Delta t) 是离散化仿真时间的粒度：每一步仿真实际代表 (\Delta t) 秒的物理过程。</p>
<ol>
<li><strong>时间步长与数值稳定性</strong>
<ul>
<li>多数引擎使用显式或半隐式积分方法，时间步长过大时，刚体和接触系统会变得不稳定——表现为速度爆炸、关节乱飞。(<a href="https://arxiv.org/html/2407.08590v1?utm_source=chatgpt.com">arXiv</a>)</li>
<li>接触越“刚”（刚度越高）、系统频率越高，<strong>所需时间步长越小</strong>。这和数值分析中的稳定性界限是一致的。</li>
</ul>
</li>
<li><strong>仿真频率、控制频率与渲染频率</strong>
<ul>
<li>仿真频率：(f_{\text{sim}} = 1/\Delta t)，例如 (\Delta t = 0.001s) 对应 1000 Hz。</li>
<li>控制频率：机器人策略输出动作的频率（可以是仿真每步都控制，也可以每 N 步控制一次）。</li>
<li>渲染频率：画面刷新的频率，一般远低于仿真频率。
在 RL 任务中常用的配置是：仿真以 500–1000 Hz 运行，每 10–20 步向策略暴露一次状态，相当于 25–100 Hz 的控制频率。</li>
</ul>
</li>
<li><strong>速度与精度的权衡</strong>
<ul>
<li>较小的 (\Delta t)：
<ul>
<li>优点：接触更稳定、轨迹更平滑；</li>
<li>缺点：同样的物理时间会有更多步，计算负担加重。</li>
</ul>
</li>
<li>较大的 (\Delta t)：
<ul>
<li>优点：计算更快；</li>
<li>缺点：需要更激进的数值技巧与接触调参，否则容易出现物体穿透、机器人行为不自然。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>在后续的 Sim2Real 中（见 7.1.4 节），时间步长的选择也会影响策略迁移：仿真中如果用了远大于控制周期的步长，策略学到的“微分方程”可能和真实机器人不一致。</p>
<hr>
<h3 id="713-仿真场景搭建与任务脚本编写"><a class="header" href="#713-仿真场景搭建与任务脚本编写">7.1.3 仿真场景搭建与任务脚本编写</a></h3>
<blockquote>
<p>【建议插图】图 7-3：从“模型文件（URDF/MJCF/USD）→ 仿真场景（机器人 + 环境 + 传感器）→ 任务脚本（reset/step/reward）”的流程图。</p>
</blockquote>
<p>从 VLA 模型的角度看，一个“仿真任务”至少包括：</p>
<ul>
<li>世界：机器人、物体、障碍和相机等组成的场景；</li>
<li>接口：如何从仿真中读出状态（观测），向仿真写入动作；</li>
<li>协议：任务的开始、结束和评测方式。</li>
</ul>
<hr>
<h4 id="7131-场景搭建"><a class="header" href="#7131-场景搭建">7.1.3.1 场景搭建</a></h4>
<p>无论是 MuJoCo、Gazebo 还是 Isaac 系列，场景搭建的核心思路是相似的。</p>
<ol>
<li><strong>机器人模型导入</strong>
<ul>
<li>使用 URDF / SDF / MJCF / USD 等格式描述机器人结构：连杆、关节、惯量、关节限制。(<a href="https://mujoco.org/?utm_source=chatgpt.com">mujoco.org</a>)</li>
<li>检查：
<ul>
<li>单位是否统一（米 / 千克 / 牛顿）；</li>
<li>关节方向和零位是否符合真实机器人；</li>
<li>关节上下界与真实硬件一致。</li>
</ul>
</li>
</ul>
</li>
<li><strong>环境与物体建模</strong>
<ul>
<li>地面（ground plane）、桌面、货架等静态几何体，可简化为平面 / 盒子 / 圆柱等基本形状；</li>
<li>目标物体：尽量用简单但形状接近的碰撞几何体（如用盒子近似复杂物体的碰撞体），视觉网格可以更精细；(<a href="https://gazebosim.org/?utm_source=chatgpt.com">gazebosim.org</a>)</li>
<li>设置物体的质量和摩擦参数，使其在仿真中表现与现实近似（例如同样的推力下移动距离相近）。</li>
</ul>
</li>
<li><strong>传感器配置</strong>
<ul>
<li>相机：位置、朝向、分辨率、视场角、更新频率和噪声模型；</li>
<li>深度相机 / LiDAR：射线数量、最大测距、噪声；</li>
<li>关节传感器：是否存在测量噪声、延迟。(<a href="https://www.theconstruct.ai/robotigniteacademy_learnros/ros-courses-library/introduction-to-gazebo-sim-with-ros2-online-course/?utm_source=chatgpt.com">theconstruct.ai</a>)</li>
</ul>
</li>
<li><strong>坐标系与标定</strong>
<ul>
<li>明确世界坐标系（world）、机器人基座坐标系（base）、末端执行器坐标系（ee）、相机坐标系（camera）；</li>
<li>在仿真场景中，保证这些变换与真实系统（手眼标定等）一致，方便后续 Sim2Real。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="7132-任务脚本"><a class="header" href="#7132-任务脚本">7.1.3.2 任务脚本</a></h4>
<p>场景只是“静态世界”；要让机器人“活起来”，需要任务脚本来定义交互逻辑。一般需要明确以下元素：</p>
<ol>
<li><strong>环境接口设计</strong>典型的 RL / 控制任务接口可以写成类似 Gym 的风格：</li>
</ol>
<p>MuJoCo、Gazebo 和 Isaac Gym / Isaac Lab都提供 Python/C++ API，用于在脚本中驱动物理步进和读写状态。(<a href="https://mujoco.org/?utm_source=chatgpt.com">mujoco.org</a>)</p>
<pre><code>- `reset()`：重置环境到初始状态（放置物体、随机扰动姿态、清零累计奖励等）；
- `step(action)`：执行一个动作步长，返回
    * 观测 `obs`（视觉、关节状态、语言上下文等）；
    * 标量奖励 `reward`；
    * 是否结束 `done`；
    * 额外信息 `info`。
</code></pre>
<ol start="2">
<li><strong>重置与随机化</strong>
<ul>
<li>重置时可以对物体初始位置、姿态、材质、光照、摄像机位置等进行随机化，为后续的域随机化和泛化打基础；(<a href="https://xbpeng.github.io/projects/SimToReal/index.html?utm_source=chatgpt.com">Xue Bin Peng</a>)</li>
<li>注意重置逻辑要<strong>确定且可重复</strong>，使用固定随机种子方便实验复现。</li>
</ul>
</li>
<li><strong>奖励函数与终止条件</strong>
<ul>
<li>奖励函数应与任务成功定义对应，例如：
<ul>
<li>抓取任务：抓取成功 +1，碰撞或超时 −1，其余为 0 或小的 shaping 奖励；</li>
<li>导航任务：每前进一步给少量负奖励，逼近目标给正奖励，撞墙大负奖励。</li>
</ul>
</li>
<li>终止条件：达到目标、失败（跌倒、掉落）或超时。
这些设计与第 5 章中的 RL 设置一一对应，只是现在在具体仿真环境中实现。</li>
</ul>
</li>
<li><strong>任务复杂度与课程设计</strong>
<ul>
<li>初学者可从“单物体、静态场景、无干扰”做起，逐渐引入多物体、移动障碍、随机初始状态等难度，形成“仿真课程学习”。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="7133-自动化评测"><a class="header" href="#7133-自动化评测">7.1.3.3 自动化评测</a></h4>
<p>一旦任务脚本搭建完成，就需要自动化评测来判断算法或 VLA 模型的好坏。</p>
<ol>
<li><strong>批量运行与指标统计</strong>
<ul>
<li>多次运行环境（如 100 或 1000 回合），统计：
<ul>
<li>任务成功率；</li>
<li>平均完成时间 / 步数；</li>
<li>平均奖励、最差奖励等。</li>
</ul>
</li>
<li>对于并行仿真框架（MuJoCo MJX、Isaac Gym/Isaac Lab），可以一次性在 GPU 上同时评测大量环境，加速统计。(<a href="https://mujoco.readthedocs.io/en/stable/mjx.html?utm_source=chatgpt.com">mujoco.readthedocs.io</a>)</li>
</ul>
</li>
<li><strong>日志与可视化</strong>
<ul>
<li>记录每步的状态、动作、奖励到日志文件（如 Python pickle、HDF5、ROS bag 等），方便之后做离线分析；(<a href="https://gazebosim.org/docs/latest/ros_installation/?utm_source=chatgpt.com">gazebosim.org</a>)</li>
<li>保存关键回合的渲染视频或截图，便于定性检查策略行为是否合理。</li>
</ul>
</li>
<li><strong>基准化与消融实验</strong>
<ul>
<li>对同一环境，使用不同算法 / 模型结构 / 超参数进行对比；</li>
<li>设计消融实验（移除某个模块或训练阶段）观察性能变化，为后续论文写作提供可靠证据。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="714-仿真现实差距的来源与缓解方法"><a class="header" href="#714-仿真现实差距的来源与缓解方法">7.1.4 仿真–现实差距的来源与缓解方法</a></h3>
<blockquote>
<p>【建议插图】图 7-4：“仿真世界”和“真实世界”两个气泡，中间标注各种差异（视觉、摩擦、延迟等），并标出几种典型弥补方法（域随机化、实机微调等）。</p>
</blockquote>
<p>在第 5.4.2 节我们已经从强化学习角度讨论过 Sim2Real 的困难与策略，这里从<strong>仿真平台和物理建模</strong>的角度，系统梳理一下“仿真–现实差距”（reality gap）的主要来源及缓解手段。</p>
<hr>
<h4 id="7141-传感器差异"><a class="header" href="#7141-传感器差异">7.1.4.1 传感器差异</a></h4>
<ol>
<li><strong>视觉传感器</strong>仿真渲染通常是“完美”的：</li>
</ol>
<p>现实中的视觉传感器则充满各种非理想因素，使得“同一场景”的图像在仿真和现实之间分布差异巨大（domain shift），从而导致 VLA 模型在实际相机图像上表现显著变差。</p>
<pre><code>- 不存在真实相机中的噪声、模糊、曝光不均、白平衡漂移；
- 深度相机在仿真中往往没有“测不出”的洞、反射、红外干扰；
- 视角、畸变等也常常被设为理想值。([theconstruct.ai](https://www.theconstruct.ai/robotigniteacademy_learnros/ros-courses-library/introduction-to-gazebo-sim-with-ros2-online-course/?utm_source=chatgpt.com))
</code></pre>
<ol start="2">
<li><strong>其他传感器</strong>
<ul>
<li>力 / 力矩传感器：现实中存在非线性、漂移和噪声，仿真常常给的是“干净数值”；</li>
<li>关节编码器：现实中会有量化误差、背隙、延迟等；</li>
<li>IMU：现实的陀螺仪 / 加速度计具有偏置和随机游走，仿真若不建模这些噪声，则会低估算法对噪声的敏感性。</li>
</ul>
</li>
<li><strong>缓解思路（传感器侧）</strong>
<ul>
<li><strong>域随机化（Domain Randomization）</strong>：在仿真中随机改变纹理、光照、相机姿态、噪声等，使模型学到对这些变化不敏感。(<a href="https://xbpeng.github.io/projects/SimToReal/index.html?utm_source=chatgpt.com">Xue Bin Peng</a>)</li>
<li><strong>真实感渲染 + 噪声建模</strong>：使用 Isaac Sim 等提供的物理化渲染（PBR）、相机噪声模型，尽量逼近实际摄像机特性。(<a href="https://developer.nvidia.com/blog/advancing-robot-learning-perception-and-manipulation-with-latest-nvidia-isaac-release/?utm_source=chatgpt.com">NVIDIA Developer</a>)</li>
<li><strong>Real-to-Sim 校准</strong>：根据真实相机标定和采集的图像统计特性（噪声分布、伽马、失真参数）调整仿真渲染管线。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="7142-动力学差异"><a class="header" href="#7142-动力学差异">7.1.4.2 动力学差异</a></h4>
<p>物理引擎做的是某种“理想模型”的数值求解，而真实机器人系统充满各种非理想性。</p>
<ol>
<li><strong>未建模 / 误建模的物理因素</strong>
<ul>
<li>质量、惯量估计不准；</li>
<li>关节摩擦、刚度、阻尼设置与真实系统不符；</li>
<li>马达和驱动链路（齿轮间隙、柔性连杆、电机饱和和延迟等）未建模或严重简化。(<a href="https://www.sciencedirect.com/science/article/pii/S2212827123006170?utm_source=chatgpt.com">科学直通车</a>)</li>
</ul>
</li>
<li><strong>接触与摩擦的不确定性</strong>
<ul>
<li>地面材质不均匀、灰尘和磨损使摩擦系数随时间变化；</li>
<li>物体边缘细节、变形、微小不规则都难以用刚体接触模型捕捉。
这些都会导致在仿真中学到的“最优动作”在真实环境下效果不佳甚至失败。</li>
</ul>
</li>
<li><strong>缓解思路（动力学侧）</strong>
<ul>
<li><strong>系统辨识 + 参数调优</strong>：利用真实机器人数据（例如手动施加已知力矩，测量响应）来拟合质量、摩擦等参数，然后在 MuJoCo、PhysX 等仿真器中调整模型，使“仿真响应曲线 ≈ 实机响应”。(<a href="https://www.sciencedirect.com/science/article/pii/S2212827123006170?utm_source=chatgpt.com">科学直通车</a>)</li>
<li><strong>动力学域随机化</strong>：在训练时随机扰动物理参数（质量、摩擦系数、关节阻尼等），使策略对这些参数变化更加鲁棒。(<a href="https://arxiv.org/abs/2110.03239?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ol>
<hr>
<h4 id="7143-差距缓解综合策略"><a class="header" href="#7143-差距缓解综合策略">7.1.4.3 差距缓解：综合策略</a></h4>
<p>现实中往往需要多种方法联合使用，才能将仿真-现实差距控制在可接受范围内。</p>
<ol>
<li><strong>域随机化（Domain Randomization）</strong>
<ul>
<li>在仿真训练中同时随机化：
<ul>
<li>视觉域：材质、颜色、光照、相机姿态、噪声；</li>
<li>动力学域：质量、摩擦、关节阻尼、控制延迟；</li>
<li>场景布置：物体位置、数量、尺寸。(<a href="https://xbpeng.github.io/projects/SimToReal/index.html?utm_source=chatgpt.com">Xue Bin Peng</a>)</li>
</ul>
</li>
<li>理论与实践均表明，在一定条件下，域随机化可以理论上保证策略对真实世界的泛化上界。(<a href="https://arxiv.org/abs/2110.03239?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>Sim-Real 协同训练与离线域优化</strong>
<ul>
<li>利用少量真实机器人轨迹来<strong>微调</strong>策略或奖励模型，以“修正”纯仿真训练中的偏差；(<a href="https://www.sciencedirect.com/science/article/pii/S0921889023000714?utm_source=chatgpt.com">科学直通车</a>)</li>
<li>或者像 DROPO 这类方法一样，用有限的真实数据来优化域随机化的分布，使仿真域更贴近真实域。(<a href="https://www.sciencedirect.com/science/article/pii/S0921889023000714?utm_source=chatgpt.com">科学直通车</a>)</li>
</ul>
</li>
<li><strong>Real-to-Sim：用真实数据改善仿真器</strong>
<ul>
<li>通过真实数据来校准渲染、传感器噪声和动力学参数，使仿真世界“更像现实”；</li>
<li>一部分工作在此基础上构建世界模型（world model），在模型内部做规划，再在现实中验证。(<a href="https://arxiv.org/abs/2510.20808?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>抽象与层次化控制</strong>
<ul>
<li>将低层连续控制抽象为更高层的技能或离散动作（例如“抓取”“放置”“移动到桌子左侧”），让策略主要在更抽象、对物理细节不那么敏感的层面上做决策；</li>
<li>低层则采用传统控制（PID、轨迹跟踪）和安全约束来屏蔽部分动力学差异。(<a href="https://arxiv.org/abs/2510.20808?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ol>
<p>从本书整体结构看，本节更多聚焦在“仿真器和物理参数”这一环，而第 5 章、9 章则分别从 <strong>强化学习算法</strong> 和 <strong>训练范式 / 数据工程</strong> 的角度继续展开。掌握这一节的内容，你就已经从“会用仿真跑 demo”迈向了“能用仿真认真做具身智能研究”的台阶。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="数据采集与示教方式"><a href="#数据采集与示教方式" class="header">数据采集与示教方式</a></h1>
<p>下面这一小节可以直接作为你书中的 7.2.* 内容使用，我按你给的层级结构展开，并尽量和前后章节衔接、避免重复。</p>
<hr>
<h3 id="721-teleoperation遥操作采集轨迹"><a class="header" href="#721-teleoperation遥操作采集轨迹">7.2.1 Teleoperation（遥操作）采集轨迹</a></h3>
<p>在上一节我们主要在仿真中“造世界”。从本节开始，重点转向“造数据”：如何让人类通过各种方式把自己的操作经验变成可以训练 VLA 模型的轨迹。最常见的一类方式就是 <strong>遥操作（teleoperation）</strong>——人类远程控制机器人完成任务，系统同时记录传感器和控制信号。</p>
<blockquote>
<p>【图 7-xx 占位：展示一个典型遥操作系统：人戴 VR 头显和手柄，通过网络控制桌面机械臂抓取物体；图中用箭头标出“人 → 控制设备 → 控制信号 → 机器人 → 相机图像回传 → 人”。】</p>
</blockquote>
<h4 id="7211-遥操作方式"><a class="header" href="#7211-遥操作方式">7.2.1.1 遥操作方式</a></h4>
<p>遥操作并不只是一种形态，而是一大类接口家族，大致可按“人是怎样发出控制信号”的角度来区分：</p>
<ol>
<li><strong>传统输入设备：手柄、键鼠、SpaceMouse 等</strong>
<ul>
<li>工业和实验室环境里最常见的是 <strong>摇杆 / 游戏手柄 / SpaceMouse</strong> 等六自由度输入设备，用来控制机械臂末端的平移、旋转和夹爪开合。(<a href="https://robin-lab.cs.utexas.edu/telemoma-web/static/pdfs/telemoma.pdf?utm_source=chatgpt.com">robin-lab.cs.utexas.edu</a>)</li>
<li>优点是硬件便宜、部署简单；缺点是学习曲线较陡，操作长期高精度任务比较累。</li>
</ul>
</li>
<li><strong>虚拟现实（VR）遥操作</strong>
<ul>
<li>使用 <strong>VR 头显 + 手柄</strong>，将机器人所在环境渲染到用户眼前，用户通过自然的手部动作控制机械臂末端姿态，已有工作用 VR 接口大量采集操作演示，用于模仿学习和 VLA 训练。(<a href="https://arxiv.org/html/2510.08807v1?utm_source=chatgpt.com">arXiv</a>)</li>
<li>相比传统手柄，VR 能提供沉浸式视角和立体深度感，对复杂三维操作尤其友好。</li>
</ul>
</li>
<li><strong>穿戴/动捕类遥操作：外骨骼、数据手套、动作捕捉</strong>
<ul>
<li>人类穿上外骨骼或戴上数据手套，机器直接跟随人手、人臂轨迹运动。(<a href="https://robin-lab.cs.utexas.edu/telemoma-web/static/pdfs/telemoma.pdf?utm_source=chatgpt.com">robin-lab.cs.utexas.edu</a>)</li>
<li>好处是动作映射直观，自然度高；缺点是硬件复杂、成本高，场地和佩戴舒适度都是工程挑战。</li>
</ul>
</li>
<li><strong>移动端 / Web 端遥操作</strong>
<ul>
<li>一些系统尝试用 <strong>手机、平板或 Web UI</strong> 提供遥操作界面，适合简化任务或给非专业用户使用。(<a href="https://robin-lab.cs.utexas.edu/telemoma-web/static/pdfs/telemoma.pdf?utm_source=chatgpt.com">robin-lab.cs.utexas.edu</a>)</li>
<li>交互方式通常是拖拽目标、点击按钮等，更接近“远程人机界面”，操作精度有限，但易于部署到大量用户。</li>
</ul>
</li>
<li><strong>辅助/共享控制遥操作（Assisted / Shared Teleoperation）</strong>
<ul>
<li>为降低人类负担，可以让 <strong>部分动作由算法自动完成</strong>，人只在关键决策点介入。例如 PATO 系统中，机器人在不确定时才请求人工接管，从而提高大规模示教效率。(<a href="https://arxiv.org/abs/2212.04708?utm_source=chatgpt.com">arXiv</a>)</li>
<li>这种“人机共驾”模式在采集大规模示教数据时尤其重要，可支持一个人同时监督多台机器人。</li>
</ul>
</li>
</ol>
<h4 id="7212-优点"><a class="header" href="#7212-优点">7.2.1.2 优点</a></h4>
<p>遥操作在现代机器人数据集构建中几乎是“默认选项”，原因主要有：</p>
<ol>
<li><strong>高质量、任务相关的演示</strong>
<ul>
<li>人类在闭环控制下完成任务，能自动避开明显不合理动作；对于抓取、插入等精细操作，人类往往能凭经验快速找到可行策略。</li>
<li>大规模操作数据集（如 BridgeData V2、DROID）都大量采用遥操作或其变体来采集示范轨迹。(<a href="https://proceedings.mlr.press/v229/walke23a/walke23a.pdf?utm_source=chatgpt.com">Proceedings of Machine Learning Research</a>)</li>
</ul>
</li>
<li><strong>任务多样性和开放性</strong>
<ul>
<li>同一套硬件和遥操作界面，可以在不同环境、不同物体、不同指令下反复采集，使得数据集覆盖大量任务变体，有利于训练通用 VLA 模型。(<a href="https://rail-berkeley.github.io/bridgedata/?utm_source=chatgpt.com">rail-berkeley.github.io</a>)</li>
</ul>
</li>
<li><strong>自然融合多模态信号</strong>
<ul>
<li>遥操作过程本身天然包含 <strong>机器人状态 + 控制命令 + 视觉观测</strong>，如果同时录音或采集语言说明，就能构造完整的视觉–语言–动作三模态数据，这为后续 VLA 训练提供了理想素材。(<a href="https://rh20t.github.io/static/RH20T_paper_compressed.pdf?utm_source=chatgpt.com">rh20t.github.io</a>)</li>
</ul>
</li>
<li><strong>对操作员技术门槛相对可控</strong>
<ul>
<li>虽然需要一定学习，但相较于直接写控制程序，遥操作让没有机器人编程经验的操作者也能参与数据采集，这对大规模数据构建是关键前提。(<a href="https://link.springer.com/article/10.1007/s10514-025-10216-5?utm_source=chatgpt.com">SpringerLink</a>)</li>
</ul>
</li>
</ol>
<h4 id="7213-挑战"><a class="header" href="#7213-挑战">7.2.1.3 挑战</a></h4>
<p>当然，遥操作也有一长串“坑”，在设计数据采集系统时要提前考虑：</p>
<ol>
<li><strong>操作负担与疲劳</strong>
<ul>
<li>长时间高精度操作会极大消耗操作者注意力和体力，导致演示质量下降。实验表明，合适的界面设计（如提供实时任务状态虚拟仪表盘）可以提高抓取精度和用户体验。(<a href="https://www.mdpi.com/2218-6581/14/7/92?utm_source=chatgpt.com">MDPI</a>)</li>
<li>在采集大型数据集时，通常需要轮换操作员、设置短任务、甚至设计游戏化机制来减轻疲劳。</li>
</ul>
</li>
<li><strong>通信延迟与带宽限制</strong>
<ul>
<li>如果人和机器人不在同一局域网，图像传输和控制命令往返会带来明显延迟，易导致操作过冲、抖动甚至碰撞。</li>
<li>工程上常见做法包括：降低视频分辨率/帧率、在机器人端做局部避障、或采用共享控制，让高频稳定控制留在本地。</li>
</ul>
</li>
<li><strong>接口与动作映射的设计难度</strong>
<ul>
<li>如何将人手、手柄或 VR 控制器的运动映射到机械臂末端、移动底盘等，是一个需要仔细调参的问题。映射不自然会导致学习难、错误多。</li>
<li>最近的工作（如 TeleMoMa、Versatile Demonstration Interface 等）都强调通过统一的接口同时支持多种示教模式，以降低使用门槛。(<a href="https://robin-lab.cs.utexas.edu/telemoma-web/static/pdfs/telemoma.pdf?utm_source=chatgpt.com">robin-lab.cs.utexas.edu</a>)</li>
</ul>
</li>
<li><strong>可扩展性问题</strong>
<ul>
<li>传统遥操作“一人一机”，当需要上万条演示时成本惊人。</li>
<li>辅助遥操作和多机器人并行采集（如 PATO）提供了一条思路：让策略在简单场景下自动执行，只有在不确定时才喊人类“救场”。(<a href="https://arxiv.org/abs/2212.04708?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>数据偏差与安全风险</strong>
<ul>
<li>示范数据只覆盖了“人类习惯的操作空间”，容易出现状态分布不均衡；在危险场景下，人类也可能不敢尝试极限操作。</li>
<li>为安全起见，遥操作系统必须提供急停、虚拟约束区域等机制，同时对碰撞、超力等异常进行硬件级保护，这些内容在第 10 章会进一步展开。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="722-kinesthetic-teaching人手带动机械臂"><a class="header" href="#722-kinesthetic-teaching人手带动机械臂">7.2.2 Kinesthetic teaching（人手带动机械臂）</a></h3>
<p>如果说遥操作是“远程操纵”，那么 <strong>kinesthetic teaching（本体示教、拖拽示教）</strong> 就是“直接上手”。在这种范式中，人直接抓住机器人机械臂本体，将其推到希望的位置或轨迹上，机器人通过关节力矩/位置传感器记录整个过程。这种方式通常被归入 <strong>Programming by Demonstration（PbD，示教编程）</strong> 的重要一支。(<a href="https://calinon.ch/papers/Calinon-EncyclopediaRobotics2019.pdf?utm_source=chatgpt.com">calinon.ch</a>)</p>
<blockquote>
<p>【图 7-xy 占位：一位操作员站在协作机械臂旁边，用双手扶着机械臂末端拖动其完成“抓取–搬运–放置”的动作，旁边简单标注“零力模式”“关节角记录”等。】</p>
</blockquote>
<h4 id="7221-示教方法"><a class="header" href="#7221-示教方法">7.2.2.1 示教方法</a></h4>
<p>典型的 kinesthetic teaching 流程包括以下步骤：</p>
<ol>
<li><strong>进入“零力模式”或重力补偿模式</strong>
<ul>
<li>机械臂低层控制切换到 <strong>力控 / 阻抗控制</strong> 模式，通过电机电流和力矩传感器主动抵消重力，使操作者感觉机械臂“很轻”，可以轻松推动。(<a href="https://calinon.ch/papers/Calinon-EncyclopediaRobotics2019.pdf?utm_source=chatgpt.com">calinon.ch</a>)</li>
</ul>
</li>
<li><strong>人手拖拽机械臂执行任务</strong>
<ul>
<li>操作员抓住末端执行器或专门的手柄，让机械臂按照完成任务的自然轨迹运动（例如从桌面抓起一个杯子再放到架子上）。</li>
<li>在复杂任务中，操作者可以多次示教不同变体，如不同初始位置、不同物体，以增加数据多样性。</li>
</ul>
</li>
<li><strong>关键帧与连续轨迹两种风格</strong>
<ul>
<li>有的系统要求操作员 <strong>逐个关键姿态点</strong> 示教（keyframe based），系统再自动做插值；有的则直接记录高频连续轨迹。(<a href="https://www.roboticsproceedings.org/rss10/p48.pdf?utm_source=chatgpt.com">roboticsproceedings.org</a>)</li>
<li>关键帧方式更适合传统工业编程；连续轨迹更适合模仿学习和 VLA 的 BC 训练。</li>
</ul>
</li>
<li><strong>交互式修正与重复示教</strong>
<ul>
<li>示教后可以回放轨迹，操作员发现不满意的部分可以再次拖拽局部修正，这在工业 PbD 中非常常见。(<a href="https://patents.google.com/patent/WO2017178469A1/en?utm_source=chatgpt.com">Google Patents</a>)</li>
</ul>
</li>
</ol>
<h4 id="7222-数据记录"><a class="header" href="#7222-数据记录">7.2.2.2 数据记录</a></h4>
<p>与遥操作类似，kinesthetic teaching 也要把“人–机交互”转成可用的数据集。常见记录内容包括：</p>
<ol>
<li><strong>关节空间与末端空间轨迹</strong>
<ul>
<li>每个时间步记录关节角 (q_t)、关节速度 (\dot{q}_t)、末端位姿（通过正运动学计算），采样频率通常在 50–200 Hz 之间，既保证细节，又可控数据量。</li>
</ul>
</li>
<li><strong>力/力矩与接触信息</strong>
<ul>
<li>如果机械臂有六维力/力矩传感器，还可以记录施加在末端的外力，这对于<strong>装配、打磨、插入</strong>等接触丰富的任务非常关键。(<a href="https://arxiv.org/html/2502.05086v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>额外传感器与人类状态</strong>
<ul>
<li>一些多模态数据集会在 kinesthetic teaching 过程中同步采集 <strong>多视角 RGB、深度、声音、人体动作捕捉、肌电（EMG）等信号</strong>，用来分析人类操作策略和丰富训练信号。(<a href="https://arxiv.org/abs/2503.05231?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>标注与元数据</strong>
<ul>
<li>同样需要记录任务 ID、物体类别、成功/失败标记等信息，这部分在 7.3 节会系统展开，这里只强调：<strong>示教方式本身会影响你需要记录哪些字段</strong>。例如，如果主要用于学习力控策略，就应该重点保证力/力矩数据的精度和同步性。</li>
</ul>
</li>
</ol>
<h4 id="7223-适用性"><a class="header" href="#7223-适用性">7.2.2.3 适用性</a></h4>
<p>相较于遥操作，kinesthetic teaching 在以下场景中尤其有优势，也有明显局限：</p>
<ol>
<li><strong>优势场景</strong>
<ul>
<li><strong>协作机械臂 / 人机共作环境</strong>：协作机器人本身具备力控和安全设计，非常适合人直接拖拽示教，是工业 PbD 的主战场。(<a href="https://www.researchgate.net/publication/386233173_Robot_Manipulator_Programming_Via_Demonstrative-Kinesthetic_Teaching_for_Efficient_Industrial_Material_Handling_Applications?utm_source=chatgpt.com">ResearchGate</a>)</li>
<li><strong>接触丰富、精细操作</strong>：例如插销装配、打磨、拧螺丝等，人通过“手感”辅助控制，能给出更符合实际的轨迹和接触模式。(<a href="https://arxiv.org/html/2502.05086v1?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>对非专业操作者友好</strong>：不需要理解坐标系、关节角等概念，只需“像教一个合作者那样拉着它做一次”。</li>
</ul>
</li>
<li><strong>局限性</strong>
<ul>
<li><strong>仅适用于能被人直接接触的机器人</strong>：对于大型工业机械臂、高速设备或移动平台，安全与体积问题往往使 kinesthetic teaching 不可行。</li>
<li><strong>操作者身体负担</strong>：长时间拖拽机械臂对肩肘腕是个挑战，尤其是机械臂负载较大时。</li>
<li><strong>操作范围受人工作空间限制</strong>：人站在机器人旁边示教，工作范围主要是人可触及空间，难以覆盖远距离或封闭空间任务。</li>
</ul>
</li>
<li><strong>与其他示教方式的互补</strong>
<ul>
<li>最新一些工作尝试将 <strong>遥操作、kinesthetic teaching、自然人类示范</strong> 集成到同一示教接口中，让操作者根据任务自由选择示教方式。(<a href="https://arxiv.org/html/2410.19141v1?utm_source=chatgpt.com">arXiv</a>)</li>
<li>在构建通用 VLA 数据集时，常见做法是：<strong>粗粒度任务用遥操作或程序化数据扩展覆盖面，关键精细操作用 kinesthetic teaching 采高质量样本</strong>。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="723-自动生成--合成数据程序化场景"><a class="header" href="#723-自动生成--合成数据程序化场景">7.2.3 自动生成 / 合成数据（程序化场景）</a></h3>
<p>仅靠人类示教，很难支撑“大模型 + 通用技能”的数据需求。这时就轮到 <strong>自动生成 / 合成数据</strong> 登场：利用仿真器、任务脚本、运动规划甚至三维编辑，自动合成大量示范轨迹和对应观测。</p>
<blockquote>
<p>【图 7-xz 占位：示意程序化场景生成流程：脚本随机生成桌面布局 → 调用运动规划器生成抓取–放置轨迹 → 仿真器渲染多视角图像 → 输出“图像 + 状态 + 动作”数据集。】</p>
</blockquote>
<h4 id="7231-程序化脚本"><a class="header" href="#7231-程序化脚本">7.2.3.1 程序化脚本</a></h4>
<p>在许多仿真基准中，任务和演示轨迹是通过代码“写”出来的，而不是由人操作得到。例如：</p>
<ol>
<li><strong>基于规则的任务生成</strong>
<ul>
<li>指定一组物体类别、摆放规则和目标描述（如“把蓝色方块放入左侧抽屉”），脚本随机采样物体初始位置、姿态、背景纹理等，自动生成多种场景变体。</li>
<li>这类方法在 RLBench、ManiSkill 等操作基准中广泛存在。(<a href="https://www.researchgate.net/publication/339347623_RLBench_The_Robot_Learning_Benchmark_Learning_Environment?utm_source=chatgpt.com">ResearchGate</a>)</li>
</ul>
</li>
<li><strong>基于运动规划的演示生成</strong>
<ul>
<li>针对每个任务，使用 <strong>运动规划器 + 逆运动学</strong> 自动求出“从起始位姿到目标位姿”的无碰路径，把规划出的关节轨迹当作专家示范。RLBench 就通过这种方式为 100 多个任务提供了理论上“无限多”的脚本演示。(<a href="https://arxiv.org/pdf/1909.12271?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>基于任务-运动规划（TAMP）的复杂动作生成</strong>
<ul>
<li>对多阶段任务（开门、搬运、装配等），可以先用符号规划生成动作序列，再为每个子动作调用运动规划器，自动得到长序列示范。这种思路也被应用在 DemoGen 等合成示范系统中。(<a href="https://openreview.net/pdf/bfa570c60eee149b025cd3305bc69751b8c2559a.pdf?utm_source=chatgpt.com">OpenReview</a>)</li>
</ul>
</li>
</ol>
<h4 id="7232-数据合成"><a class="header" href="#7232-数据合成">7.2.3.2 数据合成</a></h4>
<p>除了轨迹层面的“自动规划”，近年的工作还探讨更激进的 <strong>视觉和动作的合成</strong>：</p>
<ol>
<li><strong>基于 3D 场景编辑的“重排”</strong>
<ul>
<li>例如 DemoGen：只需少量真实示范，就通过 3D 点云和渲染，把物体在场景中的位置、姿态随机重排，并通过几何转换调整原始动作轨迹，从而生成大量新的“伪轨迹”。(<a href="https://arxiv.org/abs/2502.16932?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>视角、光照和材质的程序化扰动</strong>
<ul>
<li>利用渲染引擎改变相机位置、光照条件、材质贴图等，生成多视角、多光照的图像，对应同一动作轨迹。这本质上是更强大的数据增强。(<a href="https://arxiv.org/html/2402.08191v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>跨模态合成与补全</strong>
<ul>
<li>一些多模态数据集会在仿真中同时合成深度图、点云、触觉/接触信号等，为以后训练多模态表示（例如 DROID-3D + EmbodiedMAE）提供统一的三维输入。(<a href="https://arxiv.org/abs/2505.10105?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>语言指令的自动生成</strong>
<ul>
<li>对程序化任务可以自动导出语义描述（如“将最右边的红杯子放到蓝盘子上”），再用大语言模型改写成多种自然语言指令版本，为后续 VLA 训练构造大规模图文–动作对。</li>
</ul>
</li>
</ol>
<h4 id="7233-优劣"><a class="header" href="#7233-优劣">7.2.3.3 优劣</a></h4>
<p>程序化 / 合成数据不是“白嫖”，它的优点与风险都很明显：</p>
<ol>
<li><strong>优势</strong>
<ul>
<li><strong>规模几乎无限</strong>：脚本一旦写好，就可以离线生成任意数量的轨迹和场景，是支撑大模型训练的关键。RLBench 的脚本演示、BridgeData V2 中脚本 pick-and-place 轨迹都是代表例子。(<a href="https://arxiv.org/pdf/1909.12271?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>可控性强</strong>：可以系统地改变物体数量、布局、干扰物等，从而评估和提升模型的泛化能力。Colosseum 等基准就是在 RLBench 基础上增加系统 perturbation 因素来检验泛化。(<a href="https://arxiv.org/html/2402.08191v1?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>安全与成本优势</strong>：所有“试错”都发生在仿真中，不会真的摔坏机器人或物体，也不需要实验室人员盯着。</li>
</ul>
</li>
<li><strong>劣势与风险</strong>
<ul>
<li><strong>仿真–现实差距（Sim2Real gap）</strong>：合成图像和物理参数与真实世界总有差异，模型若完全在合成数据上训练，直接上真实机器人时性能可能大幅下降——这一点在第 5.4、7.1 节已讨论。</li>
<li><strong>行为模式过于理想化</strong>：运动规划生成的轨迹通常是“几何上完美”的，没有人类真实操作中的犹豫、微调、接触探索等，这对学习鲁棒策略可能是不利的。</li>
<li><strong>脚本工程成本不容忽视</strong>：要实现几十上百个任务的高质量程序化生成本身是一项工程，需要熟悉仿真引擎、运动规划、碰撞检测等模块。</li>
</ul>
</li>
<li><strong>实践中的折中策略</strong>
<ul>
<li>目前较被认可的做法是 <strong>“少量真实 + 大量合成 + 少量真实微调”</strong>：用少量遥操作或 kinesthetic 示教给出真实示范，再依靠程序化和合成方法扩充数据，最后在真实机器人上用少量数据做 domain adaptation 或 RL 微调。(<a href="https://arxiv.org/abs/2502.16932?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ol>
<hr>
<h3 id="724-多模态同步图像语言指令关节状态动作序列"><a class="header" href="#724-多模态同步图像语言指令关节状态动作序列">7.2.4 多模态同步：图像、语言指令、关节状态、动作序列</a></h3>
<p>无论数据是通过遥操作、kinesthetic teaching 还是程序化生成得到，只要最终目标是训练 <strong>VLA 模型</strong>，就必须把视觉、语言和动作这几条信息流 <strong>严格对齐到同一个时间轴上</strong>。这一节从工程角度解释如何进行多模态同步。</p>
<blockquote>
<p>【图 7-xw 占位：一条时间线，上方是 RGB 图像帧序列，中间是语言指令（整体或按短语划分），下方是关节状态和动作命令曲线，用竖直虚线表示不同模态按时间戳对齐。】</p>
</blockquote>
<h4 id="7241-时间同步"><a class="header" href="#7241-时间同步">7.2.4.1 时间同步</a></h4>
<p>时间同步是所有多模态数据工程的地基，核心思想很简单：<strong>所有传感器和控制信号都带统一时间戳</strong>。</p>
<ol>
<li><strong>统一时间源与时间戳</strong>
<ul>
<li>在机器人系统中，常通过操作系统时间 + NTP 同步，或由控制电脑作为统一时间源，所有传感器驱动在采样时记录“系统时间”。</li>
<li>在复杂多模态数据集（如 Kaiwu、RH20T、DROID 等）中，通常在硬件层面就保证各设备同步时钟，然后将 RGB、深度、力觉、音频、关节状态等全部按绝对时间戳记录下来。(<a href="https://arxiv.org/abs/2503.05231?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>软件层面的对齐与插值</strong>
<ul>
<li>由于不同话题/设备采样频率不同（例如图像 30 Hz，关节状态 100 Hz，动作命令 10 Hz），离线处理时需要选择一个“主时间轴”（经常是控制频率或图像频率），然后对其他信号做插值或最近邻对齐。</li>
<li>实践里既有以 <strong>图像帧为主</strong> 的对齐方式（每帧图像配一个最近动作），也有以 <strong>控制周期为主</strong> 的方式（每个控制 step 附近取最近一张图像和语言片段）。</li>
</ul>
</li>
<li><strong>同步精度与抖动控制</strong>
<ul>
<li>对于大多数桌面操作任务，几十毫秒级的对齐误差通常可以接受；但在高速运动或接触瞬间（如敲击、插入）中，几毫秒的误差也可能改变接触判定结果，多模态装配数据集会特别强调微秒级同步和抗振动设计。(<a href="https://arxiv.org/html/2509.23111v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>可视化与检验工具</strong>
<ul>
<li>在工程实践中，会使用像 Foxglove、RViz 等工具将多种话题按时间轴播放，以肉眼检查同步是否合理。很多开源多模态示例都提供这样的可视化配置。(<a href="https://foxglove.dev/examples?utm_source=chatgpt.com">Foxglove</a>)</li>
</ul>
</li>
</ol>
<blockquote>
<p>和 7.3 节中“轨迹数据格式与 ROS bag”不同，这里只聚焦于“如何让多条轨迹变成一条多模态时间线”；具体存储格式和解析方法将在 7.3 中详细展开。</p>
</blockquote>
<h4 id="7242-语言指令关联"><a class="header" href="#7242-语言指令关联">7.2.4.2 语言指令关联</a></h4>
<p>语言模态有两种典型来源：<strong>离线文本描述</strong> 和 <strong>在线语音/对话指令</strong>。如何把语言和具体轨迹片段关联，是构造 VLA 训练样本的关键步骤之一。</p>
<ol>
<li><strong>整体任务级指令</strong>
<ul>
<li>最简单的情形是：为整个演示轨迹提供一条文本指令，例如 “把红色杯子拿起放到右边碗里”。</li>
<li>这种形式在许多机器人数据集（如 BridgeData V2、DROID）中非常常见，每条轨迹有一条文本描述，用于训练 “(图像, 语言) → 动作” 的条件策略。(<a href="https://rail-berkeley.github.io/bridgedata/?utm_source=chatgpt.com">rail-berkeley.github.io</a>)</li>
</ul>
</li>
<li><strong>分段指令与层级标注</strong>
<ul>
<li>对更复杂、长时间任务，可以将轨迹切分为多个阶段（如“伸手–抓取–移动–放置”），为每一段配一条短指令（如“抓起杯子”“移到架子上”）。</li>
<li>这种更细粒度的对齐可支持训练层级 VLA 模型，让语言不仅描述最终目标，还能作为子任务切分信号。</li>
</ul>
</li>
<li><strong>语音指令与对话日志</strong>
<ul>
<li>如果在示教过程中使用语音控制（“再往右一点”“抓紧一点”），系统需要实时语音识别（ASR）并记录原始音频、转写文本以及时间戳。</li>
<li>在构造数据集时，可以保留“语音–动作–图像”的完整历史，从而支持训练具备对话纠偏能力的机器人策略。</li>
</ul>
</li>
<li><strong>自动生成与扩充语言描述</strong>
<ul>
<li>实践中，人类不可能为每条轨迹手工写多条指令，常用的方式是：由脚本生成模板指令，再用大语言模型做改写和多样化扩充，以提高语言分布的自然性。(<a href="https://rail-berkeley.github.io/bridgedata/?utm_source=chatgpt.com">rail-berkeley.github.io</a>)</li>
</ul>
</li>
</ol>
<h4 id="7243-多源数据记录"><a class="header" href="#7243-多源数据记录">7.2.4.3 多源数据记录</a></h4>
<p>最后，从系统工程角度看，多模态数据采集就是一个“多源日志记录问题”：</p>
<ol>
<li><strong>采集哪些模态？</strong>
对于典型 VLA 数据集，常见的模态组合包括：
<ul>
<li><strong>视觉</strong>：多视角 RGB、深度甚至点云；</li>
<li><strong>机器人本体状态</strong>：关节角、关节速度、末端位姿、夹爪开合状态；</li>
<li><strong>动作/控制命令</strong>：末端速度、关节目标、离散技能 ID 等；</li>
<li><strong>力觉与接触</strong>：力/力矩传感器、触觉阵列（若有）；</li>
<li><strong>音频与环境上下文</strong>：例如装配声、环境噪声，用于识别接触事件或异常；</li>
<li><strong>语言与人类状态</strong>：文本/语音指令、人手轨迹、目光方向等。
近期多模态数据集（如 Kaiwu、RH20T、DROID、REASSEMBLE 等）都在尝试尽可能“把能录的都录了”。(<a href="https://arxiv.org/abs/2503.05231?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>记录频率与存储权衡</strong>
<ul>
<li>高频记录能捕获更多细节，但存储和后处理代价也成倍增加；常见折衷是：<strong>控制与关节状态高频（50–200 Hz），相机中频（10–30 Hz），音频高频（kHz），语言事件按需记录</strong>。</li>
<li>对于之后要训练 Transformer 类 VLA 模型，需要提前考虑 <strong>序列长度和采样率</strong>，避免生成后期完全难以加载的超长序列。</li>
</ul>
</li>
<li><strong>统一日志格式与索引</strong>
<ul>
<li>实际工程中，常采用诸如 ROS bag、HDF5、自定义二进制格式等作为统一日志容器，把所有模态一起存进去，再通过索引文件记录每条轨迹的起止时间、任务 ID、重要事件时间点等。</li>
<li>统一的日志与索引结构是后续“切片”出训练样本（例如固定长度窗口、按阶段切片）的基础，这在 7.3 节会给出更加细致的建议。</li>
</ul>
</li>
<li><strong>多模态对下游 VLA 的意义</strong>
<ul>
<li>从模型视角看，这些多模态数据最终都要映射成一串 token——图像 patch token、语言 token、动作 token、状态 token。</li>
<li>数据采集阶段做得越规范、同步越精确、模态越丰富，下游就有越大的空间去设计强大的 VLA 架构（第 8 章会从模型结构角度回到这些设计决定）。</li>
</ul>
</li>
</ol>
<hr>
<p>这一节到这里，你基本把“人怎么教机器人、仿真怎么帮人造数据、这些数据怎么对齐成多模态轨迹”讲清楚了。后面的 7.3 节可以顺势从“时间线上铺好的多模态原始信号”，进一步落到 <strong>文件格式、标注策略和数据清洗流水线</strong> 上，形成完整的数据工程闭环。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="数据存储与标注"><a href="#数据存储与标注" class="header">数据存储与标注</a></h1>
<h3 id="731-轨迹数据格式设计时间戳topic-结构"><a class="header" href="#731-轨迹数据格式设计时间戳topic-结构">7.3.1 轨迹数据格式设计（时间戳、Topic 结构）</a></h3>
<p>从本节开始，可以把自己想象成在给“未来的 Open X-Embodiment 数据集维护者”打地基：你设计好的格式，将直接决定后面所有模型训练、可视化与复现实验的上限。(<a href="https://arxiv.org/html/2310.08864v9?utm_source=chatgpt.com">arXiv</a>)</p>
<hr>
<h4 id="7311-数据格式"><a class="header" href="#7311-数据格式">7.3.1.1 数据格式</a></h4>
<p><strong>（1）轨迹与 episode 的层次结构</strong></p>
<p>在机器人学习中，通常以“episode（任务执行回合）”为基本单位来组织数据。建议采用三层结构：</p>
<ol>
<li><strong>数据集级（dataset）元信息</strong>
<ul>
<li><code>dataset_name</code>，<code>version</code>，<code>coordinate_convention</code>（例如世界坐标系定义）</li>
<li>支持的机器人列表（如 <code>robot_type: franka_panda / ur5 / mobile_base</code>）</li>
<li>全局时间基准（如统一采用 UNIX 时间戳，单位秒 + 纳秒）</li>
</ul>
</li>
<li><strong>episode 级信息</strong>
<ul>
<li><code>episode_id</code>：唯一标识一个任务执行</li>
<li><code>task_id</code>：对应 7.3.2 中的任务类型</li>
<li><code>scene_config</code>：环境配置（物体类型、初始位置、随机种子）</li>
<li><code>robot_id</code> / <code>embodiment_id</code>：哪台机器人、哪种形态</li>
<li><code>start_time</code>，<code>end_time</code>：绝对时间戳</li>
<li>预留 <code>success_flag</code>、<code>partial_success</code> 等标记（具体定义在 7.3.2）</li>
</ul>
</li>
<li><strong>step 级数据（时间序列）</strong>
典型一个 step 可以包含：</li>
</ol>
<pre><code class="language-json">{
  "t": 1.23456789,              // 相对 episode 起始的秒数
  "timestamp": 1680000123.23456789, // 绝对时间戳，可选
  "observation": {
    "rgb_image_path": "episode_001/frame_000123.png",
    "depth_image_path": "episode_001/depth_000123.png",
    "joint_positions": [...],
    "joint_velocities": [...],
    "ee_pose": [...],
    "gripper_state": 0
  },
  "action": {
    "type": "delta_ee_pose",
    "command": [...]
  },
  "extra": {
    "reward": 0.0,
    "done": false
  }
}
</code></pre>
<p>大尺寸模态（图像、点云）一般不直接嵌在 JSON/Proto 中，而是<strong>单独存储为文件</strong>，在轨迹文件里只保存路径或索引（提升读写性能和灵活性）。</p>
<blockquote>
<p>【图 7-3-1 占位：轨迹数据的层次结构示意图：dataset / episode / step 三层结构，step 中包含多模态观测与动作指针。】</p>
</blockquote>
<p><strong>（2）时间戳的设计</strong></p>
<p>为了保证后续多模态对齐与 rosbag 回放一致，建议同时保留两类时间戳：</p>
<ul>
<li><strong>绝对时间戳</strong>：例如 UNIX 时间（秒 + 纳秒），直接使用 ROS 消息头 <code>header.stamp</code>。</li>
<li><strong>相对时间戳</strong>：以 episode 起始时刻为 0 的相对时间（浮点秒），便于后续模型训练和可视化。</li>
</ul>
<p>常见做法是：<strong>轨迹内部用相对时间用于“步长统一”与插值，跨日志同步时再回到绝对时间戳。</strong></p>
<p><strong>（3）Topic 级结构与逻辑步长</strong></p>
<p>原始数据往往来自多个 ROS Topic（视觉、关节状态、控制命令等），频率各不相同。建议在“落盘到训练格式”时做一次结构化处理：</p>
<ul>
<li>选择一个主时间轴（例如<strong>控制命令 Topic</strong> 或 <strong>固定频率定时器</strong>）作为 step 的基准；</li>
<li>其它传感器 Topic（相机、力矩传感器等）按时间<strong>就近插值 / 对齐</strong>到该主时间轴上；</li>
<li>在 step 级别记录“来自哪些 Topic 的消息已经对齐良好”（例如缺帧时标记 <code>observation.rgb_valid = false</code>）。</li>
</ul>
<p>这样可以在保持原始 rosbag 灵活性的同时，为模型提供统一粒度的“时间步”。</p>
<hr>
<h4 id="7312-ros-bag"><a class="header" href="#7312-ros-bag">7.3.1.2 ROS bag</a></h4>
<p>在 ROS 生态中，<strong>rosbag / ros2 bag</strong> 是事实标准的轨迹日志格式，用于记录任意 Topic 上的消息时间序列。(<a href="https://wiki.ros.org/rosbag/Tutorials/Recording%20and%20playing%20back%20data?utm_source=chatgpt.com">wiki.ros.org</a>)</p>
<ul>
<li>ROS1 中使用 <code>.bag</code> 文件，以自定义格式顺序存储：
<code>[(timestamp, topic_name, serialized_message), ...]</code>。(<a href="https://www.mathworks.com/help/ros/ug/work-with-rosbag-logfiles.html?utm_source=chatgpt.com">mathworks.com</a>)</li>
<li>ROS2 中 <code>ros2 bag</code> 将数据存入数据库（早期默认 SQLite <code>.db3</code>，后续发行版逐步转向 MCAP 作为默认存储后端）。(<a href="https://docs.ros.org/en/foxy/Tutorials/Beginner-CLI-Tools/Recording-And-Playing-Back-Data/Recording-And-Playing-Back-Data.html?utm_source=chatgpt.com">ROS</a>)</li>
</ul>
<p><strong>（1）选择需要记录的 Topic</strong></p>
<p>为具身智能任务设计 rosbag 时，通常会重点关注以下几类 Topic：</p>
<ul>
<li>机器人状态类：<code>/joint_states</code>、末端位姿、力矩/触觉传感器</li>
<li>视觉类：<code>/camera/rgb/image_raw</code>、<code>/camera/depth/image_raw</code>、相机外参/内参</li>
<li>控制命令类：<code>/arm_controller/command</code>、<code>/cmd_vel</code> 等</li>
<li>任务相关信号：重置信号、任务 ID、成功标志、语言指令 Topic 等</li>
</ul>
<p>原则是：<strong>能够在离线回放时还原完整任务上下文即可</strong>，不必记录实验中所有无关 Topic，以避免数据爆炸。</p>
<p><strong>（2）bag 作为“原始事实”，轨迹文件作为“训练视图”</strong></p>
<p>一个可行的工程实践：</p>
<ol>
<li>在线实验时，用 <code>rosbag record</code> / <code>ros2 bag record</code> 记录若干 Topic，作为<strong>原始事实日志</strong>；</li>
<li>离线阶段，用解析脚本将 bag 转换为“episode + step”结构的<strong>训练轨迹文件</strong>（如 JSON Lines / Parquet / HDF5）；</li>
<li>训练时仅加载结构化轨迹；调试或可视化时再用 bag 做细节回放。</li>
</ol>
<blockquote>
<p>【图 7-3-2 占位：左侧 ROS 节点与 Topic 流图，右侧 rosbag 文件与“加工后轨迹文件”的数据流示意。】</p>
</blockquote>
<hr>
<h4 id="7313-回放与解析"><a class="header" href="#7313-回放与解析">7.3.1.3 回放与解析</a></h4>
<p><strong>（1）回放（replay）</strong></p>
<p>ROS 提供的 <code>rosbag play</code> / <code>ros2 bag play</code> 能将 bag 中的消息按原始时间戳重放到对应 Topic 上，仿佛“时光回溯”到实验时刻。(<a href="https://wiki.ros.org/rosbag/Tutorials/Recording%20and%20playing%20back%20data?utm_source=chatgpt.com">wiki.ros.org</a>)</p>
<p>回放的典型用途：</p>
<ul>
<li>在仿真或离线系统中，重复调试同一条轨迹；</li>
<li>用旧数据验证新算法（感知、控制、规划）；</li>
<li>生成演示视频或用于教学展示。</li>
</ul>
<p>需要注意的是，回放时通常会把 ROS 时间（<code>/use_sim_time</code>）绑定到 bag 时间轴，避免系统使用真实系统时间造成混乱。</p>
<p><strong>（2）解析（parsing）与 episode 切分</strong></p>
<p>将 rosbag 转换为训练轨迹，需要一个清晰的解析流程。一个常见方案：</p>
<ol>
<li><strong>扫描元信息</strong>
使用命令行 <code>rosbag info</code> / <code>ros2 bag info</code> 获取 bag 中所有 Topic 名、消息类型、起止时间。(<a href="https://wiki.ros.org/rosbag/Commandline?utm_source=chatgpt.com">wiki.ros.org</a>)</li>
<li><strong>按 Topic 读取消息流</strong>
用脚本（Python C++ 或 MATLAB 等）逐条读取消息，按时间排序（bag 内部本身已经按时间顺序，但跨多个文件或分段时需重新合并）。(<a href="https://www.mathworks.com/help/ros/ug/work-with-rosbag-logfiles.html?utm_source=chatgpt.com">mathworks.com</a>)</li>
<li><strong>确定 episode 边界</strong>
<ul>
<li>可以依据专门的“重置 Topic”（例如 <code>/task_reset</code>）；</li>
<li>或通过机器人状态检测 reset 事件（如末端回到初始 pose，物体恢复初始位置）；</li>
<li>或根据外部标注文件给出的 episode 起止时间段。</li>
</ul>
</li>
<li><strong>对齐多模态数据到统一 step</strong>
<ul>
<li>以控制命令 Topic 的时间戳为主轴；</li>
<li>对每个时间戳，在图像/传感器流中找到相邻两帧做最近邻或插值；</li>
<li>将结果写入标准化轨迹格式。</li>
</ul>
</li>
<li><strong>附加元数据与标签</strong>
留出接口与 7.3.2（任务标签）和 7.3.3（语言指令）对接。</li>
</ol>
<p><strong>（3）离线调试与可视化</strong></p>
<p>为了帮助人类快速感知轨迹质量，推荐在解析脚本中顺便生成：</p>
<ul>
<li>集成可视化：例如每个 episode 导出一个“关键帧 + 末端轨迹 2D 投影图”；</li>
<li>快速统计：轨迹长度分布、关节速度分布等，用于后续清洗（7.3.4）。</li>
</ul>
<blockquote>
<p>【图 7-3-3 占位：从 rosbag 时间线到统一 step 时间线的对齐示意图，展示多种 Topic 的时间戳如何投影到主时间轴上。】</p>
</blockquote>
<hr>
<h3 id="732-任务标签与成功--失败标注"><a class="header" href="#732-任务标签与成功--失败标注">7.3.2 任务标签与成功 / 失败标注</a></h3>
<p>轨迹本身只是“机器人做了什么”的记录，要让 VLA 模型真正学习到“机器人为什么这样做、做得好不好”，就必须在轨迹之上叠加<strong>任务语义与质量标签</strong>。近年来的大规模具身数据集（如 Open X-Embodiment、各种语言条件操作数据集）无一例外都重视这一层信息。(<a href="https://arxiv.org/html/2310.08864v9?utm_source=chatgpt.com">arXiv</a>)</p>
<hr>
<h4 id="7321-任务元数据"><a class="header" href="#7321-任务元数据">7.3.2.1 任务元数据</a></h4>
<p><strong>（1）任务级别信息</strong></p>
<p>每个 episode 至少应具备：</p>
<ul>
<li><code>task_id</code>：简洁机器可读的标识，如 <code>"pick_and_place"</code>、<code>"open_drawer"</code>；</li>
<li><code>task_family</code>：更高层级的任务族，例如 <code>"manipulation"</code>、<code>"navigation"</code>；</li>
<li><code>task_params</code>：与本次任务实例相关的参数
<ul>
<li>目标物体类别 / 颜色 / 尺寸</li>
<li>目标区域（容器类型、位置）</li>
<li>初始布局随机种子等</li>
</ul>
</li>
<li><code>language_instruction_ids</code>：与 7.3.3 中语言指令条目关联的 ID 列表。</li>
</ul>
<p>这种设计既方便后续按照任务类型过滤数据，也为模板化语言生成（7.3.3.2）提供了参数来源。</p>
<p><strong>（2）环境与机器人配置</strong></p>
<p>建议把容易被忽略但对泛化十分关键的信息也纳入元数据：</p>
<ul>
<li>机器人类型与工具末端（两指爪、三指手、吸盘等）；</li>
<li>相机类型与安装位置（手眼 / 外参 ID 参考）；</li>
<li>场景类型（桌面操作、地面导航、台面整理等）。</li>
</ul>
<p>在跨机器人、多任务的大规模数据集中，这些字段是进行<strong>条件建模和跨平台迁移</strong>的关键。(<a href="https://arxiv.org/html/2310.08864v9?utm_source=chatgpt.com">arXiv</a>)</p>
<hr>
<h4 id="7322-成功--失败记录"><a class="header" href="#7322-成功--失败记录">7.3.2.2 成功 / 失败记录</a></h4>
<p><strong>（1）“成功”的定义</strong></p>
<p>理想情况下，需要在数据采集协议中提前定义每个任务的“成功条件”，例如：</p>
<ul>
<li>抓取任务：目标物体被稳定抓起、离开桌面超过一定高度；</li>
<li>放置任务：目标物体中心落在目标区域内，且最终静止；</li>
<li>门 / 抽屉任务：开合角度超过一定阈值。</li>
</ul>
<p>可以用<strong>规则 + 传感器检测</strong>自动判断（如通过视觉检测物体位置），也可以在实验结束后由操作者通过 UI 一键标注“成功 / 失败”。</p>
<p><strong>（2）标签结构</strong></p>
<p>建议引入显式结构，而不是一个单布尔变量“一刀切”：</p>
<pre><code class="language-json">{
  "episode_id": "...",
  "success": true,
  "failure_reason": null,
  "metrics": {
    "final_distance_to_goal": 0.012,
    "time_to_success": 5.4
  }
}
</code></pre>
<p>或者在失败时记录：</p>
<pre><code class="language-json">"success": false,
"failure_reason": "object_slipped",
"metrics": {
  "max_gripper_force": 15.2
}
</code></pre>
<p>这些额外信息可以用于后续<strong>成功预测模型</strong>或<strong>安全性分析</strong>，而不仅仅是过滤样本。</p>
<hr>
<h4 id="7323-部分成功标记"><a class="header" href="#7323-部分成功标记">7.3.2.3 部分成功标记</a></h4>
<p>现实任务往往是长序列、多阶段的，如“打开抽屉 → 拿出物体 → 放到盒子里”。只用一个最终成功标记，会导致大量“前半段做得很好但最后一步失败”的轨迹全部被当成失败样本丢弃，极度浪费。</p>
<p><strong>（1）阶段划分</strong></p>
<p>一种常见实践是为每个任务设计<strong>阶段化 schema</strong>，例如：</p>
<pre><code class="language-json">"subtasks": [
  {
    "name": "reach_object",
    "success": true,
    "t_start": 0.0,
    "t_end": 1.2
  },
  {
    "name": "grasp_object",
    "success": true,
    "t_start": 1.2,
    "t_end": 2.0
  },
  {
    "name": "place_object",
    "success": false,
    "t_start": 2.0,
    "t_end": 5.0
  }
$$
</code></pre>
<p>阶段边界可以通过：</p>
<ul>
<li>人工标注关键帧；</li>
<li>规则（如“末端距离物体小于阈值时认为进入 grasp 阶段”）；</li>
<li>或基于任务分解模型自动推断。(<a href="https://openaccess.thecvf.com/content/ICCV2025/papers/Yang_AR-VRM_Imitating_Human_Motions_for_Visual_Robot_Manipulation_with_Analogical_ICCV_2025_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</li>
</ul>
<p><strong>（2）部分成功的用法</strong></p>
<ul>
<li>在训练模仿策略或技能原语时，只使用对应阶段成功的轨迹片段；</li>
<li>在层级 RL 中，把每个子任务视作一个“option / skill”，利用阶段成功率进行单独评估；</li>
<li>在数据分析时识别瓶颈环节（例如普遍在 place 阶段失败），指导任务设计与硬件改进。</li>
</ul>
<blockquote>
<p>【图 7-3-4 占位：长任务时间轴上不同子任务阶段的标记示意图（reach / grasp / place 等），并显示各阶段 success / fail。】</p>
</blockquote>
<hr>
<h3 id="733-语言指令的设计与采集手工--自动生成"><a class="header" href="#733-语言指令的设计与采集手工--自动生成">7.3.3 语言指令的设计与采集（手工 / 自动生成）</a></h3>
<p>在具身智能场景中，语言不再只是“标签”，而是直接参与决策的<strong>条件变量</strong>：同一视觉场景，在“把红色方块放进盒子”和“把蓝色圆柱放到桌子右侧”两条指令下，机器人应做出完全不同的行为。因此，本节关注如何为轨迹配备高质量语言指令，并扩展到大规模。(<a href="https://proceedings.neurips.cc/paper_files/paper/2024/file/439539557e9ba0d04055773ff1f3241c-Paper-Datasets_and_Benchmarks_Track.pdf?utm_source=chatgpt.com">NeurIPS 会议记录</a>)</p>
<hr>
<h4 id="7331-人工编写指令"><a class="header" href="#7331-人工编写指令">7.3.3.1 人工编写指令</a></h4>
<p><strong>（1）指令风格与基本原则</strong></p>
<p>面向 VLA 模型的指令，推荐采用<strong>自然、简洁、面向用户的任务描述</strong>，而不是低层控制命令。例如：</p>
<ul>
<li>“把红色方块放入右边的蓝色盒子里。”</li>
<li>“从上面抓起杯子，然后放到桌子中央。”</li>
</ul>
<p>为了兼顾可学性与可扩展性，编写时可遵循几点原则：</p>
<ol>
<li><strong>任务导向、结果导向</strong>：描述目标而非每一步动作细节，让模型有空间自发规划；</li>
<li><strong>对视觉可对齐</strong>：指令中涉及的颜色、形状、位置等，应在图像中确实可见；</li>
<li><strong>减少歧义</strong>：避免“它”“那里”等指代含糊的词，优先使用“红色杯子”“左边的盒子”等明确描述；</li>
<li><strong>风格一致</strong>：同一数据集内，尽量保持时态、句式的一致性，降低模型学习负担。</li>
</ol>
<p><strong>（2）人工标注流程</strong></p>
<p>典型工作流如下：</p>
<ol>
<li>标注工具展示<strong>关键帧或者轨迹视频</strong>；</li>
<li>标注员观看后，为当前 episode 编写 1–3 条自然语言指令；</li>
<li>将每条指令分配唯一 ID，并与 <code>episode_id</code> 建立关联；</li>
<li>选取一部分样本做交叉审核，保证指令语义与轨迹行为一致。</li>
</ol>
<blockquote>
<p>【图 7-3-5 占位：标注界面示意图：左侧播放轨迹视频，右侧文本框输入多条语言指令，并显示任务元数据。】</p>
</blockquote>
<p>人工指令的优势是<strong>自然、贴近真实用户语言</strong>；缺点是成本较高，因此通常与模板和大模型方法结合使用。</p>
<hr>
<h4 id="7332-模板自动生成"><a class="header" href="#7332-模板自动生成">7.3.3.2 模板自动生成</a></h4>
<p>为了在大型数据集中批量生成语言指令，可以基于任务元数据设计<strong>参数化模板</strong>。</p>
<p><strong>（1）模板结构</strong></p>
<p>以抓取放置为例，可以设计一组中文模板：</p>
<ul>
<li>“把{color}{object}放到{target_location}的{target_object}里。”</li>
<li>“将{target_location}的{target_object}中的{color}{object}拿出来。”</li>
<li>“把桌子上{side}的{color}{object}移到{target_location}。”</li>
</ul>
<p>其中 <code>{color}</code>、<code>{object}</code>、<code>{target_location}</code>、<code>{side}</code> 等字段，都来自 7.3.2.1 中定义的 <code>task_params</code>。</p>
<p><strong>（2）模板系统要点</strong></p>
<ul>
<li>对每个任务族维护一套模板列表；</li>
<li>生成指令时，随机选择不同模板，增强语言多样性；</li>
<li>确保模板不会生成与环境不符的描述，例如在没有“蓝色物体”时不会使用 <code>{color=蓝色}</code>；</li>
<li>可以为同一 episode 生成多条模板指令，供训练时随机采样。</li>
</ul>
<p>很多语言–机器人数据集采用类似策略，将结构化任务参数转换为成千上万条指令，从而在有限的环境配置上构造出丰富语言分布。(<a href="https://proceedings.neurips.cc/paper_files/paper/2024/file/439539557e9ba0d04055773ff1f3241c-Paper-Datasets_and_Benchmarks_Track.pdf?utm_source=chatgpt.com">NeurIPS 会议记录</a>)</p>
<hr>
<h4 id="7333-大模型辅助"><a class="header" href="#7333-大模型辅助">7.3.3.3 大模型辅助</a></h4>
<p>大语言模型（LLM）与视觉语言模型（VLM）在具身数据标注中的角色，越来越从“锦上添花”变成“必备基础设施”。(<a href="https://arxiv.org/html/2310.08864v9?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>（1）基于元数据的指令扩写与改写</strong></p>
<p>在已有模板或人工指令的基础上，可以用 LLM 进行：</p>
<ul>
<li><strong>释义生成（paraphrasing）</strong>：保持语义不变，改变表达方式，例如“把红色方块放进蓝色盒子里”→“请将红色的小方块移入蓝色的盒子中”；</li>
<li><strong>难度分级</strong>：生成“口语化版本”“正式版本”或“儿童友好版本”，用于研究语言风格对模型行为的影响；</li>
<li><strong>多语言扩展</strong>：在保持语义一致的前提下生成英文、日文等多语言指令。</li>
</ul>
<p>这类生成通常只需提供结构化 <code>task_params</code> 与示例提示即可自动化运行。</p>
<p><strong>（2）基于视觉的自动描述</strong></p>
<p>对于没有现成元数据的旧轨迹，可以利用 VLM：</p>
<ul>
<li>输入关键帧或短视频片段；</li>
<li>令模型生成动作摘要或任务说明；</li>
<li>再由人类抽检与修订，形成稳定风格的指令集。</li>
</ul>
<p><strong>（3）质量控制与防止“幻觉”</strong></p>
<p>大模型可能会描述实际上并不存在的物体或动作。因此需要：</p>
<ul>
<li>用脚本检查生成指令中的实体名是否都出现在环境元数据中；</li>
<li>对高风险任务（涉及安全）保留人工审核；</li>
<li>将自动生成的指令打上 <code>source: llm</code>，方便后续分析其对训练的影响。</li>
</ul>
<blockquote>
<p>【图 7-3-6 占位：利用大模型进行指令生成与扩写的流程图：输入轨迹 + 元数据 → 模型生成 → 自动检查 → 人工抽检。】</p>
</blockquote>
<hr>
<h3 id="734-数据清洗与异常轨迹处理"><a class="header" href="#734-数据清洗与异常轨迹处理">7.3.4 数据清洗与异常轨迹处理</a></h3>
<p>在具身智能项目中，“垃圾进，垃圾出”尤为明显：带有错误传感器读数、时间错乱、标签不一致的轨迹，会直接使模型学到“违反物理常识”的策略。因此，构建系统性的数据清洗与异常处理流程，是整个数据工程链路的关键一环。(<a href="https://ceur-ws.org/Vol-3379/BMDA_2023_paper_1870.pdf?utm_source=chatgpt.com">ceur-ws.org</a>)</p>
<hr>
<h4 id="7341-清洗目的"><a class="header" href="#7341-清洗目的">7.3.4.1 清洗目的</a></h4>
<p>数据清洗的目标不只是“丢掉坏样本”，而是更精确地做到：</p>
<ol>
<li><strong>识别并修复结构性错误</strong>：例如时间戳乱序、缺失模态、轨迹被中途截断；</li>
<li><strong>过滤物理不合理的轨迹</strong>：例如关节角度越界、速度跳变不符合机器人动力学；</li>
<li><strong>纠正或标记错误标签</strong>：成功标为失败、任务 ID 错配、语言指令与行为不对应；</li>
<li><strong>为后续分析提供“质量标签”</strong>：不是简单删除异常，而是标记其质量等级，使不同算法可以有选择地使用。</li>
</ol>
<p>在大规模轨迹数据上，异常比例常常不会小（传感器故障、示教错误、软件崩溃等），但通过良好的清洗流程，可以在保证覆盖多样性的同时提高整体训练信噪比。(<a href="https://www.mdpi.com/1424-8220/24/4/1330?utm_source=chatgpt.com">MDPI</a>)</p>
<hr>
<h4 id="7342-异常检测"><a class="header" href="#7342-异常检测">7.3.4.2 异常检测</a></h4>
<p>异常检测可以分为三类：<strong>结构异常、物理异常、语义异常</strong>。</p>
<p><strong>（1）结构异常</strong></p>
<p>关注轨迹“长什么样”是否合理：</p>
<ul>
<li>时间戳是否单调递增；</li>
<li>episode 长度是否在合理范围内（过短可能是记录中断，过长可能包含多个任务混在一起）；</li>
<li>关键字段是否缺失（如动作为空、图像路径不存在）。</li>
</ul>
<p>这类异常可以通过<strong>规则 + 脚本检查</strong>快速发现，例如：</p>
<ul>
<li>若 <code>len(steps) &lt; min_steps</code> 则标记为异常；</li>
<li>若连续两步的 <code>t</code> 差值超过上限（例如 &gt; 1s），视为“中断”。</li>
</ul>
<p><strong>（2）物理异常</strong></p>
<p>基于机器人动力学和控制常识判断：</p>
<ul>
<li>关节角度突破硬件极限或安全范围；</li>
<li>在物理上不可能的加速度 / 速度（例如 1ms 内转动 90°）；</li>
<li>碰撞检测 Topic 报警，但成功标记仍为 true。</li>
</ul>
<p>可以利用简单统计与规则：</p>
<ul>
<li>计算每个关节的速度与加速度直方图，将高于一定分位数（如 99.9%）的样本标记为 outlier；</li>
<li>检查末端与场景中障碍物的最小距离（若有几何信息）。</li>
</ul>
<p><strong>（3）语义异常</strong></p>
<p>这是更“智能”的一层：</p>
<ul>
<li>轨迹最终状态与任务成功条件矛盾（如物体未进入目标区域，却被标记为成功）；</li>
<li>语言指令与真实行为不匹配（指令要求“放进盒子”，结果轨迹只有抓取没有放置）；</li>
<li>中途出现明显“任务崩溃”（例如示教者抖手，把物体甩飞）。</li>
</ul>
<p>对于语义异常，可以使用：</p>
<ul>
<li>简单规则（基于 7.3.2 中的任务成功定义）；</li>
<li>或训练一个**“正常轨迹”预测模型 / 自编码器**，通过重构误差或预测误差检测异常模式，这是当前机器人与轨迹异常检测文献中常用的思路。(<a href="https://arxiv.org/pdf/2209.02379?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<hr>
<h4 id="7343-清洗流程"><a class="header" href="#7343-清洗流程">7.3.4.3 清洗流程</a></h4>
<p>为了让清洗过程可复用、可追溯，可以设计一个<strong>标准管线</strong>，类似机器学习训练 pipeline：</p>
<p><strong>（1）步骤 0：版本化备份</strong></p>
<ul>
<li>原始 rosbag 与初始轨迹文件应只读保存；</li>
<li>每次清洗产生一个新的数据集版本，如 <code>v1.0_raw</code> → <code>v1.1_cleaned_basic</code> → <code>v1.2_cleaned_semantic</code>。</li>
</ul>
<p><strong>（2）步骤 1：批量结构检查</strong></p>
<ul>
<li>运行脚本对所有 episode 进行结构校验，统计：缺失字段数、异常时间间隔、长度分布；</li>
<li>给每个 episode 打一个结构级“质量分数”，例如 <code>structure_score ∈ [0, 1]</code>。</li>
</ul>
<p><strong>（3）步骤 2：物理约束过滤</strong></p>
<ul>
<li>使用机器人模型（关节上下界、最大速度等）定义一系列约束；</li>
<li>批量计算每条轨迹是否违反约束，并记录违反的类型（越界 / 高速 / 碰撞）；</li>
<li>对严重违反物理约束的轨迹打上 <code>quality: bad_physics</code> 标记，默认不用于训练。</li>
</ul>
<p><strong>（4）步骤 3：语义一致性检查</strong></p>
<ul>
<li>使用任务定义与成功条件，自动判断 episode 成功 / 失败，并与人工标注比对；</li>
<li>对冲突案例（如“系统判断失败但人工标成功”）输出列表，用于人工复查；</li>
<li>对语言–行为不一致的样本，选择修正语言或丢弃该指令。</li>
</ul>
<p><strong>（5）步骤 4：人工抽检与可视化</strong></p>
<ul>
<li>对边缘样本（例如自动评分在 0.4–0.6 之间）进行人工抽检；</li>
<li>借助可视化工具（轨迹动画、关键帧拼图）帮助快速决策。</li>
</ul>
<p><strong>（6）步骤 5：输出清洗报告与标签</strong></p>
<p>最终，每条 episode 除了原始任务标签外，还应多出一组与清洗相关的字段：</p>
<pre><code class="language-json">"quality": {
  "structure_score": 0.95,
  "physics_score": 0.9,
  "semantic_score": 0.85,
  "flags": ["passed_basic_checks"]
}
</code></pre>
<p>这样，在后续训练中可以：</p>
<ul>
<li>先只使用高质量子集训练基线模型；</li>
<li>再尝试加入部分噪声样本，研究模型对噪声的鲁棒性；</li>
<li>或在研究异常检测、恢复策略时专门用“异常集”做基准。(<a href="https://ceur-ws.org/Vol-3379/BMDA_2023_paper_1870.pdf?utm_source=chatgpt.com">ceur-ws.org</a>)</li>
</ul>
<blockquote>
<p>【图 7-3-7 占位：数据清洗流水线示意图：原始轨迹 → 结构检查 → 物理约束过滤 → 语义检查 → 人工抽检 → 生成带质量标签的清洗后数据集。】</p>
</blockquote>
<hr>
<p>通过本节内容，读者应当能从工程和建模两个角度，理解“一个高质量 VLA 训练数据集”在存储格式、任务标签、语言指令以及清洗流程上的设计要点。后续章节在介绍预训练与模仿学习训练范式（第 9 章）时，将反复依赖这里所建立的这些“数据基础设施”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="开源数据集与基准"><a href="#开源数据集与基准" class="header">开源数据集与基准</a></h1>
<p>下面这一节可以直接作为教材正文使用，我按你给的三级标题展开，语气尽量保持“教科书级但读得懂”的风格。</p>
<hr>
<h3 id="741-多机器人多任务数据集概览"><a class="header" href="#741-多机器人多任务数据集概览">7.4.1 多机器人、多任务数据集概览</a></h3>
<p>到目前为止，你已经知道如何自己在实验室里采集数据。本小节换个视角：站在“数据使用者”的角度，了解几个已经被社区广泛采用的多机器人、多任务开源数据集。它们是训练和评测 VLA 模型的“公共语料库”，也是你快速开始实验的捷径。</p>
<blockquote>
<p>【图 7-12 占位】
建议配一张“多数据集对比示意图”：横轴为 RoboNet / RLBench / Open X-Embodiment，纵轴列出“现实/仿真”“机器人数量”“任务数量”“是否有自然语言指令”等，用图标和简单数字对比。</p>
</blockquote>
<h4 id="7411-robonet"><a class="header" href="#7411-robonet">7.4.1.1 RoboNet</a></h4>
<p>RoboNet 是加州大学伯克利等机构提出的大规模多机器人操作数据集，核心目标是**“用共享数据推动通用视觉操作模型”**。(<a href="https://arxiv.org/abs/1910.11215?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>基本属性</strong></li>
</ol>
<ul>
<li><strong>数据规模</strong>：约 1500 万张图像帧（video frames），组成大量的交互序列。</li>
<li><strong>机器人种类</strong>：包含至少 7 种不同平台，如 Sawyer、Franka、KUKA、WidowX、Baxter 等，覆盖不同结构、不同控制接口的机械臂。(<a href="https://proceedings.mlr.press/v100/dasari20a/dasari20a.pdf?utm_source=chatgpt.com">Proceedings of Machine Learning Research</a>)</li>
<li><strong>任务类型</strong>：主要是桌面场景下的非结构化物体交互——推、拨、移动、简单抓取等，不刻意区分“具体任务标签”，更像是“通用交互经验池”。</li>
</ul>
<ol start="2">
<li><strong>数据模态与动作空间</strong></li>
</ol>
<ul>
<li><strong>视觉</strong>：单或多视角 RGB 图像，来自 113 个不同相机视角，场景（桌面、背景、物体外观）有较强随机化。(<a href="https://bair.berkeley.edu/blog/2019/11/26/robo-net/?utm_source=chatgpt.com">bair.berkeley.edu</a>)</li>
<li><strong>状态与动作</strong>：
<ul>
<li>状态通常包含末端执行器笛卡尔位姿（位置 + 局部朝向）以及夹爪开合状态。</li>
<li>动作采用<strong>末端执行器增量控制（delta pose action）</strong>：在当前位姿基础上给出位置/旋转小增量，以及一个维度控制夹爪开/合。(<a href="https://www.tensorflow.org/datasets/catalog/robonet?utm_source=chatgpt.com">TensorFlow</a>)</li>
</ul>
</li>
<li><strong>其他传感信息</strong>：部分子集还包含力/力矩传感器读数，可用于建模接触动力学。(<a href="https://bair.berkeley.edu/blog/2019/11/26/robo-net/?utm_source=chatgpt.com">bair.berkeley.edu</a>)</li>
</ul>
<p>对 VLA 来说，这种“视觉 + 增量位姿 + 多机器人”的统一格式，非常适合作为<strong>动作 token 化</strong>的基础（见第 8 章对动作表示的讨论）。</p>
<ol start="3">
<li><strong>设计特点与适用场景</strong></li>
</ol>
<ul>
<li><strong>多机器人统一格式</strong>：不同机械臂的数据被规整为统一的末端空间控制，使得同一个模型有可能在多种平台之间共享参数。(<a href="https://arxiv.org/abs/1910.11215?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>偏重物理交互多样性，而非语义任务标签</strong>：更适合
<ul>
<li>视觉预测 / 视频预测模型、世界模型</li>
<li>通用抓取/推动技能的预训练</li>
<li>多机器人共享视觉-控制表征的研究</li>
</ul>
</li>
</ul>
<blockquote>
<p>【图 7-13 占位】
建议配 RoboNet 官方博客中的拼图式示例：多种机械臂在不同桌面场景中与杂物交互的若干帧截图。(<a href="https://bair.berkeley.edu/blog/2019/11/26/robo-net/?utm_source=chatgpt.com">bair.berkeley.edu</a>)</p>
</blockquote>
<p>在后续章节，当我们讨论“单模型多机器人”的 VLA 架构时，可以把 RoboNet 看作现实世界数据的一个典型来源。</p>
<hr>
<h4 id="7412-rlbench"><a class="header" href="#7412-rlbench">7.4.1.2 RLBench</a></h4>
<p>RLBench 既是仿真环境又是基准数据集，可以理解为“带有标准任务库的操作仿真平台”。(<a href="https://arxiv.org/abs/1909.12271?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>基本属性</strong></li>
</ol>
<ul>
<li><strong>仿真实现</strong>：基于 CoppeliaSim（原 V-REP）物理引擎，内部集成一台 7 自由度机械臂（Franka Panda 类似结构）和若干场景。</li>
<li><strong>任务数量</strong>：最初发布时包含 100 个手工设计的任务，从伸手触碰目标到开门、拉抽屉、整理物品等，难度跨度大。(<a href="https://arxiv.org/abs/1909.12271?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>演示数据</strong>：每个任务提供大量通过运动规划器自动生成的示教轨迹，理论上可以生成无限多的演示，方便行为克隆和模仿学习。(<a href="https://arxiv.org/abs/1909.12271?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<ol start="2">
<li><strong>观测与动作空间</strong></li>
</ol>
<ul>
<li><strong>多视角视觉输入</strong>：
<ul>
<li>肩部上方的双目或多视角相机</li>
<li>手眼相机（eye-in-hand）
提供 RGB、深度图以及语义分割掩膜等。(<a href="https://arxiv.org/abs/1909.12271?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>机器人观测</strong>：关节角、关节速度、末端位姿、夹爪状态等。</li>
<li><strong>动作</strong>：可以在关节空间或末端空间发送位置/速度/增量命令，是强化学习与行为克隆常用的控制接口。</li>
</ul>
<ol start="3">
<li><strong>扩展与语言指令</strong></li>
</ol>
<p>后续许多工作在 RLBench 上叠加了<strong>自然语言指令</strong>，形成“视觉 + 语言 + 操作”的实验平台，例如 HIVEformer、Ex-PERACT 等方法在 RLBench 上评估语言条件下的多任务操作能力。(<a href="https://arxiv.org/pdf/2209.04899?utm_source=chatgpt.com">arXiv</a>)</p>
<ol start="4">
<li><strong>适用场景</strong></li>
</ol>
<ul>
<li>快速原型：无需真实机器人，即可在仿真中大规模采集演示和在线交互。</li>
<li>多任务研究：任务多而标准化，是研究多任务学习、少样本学习、长期操作（multi-stage tasks）的常见基准。(<a href="https://arxiv.org/abs/1909.12271?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<blockquote>
<p>【图 7-14 占位】
建议截图 RLBench 中几个典型任务（如“打开抽屉”“堆积木”“开烤箱放托盘”），并标注不同相机视角。</p>
</blockquote>
<hr>
<h4 id="7413-open-x-embodiment-数据集"><a class="header" href="#7413-open-x-embodiment-数据集">7.4.1.3 Open X-Embodiment 数据集</a></h4>
<p>Open X-Embodiment 是由 Google DeepMind 联合多家学术机构发布的<strong>多机器人、多任务真实操作大合集</strong>，可以视为“现实世界版的多机器人基础语料库”。(<a href="https://arxiv.org/abs/2310.08864?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>规模与来源</strong></li>
</ol>
<ul>
<li><strong>轨迹数量</strong>：超过 100 万条真实机器人轨迹。(<a href="https://robotics-transformer-x.github.io/?utm_source=chatgpt.com">Open X-Embodiment</a>)</li>
<li><strong>机器人多样性</strong>：覆盖 22 种不同“具身类型”（embodiments），包括单臂、双臂、多关节机械臂、移动平台、四足机器人等，由 30+ 个实验室联合贡献。(<a href="https://arxiv.org/abs/2310.08864?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>技能与任务</strong>：官方统计约 527 种“技能（skills）”与 16 万+ 任务变体，涵盖抓取、开门、整理物品、清洁、工具使用等多种日常操作。(<a href="https://arxiv.org/abs/2310.08864?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<ol start="2">
<li><strong>数据格式与模态</strong></li>
</ol>
<ul>
<li><strong>视觉</strong>：以 RGB 图像为主，部分数据集含多视角或视频序列。由于是汇集多个独立数据集，摄像机内参、深度图、点云等信息在不同子集中的完备程度不一。(<a href="https://robotics-transformer-x.github.io/?utm_source=chatgpt.com">Open X-Embodiment</a>)</li>
<li><strong>语言</strong>：相当一部分轨迹带有自然语言指令或描述，如“把黄色杯子放进水槽”。不同子集的语言风格和详细程度也存在差异。(<a href="https://arxiv.org/abs/2310.08864?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>动作与状态</strong>：
<ul>
<li>大多为末端位姿或关节命令的连续控制序列。</li>
<li>官方统一成标准化格式，便于在统一模型中训练“跨机器人策略”。(<a href="https://arxiv.org/abs/2310.08864?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>与 RT-X 模型的关系</strong></li>
</ol>
<p>在 Open X-Embodiment 基础上，作者训练了大规模机器人 Transformer 模型 RT-X / RT-1-X，展示了<strong>跨机器人正迁移</strong>：在一个机器人上学到的能力可以提升其他机器人在相关任务上的表现。(<a href="https://arxiv.org/abs/2310.08864?utm_source=chatgpt.com">arXiv</a>)</p>
<p>这为“通用具身基础模型”提供了强有力的实证支持，也是本书后面讨论多机器人 VLA 架构时的重要参考。</p>
<blockquote>
<p>【图 7-15 占位】
建议绘制“多机器人时间轴示意图”：横向排列不同机器人（移动底盘、机械臂、四足等）的轮廓图，下方标出对应数据量或任务示例。</p>
</blockquote>
<hr>
<h3 id="742-常见操作基准任务与评价指标"><a class="header" href="#742-常见操作基准任务与评价指标">7.4.2 常见操作基准任务与评价指标</a></h3>
<p>有了数据，还需要“统一的考试卷”——即<strong>操作基准任务（benchmarks）与明确的评价指标</strong>。这部分内容既关系到论文实验的可比性，也直接影响你如何设计自己的任务和实验。</p>
<h4 id="7421-典型基准任务"><a class="header" href="#7421-典型基准任务">7.4.2.1 典型基准任务</a></h4>
<p>当前社区中，机器人操作基准大致可分为几类维度：<strong>任务复杂度</strong>、<strong>场景复杂度</strong>、<strong>多任务/多机器人</strong> 等。下面给出若干典型任务模式，并不局限于单个数据集。</p>
<ol>
<li><strong>基础操作原语类</strong></li>
</ol>
<ul>
<li><strong>到达（reach / point）</strong>：控制末端到达目标位置或物体上方，用于评估基础运动学控制与简单视觉定位。</li>
<li><strong>单物体抓取（grasp）</strong>：在桌面上抓起一件物体，如积木或小瓶子，通常要求夹爪闭合后物体离开桌面一定高度即视为成功。</li>
<li><strong>推动与拉动（push / pull）</strong>：用末端将物体沿指定方向推至目标区域，考察接触动力学和摩擦建模。</li>
</ul>
<ol start="2">
<li><strong>Pick-and-Place 与物体搬运类</strong></li>
</ol>
<p>这类任务是现有基准中最常见的“中等难度操作”：</p>
<ul>
<li><strong>单物体搬运</strong>：如“将红色方块放入绿色碗中”。需要完成抓取、搬运、放置三个阶段。</li>
<li><strong>多物体排序 / 分类</strong>：把不同颜色或形状的物体放入对应容器，考察感知-语言-动作之间的对齐能力（例如 RLBench、RLBench-LC 上的多任务任务集）。(<a href="https://arxiv.org/abs/1909.12271?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<ol start="3">
<li><strong>长序列与多阶段任务</strong></li>
</ol>
<ul>
<li><strong>开门 / 开抽屉 / 打开烤箱并放入托盘</strong>：需要先找到把手，抓取并沿特定方向施力，然后在另外一个空间完成放置，是典型的多阶段任务。(<a href="https://arxiv.org/abs/1909.12271?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>装配 / 插入（assembly / insertion）</strong>：例如“把插头插入插座”“将方块插入带孔的结构体”，要求高精定位和力控，常用于检验高精度操作能力。</li>
</ul>
<ol start="4">
<li><strong>语言条件与多任务基准</strong></li>
</ol>
<p>在 RLBench、Open X-Embodiment 等数据集上，越来越多工作使用<strong>自然语言指令</strong>作为条件，形成“语言 → 多任务操作”的基准：(<a href="https://arxiv.org/pdf/2209.04899?utm_source=chatgpt.com">arXiv</a>)</p>
<ul>
<li>同一场景下，不同语言指令对应不同任务（如“把蓝杯子放进抽屉”“把红杯子放到桌角”）。</li>
<li>不同任务之间共享一套视觉与语言表征，用以评估<strong>多任务泛化</strong>与<strong>零样本组合</strong>能力。</li>
</ul>
<ol start="5">
<li><strong>泛化与鲁棒性基准</strong></li>
</ol>
<p>近期更关注“在扰动和分布偏移下的表现”，例如 The Colosseum 基准通过改变物体颜色、纹理、光照、桌面材质、相机姿态等，量化模型成功率的下降，用于系统性评估泛化能力。(<a href="https://arxiv.org/html/2402.08191v2?utm_source=chatgpt.com">arXiv</a>)</p>
<blockquote>
<p>【图 7-16 占位】
画一个“任务层级金字塔”：底层为 reach / grasp，中层为 pick-and-place / sorting，顶层为多阶段语言任务与泛化评测，在图中标注对应的典型基准（RLBench、Open X-Embodiment、The Colosseum 等）。</p>
</blockquote>
<hr>
<h4 id="7422-评价指标"><a class="header" href="#7422-评价指标">7.4.2.2 评价指标</a></h4>
<p>评价指标的设计决定了模型“被鼓励做什么”。在机器人操作中，既要考虑传统机器学习指标，又要加入物理世界特有的约束（时间、能耗、安全等）。下面列出常用指标及其直观含义。</p>
<ol>
<li><strong>任务成功率（Success Rate）</strong></li>
</ol>
<ul>
<li><strong>定义</strong>：在 N 次独立尝试中有多少次任务达到预设成功条件，如“物体最终落在目标区域且未掉落”。</li>
<li><strong>常见形式</strong>：
<ul>
<li>二值成功率：成功/失败。</li>
<li>分阶段成功率：如“抓取成功率”“抓取+放置完整成功率”。</li>
</ul>
</li>
<li><strong>用途</strong>：几乎所有 manipulation 基准的<strong>主指标</strong>，简单直观，适合多任务和跨算法对比。(<a href="https://robo-eval.github.io/media/RoboEval.pdf?utm_source=chatgpt.com">robo-eval.github.io</a>)</li>
</ul>
<ol start="2">
<li><strong>时间与效率指标</strong></li>
</ol>
<ul>
<li><strong>完成时间（Completion Time）</strong>：从任务开始到判定成功/失败所消耗的时间或时间步数。</li>
<li><strong>样本效率</strong>：在强化学习场景中，常统计达到某成功率所需的环境交互步数。</li>
<li><strong>步骤数 / 动作长度</strong>：用于比较“走直路”和“绕远路”的策略差异。</li>
</ul>
<ol start="3">
<li><strong>轨迹质量与精度指标</strong></li>
</ol>
<ul>
<li><strong>空间精度</strong>：如放置误差（目标位姿与最终物体位姿的距离 / 旋转差），在高精度装配任务中尤为重要。(<a href="https://www.sciencedirect.com/science/article/pii/S0921889021000956?utm_source=chatgpt.com">科学直通车</a>)</li>
<li><strong>路径质量</strong>：包括轨迹总长度、曲率、平滑度等，有时会用能耗、关节速度积分等间接表示。</li>
<li><strong>稳定性</strong>：例如抓取过程中物体是否在移动中掉落，可以通过“保持时间”“晃动幅度”等二级指标度量。</li>
</ul>
<ol start="4">
<li><strong>鲁棒性与泛化指标</strong></li>
</ol>
<ul>
<li><strong>扰动鲁棒性</strong>：在遭受光照变化、物体外观变化、相机视角偏移、动力学参数扰动等情况下的成功率。The Colosseum 等工作会报告“标准设置成功率 vs 扰动设置成功率的差值或下降比例”。(<a href="https://arxiv.org/html/2402.08191v2?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>跨任务泛化</strong>：训练任务集合与测试任务集合不重叠时的成功率，比如“新物体、新布局、新指令”的成功率。</li>
<li><strong>跨机器人迁移</strong>：在训练过的机器人和新机器人上的表现对比，用于评估“具身泛化”能力。(<a href="https://arxiv.org/abs/2310.08864?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<ol start="5">
<li><strong>语言对齐与指令遵循指标（VLA 特有）</strong></li>
</ol>
<ul>
<li><strong>指令完成度</strong>：给定指令“把红色杯子放进蓝色碗中”，不仅要搬运杯子，还要检查目标是否匹配（是否是“红色”“杯子”“蓝色碗”）。</li>
<li><strong>语言理解准确率</strong>：在某些设定中，会附加一个“是否遵守指令关键约束”的标志，例如是否选择了正确对象、是否满足约束条件（“不要移动绿色物体”）。</li>
</ul>
<hr>
<h4 id="7423-基准意义"><a class="header" href="#7423-基准意义">7.4.2.3 基准意义</a></h4>
<p>为什么需要如此繁琐的基准和指标？从研究者的角度，可以从三个层面理解其价值。</p>
<ol>
<li><strong>公平比较与复现</strong></li>
</ol>
<p>统一的任务定义、环境配置和指标，使得不同算法的结果具有可比性——你在 RLBench 上的 80% 成功率，可以直接和别人报告的数字对照，而不是“各做各的实验，各讲各的故事”。(<a href="https://arxiv.org/abs/1909.12271?utm_source=chatgpt.com">arXiv</a>)</p>
<ol start="2">
<li><strong>引导研究重点</strong></li>
</ol>
<p>精心设计的基准能“放大痛点”：</p>
<ul>
<li>泛化基准会迫使模型走出“单场景刷分”的舒适区。(<a href="https://arxiv.org/html/2402.08191v2?utm_source=chatgpt.com">arXiv</a>)</li>
<li>多机器人、多任务基准会推动大家思考“共享表征”和“具身基础模型”。(<a href="https://arxiv.org/abs/2310.08864?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>长远来看，基准本身就是一种“研究方向工程”，它把社区的注意力集中在某些被认为重要的问题上。</p>
<ol start="3">
<li><strong>连接学术与产业</strong></li>
</ol>
<p>产业界在意的是：<strong>在真实场景下，机器人到底好不好用</strong>。如果实验室里的基准已经考虑了成功率、效率、鲁棒性、安全性等因素，那么从基准性能到工业 KPI 的距离就会缩短许多。这也是近年来 RoboEval 等工作试图系统化评估方法的原因。(<a href="https://robo-eval.github.io/media/RoboEval.pdf?utm_source=chatgpt.com">robo-eval.github.io</a>)</p>
<hr>
<h3 id="743-如何基于开源数据开始-vla-实验"><a class="header" href="#743-如何基于开源数据开始-vla-实验">7.4.3 如何基于开源数据开始 VLA 实验</a></h3>
<p>前两小节回答了“有什么数据”和“如何评价”的问题，本节回到最实际的工程视角：<strong>如果只有一台电脑和若干开源数据集，该如何从零开始做 VLA 实验？</strong></p>
<p>可以把流程粗略划分为：<strong>数据获取 → 数据筛选与预处理 → 实验设计与训练评测</strong>。</p>
<hr>
<h4 id="7431-数据获取"><a class="header" href="#7431-数据获取">7.4.3.1 数据获取</a></h4>
<ol>
<li><strong>选择合适的数据源</strong></li>
</ol>
<p>结合本书前面对 VLA 的介绍，可以按以下维度选择：</p>
<ul>
<li><strong>现实 vs 仿真</strong>：
<ul>
<li>若首要目标是快速原型与算法比较，可优先使用 RLBench 这类仿真基准。(<a href="https://github.com/stepjam/RLBench?utm_source=chatgpt.com">GitHub</a>)</li>
<li>若关注 sim2real 或通用具身模型，可采用 RoboNet、Open X-Embodiment 等真实数据集。(<a href="https://arxiv.org/abs/1910.11215?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>是否需要语言</strong>：
<ul>
<li>仅训练视觉-动作策略，RoboNet、RLBench 原始演示即可。</li>
<li>若需要 VLA，可选择带语言描述的 RLBench 扩展集、Open X-Embodiment 中带语言标注的子集，或社区整理的语言条件数据。(<a href="https://arxiv.org/pdf/2209.04899?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>机器人/任务多样性</strong>：
<ul>
<li>针对单一机器人、小任务集：RLBench 子集、某个单独实验室数据。</li>
<li>针对多机器人、多任务：优先考虑 Open X-Embodiment。(<a href="https://arxiv.org/abs/2310.08864?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>下载与基础工具</strong></li>
</ol>
<ul>
<li><strong>官方仓库与镜像</strong>
<ul>
<li>RoboNet：提供官方 GitHub 仓库与 TensorFlow Datasets 条目，可直接用 tfds 或官方脚本加载数据。(<a href="https://github.com/SudeepDasari/RoboNet?utm_source=chatgpt.com">GitHub</a>)</li>
<li>RLBench：GitHub 上提供仿真环境、任务定义与 demo 生成脚本。(<a href="https://github.com/stepjam/RLBench?utm_source=chatgpt.com">GitHub</a>)</li>
<li>Open X-Embodiment：官方网站给出各子数据集下载链接以及统一的数据格式说明。(<a href="https://robotics-transformer-x.github.io/?utm_source=chatgpt.com">Open X-Embodiment</a>)</li>
</ul>
</li>
<li><strong>本地数据组织</strong>
建议在本地为每个数据集设计统一的目录结构，例如</li>
</ul>
<pre><code class="language-plain">dataset_root/
  ├── robonet/
  ├── rlbench/
  └── open_x/
</code></pre>
<p>并在其下维护统一的“清洗后子集”，避免反复对原始数据做耗时预处理。</p>
<blockquote>
<p>【图 7-17 占位】
画一个“数据流”示意图：从“官方数据源/下载脚本”流向“原始数据缓存”，再流向“预处理 &amp; 统一格式”，最终接入“训练 DataLoader”。</p>
</blockquote>
<hr>
<h4 id="7432-数据筛选"><a class="header" href="#7432-数据筛选">7.4.3.2 数据筛选</a></h4>
<p>开源数据体量巨大，直接“喂完所有数据”往往既不现实也不高效。对于初学者，更推荐<strong>先构造一个干净的子集</strong>，再逐步扩展。</p>
<ol>
<li><strong>按研究问题筛选</strong></li>
</ol>
<p>先问自己要解决的问题是什么，然后再反推数据选择。例如：</p>
<ul>
<li>想研究“语言条件下的单机器人多任务控制”？
→ 选 RLBench 中若干带语言描述的任务，或 Open X-Embodiment 中针对某一机械臂的多任务子集。(<a href="https://arxiv.org/pdf/2209.04899?utm_source=chatgpt.com">arXiv</a>)</li>
<li>想研究“多机器人共享策略”？
→ 从 RoboNet 或 Open X-Embodiment 中选取 2–3 种机械臂，在相似的桌面任务上构造混合训练集。(<a href="https://arxiv.org/abs/1910.11215?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<ol start="2">
<li><strong>按模态与视角筛选</strong></li>
</ol>
<ul>
<li>统一视觉输入：例如只保留“正前方相机”的 RGB 图像，把其他视角作为可选扩展。</li>
<li>固定分辨率与帧率：将所有图像 resize 到统一大小（如 128×128 或 224×224），并统一每条轨迹的时间步长（如每 0.1s 采样一次帧）。</li>
<li>明确状态与动作字段：例如限制所有轨迹都包含末端位姿 + 夹爪状态，剔除缺失关键字段的样本。</li>
</ul>
<ol start="3">
<li><strong>质量控制与清洗</strong></li>
</ol>
<ul>
<li><strong>去除损坏/异常样本</strong>：如图像无法解码、轨迹突然跳变到非法关节角、时间戳缺失等。(<a href="https://robo-eval.github.io/media/RoboEval.pdf?utm_source=chatgpt.com">robo-eval.github.io</a>)</li>
<li><strong>成功/失败划分</strong>：许多数据集会对轨迹标注成功/失败或分阶段成功，建议初期只使用高置信度成功轨迹做行为克隆，将失败样本留作后续奖励学习或鲁棒性研究。(<a href="https://bair.berkeley.edu/blog/2019/11/26/robo-net/?utm_source=chatgpt.com">bair.berkeley.edu</a>)</li>
<li><strong>平衡不同任务/机器人</strong>：避免某个任务或机器人因为样本过多主导训练，可以在 DataLoader 中实现按任务/机器人类别均匀采样（这一点在第 9 章会更系统地讨论）。</li>
</ul>
<hr>
<h4 id="7433-实验设计"><a class="header" href="#7433-实验设计">7.4.3.3 实验设计</a></h4>
<p>在有了“干净子集”之后，接下来是如何设计一个结构清晰、可逐步扩展的 VLA 实验。以下给出三种循序渐进的典型路线。</p>
<ol>
<li><strong>路线一：单任务 / 单机器人 VLA 入门</strong></li>
</ol>
<p>目标是先把**最小可行系统（MVP）**搭起来：</p>
<ul>
<li>数据：在 RLBench 里选一个带语言描述的任务（比如“打开抽屉”），采集若干演示。(<a href="https://arxiv.org/abs/1909.12271?utm_source=chatgpt.com">arXiv</a>)</li>
<li>模型：
<ul>
<li>视觉部分可以使用预训练 ResNet / ViT 提取图像特征。</li>
<li>语言部分使用小型 Transformer 或句向量模型将指令编码为向量。</li>
<li>动作输出使用简单的末端增量控制（例如 4–7 维连续动作，或粗粒度离散化成动作 token）。</li>
</ul>
</li>
<li>训练方式：
<ul>
<li>行为克隆（BC）：最简单直接，把“图像 + 语言 + 状态 → 下一步动作”当作监督学习。</li>
<li>评价：在同一任务新初始化条件下测试多次，统计成功率与平均完成时间。</li>
</ul>
</li>
</ul>
<p>这一阶段主要目的是熟悉<strong>数据管线 + 模型训练 + 仿真部署</strong>的完整闭环，而不是追求 SOTA 指标。</p>
<ol start="2">
<li><strong>路线二：多任务 VLA（同一机器人）</strong></li>
</ol>
<p>当单任务跑通后，可以迈向“一个模型管多个任务”的设置：</p>
<ul>
<li>数据：在 RLBench 或 Open X-Embodiment 中选择一台机器人和若干任务（如 10–20 个日常操作任务），保证每个任务有足够演示。(<a href="https://arxiv.org/abs/1909.12271?utm_source=chatgpt.com">arXiv</a>)</li>
<li>设计要点：
<ul>
<li>使用语言指令作为统一的“任务条件”，避免为每个任务单独加一个 one-hot ID。</li>
<li>在训练时采用按任务均衡采样，防止模型只学会样本量大的简单任务。</li>
<li>增加一个“任务泛化”测试：预留一部分任务只在测试时出现，检验零样本能力（只提供语言描述不提供演示）。</li>
</ul>
</li>
<li>评价：除成功率外，可以统计模型在“训练任务 vs 新任务”上的性能差距，观察是否存在明显的过拟合。</li>
</ul>
<ol start="3">
<li><strong>路线三：多机器人 VLA 与跨具身泛化</strong></li>
</ol>
<p>最后一步是利用 Open X-Embodiment 或 RoboNet 做“多机器人单模型”实验：(<a href="https://arxiv.org/abs/1910.11215?utm_source=chatgpt.com">arXiv</a>)</p>
<ul>
<li>数据选择：
<ul>
<li>选取 2–3 台结构差异适中的机械臂，保证它们都有类似的桌面操作任务（抓取、放置、推物体等）。</li>
<li>若使用 Open X-Embodiment，优先选择含语言标注的子集，便于复用前面多任务 VLA 的架构。</li>
</ul>
</li>
<li>模型设计：
<ul>
<li>在输入中加入<strong>具身编码（embodiment token）</strong>，例如一个表示机器人 ID 的向量，或基于机器人几何信息提取的嵌入。</li>
<li>输出端要么统一使用末端增量空间，要么为不同机器人设计轻量映射层，将共享“动作 token”映射到各自控制命令。</li>
</ul>
</li>
<li>训练与评测：
<ul>
<li>训练时混合不同机器人轨迹；</li>
<li>测试时既评估“见过的机器人”，也评估<strong>仅在少量数据上微调的新机器人</strong>的表现，考察跨具身迁移能力——这与 RT-X 的实验思路类似。(<a href="https://arxiv.org/abs/2310.08864?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>与后续章节的衔接</strong></li>
</ol>
<p>上述三条路线在复杂度上刚好吻合本书后续章节的难度递进：</p>
<ul>
<li>单任务 VLA → 第 8 章 VLA 架构中“单步决策 vs 序列决策”的最小例子；</li>
<li>多任务 VLA → 第 9 章多任务预训练与行为克隆阶段的实践案例；</li>
<li>多机器人 VLA → 第 10 章部署与跨平台评测中的“跨机器人迁移能力评估”。</li>
</ul>
<blockquote>
<p>【图 7-18 占位】
用一张“学习曲线 + 路线图”示意图，把三条路线画成由浅到深的阶梯，每一级标注“数据来源、模型复杂度、评测重点”等，帮助读者从宏观上把握学习路径。</p>
</blockquote>
<hr>
<p>通过本节，你可以将“抽象的数据集名字”和“看论文里的成功率曲线”转化为<strong>具体可操作的实验方案</strong>：
从哪个数据集下载数据、该怎么清洗、如何设计最初的实验问题、用什么指标衡量。等你真正动手跑完一两个这样的 VLA 实验，再回头看 RoboNet、RLBench、Open X-Embodiment、RT-X 等论文时，它们就不仅仅是公式和曲线，而是你自己已经踩过的一条经验路径的拓展与延伸。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="vla-的输入输出与总体结构"><a href="#vla-的输入输出与总体结构" class="header">VLA 的输入输出与总体结构</a></h1>
<h3 id="811-输入模态视觉语言状态历史轨迹"><a class="header" href="#811-输入模态视觉语言状态历史轨迹">8.1.1 输入模态：视觉、语言、状态、历史轨迹</a></h3>
<p>在 VLA 中，输入不再只是“图像 + 文字”这么简单，而是一个多模态的时序信息流。形式上，可以把当前时刻的决策看成是下面这个映射：</p>
<p>$$
a_t = \pi\big( I_{1:t}, L, s_{1:t}, a_{1:t-1} \big)
$$</p>
<p>其中 (I) 是视觉观测（图像/视频），(L) 是语言指令，(s) 是机器人状态，(a) 是历史动作。不同工作会对这些量做不同的简化，但整体思路类似：把“机器人看到的、听到的、感觉到的、以及刚刚做过什么”统一编码成一串 token，再交给 Transformer 这类序列模型处理。Gato、RT-1、RT-2、OpenVLA 等代表性系统都采用了类似的多模态序列建模范式。(<a href="https://openreview.net/forum?id=1ikK0kHjvj&amp;utm_source=chatgpt.com">OpenReview</a>)</p>
<p>【示意图：VLA 输入结构。左侧一列为多帧相机图像，中间为一行文本指令，上方为机器人关节状态曲线，下方为历史动作时间轴，右侧箭头指向“Transformer 编码器”。】</p>
<hr>
<h4 id="8111-视觉输入"><a class="header" href="#8111-视觉输入">8.1.1.1 视觉输入</a></h4>
<p>视觉输入是 VLA 的“眼睛”。它通常来自：</p>
<ul>
<li>单目 / 双目 / 多相机 RGB 图像</li>
<li>RGB-D（带深度）图像</li>
<li>直接的点云或投影到图像平面的 3D 特征</li>
</ul>
<p><strong>（1）单帧 vs 多帧</strong>
在最简单的设置里，模型每次看到一帧图像，基于这张图像和指令输出动作。但对于大多数操作任务，一张图不足以捕捉运动趋势：比如杯子是不是被刚刚推了一点、抽屉是打开还是正在打开。
因此，很多系统会输入最近的若干帧图像，让模型通过时间上的差异感知动态信息。比如 RT-1 就将一段短历史图像序列与任务描述一起输入 Transformer，再输出当前一步的动作。(<a href="https://community.libretranslate.com/t/rt-1-robotics-transformer/441?utm_source=chatgpt.com">LibreTranslate Community</a>)</p>
<p><strong>（2）原始像素 vs 中间表征</strong>
从工程角度看，视觉输入有两种常见形态：</p>
<ol>
<li><strong>原始像素（raw RGB/RGB-D）</strong>：
<ul>
<li>优点：信息最完整；端到端训练时，模型可以自己学“看到什么重要”。</li>
<li>缺点：维度高，对数据和算力要求大。</li>
</ul>
</li>
<li><strong>中间视觉特征</strong>（例如由 ResNet、ViT、DINOv2 等 backbone 提取的特征图或 token）(<a href="https://en.wikipedia.org/wiki/Vision-language-action_model?utm_source=chatgpt.com">维基百科</a>)：
<ul>
<li>优点：可以直接复用大规模视觉预训练的能力（如自监督学习得到的泛化特征），显著提升样本效率。</li>
<li>缺点：感知模块与决策模块之间形成“模块边界”，端到端微调时需要注意稳定性与接口设计。</li>
</ul>
</li>
</ol>
<p>目前主流 VLA，如 RT-1/RT-2、OpenVLA，多采用“预训练视觉 backbone + Transformer 决策头”的结构，在机器人数据上只微调部分层。(<a href="https://research.google/blog/rt-1-robotics-transformer-for-real-world-control-at-scale/?utm_source=chatgpt.com">Google Research</a>)</p>
<p><strong>（3）多视角与 3D 信息</strong>
对于抓取、插入等 3D 要求较高的任务，仅靠单视角 RGB 信息往往不够可靠，因此会引入：</p>
<ul>
<li>双目相机：由视差估计深度；</li>
<li>额外的顶视/侧视相机：从不同角度减少遮挡；</li>
<li>深度相机 / LiDAR：直接提供点云或深度图。</li>
</ul>
<p>这些 3D 信息要么被编码成额外的通道（如将深度图与 RGB 堆叠），要么单独通过 3D backbone（如 PointNet/3D-CNN）编码，再与图像特征在后续进行融合。</p>
<p>【示意图：上图为桌面场景真实 RGB 图像，下方为对应深度图和点云示意，箭头指向“视觉编码器”，输出若干视觉 token。】</p>
<hr>
<h4 id="8112-语言输入"><a class="header" href="#8112-语言输入">8.1.1.2 语言输入</a></h4>
<p>语言输入是 VLA 的“耳朵和任务说明书”。与传统机器人“通过 API 调参”不同，这里希望人类可以直接用自然语言描述任务，如：</p>
<blockquote>
<p>“把最靠近红杯子的蓝色方块放进抽屉里。”</p>
</blockquote>
<p>语言在 VLA 中主要承担三类角色（将在 4.4 展开，这里只做结构层面说明）：</p>
<ol>
<li><strong>任务目标描述（goal specification）</strong>
用一句话或几句话给出当前要完成的任务，这是最基础的形式。</li>
<li><strong>约束与偏好</strong>
例如“轻拿轻放”“不要碰到桌上的笔记本电脑”等，可视为对规划和控制的软约束。</li>
<li><strong>交互式纠偏 / 解释</strong>
在任务执行过程中用户追加指令：“速度再慢一点”“换另一只手抓”等，这些更新需要和当前状态一起被送入模型。</li>
</ol>
<p><strong>（1）语言编码方式</strong>
在现代 VLA 中，语言通常通过预训练大语言模型或轻量 Transformer 编码成 token 序列或句向量。RT-2 的一个关键设计，就是把机器人动作和自然语言统一表示为“文本 token”，这样模型在训练时可以在同一输出空间内既学回答问题，又学输出控制命令。(<a href="https://arxiv.org/abs/2307.15818?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>（2）上下文与多轮指令</strong>
VLA 常会把整个指令对话历史拼接起来，一并作为语言输入，让模型理解“之前已经说过什么”。这与 ChatGPT 等对话式 LLM 的做法类似，只是这里下游任务变成了“输出动作 token 序列”，而不仅仅是自然语言回复。</p>
<p>【示意图：一条时间轴，上方是用户多轮语言指令气泡（如对话框），下方是机器人执行示意，箭头连接至“语言编码器”输出 token 序列。】</p>
<hr>
<h4 id="8113-机器人状态"><a class="header" href="#8113-机器人状态">8.1.1.3 机器人状态</a></h4>
<p>如果视觉是“外感知”，机器人状态就是“本体感知（proprioception）”：机器人自己知道关节在哪里、动得快不快、有没有受力等。</p>
<p>典型的状态变量包括：</p>
<ul>
<li>关节角度 (q)、关节速度 (\dot{q})、（可选）关节力矩 (\tau)；</li>
<li>末端执行器的位姿（位置 + 姿态）、末端速度；</li>
<li>轮式底盘的位置和速度（对移动平台而言）；</li>
<li>手爪开合程度、吸盘是否吸附成功等执行器状态；</li>
<li>力/力矩传感器、碰撞开关等触觉/接触信息。</li>
</ul>
<p>在很多通用 agent（如 Gato）中，这些状态会被离散化或量化为 token，和文本、图像一起作为序列输入。(<a href="https://patrick-llgc.github.io/Learning-Deep-Learning/paper_notes/gato.html?utm_source=chatgpt.com">Patrick LLGC</a>)</p>
<p>从工程上看，状态向量通常会：</p>
<ul>
<li>做归一化（normalization），例如线性缩放到 ([-1, 1]) 区间，便于不同关节、不同机器人共享模型；</li>
<li>做子集选择，只保留与当前任务高度相关的维度（例如只给出末端姿态而不必给全部关节角）。</li>
</ul>
<p>在决策逻辑上，状态信息对“接触与力控”特别关键：视觉可能看不到当前接触力，但力/力矩传感器可以直接告诉模型“已经顶到墙了，不能再推”。</p>
<hr>
<h4 id="8114-历史轨迹"><a class="header" href="#8114-历史轨迹">8.1.1.4 历史轨迹</a></h4>
<p>现实世界通常是<strong>部分可观测</strong>的：一帧图像未必包含全部信息。例如机器人刚才是否已经把抽屉打开了一半，从当前视角可能看不清，但历史图像和动作是知道的。这就是为什么许多通用模型会把“历史轨迹”也一并编码进去。</p>
<p>所谓历史轨迹，可以简单理解为：</p>
<p>$$
\mathcal{H}<em>{t} = \big{(I_1, s_1, a_1), (I_2, s_2, a_2), \dots, (I</em>{t-1}, s_{t-1}, a_{t-1})\big}
$$</p>
<p>在序列建模框架下，这些元素被串成一个长序列，交替出现“观测 token、分隔符 token、动作 token”等，Transformer 每一步在整个上下文上自注意力，然后输出下一步动作 token。Gato 就明确采用这种“观测–动作交错 token 序列”的形式，并在一个固定的上下文窗口（如 1024 token）内滚动地进行决策。(<a href="https://arxiv.org/pdf/2205.06175?utm_source=chatgpt.com">arXiv</a>)</p>
<p>实践中，历史轨迹建模有几个常见技巧：</p>
<ul>
<li>使用<strong>滑动窗口</strong>：只保留最近 (K) 步历史，越久远的信息越不重要，避免序列过长导致计算量爆炸；</li>
<li>引入<strong>时间编码</strong>：类似位置编码，在每个 token 上叠加时间步 index 或相对时间，使模型区分“刚刚发生的”和“很久以前发生的”；</li>
<li>将长历史压缩为<strong>摘要 token</strong>：例如用一个小网络对过去几十步进行编码，输出一个“记忆向量”，再附加到当前输入中。</li>
</ul>
<p>【示意图：时间轴上依次排列观测 token（图像/状态）、动作 token，颜色不同表示不同模态，外层一个大括号表示”Transformer 上下文窗口“。】</p>
<hr>
<h3 id="812-输出模态动作-token--连续动作的离散化"><a class="header" href="#812-输出模态动作-token--连续动作的离散化">8.1.2 输出模态：动作 token / 连续动作的离散化</a></h3>
<p>输入统一成 token 序列之后，一个核心问题就是：<strong>机器人动作如何也变成“token”</strong>，从而可以用同一套语言建模技术来预测。</p>
<p>真实机器人控制量通常是连续的（力矩、速度、位置等），而 Transformer/LLM 天然擅长预测<strong>离散 token 序列</strong>。VLA 的一大关键设计，就是在“连续动作空间”与“离散 token 空间”之间搭建桥梁。</p>
<hr>
<h4 id="8121-连续动作空间"><a class="header" href="#8121-连续动作空间">8.1.2.1 连续动作空间</a></h4>
<p>在传统控制和强化学习中，机器人动作一般被表示为一个实数向量：</p>
<p>$$
a_t \in \mathbb{R}^d
$$</p>
<p>其中 (d) 可以是：</p>
<ul>
<li>机械臂末端的 6D 位姿增量（位置 3 维 + 姿态 3 维），再加一个抓手开合，凑成 7 维；</li>
<li>每个关节的目标位置/速度/力矩，一共若干维；</li>
<li>移动底盘的线速度 (v) 和角速度 (\omega) 等。</li>
</ul>
<p>连续动作的优点：</p>
<ul>
<li>表达精细，可直接对应物理量，易与现有控制器（如力矩控制、速度控制）对接；</li>
<li>在局部光滑条件下，易于用梯度方法优化（例如在模型预测控制 MPC 里做连续优化）。</li>
</ul>
<p>缺点也很明显：</p>
<ul>
<li>连续空间需要数值优化或函数逼近，直接塞进“下一个 token 预测”框架比较别扭；</li>
<li>不同机器人、不同任务的动作空间维度和范围差异巨大，想要共享一个统一策略会比较困难。</li>
</ul>
<p>因此，很多 VLA 工作会在“机器人实际控制接口”和“模型内部表示”之间，再加一层 <strong>动作离散化 + 解码</strong> 模块。</p>
<hr>
<h4 id="8122-动作离散化"><a class="header" href="#8122-动作离散化">8.1.2.2 动作离散化</a></h4>
<p>动作离散化（action discretization）的核心思想是：
<strong>把连续向量划分为若干有限的“动作符号”，这些符号可以当作 token 来预测</strong>。</p>
<p>常见方式包括：</p>
<p><strong>（1）逐维均匀量化</strong>
以 RT-1 为例，它将每个动作维度（如末端位移、旋转、抓手状态）离散成 256 个 bins，相当于把实数区间切成 256 段，每段对应一个离散 index。(<a href="https://research.google/blog/rt-1-robotics-transformer-for-real-world-control-at-scale/?utm_source=chatgpt.com">Google Research</a>)</p>
<ul>
<li>优点：实现简单、直观；</li>
<li>缺点：维数较高时，动作组合空间非常大，需要一些结构设计（如逐维预测、分组预测）才能训练得动。</li>
</ul>
<p>维基百科对 VLA 的总结同样指出，许多系统会把 6-DoF 末端位姿和抓手状态量化为 256 个离散等级，再通过“动作解码器”恢复到连续控制命令。(<a href="https://en.wikipedia.org/wiki/Vision-language-action_model?utm_source=chatgpt.com">维基百科</a>)</p>
<p><strong>（2）非均匀量化与 codebook 学习</strong>
另一个思路是从数据中学习一组“常用动作原语”：</p>
<ul>
<li>先对示教轨迹中的动作进行聚类（如 k-means），得到若干中心向量；</li>
<li>每个聚类中心视为一种“动作 token”；</li>
<li>训练时模型只需选择这些 token 的 index。</li>
</ul>
<p>这种方式本质上是做“动作向量的向量量化（VQ）”，能够把模型注意力集中在训练数据中出现频繁的动作模式上，而不是覆盖整个理论上的连续空间。</p>
<p><strong>（3）高层离散技能</strong>
在层级控制框架中，还可以把“技能（skill）”看作高层离散动作，比如：</p>
<ul>
<li><code>open_drawer</code></li>
<li><code>pick(red_block)</code></li>
<li><code>place_in(box)</code></li>
</ul>
<p>每个技能内部由专门的低层控制器或策略实现，VLA 只需要在技能级别做离散决策。这种做法在 SayCan 等“LLM+技能库”的工作中已经得到验证。(<a href="https://say-can.github.io/?utm_source=chatgpt.com">SayCan</a>)</p>
<p>【示意图：左侧是连续动作空间中的点云，右侧是若干离散“簇中心”（动作原语）和均匀量化区间，分别标注为不同 token ID。】</p>
<hr>
<h4 id="8123-动作-token-序列"><a class="header" href="#8123-动作-token-序列">8.1.2.3 动作 token 序列</a></h4>
<p>在完成离散化之后，动作就可以像语言一样被表示为 token 序列：</p>
<ul>
<li>每一个动作维度（或动作原语）对应一个 token；</li>
<li>整个动作向量可以是多个 token 的组合；</li>
<li>跨时间步的动作序列自然就变成一个长 token 序列。</li>
</ul>
<p>Gato 这样的通用 agent 就是用统一的 token 库来表示文本、图像特征索引、机器人状态以及动作，并在同一个 Transformer 中按 autoregressive 方式预测“下一个 token”。(<a href="https://arxiv.org/pdf/2205.06175?utm_source=chatgpt.com">arXiv</a>)</p>
<p>RT-2 更进一步，直接把机器人动作编码成“伪文本 token”，与自然语言 token 混在一起训练，使得同一个模型既能输出文字（回答问题），也能输出可执行动作序列。(<a href="https://arxiv.org/abs/2307.15818?utm_source=chatgpt.com">arXiv</a>)</p>
<p>典型的控制循环可以被描述为：</p>
<ol>
<li>将最新的视觉、语言、状态以及历史动作编码为 token 序列；</li>
<li>Transformer 在这些 token 上自回归地生成接下来若干动作 token；</li>
<li>将这些动作 token 解码为连续控制量，发送给机器人；</li>
<li>环境反馈新的图像和状态，周而复始。</li>
</ol>
<p>【示意图：一条 token 序列，前一部分是“文本 token + 视觉 token + 状态 token”，后面是待预测的“动作 token”，Transformer 自回归地一个一个生成，最后再通过“动作解码器”恢复到连续动作向量。】</p>
<hr>
<h3 id="813-单步决策-vs-序列决策"><a class="header" href="#813-单步决策-vs-序列决策">8.1.3 单步决策 vs 序列决策</a></h3>
<p>有了统一的输入和动作 token 表示之后，还要回答一个问题：
<strong>模型每次决策，是只输出“下一步动作”，还是直接输出“一整段动作序列”？</strong></p>
<p>这对应到控制理论，就是“闭环单步控制”与“开环/有限时域规划”的区别。不同任务、不同平台、不同安全需求，对这两种方式的偏好会不同。</p>
<hr>
<h4 id="8131-单步决策"><a class="header" href="#8131-单步决策">8.1.3.1 单步决策</a></h4>
<p>单步决策（step-wise / reactive policy）是当前现实机器人中最常见的方式。形式上，它实现的是：</p>
<p>$$
a_t \sim \pi(a_t \mid I_{1:t}, L, s_{1:t}, a_{1:t-1})
$$</p>
<p>每次只输出当前时刻的一个动作（或一组动作 token），然后等待环境给出新的传感输入，再进行下一步。这本质上是一个<strong>闭环反馈控制</strong>过程。</p>
<p>以 RT-1 为例，它每一控制周期读取最近几个图像帧和当前任务描述，Transformer 输出一个离散化动作向量，立即执行，再继续下一轮。(<a href="https://community.libretranslate.com/t/rt-1-robotics-transformer/441?utm_source=chatgpt.com">LibreTranslate Community</a>)</p>
<p>优点：</p>
<ul>
<li>对扰动、噪声和建模误差更鲁棒——环境有变化，下一步动作可以立刻调整；</li>
<li>更接近传统 RL/BC 的框架，算法和分析比较成熟；</li>
<li>易于与安全约束和低层控制器结合（例如每一步都可以进行可行性检查）。</li>
</ul>
<p>缺点：</p>
<ul>
<li>需要频繁调用大模型进行前向推理，算力和延迟开销较大；</li>
<li>难以显式表示“长远计划”，特别是在长时间、长距离导航或复杂多阶段操作任务中。</li>
</ul>
<hr>
<h4 id="8132-序列决策"><a class="header" href="#8132-序列决策">8.1.3.2 序列决策</a></h4>
<p>序列决策（sequence prediction / trajectory generation）的思路是：
<strong>模型在当前时刻一次性生成未来若干步的动作序列</strong>：</p>
<p>$$
(a_t, a_{t+1}, \dots, a_{t+H}) \sim \pi(\cdot \mid I_{1:t}, L, s_{1:t}, a_{1:t-1})
$$</p>
<p>这些动作可以在一段时间内作为“开环计划”执行，也可以在 MPC（模型预测控制）风格的框架中，只执行前几步再重规划。</p>
<p>利用序列决策的工作经常会：</p>
<ul>
<li>把未来动作序列看作“要预测的 token 序列”，用自回归或扩散模型在动作 token 空间上进行生成；(<a href="https://papers.nips.cc/paper_files/paper/2024/file/378226e5df7eded3e401de5c9493143c-Paper-Conference.pdf?utm_source=chatgpt.com">NIPS 论文集</a>)</li>
<li>或者同时预测未来动作和未来观测（如未来视频帧），利用“想象的未来”来评估不同计划的好坏，再选择其中最优的一条。</li>
</ul>
<p>优势：</p>
<ul>
<li>便于在计划阶段统一考虑长期约束，例如避障、能量消耗、任务时间等；</li>
<li>可以减少在线调用大模型的频率：一次生成多步动作，在低层快速执行。</li>
</ul>
<p>但它的弱点也很明显：</p>
<ul>
<li>对环境建模误差更敏感，一旦真实世界偏离预测，后续的开环动作可能变得不合理甚至危险；</li>
<li>序列越长，对模型的长期预测能力要求越高，对数据质量也越敏感。</li>
</ul>
<hr>
<h4 id="8133-折中方案"><a class="header" href="#8133-折中方案">8.1.3.3 折中方案</a></h4>
<p>在实际系统里，常见的做法不是“纯单步”或“纯序列”，而是各种折中与层级设计。几种典型思路：</p>
<p><strong>（1）有限时域滚动规划（MPC 风格 VLA）</strong></p>
<ul>
<li>模型每次生成一个有限长度 (H) 的动作序列；</li>
<li>实际执行时只执行前 (k) 步（通常 (k &lt; H)）；</li>
<li>然后重新获取传感信息，再生成新的序列。</li>
</ul>
<p>这样既能利用“多步规划”的优势，又保持对环境变化的适应性。很多现代操作系统隐含地采用了这种模式，只是把“序列”压缩为“几个关键帧”或“里程碑子目标”。</p>
<p><strong>（2）高层序列 + 低层单步控制（层级架构）</strong>
SayCan 是一个代表性例子：LLM 在高层输出一串“技能序列”（如“移动到桌边 → 抓取杯子 → 放入抽屉”），然后每个技能由经过 RL/BC 训练的低层策略在闭环方式下执行。(<a href="https://say-can.github.io/?utm_source=chatgpt.com">SayCan</a>)</p>
<p>在更一般的层级 VLA 中，高层可能输出：</p>
<ul>
<li>一串子目标位姿（waypoints）；</li>
<li>一组动作原语的调用序列；</li>
<li>或者自然语言形式的子任务列表。</li>
</ul>
<p>低层则专注于：给定局部目标，每个控制周期做单步闭环决策。</p>
<p><strong>（3）在线修正的计划执行</strong>
另一类折中是让 VLA 生成一段动作序列，但同时引入：</p>
<ul>
<li>在线视觉/力觉监控模块，在发现偏离预期或出现危险时打断计划；</li>
<li>或者一个额外的“纠偏网络”，根据当前偏差对后续计划进行重参数化。</li>
</ul>
<p>这类设计可以理解为“计划–执行并行”：计划提供长远结构，执行提供即时报错和调整。</p>
<p>【示意图：上半部分是“高层序列规划模块”，输出一串关键帧/技能；下半部分是“低层闭环控制模块”，每一小步根据当前观测微调动作；两者通过时间轴连接。】</p>
<hr>
<h3 id="814-统一模型-vs-模块化架构思路"><a class="header" href="#814-统一模型-vs-模块化架构思路">8.1.4 统一模型 vs 模块化架构思路</a></h3>
<p>到目前为止，我们都在假定“存在一个 VLA 模型 (\pi)”，它吃进一堆输入 token，吐出动作 token。但在现实系统中，这个“模型”到底是一整个端到端的大网络，还是多个模块的组合，是一个非常重要的系统设计问题。</p>
<p>简化地说，有三种典型风格：</p>
<ol>
<li>完全统一的端到端模型；</li>
<li>明确拆分的模块化架构；</li>
<li>兼顾两者优点的折中设计（部分统一、部分模块化）。</li>
</ol>
<hr>
<h4 id="8141-统一端到端模型"><a class="header" href="#8141-统一端到端模型">8.1.4.1 统一端到端模型</a></h4>
<p>统一端到端（monolithic, end-to-end）模型的代表包括 Gato、RT-1、RT-2、OpenVLA 等。(<a href="https://deepmind.google/blog/a-generalist-agent/?utm_source=chatgpt.com">Google DeepMind</a>)</p>
<p>共同特点是：</p>
<ul>
<li><strong>统一序列建模</strong>：
把图像特征、语言 token、机器人状态、历史动作统统映射到一个统一的 token 序列里；</li>
<li><strong>单一 Transformer 主干</strong>：
一个大型 Transformer 网络负责所有模态间的交互和时序建模；</li>
<li><strong>统一输出空间</strong>：
输出的 token 既可以代表文字，又可以代表动作、按钮、离散化连续量等。</li>
</ul>
<p>优势：</p>
<ol>
<li><strong>表示共享</strong>：不同任务、不同机器人、不同模态之间共享参数，利于涌现出通用的感知与决策能力；</li>
<li><strong>端到端优化</strong>：理论上可以把“视觉–语言–决策–动作”的整个链路一起训练，最大化最终任务成功率；</li>
<li><strong>系统结构简洁</strong>：对外暴露的是一个统一的“黑盒策略接口”，使用者只需要关心输入与输出。</li>
</ol>
<p>但代价也不小：</p>
<ul>
<li>需要巨量数据与算力支持大模型训练；</li>
<li>调试困难——出了问题很难定位是视觉没看懂、语言没理解，还是决策策略本身有缺陷；</li>
<li>在安全关键场景（如人机协作、医疗机器人）中，监管机构往往更倾向于“可解释、可验证”的模块化设计。</li>
</ul>
<hr>
<h4 id="8142-模块化架构"><a class="header" href="#8142-模块化架构">8.1.4.2 模块化架构</a></h4>
<p>模块化架构更接近传统机器人系统：</p>
<blockquote>
<p>感知（Perception） → 世界建模 / 语义理解 → 规划（Planning） → 控制（Control）</p>
</blockquote>
<p>在引入大模型之后，模块化思路通常会：</p>
<ul>
<li>使用 VLM/LLM 做<strong>高层语义理解与规划</strong>；</li>
<li>使用传统或基于学习的视觉模块做目标检测、场景重建；</li>
<li>使用经典运动规划（如 MoveIt, RRT*, TrajOpt）和控制（如 PID、力控制）作为低层执行器。</li>
</ul>
<p>SayCan 就是一个典型的模块化/层级系统：LLM 根据语言指令和环境文本描述计算“技能有多有用”，再结合 RL 训练得到的 value function 评价“技能在当前状态下有多可行”，两者合成后选择要执行的技能。(<a href="https://say-can.github.io/?utm_source=chatgpt.com">SayCan</a>)</p>
<p>近期的一些层级框架（如 RoBridge、分层 MA-LLM 等）进一步将“高层认知规划、符号中间表示、低层具身执行”拆成三个相对独立的子系统：(<a href="https://arxiv.org/html/2505.01709v3?utm_source=chatgpt.com">arXiv</a>)</p>
<ul>
<li>高层：大规模 VLM/LLM 做任务理解与策略规划；</li>
<li>中层：构造与物理直觉一致的符号表示（如拓扑地图、可操作对象集合）；</li>
<li>低层：具身 agent 根据中层指令进行精确控制与执行。</li>
</ul>
<p>模块化的优势：</p>
<ol>
<li><strong>可解释、可验证</strong>：每个模块有清晰的输入/输出接口，便于单独测试和验证；</li>
<li><strong>工程复用性高</strong>：可以直接用成熟的 SLAM、路径规划、控制库，而不是全靠大模型“自己学”；</li>
<li><strong>安全与调试友好</strong>：系统出错时容易定位在哪一环节，并可针对性增加“安全壳层”。</li>
</ol>
<p>缺点在于：</p>
<ul>
<li>模块之间的接口常常是“手工定义”的，中间表示不一定是最利于学习和泛化的；</li>
<li>端到端优化困难，可能导致整体性能被最弱的模块限制；</li>
<li>不同模块的分布偏移和误差会相互放大（error compounding）。</li>
</ul>
<p>【示意图：典型模块化系统框图，左侧为「视觉模块」和「语言理解模块」，中间是「任务规划 / 技能选择」，右侧是「运动规划」和「低层控制」，箭头表示信息流向。】</p>
<hr>
<h4 id="8143-折中设计"><a class="header" href="#8143-折中设计">8.1.4.3 折中设计</a></h4>
<p>现实中，很多最新的 VLA 系统都采用了<strong>介于“完全统一”和“完全模块化”之间的折中方案</strong>。几类常见设计：</p>
<p><strong>（1）预训练 backbone + 端到端决策头</strong>
例如 RT-2：</p>
<ul>
<li>视觉与语言部分采用预训练的 VLM（如 PaLM-E / PaLI-X）作为 backbone；</li>
<li>在其输出的多模态特征之上，增加一个轻量的动作头，把动作也当作 token 进行训练；</li>
<li>整体上保留端到端的 VLA 训练，但大部分参数来自稳定的预训练模型。(<a href="https://arxiv.org/abs/2307.15818?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>类似地，OpenVLA 采用 DINOv2 + CLIP 的组合视觉特征，再加上 Llama-2 语言 backbone，在统一的 Transformer 里输出离散动作 token，但同时支持参数高效微调和量化，以适应不同机器人平台。(<a href="https://en.wikipedia.org/wiki/Vision-language-action_model?utm_source=chatgpt.com">维基百科</a>)</p>
<p><strong>（2）统一高层脑 + 模块化低层身体</strong>
另一类折中是：</p>
<ul>
<li>高层完全交给一个大 VLA/LLM 模型，负责理解任务、规划子目标或技能序列；</li>
<li>低层则继续使用传统运动规划与控制器，对每个子目标进行精确执行和安全校验。</li>
</ul>
<p>RoBridge 等工作就采用了“高层认知规划（基于 VLM）、中层符号桥接、低层具身控制”的三层架构。(<a href="https://arxiv.org/html/2505.01709v3?utm_source=chatgpt.com">arXiv</a>)</p>
<p>这种方式既能充分利用大模型在语义和知识层面的优势，又不会完全丢弃现有机器人系统几十年积累下来的可靠控制和规划技术。</p>
<p><strong>（3）统一模型内部的“软模块化”</strong>
还有一些设计在一个统一模型内部，通过：</p>
<ul>
<li>不同的 prompt 模式（推理模式、执行模式）；</li>
<li>不同的输入前缀（如“你现在是一个规划器” vs “你现在是一个控制器”）；</li>
<li>或者不同的 adapter 分支</li>
</ul>
<p>来实现一种“软模块化”：在参数上高度共享，但在功能上分工明确。</p>
<p>总体来看，统一与模块化不存在绝对优劣。对于读者将来自己设计系统，可以参考如下经验性判断：</p>
<ul>
<li><strong>以研究和原型为主</strong>：倾向统一或半统一模型，尝试涌现出更通用的能力；</li>
<li><strong>以安全可靠部署为主</strong>：倾向模块化或层级架构，将 VLA 放在高层决策位置，与传统感知/规划/控制模块协同工作；</li>
<li><strong>从长远发展看</strong>：更大规模、更统一的具身基础模型很可能会逐步取代一部分手工模块，但在可预见的未来，“统一模型 + 安全壳层 + 工程模块”的混合形态将长期共存。</li>
</ul>
<p>【示意图：一张二维坐标图，横轴为“统一程度”（从完全模块化到完全端到端），纵轴为“安全/可解释性”，在中间区域标出 RT-2 / OpenVLA / RoBridge 等代表工作，说明它们处于不同折中点。】</p>
<hr>
<p>本节从输入模态、输出动作表示、决策粒度到整体架构，对 VLA 的“接口与形态”做了系统梳理。后续章节将在此基础上更具体地讨论视觉/语言编码模块（8.2）、动作解码与控制（8.3），以及多模态融合与条件建模（8.4），帮助读者把“接口层的直觉”逐渐深化为具体可实现的模型设计。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="视觉与语言编码模块"><a href="#视觉与语言编码模块" class="header">视觉与语言编码模块</a></h1>
<h3 id="821-视觉编码器cnn--vit--预训练视觉-backbone-使用方式"><a class="header" href="#821-视觉编码器cnn--vit--预训练视觉-backbone-使用方式">8.2.1 视觉编码器：CNN / ViT / 预训练视觉 backbone 使用方式</a></h3>
<p>在 VLA 模型中，视觉编码器的任务不是“给一张图打个标签”那么简单，而是要把来自相机的高维像素压缩为对决策最有用的表征：既要包含物体类别、空间布局、可抓取区域等语义信息，又要在实时性和算力约束下高效运行。典型做法是选取成熟的视觉 backbone（ResNet、ViT 等），在其输出特征基础上接入后续的多模态与决策模块。</p>
<p>【图 8-2-1 占位：CNN 与 ViT 作为视觉编码器的对比示意图。左：ResNet 结构示意（卷积 + 残差块 + 特征金字塔）；右：ViT 结构示意（图像切成 patch，加入位置编码后送入 Transformer）。】</p>
<h4 id="8211-卷积网络-cnn"><a class="header" href="#8211-卷积网络-cnn">8.2.1.1 卷积网络 CNN</a></h4>
<p>卷积神经网络（CNN）依靠“局部感受野 + 权重共享”的结构，在图像分类、检测、分割等任务上长时间占据主流地位，很多经典的视觉 backbone（如 VGG、ResNet、EfficientNet 等）都属于这一范畴。(<a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC7340949/?utm_source=chatgpt.com">PMC</a>)</p>
<p>在具身智能场景中使用 CNN 时，重点在于理解“它产出的特征张量能为机器人决策提供什么信息”：</p>
<ul>
<li><strong>层级特征与语义抽象</strong>
底层卷积核往往学习到边缘、角点等局部纹理；中层逐渐组合成轮廓、部件；高层则对应整物体或复杂结构。对机器人而言：
<ul>
<li>中低层特征有利于几何对齐（如抓取点回归、物体边缘检测）；</li>
<li>高层特征则承载“这是一个杯子/抽屉/门把手”这类语义。</li>
</ul>
</li>
<li><strong>残差网络 ResNet 的 backbone 角色</strong>
ResNet 通过残差连接显著减轻了深层网络的梯度消失问题，成为大量检测与分割网络的标准 backbone，如 Faster R-CNN、Mask R-CNN 等。(<a href="https://csm-kr.tistory.com/53?utm_source=chatgpt.com">아무블로그</a>)
对于机器人应用而言常见选型是：
<ul>
<li>ResNet-18 / 34：较浅，延迟低，适合嵌入式部署和高控制频率场景；</li>
<li>ResNet-50 / 101：表征能力更强，适合复杂场景或云端推理。</li>
</ul>
</li>
<li><strong>空间分辨率与特征金字塔</strong>
Backbone 通常通过步长为 2 的卷积或池化层逐步下采样，最终 feature map 的空间分辨率较低。对于需要精确抓取点的任务，单一低分辨率特征往往不够，需要：
<ul>
<li>使用特征金字塔（FPN）融合不同尺度特征；</li>
<li>或从 backbone 中间层（stride 较小的 feature map）读取特征，用于精细的像素级预测（可抓取检测、位姿估计等）。</li>
</ul>
</li>
<li><strong>机器人场景下的工程折中</strong>
在 VLA 系统中，视觉编码通常是端到端 pipeline 最重的一环。需要根据硬件限制进行折中：
<ul>
<li>控制周期较高（&gt;10 Hz）时优先选择浅层 backbone 或减小输入分辨率；</li>
<li>对场景变化不剧烈的任务，可降低视觉更新频率（如每 3–5 步更新一次视觉），中间时间步依赖预测或低维状态。</li>
</ul>
</li>
</ul>
<p>实践中，一个典型的“CNN 视觉编码器”实现是：相机图像缩放到固定尺寸（如 224×224），送入预训练的 ResNet，截取某一层的特征（如 C3/C4/C5），做全局平均池化得到一个固定维度的视觉 embedding，作为后续多模态 Transformer 的视觉 token。</p>
<h4 id="8212-视觉-transformer-vit"><a class="header" href="#8212-视觉-transformer-vit">8.2.1.2 视觉 Transformer ViT</a></h4>
<p>Vision Transformer（ViT）提出直接把图像切分为固定大小的 patch，将每个 patch 映射为向量，加上位置编码后送入标准 Transformer Encoder，从而完全抛弃卷积运算。(<a href="https://arxiv.org/abs/2010.11929?utm_source=chatgpt.com">arXiv</a>)</p>
<p>其关键思想是：“把图像当成序列”，让 self-attention 在所有 patch 之间建模全局关系。这种设计天然与语言、动作 token 的建模方式兼容，非常利于构建统一的多模态 Transformer 架构（在 8.5 节会进一步讨论）。</p>
<p>ViT 作为 VLA 视觉编码器时有以下特点：</p>
<ul>
<li><strong>全局建模能力强</strong>
self-attention 可以在任意两个 patch 之间建立直接联系，不受卷积感受野限制。这对需要理解大范围关系的任务尤其有利，例如：
<ul>
<li>判断目标物体与障碍物的相对位置；</li>
<li>理解“桌面整体整洁程度”这类全局属性。(<a href="https://arxiv.org/abs/2010.11929?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>对大规模预训练依赖更强</strong>
原始工作表明，ViT 在数据量不足时容易过拟合，需要在大规模数据（如 ImageNet-21K 或更大的私有数据集）上预训练，然后再在中小规模数据上微调。(<a href="https://arxiv.org/abs/2010.11929?utm_source=chatgpt.com">arXiv</a>)
对于机器人领域这种数据昂贵的场景，这反而与“强预训练 + 轻微调”的趋势高度契合。</li>
<li><strong>token 粒度与决策接口</strong>
ViT 输出通常包括：
<ul>
<li>全局 [CLS] token：可视作整幅图的压缩语义，用于与语言 embedding 对齐；</li>
<li>所有 patch token：可在 cross-attention 中作为“可被指令聚焦的视觉记忆”，例如根据语言“红色杯子”在 patch token 上做注意力聚焦。</li>
</ul>
</li>
<li><strong>计算开销与部署</strong>
ViT 的复杂度与 token 数量成二次方增长，分辨率越高、patch 越小，计算越重。实际 VLA 系统常选：
<ul>
<li>中等规模模型（如 ViT-B/16）；</li>
<li>较大的 patch 大小（16 或 32 像素）以减少 token 数；</li>
<li>或使用分层结构的视觉 Transformer（如 Swin Transformer）兼顾局部归纳偏置和全局建模能力。(<a href="https://www.mdpi.com/2227-7080/13/1/32?utm_source=chatgpt.com">MDPI</a>)</li>
</ul>
</li>
</ul>
<p>对于想构建“一个 Transformer 统一处理视觉、语言、动作”的读者而言，选择 ViT 或其变种作为视觉 backbone，会在结构上带来极大便利。</p>
<h4 id="8213-预训练骨干使用"><a class="header" href="#8213-预训练骨干使用">8.2.1.3 预训练骨干使用</a></h4>
<p>在具身智能中，“从零训练一个视觉编码器”几乎没有现实意义：机器人真实数据极其昂贵，且采集环境有限，如果不加约束，很容易过拟合某个特定实验室、某几件物体。因此，合理使用预训练视觉 backbone 是 VLA 系统设计中的核心共识。</p>
<p>常见的预训练来源包括：</p>
<ol>
<li><strong>监督预训练（ImageNet 等）</strong>
<ul>
<li>ResNet、ViT 等在 ImageNet-1K、ImageNet-21K 上进行分类预训练，学习到通用的视觉语义特征。(<a href="https://arxiv.org/abs/2010.11929?utm_source=chatgpt.com">arXiv</a>)</li>
<li>这类模型在许多下游任务中表现良好，是最常用的初始化方式。</li>
</ul>
</li>
<li><strong>自监督预训练（MAE 等）</strong>
<ul>
<li>Masked Autoencoder（MAE）等方法通过随机遮挡图像 patch、让模型重建缺失区域，学习高质量视觉表征，而无需人工标签。(<a href="https://arxiv.org/abs/2111.06377?utm_source=chatgpt.com">arXiv</a>)</li>
<li>自监督模型在迁移到各种视觉任务时往往比纯分类预训练有更好的泛化性，尤其适合与机器人多样环境结合。</li>
</ul>
</li>
<li><strong>多模态预训练（CLIP 图像塔）</strong>
<ul>
<li>CLIP 使用大规模图文对数据，通过对比学习共同训练图像编码器和文本编码器，使两者对齐到同一语义空间。(<a href="https://arxiv.org/abs/2103.00020?utm_source=chatgpt.com">arXiv</a>)</li>
<li>其图像塔（可以是 ResNet 或 ViT）已经学会“用自然语言描述世界”，在 VLA 中使用这样的 backbone 能显著提升“看懂指令所说之物”的能力。</li>
</ul>
</li>
</ol>
<p>使用预训练 backbone 时有几种典型策略：</p>
<ul>
<li><strong>冻结 backbone，只训练顶层投影/决策网络</strong>
适用于数据较少时，最大限度保留预训练知识，缺点是无法针对特定机器人场景做细致适配。</li>
<li><strong>部分解冻：只微调高层</strong>
把低层特征看作通用的边缘纹理，高层特征根据机器人任务进行微调，是实际工程中最常见的折中方案。</li>
<li><strong>全量微调</strong>
仅在具备大量机器人视觉数据或强正则化时使用；否则容易导致“灾难性遗忘”，把通用视觉知识破坏掉。</li>
</ul>
<p>【图 8-2-2 占位：预训练视觉 backbone 在 VLA pipeline 中的使用方式：左侧为相机图像流，经 backbone 变为特征；右侧连接多模态 Transformer 与动作解码头。】</p>
<p>在后续章节中，我们会多次强调：视觉 backbone 的选择和微调策略，往往决定了一个 VLA 系统在“看得懂世界”这件事上能走多远。</p>
<hr>
<h3 id="822-语言编码器llm-或轻量文本编码器"><a class="header" href="#822-语言编码器llm-或轻量文本编码器">8.2.2 语言编码器：LLM 或轻量文本编码器</a></h3>
<p>语言编码器负责把自然语言指令、环境描述、安全约束等文本信息变成向量形式，使之可以与视觉特征融合并指导动作生成。与纯 NLP 任务不同，机器人场景的语言往往简短（命令式）、结构清晰，但对细节和歧义极其敏感，例如“轻轻地把玻璃杯放到桌子角落”。</p>
<p>因此，本节重点不在于重新讲解 Transformer 原理，而是讨论：<strong>在具身智能系统中，如何选用合适的语言编码器，并与视觉、动作模块对接。</strong></p>
<h4 id="8221-大型语言模型作为编码器"><a class="header" href="#8221-大型语言模型作为编码器">8.2.2.1 大型语言模型作为编码器</a></h4>
<p>BERT 及后续的一系列大型 Transformer 语言模型证明，通过在海量文本上进行自监督预训练，可以得到极强的语义表征能力。(<a href="https://arxiv.org/abs/1810.04805?utm_source=chatgpt.com">arXiv</a>) 随着参数规模和数据量持续增大，现代 LLM（GPT 系列、PaLM、LLaMA 等）已经具备丰富的世界知识和强大的推理能力。</p>
<p>在 VLA 框架中，LLM 通常以两种方式参与：</p>
<ol>
<li><strong>作为“冻结的文本编码器”</strong>
<ul>
<li>给定一条指令，将其 tokenize 后输入 LLM，提取：
<ul>
<li>[CLS] 或特殊位置的向量；</li>
<li>或所有 token 向量的平均/加权和；</li>
</ul>
</li>
<li>得到的句子 embedding 作为后续多模态 Transformer 的语言条件。大量工作表明，使用 BERT 类模型的上下文化 embedding 可显著优于静态词向量。(<a href="https://aclanthology.org/2020.lrec-1.676/?utm_source=chatgpt.com">ACL Anthology</a>)</li>
<li>在这种设置下，LLM 的参数往往被冻结，仅在上方加一层小型投影网络适配当前任务。</li>
</ul>
</li>
<li><strong>作为“高层规划器/解释器”</strong>
<ul>
<li>更进一步，可以让一个对话式 LLM 接收环境摘要（视觉描述、当前状态）和人类指令，输出结构化的子任务列表或符号计划，然后由下游 VLA 模型执行。</li>
<li>这属于“LLM + 具身控制器”的层次化架构，本节不展开细节，但需要读者意识到：即便 LLM 不直接输出关节命令，其强大的语言理解与推理能力仍然可以在宏观层面塑造机器人行为。</li>
</ul>
</li>
</ol>
<p>LLM 作为编码器的优点是明显的：对复杂长指令、模糊描述、指代现象（“把它放回原处”）等有更好的理解；并且可以利用其世界知识补足训练数据中没有明说的常识（如“玻璃杯易碎，动作要慢”）。代价则是：</p>
<ul>
<li>参数量巨大，推理延迟高（尤其是云端部署时还要加上网络延迟）；</li>
<li>很难在机器人本体有限算力上直接部署全尺寸模型；</li>
<li>安全与可控性需要额外设计（将在第 10 章讨论）。</li>
</ul>
<p>因此，实际系统中常采用“离线或远程 LLM 负责高层规划 + 本地小模型负责实时控制”的混合方案。</p>
<h4 id="8222-轻量级文本编码"><a class="header" href="#8222-轻量级文本编码">8.2.2.2 轻量级文本编码</a></h4>
<p>与大型语言模型相比，小型 Transformer 编码器（如 DistilBERT、ALBERT、MobileBERT 等）通过知识蒸馏和结构压缩，在保持大部分语义能力的同时，显著降低了参数量与推理延迟。(<a href="https://huggingface.co/docs/transformers/en/model_doc/distilbert?utm_source=chatgpt.com">Hugging Face</a>)</p>
<p>在机器人场景中，这类模型非常适合用作“在线指令编码器”：</p>
<ul>
<li><strong>性能与效率折中</strong>
例如 DistilBERT 通过在预训练阶段对 BERT 进行知识蒸馏，参数量减少约 40%，但在多种 NLP 任务上仍保留约 97% 的性能。(<a href="https://arxiv.org/pdf/1910.01108?utm_source=chatgpt.com">arXiv</a>)
对于指令长度通常不长的 VLA 任务，这样的性能完全足够。</li>
<li><strong>专用句向量模型</strong>
Sentence-BERT 等“句子 Transformer”直接以“句子相似度”为优化目标，输出的 embedding 更适合距离度量与检索，也非常适合将语言指令编码为一个定长的语义向量，在多模态空间中与视觉 embedding 对齐。(<a href="https://www.sbert.net/docs/sentence_transformer/pretrained_models.html?utm_source=chatgpt.com">sbert.net</a>)</li>
<li><strong>领域内微调与蒸馏</strong>
一种常见策略是：
<ul>
<li>先用大模型（LLM）对机器人指令数据做离线标注或生成“伪标签”（例如对指令进行语义解析）；</li>
<li>再将这些信号蒸馏到一个小型文本编码器上，使其在本领域指令上表现接近大模型；</li>
<li>部署时仅保留小模型，兼顾性能与实时性。</li>
</ul>
</li>
</ul>
<p>对于想在真实机器人上本地运行 VLA 的读者，小型 Transformer 编码器 + 适度微调，往往是比直接调用 LLM 更务实的起点。</p>
<h4 id="8223-子词级别处理"><a class="header" href="#8223-子词级别处理">8.2.2.3 子词级别处理</a></h4>
<p>无论是大模型还是小模型，现代神经语言模型几乎都采用<strong>子词（subword）级别的分词方案</strong>，而不是传统的“空格切词”。这样做的原因包括：</p>
<ul>
<li>新词、拼写变体、混合语言非常常见；</li>
<li>机器人指令里常出现大量“物体名 + 型号 + 符号”（如“drawer_3”“箱子A-2”）；</li>
<li>单纯按词分割会导致词表巨大且 OOV（未登录词）严重。</li>
</ul>
<p><strong>Byte Pair Encoding（BPE）</strong> 是最常用的子词分词算法之一，最初源自数据压缩，后被引入神经机器翻译和语言建模。其基本过程是从字符级词表出发，迭代地将频繁共现的 token 对合并为新的子词单元，直到词表达到预设大小。(<a href="https://datasciencedojo.com/blog/byte-pair-encoding/?utm_source=chatgpt.com">Data Science Dojo</a>)</p>
<p>Google 提出的 <strong>SentencePiece</strong> 则进一步将 BPE 和 unigram 语言模型封装为一个“语言无关的子词分词工具”，可以直接在原始句子上训练分词器，不依赖预分词。(<a href="https://arxiv.org/abs/1808.06226?utm_source=chatgpt.com">arXiv</a>)</p>
<p>在 VLA 语言编码模块中，子词分词带来以下工程影响：</p>
<ul>
<li><strong>指令数据的准备</strong>
<ul>
<li>通常直接使用预训练模型自带的 tokenizer（BPE / SentencePiece），而不是自己重新分词；</li>
<li>如果机器人任务涉及大量专业名词或物体别名，可以在训练 tokenizer 时把这些词加入“用户词表”，避免被拆得过碎。</li>
</ul>
</li>
<li><strong>跨语言与混合输入</strong>
<ul>
<li>对中文、日文等不以空格分词的语言，子词方法可直接在字符/字节级进行建模；</li>
<li>对“中英混杂”的指令同样适用，对于具身任务中常见的“英文编号 + 中文描述”的情况尤为方便。</li>
</ul>
</li>
<li><strong>与多模态对齐的稳定性</strong>
<ul>
<li>物体名称、动作名等重要 token 的切分若不稳定，会给图文对齐带来噪声；</li>
<li>实践中常对这类 token 使用一致的格式（如 <code>&lt;OBJ_cup&gt;</code>）、或在分词器中锁定其为单一 token，以获得稳定的语义锚点。</li>
</ul>
</li>
</ul>
<p>【图 8-2-3 占位：语言编码示意图。左：原始文本指令；中：经 BPE/SentencePiece 分词得到 token 序列；右：经 Transformer 编码获得句向量和 token 向量。】</p>
<hr>
<h3 id="823-对齐视觉与语言特征空间的方法投影层对比训练"><a class="header" href="#823-对齐视觉与语言特征空间的方法投影层对比训练">8.2.3 对齐视觉与语言特征空间的方法（投影层、对比训练）</a></h3>
<p>当视觉编码器和语言编码器分别输出特征向量后，下一步问题是：<strong>如何把这两种模态“放进同一个语义空间”</strong>，从而支持：</p>
<ul>
<li>以文找图、以图找文；</li>
<li>“指令聚焦”到图像中的相关区域；</li>
<li>在统一 Transformer 中同时处理视觉、语言、动作 token。</li>
</ul>
<p>本节介绍三类常见对齐方式：投影层、对比训练、共享 Transformer。</p>
<h4 id="8231-投影层"><a class="header" href="#8231-投影层">8.2.3.1 投影层</a></h4>
<p>投影层（projection head）是紧接在视觉/语言编码器之后的小网络，一般由 1–2 层线性层或小型 MLP 组成，其作用包括：</p>
<ul>
<li>将不同编码器输出的特征统一到<strong>相同维度</strong>（例如都映射到 512 或 1024 维向量空间）；</li>
<li>施加适当的归一化（LayerNorm、L2 归一化），便于用点积或余弦距离衡量相似度；</li>
<li>引入极少量可训练参数，使得下游任务可以“调整”预训练特征而不破坏 backbone。</li>
</ul>
<p>在 CLIP 中，图像编码器和文本编码器各自后接一个线性投影层，并对输出向量进行 L2 归一化，从而将两者对齐到同一单位球面上。(<a href="https://arxiv.org/abs/2103.00020?utm_source=chatgpt.com">arXiv</a>) 在此基础上，可以直接用内积作为相似度，进行对比学习。</p>
<p>对 VLA 来说，投影层还有几种常用扩展：</p>
<ul>
<li><strong>模态特定投影 + 共享多模态空间</strong>
不同机器人、不同相机可以各自有一套视觉投影层，但共享语言投影层和后续决策模块，从而在“对齐空间”中抽象掉硬件差异。</li>
<li><strong>将机器人状态注入投影层</strong>
对于视觉特征，可以在投影时拼接当前机器人状态（关节角、夹爪开合等），让特征更接近实际可操作性（例如同一图像下，伸手前/伸手后看到的场景语义略有不同）。</li>
</ul>
<p>设计时的经验原则是：<strong>保持 backbone 尽量通用，把领域特定的适配集中在小而灵活的投影层中。</strong></p>
<h4 id="8232-对比训练"><a class="header" href="#8232-对比训练">8.2.3.2 对比训练</a></h4>
<p>投影层只是几何上的“对齐”，要真正让视觉与语言在语义上对齐，通常需要对比学习（contrastive learning）作为训练目标。</p>
<p>CLIP 的训练方式是典型代表：(<a href="https://arxiv.org/abs/2103.00020?utm_source=chatgpt.com">arXiv</a>)</p>
<ul>
<li>给定一个 batch 的图文对 ((I_i, T_i))，分别通过图像编码器和文本编码器 + 投影层得到向量 (v_i, t_i)；</li>
<li>计算所有图像–文本向量之间的相似度矩阵 (S_{ij} = \langle v_i, t_j \rangle)；</li>
<li>对每一行、每一列分别做 softmax 和交叉熵，使得：
<ul>
<li>正确配对 ((I_i, T_i)) 的相似度最大；</li>
<li>其他“错配”作为负例，被拉远。</li>
</ul>
</li>
</ul>
<p>这种 InfoNCE 风格的对比损失在实践中非常有效地学习到了图文对齐的语义空间，支持零样本分类、跨模态检索等能力。(<a href="https://en.wikipedia.org/wiki/Contrastive_Language-Image_Pre-training?utm_source=chatgpt.com">维基百科</a>)</p>
<p>在 VLA 预训练中，对比学习可以以多种方式使用：</p>
<ul>
<li><strong>互联网图文数据上的 CLIP 式预训练</strong>
先用大规模图文对训练基础视觉–语言对齐，再将该空间与机器人动作空间衔接。这一步更多是“通用语义”层面的学习。</li>
<li><strong>机器人示教数据上的任务级对比</strong>
利用指令–视觉–轨迹三元组构造正/负样本：
<ul>
<li>正样本：能成功完成某指令的轨迹起始帧与该指令；</li>
<li>负样本：同一帧配上其他不相关指令，或同一指令配上失败/不相干场景；
通过对比损失强化模型对“哪种视觉场景对应哪种任务意图”的辨别能力。</li>
</ul>
</li>
</ul>
<p>工程上，需要注意对比学习对 batch size、温度参数等非常敏感：</p>
<ul>
<li>batch 越大，负例越丰富，训练信号越强；</li>
<li>温度参数控制相似度的“锐度”，过大或过小都会影响收敛；</li>
<li>可以通过 hard negative mining 选取语义上接近但错误的图文对作为负例，提升模型判别能力。</li>
</ul>
<h4 id="8233-共享-transformer"><a class="header" href="#8233-共享-transformer">8.2.3.3 共享 Transformer</a></h4>
<p>与双塔（dual-encoder）结构中“先各自编码、再对齐”的思路不同，<strong>共享 Transformer</strong> 直接把视觉 token 和语言 token 拼接成一个长序列，送入统一的 Transformer 中进行 self-attention，从而在内部同时完成融合与对齐。</p>
<p>这类结构是许多视觉–语言模型（VLM）的基础：将图像 patch token（来自 CNN feature map 或 ViT）、语言 token 一并输入，让每个 token 可以对任意其他 token 建立注意力连接。</p>
<p>优点包括：</p>
<ul>
<li><strong>自然的跨模态交互</strong>
无需显式设计对齐损失，注意力机制会自动学习“哪个语言 token 应该关注哪些视觉 token”，例如指令中的“红色杯子”会在图像中激活对应区域。</li>
<li><strong>表达能力更强</strong>
单一 Transformer 可以同时为视觉和语言建模高阶组合关系，适合复杂推理任务，如多步操作计划、视觉问答等。相关工作表明，基于 Transformer 的视觉编码在足够数据条件下可以达到或超过传统 CNN。(<a href="https://www.mdpi.com/2227-7080/13/1/32?utm_source=chatgpt.com">MDPI</a>)</li>
<li><strong>易于扩展到动作 token</strong>
在 VLA 中，还可以进一步将动作 token 加入序列，实现“视觉–语言–动作”统一建模，这在 8.5 节会系统化地抽象。</li>
</ul>
<p>缺点则主要是计算开销：视觉 token 数量远多于语言 token，长序列 self-attention 的复杂度为 (O(n^2))，必须通过 patch 下采样、稀疏注意力、分块注意力等方式控制成本。</p>
<p>【图 8-2-4 占位：特征对齐结构对比图。左：双塔结构（独立图像/文本编码器 + 投影 + 对比学习）；右：共享 Transformer 结构（视觉/语言 token 拼接输入统一 Transformer）。】</p>
<hr>
<h3 id="824-时间维度处理多帧图像视频编码器的设计"><a class="header" href="#824-时间维度处理多帧图像视频编码器的设计">8.2.4 时间维度处理：多帧图像、视频编码器的设计</a></h3>
<p>机器人不是在看静态照片，而是在不断从视频流中感知世界。抓取、插拔、开门、跟随等操作都隐含了明确的时间顺序和动力学过程：物体是否已经被握紧？抽屉是不是已经完全打开？前方障碍物是在远离还是靠近？单帧图像往往不足以回答这些问题。</p>
<p>因此，VLA 模型在视觉编码阶段必须考虑时间维度。本节介绍从简单到复杂的几类设计。</p>
<h4 id="8241-视频输入需求"><a class="header" href="#8241-视频输入需求">8.2.4.1 视频输入需求</a></h4>
<p>从任务角度看，可大致区分两类：</p>
<ul>
<li><strong>准静态任务</strong>
如“从桌面抓起红色方块”，环境变化缓慢，单帧图像足够决策，只需偶尔更新视觉即可。</li>
<li><strong>强时序任务</strong>
如“旋开瓶盖”“把抽屉慢慢关上”“沿着人移动的方向跟随”，需要理解连续状态变化、物体速度和接触顺序，仅依靠当前帧容易模糊任务进度。</li>
</ul>
<p>视频输入能够为模型提供：</p>
<ul>
<li>运动信息：物体速度、方向、是否滑动、是否即将跌落；</li>
<li>交互阶段：如夹爪是否已经接触物体、有无碰撞、是否松手；</li>
<li>相机/机器人自身运动：在移动机器人或手眼相机场景中尤为重要。</li>
</ul>
<p>在系统实现上，视频输入还受到<strong>帧率、带宽和算力</strong>限制：</p>
<ul>
<li>视觉编解码和神经网络推理本身占用大量时间；</li>
<li>控制环路不能因“等视觉”而严重阻塞；</li>
<li>常见做法是：
<ul>
<li>只保留最近 (K) 帧（例如 2–8 帧）作为时序窗口；</li>
<li>或者对视频做时间下采样（每隔若干帧取一帧）；</li>
<li>对于高频控制，视觉更新频率通常低于控制频率。</li>
</ul>
</li>
</ul>
<p>随着专用视频 Transformer（如 TimeSformer）和自监督视频模型（如 VideoMAE）的发展，直接使用视频 backbone 进行时空特征编码正成为趋势。(<a href="https://arxiv.org/abs/2102.05095?utm_source=chatgpt.com">arXiv</a>)</p>
<h4 id="8242-多帧图像编码"><a class="header" href="#8242-多帧图像编码">8.2.4.2 多帧图像编码</a></h4>
<p>多帧编码可以从非常朴素的方案做起，再逐步演进到复杂的视频 Transformer。</p>
<ol>
<li>**多帧堆叠 + 2D CNN（早期融合）**最简单的方式是将最近 (K) 帧图像在通道维度上堆叠，例如将 3×H×W 的 RGB 图像变为 (3K \times H \times W)，然后交给标准 2D CNN 处理。卷积核在通道维的线性组合会捕捉到帧间差分，从而隐式利用时间信息。
<ul>
<li>优点：无需改动 backbone 结构，可直接复用现有的 2D CNN 权重（在某种程度上）；</li>
<li>缺点：时间维度被混合在通道维中，很难捕捉长距离依赖，对“动作阶段”的理解有限。</li>
</ul>
</li>
<li><strong>3D 卷积与时空 CNN</strong>3D 卷积在 ((t, h, w)) 三个维度上卷积，可直接建模局部时空体积，是传统视频动作识别中的主力工具。相比堆叠多帧，3D Conv 明确区分了时间与空间维度，对短时间窗口内的运动（如抓取瞬间的对准、物体滑动）建模更准确。在机器人场景中，3D CNN 常用于：
<ul>
<li>对几百毫秒尺度的动作阶段做精细分类（接近、抓取、提起、放置）；</li>
<li>建立视觉与动作之间更紧密的定时关系。</li>
</ul>
</li>
<li><strong>时序 Transformer / 视频 Transformer</strong>近年来的 TimeSformer 等工作把 Transformer 直接用于视频：将每一帧划分为 patch，并在空间和时间上统一做 self-attention，或采用“空间注意力 + 时间注意力分离”的分解结构，以降低计算复杂度。(<a href="https://arxiv.org/abs/2102.05095?utm_source=chatgpt.com">arXiv</a>)
<ul>
<li>空间注意力负责捕捉同一帧内的空间关系；</li>
<li>时间注意力建模不同帧之间的状态演化；</li>
<li>对于需要长期动作理解的任务（如人类演示的长视频）尤其有用。</li>
</ul>
</li>
</ol>
<p>在 VLA 中，一个务实的路线是：</p>
<ul>
<li>入门阶段：使用“多帧 2D CNN + 简单时序池化”（例如对每帧特征做平均或拼接，再输入决策 Transformer）；</li>
<li>进阶阶段：引入 3D CNN 或视频 Transformer 作为视觉 backbone，把“时间理解”尽可能下沉到视觉编码层。</li>
</ul>
<p>【图 8-2-5 占位：多帧图像编码结构对比图。上：多帧堆叠 + 2D CNN；中：3D CNN 时空卷积；下：TimeSformer 风格的时空注意力结构。】</p>
<h4 id="8243-隐状态记忆"><a class="header" href="#8243-隐状态记忆">8.2.4.3 隐状态记忆</a></h4>
<p>即便使用了多帧视频编码，模型看到的时间范围仍然有限。而机器人任务往往跨越数十秒甚至数分钟，仅依靠固定长度的视频窗口难以捕捉完整上下文。因此，决策模块还需要一个<strong>跨时间步的隐状态记忆（hidden state / memory）</strong>。</p>
<p>典型方案包括：</p>
<ol>
<li><strong>RNN / GRU / LSTM 上接视觉特征</strong>在每个控制周期，将视觉编码器输出的向量（或向量序列）送入一个轻量 RNN（如 GRU 或 LSTM），其隐状态在时间上递归更新：[
h_t = \mathrm{GRU}(x_t, h_{t-1})
$$
<ul>
<li>优点：实现简单、计算稳定，适合作为 CNN/ViT 之后的“时序头”；</li>
<li>缺点：对极长序列的建模能力有限，梯度传播容易衰减。</li>
</ul>
</li>
<li><strong>Transformer 的 KV-cache 记忆</strong>对于基于自回归 Transformer 的 VLA 模型，可以采用与 LLM 推理相同的 KV-cache 技术：</li>
</ol>
<p>这种做法具备：</p>
<p>代价是显存随历史长度线性增长，需要定期“截断上下文”或对旧信息做压缩。</p>
<pre><code>- 在时间步 (t)，将视觉 token、语言 token、历史动作 token 组成输入序列，通过 Transformer 得到当前输出；
- 同时缓存每一层的 Key/Value；
- 在时间步 (t+1) 时，仅追加新的 token，复用已有 KV，从而在意义上保留了完整历史。
- 强大的长程依赖建模能力；
- 与大模型推理的工程栈兼容（同一套优化工具可用于机器人推理）。
</code></pre>
<ol start="3">
<li><strong>显式记忆槽与摘要</strong>为了避免 KV-cache 无节制膨胀，可以设计显式记忆槽（memory slots）或状态摘要：
<ul>
<li>通过一个小网络将若干步历史视觉–动作信息压缩成固定维度的摘要向量；</li>
<li>将摘要作为额外 token 输入决策 Transformer，代替全部历史原始 token；</li>
<li>对于长时间任务（例如“打扫整个房间”），这样的摘要可以记录“已清扫区域”“已搬运物体”等高层状态。</li>
</ul>
</li>
</ol>
<p>在具身系统中，隐状态记忆的设计还与<strong>控制频率与 episode 管理</strong>紧密关联：</p>
<ul>
<li>视觉更新频率低于控制频率时，隐状态必须在视觉未更新的时间段内继续演化，预测“环境近似连续”的变化；</li>
<li>每次任务开始时要正确重置记忆，避免“上一次任务的残留状态”干扰当前决策；</li>
<li>对多机器人/多环境训练，需要在记忆中显式编码当前机器人 ID、环境 ID，以免跨环境信息污染。</li>
</ul>
<p>从长远看，“隐状态记忆”与第 12 章将讨论的<strong>世界模型和长序列建模</strong>紧密相关。未来的具身基础模型很可能会把“视频编码器 + 记忆网络”统一视为一个长序列模型，在几分钟甚至更长时间跨度内，端到端地建模视觉、语言和动作的相互作用。</p>
<p>【图 8-2-6 占位：时间维度与隐状态记忆示意图。左：摄像头连续帧经视觉编码器得到特征序列；中：RNN/Transformer 维护隐状态；右：隐状态影响当前动作输出。】</p>
<hr>
<p>通过本节的内容，读者应该对 VLA 中“看”和“听”的前端结构有了完整图景：
用 CNN 或 ViT 作为视觉 backbone；用 LLM 或轻量 encoder 作为语言模块；通过投影层和对比学习对齐跨模态特征；再在时间维度上用视频编码与隐状态记忆把片段连成故事。
在此基础上，下一节（8.3）将转向“如何把这些感知结果真正解码成可执行的动作”，完成从“看懂/听懂”到“做对”的关键一跳。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="动作表示与解码"><a href="#动作表示与解码" class="header">动作表示与解码</a></h1>
<p>下面这一节可以直接作为书稿的主体内容插进去（保留你原有的标题层级）。我会尽量用直观例子把概念讲清，同时避免和前面“任务建模与动作表示”等章节的重复。</p>
<hr>
<h3 id="83-动作表示与解码导言"><a class="header" href="#83-动作表示与解码导言">8.3 动作表示与解码（导言）</a></h3>
<p>前面在第 6 章我们已经从“机器人学”的视角讨论过关节空间、末端空间、Delta Pose / Velocity 命令等概念。到了 VLA 模型这一章，我们关心的是另一件事：<strong>如何把这些连续的控制量变成“token”，再用 Transformer 一类的大模型去“说出”动作序列</strong>。</p>
<p>这一节可以理解为“动作的语言学”：</p>
<ul>
<li>8.3.1 解决“如何把连续动作变成离散 token（tokenization）”；</li>
<li>8.3.2 解决“模型头（decoder head）如何按 token 生成动作”；</li>
<li>8.3.3 讨论多步动作生成时的采样与剪裁；</li>
<li>8.3.4 讨论把离散 token 再变回可执行、平滑、满足约束的轨迹。</li>
</ul>
<hr>
<h3 id="831-动作离散化tokenization-策略关节空间--末端空间"><a class="header" href="#831-动作离散化tokenization-策略关节空间--末端空间">8.3.1 动作离散化：tokenization 策略（关节空间 / 末端空间）</a></h3>
<p>从控制角度看，机器人动作通常是连续向量（关节角速度、末端速度等）；但从“语言模型”角度看，我们更希望它是<strong>有限词表上的离散 token</strong>。这一小节讨论如何从连续空间到 token 空间。</p>
<blockquote>
<p>【图 8-7 占位：关节空间与末端空间动作离散化示意图。
左：每个关节角度 / 速度被均匀分成若干区间；
右：工作空间中末端位姿被划分为 3D 网格与若干离散朝向。】</p>
</blockquote>
<h4 id="8311-逐关节离散"><a class="header" href="#8311-逐关节离散">8.3.1.1 逐关节离散</a></h4>
<p><strong>逐关节离散</strong>（per-joint / per-dimension discretization）是目前最经典、也最容易工程落地的一种方案：</p>
<ol>
<li><strong>确定每个动作维度的取值范围</strong>
例如 RT-1 中针对一台移动机械臂，将 7 维末端位姿（x, y, z, roll, pitch, yaw, gripper）、3 维底盘（x, y, yaw）以及一个模式选择变量统统视为动作维度，先在数据中统计它们的取值范围。(<a href="https://research.google/blog/rt-1-robotics-transformer-for-real-world-control-at-scale/?utm_source=chatgpt.com">谷歌研究</a>)</li>
<li><strong>将每个维度量化为固定个数的 bin</strong>
常见做法是为每一维设定 128 或 256 个离散区间（bin），每个区间对应一个 token ID。例如 RT-1 采用每维 256 个 bin 的量化，构成统一的“动作词表”，使不同任务、不同机器人共享同一种离散表示。(<a href="https://research.google/blog/rt-1-robotics-transformer-for-real-world-control-at-scale/?utm_source=chatgpt.com">谷歌研究</a>)</li>
<li><strong>量化策略：均匀 vs 分位数</strong>
<ul>
<li><strong>简单均匀量化</strong>：直接按区间长度均分整个范围；实现简单，但如果数据分布高度非均匀，会浪费很多 bin。</li>
<li><strong>分位数量化</strong>：先统计训练数据的分布，只在 [1%, 99%] 这样的高频区间内均匀划分，把极端异常值舍弃或单独处理，这也是不少 VLA 实践中常用的策略。(<a href="https://www.researchsquare.com/article/rs-5770637/v1.pdf?utm_source=chatgpt.com">Research Square</a>)</li>
</ul>
</li>
<li><strong>token 序列的结构</strong>
对于每一步动作，可以直接把“所有维度的 token 串联起来”视作一段短序列：
$$
a_t = [\text{tok}^{(1)}_t, \text{tok}^{(2)}_t, \dots, \text{tok}^{(D)}_t]
$$
其中 (D) 是动作维度数。解码器可以选择<strong>并行预测所有维度</strong>（见 8.3.2.2），也可以把每个维度也放在自回归链上逐个生成（虽然这样通常没必要）。</li>
</ol>
<p>逐关节离散的优点与不足：</p>
<ul>
<li><strong>优点</strong>：
<ul>
<li>实现简单，和 LLM 的 token 概念天然对齐。</li>
<li>各维度可独立量化，易于处理高维动作。</li>
<li>对于不同机器人，只要做同样的量化，就能共享一部分“动作语言”。</li>
</ul>
</li>
<li><strong>不足</strong>：
<ul>
<li>默认假设各维度近似独立，无法显式编码“某些组合更常见、更合理”的结构。</li>
<li>多维联合空间仍然是连续的；如果每维都需要高分辨率，bin 数急剧膨胀。</li>
<li>不能直接编码更高级别的语义，比如“沿桌面边缘平行滑动”这种空间模式。</li>
</ul>
</li>
</ul>
<p>近期的一些工作（如 FAST）开始探索用离散余弦变换（DCT）等压缩方式，把多维动作先映射到频域再量化，在保持精度的同时大幅压缩 token 数量，这类方法在高频、高维度的灵巧操作上很有优势。(<a href="https://arxiv.org/html/2501.09747v1?utm_source=chatgpt.com">arXiv</a>)</p>
<h4 id="8312-末端空间离散"><a class="header" href="#8312-末端空间离散">8.3.1.2 末端空间离散</a></h4>
<p>和逐关节离散相比，<strong>末端空间离散</strong>（end-effector space discretization）是在更“几何直观”的空间中划分 token：</p>
<ol>
<li><strong>工作空间网格化</strong>
<ul>
<li>在机器人可达的笛卡尔空间中建立 3D 网格（如 [x, y, z] 坐标的体素 grid），每个网格单元对应一个“粗略位置 token”。</li>
<li>姿态（roll, pitch, yaw）可以单独以球面网格或预定义有限集合（例如若干典型抓取姿态）离散。</li>
</ul>
</li>
<li><strong>增量式末端命令</strong>
实际控制中更常见的是离散化 <strong>Delta Pose</strong>：
<ul>
<li>例如对 (x,y,z) 的每轴位移离散成 {−2 cm, −1 cm, 0, +1 cm, +2 cm}；</li>
<li>姿态变换则离散为若干固定的旋转增量。
这样 token 更像是“方向键”而不是绝对坐标，和 6.3 节中的增量命令思想相呼应。</li>
</ul>
</li>
<li><strong>通用性与跨机器人共享</strong>
末端空间离散的一个重要优势是<strong>比较容易在不同机械臂之间共享</strong>：不同机器人在位姿空间具有相似的语义（靠近桌边、朝向物体等），只要 IK 求解器能把末端命令映射到各自关节空间，就可以用同一套动作 token 控制多种形态的机器人。</li>
<li><strong>挑战</strong>
<ul>
<li>必须依赖逆运动学（IK）和碰撞检测来保证动作可执行；</li>
<li>网格太粗会降低精度，太细又使词表爆炸；</li>
<li>对于高度冗余机械臂，同一末端 token 会对应大量关节解，可能导致执行时姿态不稳定。</li>
</ul>
</li>
</ol>
<p>在大规模 VLA 实践中，末端空间离散往往与逐关节离散同时存在：例如用末端增量 token 处理大尺度运动，再用关节级连续控制或更细粒度 token 做微调。</p>
<h4 id="8313-经验设计-vs-学习生成"><a class="header" href="#8313-经验设计-vs-学习生成">8.3.1.3 经验设计 vs 学习生成</a></h4>
<p>动作离散化有两条路线：<strong>经验设计（hand-crafted）<strong><strong>和</strong></strong>学习生成（learned tokenization）</strong>。</p>
<ol>
<li><strong>经验设计：Uniform / heuristic binning</strong>这类方法以 RT-1、RT-2 等工作为代表：</li>
</ol>
<p>优点是<strong>可解释、易调参</strong>，不同实验室可以用相似规范复现；缺点是：</p>
<pre><code>- 人工设定每个维度的范围与 bin 数，通常是“每维 256 bin + 分位数裁剪”之类的规则。([谷歌研究](https://research.google/blog/rt-1-robotics-transformer-for-real-world-control-at-scale/?utm_source=chatgpt.com))
- Grounding Multimodal LLMs in Actions 中称这种方法为“Uniform Action Tokenization”：对每个连续维度进行均匀或分位数切分，再将每一步动作表示成一串 token。([arXiv](https://arxiv.org/pdf/2406.07904?utm_source=chatgpt.com))
- 没有利用到数据的结构；
- 为了兼容各种任务，往往需要牺牲一部分分辨率或压缩率。
</code></pre>
<ol start="2">
<li><strong>学习生成：VQ / RVQ / Learned Codebook</strong>更近一步，可以把动作 token 看成“代码本（codebook）中的索引”，代码本则通过学习得到。典型思路是训练一个<strong>向量量化（VQ）或 VQ-VAE</strong>，用来压缩动作序列：(<a href="https://arxiv.org/abs/2507.01016?utm_source=chatgpt.com">arXiv</a>)</li>
</ol>
<p>这样，每个 code 就是一个 <strong>“典型动作模式” token</strong>，可以同时捕获多维之间的相关性，甚至可以直接在时间维做编码（一个 token = 一个短 action chunk）。</p>
<p>研究表明，基于语义对齐的动作 token 通常比简单回归或均匀量化取得更高的任务成功率。例如，针对 CALVIN 等长时操作基准时，学习到的 tokenization 在成功率上明显优于直接回归和 naive uniform binning。(<a href="https://www.researchgate.net/publication/361082731_CALVIN_A_Benchmark_for_Language-Conditioned_Policy_Learning_for_Long-Horizon_Robot_Manipulation_Tasks?utm_source=chatgpt.com">ResearchGate</a>)</p>
<p>这类方法的代价在于：</p>
<pre><code>- 编码器：将连续动作或短动作片段映射到一个潜在向量；
- VQ 模块：在一个离散代码本中找最近的若干 code（或级联 Residual VQ 的多级 code）；
- 解码器：从 code 重构回原始动作。
- 需要大量轨迹数据来训练 tokenizers（VQ-VLA 使用了比以往工作多两个数量级的合成轨迹数据）；([arXiv](https://arxiv.org/abs/2507.01016?utm_source=chatgpt.com))
- tokenizer 本身增加了一层建模误差，需要保证重构精度足够高。
</code></pre>
<ol start="3">
<li><strong>实践建议</strong>
<ul>
<li>如果数据规模有限或系统原型阶段，<strong>优先考虑简单的逐关节均匀离散</strong>，避免在 tokenizer 设计上耗尽精力。</li>
<li>当数据量很大、任务多样或需要长时规划时，可以引入<strong>学习型 tokenization</strong>（VQ / DCT 压缩等），把“动作词汇”当作一个需要预训练的模块，就像视觉 backbone 和语言 backbone 一样。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="832-动作解码头自回归解码-vs-并行预测"><a class="header" href="#832-动作解码头自回归解码-vs-并行预测">8.3.2 动作解码头：自回归解码 vs 并行预测</a></h3>
<p>有了动作 token，还需要一个“解码头”（policy head）将视觉–语言–历史状态的融合表示，转换为下一段动作 token 序列。这里的关键设计是：<strong>这些 token 是按顺序一个一个吐出来，还是一次性并行给出？</strong></p>
<blockquote>
<p>【图 8-8 占位：三种解码方式对比示意图。
左：自回归解码，按时间和维度逐个 token 生成；
中：并行解码，一次输出整个动作向量 / 短序列；
右：混合解码，先并行给出草案，再通过少量自回归 / diffusion 步骤细化。】</p>
</blockquote>
<h4 id="8321-自回归解码"><a class="header" href="#8321-自回归解码">8.3.2.1 自回归解码</a></h4>
<p>**自回归解码（autoregressive decoding）**是最接近传统语言模型的方式：把动作当作“句子”，下一个 token 的概率由“前文上下文 + 已生成的动作 token”共同决定。(<a href="https://www.emergentmind.com/topics/visual-action-autoregressive-transformer?utm_source=chatgpt.com">Emergent Mind</a>)</p>
<ol>
<li><strong>形式化</strong>
设当前时间步的动作序列为 (a_t = (a_{t,1}, \dots, a_{t,L}))，则自回归模型建模：
$$
p(a_t | \text{obs}, \text{instr}, \text{history}) = \prod_{i=1}^{L} p(a_{t,i} | a_{t,&lt;i}, \text{obs}, \text{instr}, \text{history})
$$</li>
<li><strong>优点</strong>
<ul>
<li>能自然表达多峰分布和复杂相关性，例如“如果前两个关节选择了某一组合，后面关节就自适应配合”。</li>
<li>序列长度可以灵活，和语言 token 混在一起训练（如 RT-2 中同时生成文字和动作 token）。(<a href="https://arxiv.org/abs/2307.15818?utm_source=chatgpt.com">arXiv</a>)</li>
<li>完全沿用 LLM 的训练管线，工程复用度高。</li>
</ul>
</li>
<li><strong>缺点</strong>
<ul>
<li>推理延迟高：一个 token 一次前向。对于高频控制（&gt;50 Hz）或长动作 chunk，这会成为关键瓶颈。</li>
<li>错误累积（exposure bias）：一旦前面某个 token 掉坑，后面整个序列都会围绕错误展开。</li>
<li>在动作维度不多、依赖结构相对简单时，自回归有点“杀鸡用牛刀”。</li>
</ul>
</li>
</ol>
<p>因此很多机器人工作采用折中的做法：<strong>在时间上自回归，在同一时间步的各维度上并行输出</strong>，即一步生成所有关节 / 末端的 token，而不是逐维自回归。</p>
<h4 id="8322-并行解码"><a class="header" href="#8322-并行解码">8.3.2.2 并行解码</a></h4>
<p>**并行解码（parallel decoding）**强调在一个前向中直接给出整段动作序列。典型例子包括：</p>
<ol>
<li><strong>Action Chunking Transformer（ACT / MT-ACT）</strong>
ACT 把一段连续控制序列视为一个“chunk”，用条件 VAE 或 Transformer 一次性生成整段动作，而不是逐步滚动生成。多任务版本 MT-ACT 则结合了多摄像头、语言指令等模态，在 encoder–decoder 结构上一次性吐出多个时间步的动作。(<a href="https://radekosmulski.com/how-to-train-your-robot-with-a-transformer/?utm_source=chatgpt.com">Radek Osmulski</a>)
<ul>
<li>解码器输入是一组“时间查询向量”，输出是对应时间步的动作；</li>
<li>从解码时看，这是一种<strong>时间维度并行解码</strong>：所有未来 H 步一起预测。</li>
</ul>
</li>
<li><strong>并行固定点解码（Parallel Fixed-Point Decoding）</strong>
近期有工作（如 PD-VLA 框架）把原本自回归的解码过程等价重写为一个非线性方程，再用并行迭代的方式求解，使得在不改网络结构的前提下也可以近似并行地预测所有动作 token。(<a href="https://arxiv.org/html/2503.02310v1?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>离散 diffusion / mask-based refinement</strong>
“离散 diffusion 到动作解码”的思路是：</li>
</ol>
<p>这也是一种<strong>并行 + 迭代 refinement</strong> 的解码方式，和图像生成中的 discrete diffusion 完全类似。</p>
<pre><code>- 从“全噪声”或“全 mask”动作序列开始；
- 多轮迭代中，每轮并行更新所有 token（或一部分 token），逐渐从噪声收敛到可执行的动作序列。([arXiv](https://arxiv.org/html/2508.20072v1?utm_source=chatgpt.com))
</code></pre>
<p>并行解码的优势在于<strong>延迟极低</strong>、适合高频控制或长时 chunk；缺点是：</p>
<ul>
<li>需要专门的训练目标（如重构整个序列），对超长序列时可能不易收敛；</li>
<li>在真正复杂的多步逻辑任务上，有时会暴露出“局部矛盾、不一致”的问题，需要配合后处理或额外约束（见 8.3.4）。</li>
</ul>
<h4 id="8323-混合方式"><a class="header" href="#8323-混合方式">8.3.2.3 混合方式</a></h4>
<p>在语言领域，已经出现大量<strong>半自回归（semi-autoregressive）</strong>、分组自回归等折中方案；这一思想同样可以迁移到动作生成：(<a href="https://www.mdpi.com/1424-8220/22/24/9606?utm_source=chatgpt.com">MDPI</a>)</p>
<ol>
<li><strong>分组 / 分层解码</strong>
<ul>
<li>把动作序列分成若干组（例如每组 4 步或每组若干关节），组内并行生成，组间自回归；</li>
<li>或者先生成一个<strong>粗分辨率</strong>的动作草图（低频、长时间步），再在每个时间插值点上用自回归 / diffusion 小网络做局部精细化。</li>
</ul>
</li>
<li><strong>“草稿 + 校对”式解码</strong>
<ul>
<li>第一阶段用并行解码或 diffusion 生成一个候选动作序列；</li>
<li>第二阶段使用一个轻量自回归“校对头”检查并局部修改高风险区域（例如接触发生前后的几步）。</li>
</ul>
</li>
<li><strong>chunk 级别自回归</strong>
ACT 的一个视角是：<strong>在 chunk 级别自回归，在 chunk 内部并行生成</strong>。即 policy 不是一步一步走，而是按宏观步骤（chunk）推进，每个 chunk 由专门的解码器一次生成。(<a href="https://radekosmulski.com/how-to-train-your-robot-with-a-transformer/?utm_source=chatgpt.com">Radek Osmulski</a>)</li>
</ol>
<p>对实际系统而言，“混合方式”最大的价值在于：
同时兼顾 <strong>决策延迟、序列一致性和网络复用</strong>，而且容易和后续的轨迹优化、约束投影（8.3.4）结合。</p>
<hr>
<h3 id="833-多步动作生成与剪裁temperaturetop-k-等"><a class="header" href="#833-多步动作生成与剪裁temperaturetop-k-等">8.3.3 多步动作生成与剪裁（temperature、top-k 等）</a></h3>
<p>一旦采用类似语言模型的解码方式，就不可避免要面对“<strong>如何从分布中采样动作 token</strong>”的问题。本节从采样策略、长序列剪裁、以及探索–确定性平衡三个角度展开。</p>
<blockquote>
<p>【图 8-9 占位：不同采样策略对 token 分布的影响。
图中展示同一 softmax 分布下：贪心、不同 temperature、top-k、top-p 的选取差异，以及对生成动作轨迹的影响。】</p>
</blockquote>
<h4 id="8331-取样策略"><a class="header" href="#8331-取样策略">8.3.3.1 取样策略</a></h4>
<p>给定解码器输出的 logits，我们可以有多种采样选择：</p>
<ol>
<li><strong>贪心 / Argmax 解码（Greedy）</strong>
直接选取概率最高的 token：
$$
a = \arg\max_i p_i
$$
<ul>
<li>优点：确定性强，行为可复现；</li>
<li>缺点：在多模态任务中容易倾向“平均动作”，比如抓取时输出“介于两个物体之间”的中庸轨迹。</li>
</ul>
</li>
<li><strong>温度缩放（Temperature Scaling）</strong>
将 logits 除以温度 (T)：
<ul>
<li>(T &lt; 1)：分布变尖锐，更接近贪心；</li>
<li>(T &gt; 1)：分布变平滑，增加随机性。
机器人场景中通常选用 <strong>较低温度（如 0.1–0.5）</strong>，保留一点探索以避免陷入坏局部解，但不过度随机。</li>
</ul>
</li>
<li><strong>Top-k / Nucleus（Top-p）采样</strong>
<ul>
<li><strong>Top-k</strong>：只在概率最高的 k 个 token 中重新归一化再采样；</li>
<li><strong>Top-p（Nucleus）</strong>：在累积概率达到 p（如 0.8）的一组 token 中采样。
对动作生成来说，这可以防止模型偶尔抽到极不合理的尾部 token，从而减少“抽风动作”。</li>
</ul>
</li>
<li><strong>对连续动作的采样</strong>
对于使用 diffusion policy 等连续生成方式的模型，其“采样”体现为<strong>多步噪声注入 + 梯度更新过程</strong>。这类方法往往天然具备多模态输出能力，能够处理高维连续动作空间，在实际机器人操作实验中取得了显著优势。(<a href="https://arxiv.org/abs/2303.04137?utm_source=chatgpt.com">arXiv</a>)</li>
</ol>
<p>训练阶段还可以使用“教师强迫 + 抽样”的混合策略：一部分步长用专家动作监督，一部分步长从模型分布中采样，以减轻纯教师强迫带来的分布漂移。</p>
<h4 id="8332-长序列剪裁"><a class="header" href="#8332-长序列剪裁">8.3.3.2 长序列剪裁</a></h4>
<p>VLA 模型在决策时通常不会只输出“下一步”，而是生成一个 <strong>长为 H 的动作序列</strong>，类似于 MPC（模型预测控制）中的预测地平线。</p>
<ol>
<li><strong>最大长度限制与 EOS token</strong>
<ul>
<li>在设计动作 token 序列格式时，可以加入类似文本中的 “” 终止符；</li>
<li>同时在训练和推理阶段限定一个 <strong>最大地平线 H</strong>，超过这一步就强制剪裁。
这样可以防止模型在长序列上“自言自语”过久，而不去接受新的感知信息。</li>
</ul>
</li>
<li><strong>滑动窗口与 receding horizon</strong>
常见做法是：
<ul>
<li>模型每次出一个 H 长度的序列；</li>
<li>实际只执行其中前 (h \ll H) 步；</li>
<li>然后重新观察环境，再由模型生成最新一段序列。
ACT / MT-ACT 一类 action-chunk 模型可以视作这种 receding horizon 策略在“chunk 级”的自然实现。(<a href="https://radekosmulski.com/how-to-train-your-robot-with-a-transformer/?utm_source=chatgpt.com">Radek Osmulski</a>)</li>
</ul>
</li>
<li><strong>基于任务阶段的剪裁</strong>
对复杂操作可以人为拆成若干阶段（approach / grasp / lift / place 等），每一阶段对应一个较短的动作序列。阶段之间通过语言指令、状态条件或高层 planner 触发切换，从而避免在一次解码中生成特别冗长的序列。</li>
</ol>
<h4 id="8333-平衡探索和确定性"><a class="header" href="#8333-平衡探索和确定性">8.3.3.3 平衡探索和确定性</a></h4>
<p>和强化学习中相似，动作生成也需要在“<strong>探索多样性</strong>”和“<strong>执行可靠性</strong>”之间平衡：</p>
<ol>
<li><strong>不同场景使用不同解码模式</strong>
<ul>
<li><strong>离线数据增强 / 仿真探索</strong>：可以适当提高温度、用 top-k / top-p 增加多样性，得到多条略有差异的轨迹，用来扩充训练数据。</li>
<li><strong>真实机器人执行</strong>：通常采用低温度甚至纯贪心解码，减少突发异常动作的概率。</li>
</ul>
</li>
<li><strong>不确定性感知与自适应采样</strong>
<ul>
<li>可以用输出熵、logits margin 等度量解码不确定性；</li>
<li>在不确定性高时：
<ul>
<li>生成多个候选序列，再用一个价值函数（例如预测成功率的网络）做重排序；</li>
<li>或者缩短预测地平线，让系统更快地重新观察和 replanning。</li>
</ul>
</li>
</ul>
</li>
<li><strong>与安全约束结合</strong>
解码自主增加随机性必须和安全层配合：
<ul>
<li>例如即使模型采样到速度较大的 token，后处理层仍会限幅（见 8.3.4.2）；</li>
<li>对高风险动作（接触、快速运动等）可以强制使用确定性解码。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="834-动作后处理插值平滑约束修正"><a class="header" href="#834-动作后处理插值平滑约束修正">8.3.4 动作后处理：插值、平滑、约束修正</a></h3>
<p>到这里，VLA 模型已经输出了一串“动作 token”。但真实机器人并不能直接执行 token，它需要的是平滑、连续、满足动力学/安全约束的轨迹。本节可以视作“把离散句子翻译成电机指令”的步骤。</p>
<blockquote>
<p>【图 8-10 占位：动作后处理整体流程图。
上：模型输出的离散 token 序列；
中：通过插值和平滑生成连续关节 / 末端轨迹；
下：加入关节限位、速度/加速度限幅和碰撞检查后的最终执行轨迹，同时标出执行监控的反馈回路。】</p>
</blockquote>
<h4 id="8341-插值与平滑"><a class="header" href="#8341-插值与平滑">8.3.4.1 插值与平滑</a></h4>
<p>离散 token 通常只对应<strong>稀疏时间点</strong>上的动作（每 50–100ms 一个），而低层伺服控制需要 1kHz 级别的目标轨迹。因此必须进行插值和平滑处理：</p>
<ol>
<li><strong>线性插值（Piecewise Linear）</strong>
最简单的方案是在相邻两个动作之间做线性插值：
$$
a(\tau) = (1-\alpha)a_t + \alpha a_{t+1},\quad \alpha\in[0,1]
$$
<ul>
<li>优点：实现简单、实时性好；</li>
<li>缺点：速度和加速度在关键点存在不连续，可能导致机械结构抖动。</li>
</ul>
</li>
<li><strong>多项式 / 样条插值（Cubic Spline, B-Spline）</strong>
使用三次样条或 B-spline 可以生成速度和加速度连续的轨迹；
一些最近的动作 tokenization 工作直接把动作表示为 B-spline 控制点的离散编码，在 token 层面就内置平滑轨迹先验，相当于“把平滑性学进 tokenizer 里”。(<a href="https://arxiv.org/html/2506.06072v1?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>滤波与低通处理</strong>
对于关节速度、末端速度等指令，可以在插值后的轨迹上施加：
<ul>
<li>低通滤波器（如一阶滤波、Butterworth）；</li>
<li>或 Savitzky–Golay 平滑滤波，在尽量不扭曲轨迹形状的前提下降噪。
这些操作可以视为在轨迹空间对高频成分限幅，从而避免激发结构共振或电机噪音。</li>
</ul>
</li>
</ol>
<p>实际系统会根据硬件约束和任务特点选择合适的插值方案：高速、刚性系统更依赖样条和平滑；慢速、柔顺系统可以接受略粗糙的线性插值。</p>
<h4 id="8342-约束修正"><a class="header" href="#8342-约束修正">8.3.4.2 约束修正</a></h4>
<p>无论离散化和解码做得多精致，都不能保证输出动作天然满足所有物理和安全约束，因此需要在执行前做一次<strong>约束修正（constraint projection / correction）</strong>。</p>
<p>典型的约束包括：</p>
<ol>
<li><strong>关节限位与软限位</strong>
<ul>
<li>对每个关节设置硬限位（物理极限）和软限位（安全范围）；</li>
<li>对插值后的关节角度、速度、加速度进行逐点检查，若超出范围则进行裁剪（clipping）或缩放（scaling）。</li>
</ul>
</li>
<li><strong>速度 / 加速度限幅与轨迹重定时</strong>
<ul>
<li>原始轨迹在几何上合理，但速度峰值可能超出驱动能力；</li>
<li>可以通过“时间重缩放”（time scaling）的方法：延长执行时间，使得在任何时刻速度、加速度都不超阈值。
这和传统轨迹规划中的“时间参数化”完全一致，只不过这里的输入轨迹是 VLA 模型给的。</li>
</ul>
</li>
<li><strong>碰撞和可达性检查</strong>
<ul>
<li>在末端空间离散；某些 token 对应的末端位姿可能落在障碍物内部或超出可达域；</li>
<li>可在执行前对关键点（尤其是接近目标物体和环境边界的位置）调用快速碰撞检测；</li>
<li>对不可行的动作，可以：
<ul>
<li>就近投影到安全边界；</li>
<li>或直接标记该 token 无效，重新采样 / 重新解码。</li>
</ul>
</li>
</ul>
</li>
<li><strong>与 tokenization 的联动</strong>
<ul>
<li>如果使用学习型 tokenizer（比如 VQ 或采用 B-spline 的 BEAST），可以把“物理可行性”作为重建损失和代码本学习的一部分，使多数 token 本身就对应“好轨迹”；(<a href="https://arxiv.org/html/2506.06072v1?utm_source=chatgpt.com">arXiv</a>)</li>
<li>但在工程上，仍然需要显式的约束层做最后把关，避免“罕见失败”带来严重后果。</li>
</ul>
</li>
</ol>
<h4 id="8343-执行监控"><a class="header" href="#8343-执行监控">8.3.4.3 执行监控</a></h4>
<p>最后，即便轨迹已经过插值和平滑、约束修正，在执行过程中也需要实时<strong>监控（execution monitoring）</strong>，这部分相当于一个“安全监督者”和“现实检验器”。</p>
<ol>
<li><strong>跟踪误差监控</strong>
<ul>
<li>监控关节空间或末端空间的跟踪误差（误差超过阈值说明执行不如预期）；</li>
<li>一旦误差持续高企，可以触发：
<ul>
<li>暂停执行并进入安全姿态；</li>
<li>向高层 VLA 请求重新规划；</li>
<li>切换到传统稳定控制（如一个保守的抓取/放置脚本）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>环境结果监控</strong>
<ul>
<li>利用视觉 / 触觉感知检查关键事件是否发生：例如抓取后物体是否真正离开桌面、放置物体是否稳定；</li>
<li>如果检测到“动作没有产生预期效果”（比如物体滑落），可以在语言层反馈（“抓取失败”）并重新发起局部操作。</li>
</ul>
</li>
<li><strong>安全监控与急停</strong>
<ul>
<li>监控力矩、电流、关节温度等指标，检测潜在碰撞或机械过载；</li>
<li>一旦检测到异常，优先触发硬件或软件急停，而不是继续执行后续 token；</li>
<li>在具备人机协作场景时，需要配合前面第 10.3 节的安全策略一起设计，形成从高层决策到低层驱动的多重防线。</li>
</ul>
</li>
</ol>
<p>从系统整体角度来看，本节介绍的动作后处理层可以视为 VLA 模型与传统机器人控制模块之间的“缓冲区”——上游是高维 token 序列，下游是电机电流和力矩指令，中间这一层负责：<strong>把“语言式的决策”翻译成“物理上合理、平滑、安全的动作”</strong>。</p>
<hr>
<p>本节完成后，读者应该能够从“动作作为 token”到“动作在机器人上真实执行”建立一条完整链路的直觉。在第 9 章中，我们会进一步从训练角度讨论：在有了这些动作表示和解码方式之后，如何设计行为克隆、强化学习、自监督目标，让模型在数据中习得高质量的动作分布。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="多模态融合与条件建模"><a href="#多模态融合与条件建模" class="header">多模态融合与条件建模</a></h1>
<h3 id="841-早期融合晚期融合与中间融合方式"><a class="header" href="#841-早期融合晚期融合与中间融合方式">8.4.1 早期融合、晚期融合与中间融合方式</a></h3>
<p>在 VLA 中，“多模态融合”不仅仅是一个抽象概念，而是一个非常具体的工程设计问题：<strong>视觉、语言、机器人状态 / 动作这几路信息到底在什么阶段合在一起？</strong>
从时间位置来看，主流做法可以分为三类：早期融合（early fusion）、中间融合（intermediate / mid-level fusion）、晚期融合（late fusion）(<a href="https://arxiv.org/html/2504.02477v3?utm_source=chatgpt.com">arXiv</a>)。三者各有优劣，并且已经在不同的 VLA 架构中得到应用。</p>
<p>【插图占位 8.4-1：一张流水线示意图，分别画出早期融合（原始模态直接拼接）、中间融合（各自编码后在特征层合并）、晚期融合（各自输出决策后再融合）的结构对比】</p>
<h4 id="8411-早期融合"><a class="header" href="#8411-早期融合">8.4.1.1 早期融合</a></h4>
<p><strong>定义：</strong>
早期融合是指在“输入阶段”就把各模态的数据合在一起，再交给统一的主干网络学习。例如：</p>
<ul>
<li>将图像 patch token、语言 token、机器人状态 token 直接串联成一个长序列，送入同一个 Transformer；</li>
<li>或者在进入策略网络之前，先用一个 VLM（如 CLIP）对视觉与语言进行对齐，再将得到的<strong>联合视觉–语言特征</strong>与动作 / 状态一起输入策略网络，这类专门强调“Early Fusion VLA”的工作已经出现(<a href="https://openreview.net/pdf/597ad7d82069689b810bb1d506f1ed3dcfbe2bc1.pdf?utm_source=chatgpt.com">OpenReview</a>)。</li>
</ul>
<p>形式上可以理解为：
$$
\text{输入序列} = [\text{语言 token},\ \text{图像 patch token},\ \text{状态 / 历史 token}]
$$
统一送入一个 Transformer，通过自注意力让所有模态在<strong>第一层</strong>就开始交互。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>细粒度对齐能力强。</strong>
例如“抓起碗左边的红色杯子”，语言 token 中的“红色杯子”“左边”，可以直接在自注意力中与对应图像 patch 建立紧密联系，有利于精准 grounding。</li>
<li><strong>信息损失少。</strong>
由于在非常早的阶段就共同建模，模型可以自己决定保留什么细节、丢弃什么细节，而不是先分别压缩各模态后再合并。</li>
<li><strong>对 VLM 预训练能力利用充分。</strong>
一些工作在 CLIP 之上做早期融合，将预训练好的图文对齐特征直接用于控制决策，而不是“晚点才考虑语言”(<a href="https://openreview.net/pdf/597ad7d82069689b810bb1d506f1ed3dcfbe2bc1.pdf?utm_source=chatgpt.com">OpenReview</a>)。</li>
</ul>
<p><strong>缺点与工程挑战：</strong></p>
<ul>
<li><strong>维度高、计算重。</strong>
所有模态 token 放一起，自注意力复杂度是 (O(n^2))，视觉 patch 多时，对显存和算力要求很高。</li>
<li><strong>对噪声敏感。</strong>
早期融合意味着低层表示就互相影响，视觉噪声、语言歧义都可能放大到整个网络。</li>
<li><strong>训练更加“脆弱”。</strong>
如果机器人数据量不够大，很容易把预训练 VLM 学到的“通用知识”扰乱。实际工程中，常见做法是：
<ul>
<li>冻结大部分预训练视觉–语言编码器；</li>
<li>只训练少量适配层或策略头，或者采用参数高效微调（如 LoRA）。</li>
</ul>
</li>
</ul>
<p>在本书语境下，可以把早期融合看成**“极端端到端”**的 VLA 设计：从最原始的多模态输入开始，就只交给一个统一的 Transformer 去学。</p>
<h4 id="8412-晚期融合"><a class="header" href="#8412-晚期融合">8.4.1.2 晚期融合</a></h4>
<p><strong>定义：</strong>
晚期融合（late fusion）是指<strong>先让每个模态（甚至每个模态自己的决策网络）各自算完，再在输出层或决策层做组合</strong>(<a href="https://arxiv.org/html/2504.02477v3?utm_source=chatgpt.com">arXiv</a>)。在 VLA 中常见几种形式：</p>
<ul>
<li>视觉–语言用一个现成的 VLM 做理解；</li>
<li>动作策略用另一个网络，仅接收“任务 embedding”或“检索结果”；</li>
<li>最终决策由一个小网络或手工规则，把“视觉–语言建议”和“低层控制建议”做加权或门控。</li>
</ul>
<p>可以形式化为：
$$
\pi(a|o, x) = g\big(\pi_{\text{vision}}(o),\ \pi_{\text{language}}(x),\ \pi_{\text{state}}(s)\big)
$$
其中 (g) 是一种融合函数，可以是简单加权平均，也可以是门控网络或 Mixture-of-Experts。</p>
<p><strong>优点：</strong></p>
<ul>
<li><strong>模块化强，易维护。</strong>
视觉–语言理解模块、策略模块可以相对独立演化。比如更新 VLM 到更大的版本，不一定要重训整套策略。</li>
<li><strong>利用已有系统更方便。</strong>
工程中常见：保留已有的 SLAM、规划器或传统控制器，只用 VLA 模块提供“高层建议”，这本质上就是一种晚期融合。</li>
<li><strong>训练稳定性好。</strong>
各模态先在自己的任务上得到较稳定的表示（例如 VLM 保持冻结），最终只微调一个小的融合 / 决策头，出错范围相对可控。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>跨模态细粒度交互能力弱。</strong>
如果视觉和语言各自“先压缩成一个向量”，再合并，模型很难在像素级精确理解“哪个杯子才是‘左边的红色杯子’”。</li>
<li><strong>容易产生“决策割裂”。</strong>
视觉模块说 A 更重要，语言模块说 B 更重要，若融合函数设计不当，整体行为可能不稳定。</li>
<li><strong>对 VLA 的统一性有限。</strong>
从理念上，晚期融合更接近“模块堆叠”，而不是一个真正统一的“视觉–语言–动作基础模型”。</li>
</ul>
<p>晚期融合在机器人系统整合阶段非常常见，在第 10 章中讨论“VLA 与传统规划 / 控制模块”接口时，可以与这里形成呼应。</p>
<h4 id="8413-中间融合"><a class="header" href="#8413-中间融合">8.4.1.3 中间融合</a></h4>
<p><strong>定义：</strong>
中间融合（mid-level / intermediate fusion）介于二者之间：<strong>先为每种模态提取中层特征，再通过特征级别的交互模块（往往是 cross-attention 或特征拼接）进行融合</strong>(<a href="https://arxiv.org/html/2504.02477v3?utm_source=chatgpt.com">arXiv</a>)。
典型做法是：</p>
<ol>
<li>视觉 backbone（CNN/ViT）将图像映射为一组视觉 token；</li>
<li>语言编码器（LLM 或小型 Transformer）将指令映射为一组语言 token 或一个全局 embedding；</li>
<li>再用专门的多模态 Transformer / cross-attention 层，将二者、中加机器人状态 token 在<strong>中层</strong>融合，最后输出动作。</li>
</ol>
<p>许多代表性的 VLM/VLA（如 Flamingo、PaLI-X 及在其基础上扩展的 RoboFlamingo、RT-2、OpenVLA 等）都属于此类结构：视觉、语言分别有自己的 encoder，然后在若干层 cross-attention 模块中交互(<a href="https://openaccess.thecvf.com/content/ICCV2025/papers/Miao_FedVLA_Federated_Vision-Language-Action_Learning_with_Dual_Gating_Mixture-of-Experts_for_Robotic_ICCV_2025_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)。</p>
<p><strong>中间融合的特点：</strong></p>
<ul>
<li><strong>保留每个模态的“专业 backbone”。</strong>
可以直接复用 ImageNet / 自监督预训练视觉模型，和通用语言模型，不必从头端到端训练。</li>
<li><strong>融合层承担“任务对齐”的角色。</strong>
中间的 cross-attention / 特征拼接层负责把视觉、语言、动作历史等映射到对决策友好的公共空间。</li>
<li><strong>在表达能力与工程复杂度之间折中。</strong>
相比早期融合，序列长度与相互影响范围更可控；相比晚期融合，又能实现更细粒度的跨模态信息流动。</li>
</ul>
<p>在实践中，多数 VLA 系统采用“<strong>中间融合 + 局部早期 / 晚期融合</strong>”的混合结构：例如在视觉内部多尺度早期融合不同传感器，在输出层再做一点晚期融合（如安全过滤），而核心策略部分仍然是中间融合。</p>
<p>【插图占位 8.4-2：典型 VLA 中间融合结构示意图。图像通过 ViT 得到 patch token，语言通过 Transformer 得到 token，状态 / 历史为若干额外 token，中间一个 Cross-Attention Transformer 将所有 token 交互，输出动作 token】</p>
<hr>
<h3 id="842-cross-attention-在-vla-中的角色"><a class="header" href="#842-cross-attention-在-vla-中的角色">8.4.2 Cross-Attention 在 VLA 中的角色</a></h3>
<p>在第 2 章我们已经介绍了自注意力（self-attention），Cross-Attention 可以看作“查询来自一方，键 / 值来自另一方”的注意力，是多模态模型最常用的“胶水”。当前大量 VLM / VLA 使用 cross-attention 将视觉、语言、动作串联起来(<a href="https://arxiv.org/html/2505.04769v1?utm_source=chatgpt.com">arXiv</a>)，例如 RT-2、VLA-Grasp 等都采用了基于 cross-attention 的多模态 Transformer(<a href="https://seohyun00.tistory.com/34?utm_source=chatgpt.com">Embodied AI in Robotics</a>)。</p>
<h4 id="8421-语言引导注意力"><a class="header" href="#8421-语言引导注意力">8.4.2.1 语言引导注意力</a></h4>
<p>在 VLA 中，一个非常重要的模式是：<strong>“语言作为 Query，引导模型在视觉 / 状态空间中寻找与任务相关的部分。”</strong></p>
<p>具体来说：</p>
<ul>
<li>语言编码器输出一组语言 token ({l_i})；</li>
<li>视觉编码器输出一组图像 patch token ({v_j})；</li>
<li>在 cross-attention 中，以语言 token 为 Query，视觉 token 为 Key/Value：
$$
\text{Attn}(L,V) = \text{softmax}\big(\frac{Q_L K_V^\top}{\sqrt{d}}\big) V_V
$$
这样每个语言 token 会“指向”与其语义相关的图像区域。</li>
</ul>
<p>直观理解：</p>
<ul>
<li>“红色杯子”这个 token，会给那些呈现红色圆柱形物体的 patch 更高权重；</li>
<li>“在碗左边的”会让注意力分布偏向图像左侧相关区域；</li>
<li>机器人状态 token（如末端位姿）也可以被语言 token 查询，用于回答“已经抓住了吗？”这类隐式问题。</li>
</ul>
<p>RT-2 这类大规模 VLA 将视觉 token、语言 token 和离散动作 token 一起放在 Transformer 中，通过 cross-attention 让语言指令在视觉 patch 上选择与任务相关的区域，从而实现复杂的指令执行(<a href="https://seohyun00.tistory.com/34?utm_source=chatgpt.com">Embodied AI in Robotics</a>)。</p>
<p>【插图占位 8.4-3：Cross-Attention 可视化图。左边是图像上高亮的注意力热力图（红色杯子区域被高亮），右边是一句指令的词向量，箭头表示“红色杯子”“左边”等词 Query 到图像 patch 的注意力连接】</p>
<h4 id="8422-多模态交互"><a class="header" href="#8422-多模态交互">8.4.2.2 多模态交互</a></h4>
<p>Cross-attention 不一定总是“语言查视觉”，在 VLA 中常见几种交互方向：</p>
<ol>
<li><strong>动作解码器 Query 视觉 + 语言。</strong>
<ul>
<li>把“历史动作 token + 语言 token + 状态 token”输入一个解码器；</li>
<li>解码器通过 cross-attention 查询视觉特征，得到用于下一步动作预测的上下文；</li>
<li>这种模式类似机器翻译中的 Encoder–Decoder 架构，只不过这里的“源语言”是视觉 / 状态。</li>
</ul>
</li>
<li><strong>视觉 Query 语言（反向引导）。</strong>
<ul>
<li>有时希望视觉特征根据语言“重构”或“筛选”自身，例如只保留与当前指令相关的物体特征；</li>
<li>这可以通过视觉 token Query 语言 token，实现“从指令中抽取与当前 patch 相关的语义”。</li>
</ul>
</li>
<li><strong>三模态交互：视觉–语言–动作。</strong>
<ul>
<li>部分 VLA（如 VLA-Grasp 等）显式为视觉、语言、候选动作建立多通道编码器，再用多层 cross-attention 互相查询，以捕获三者之间的内在联系(<a href="https://link.springer.com/article/10.1007/s40747-025-01893-x?utm_source=chatgpt.com">SpringerLink</a>)；</li>
<li>例如针对不同候选抓取姿态，分别计算“该动作与当前视觉–语言任务的匹配程度”，从而选出更合理的动作。</li>
</ul>
</li>
</ol>
<p>从信息流角度看，cross-attention 提供了一个<strong>可控的“信息输送通道”</strong>：</p>
<ul>
<li>谁是 Query，谁就有“提问权”；</li>
<li>通过不同方向的 cross-attention，可以有选择地把信息从一个模态灌输到另一个模态。</li>
</ul>
<h4 id="8423-实现细节"><a class="header" href="#8423-实现细节">8.4.2.3 实现细节</a></h4>
<p>在工程上，Cross-Attention 在 VLA 中的落地细节主要体现在以下几个方面：</p>
<ol>
<li><strong>插入位置与层数设计。</strong>
<ul>
<li>常见做法是在 Transformer block 中，将自注意力扩展为两段：
1）对解码器内部 token 做 self-attention；
2）再对编码器输出（视觉 / 语言）做 cross-attention；</li>
<li>对于“统一 Transformer”架构，也可以在部分层中专门使用 cross-attention，在其他层继续使用 self-attention，从而控制不同层的模态交互强度(<a href="https://arxiv.org/html/2505.04769v1?utm_source=chatgpt.com">arXiv</a>)。</li>
</ul>
</li>
<li><strong>模态类型编码（type embedding）。</strong>
<ul>
<li>为视觉 token、语言 token、状态 / 动作 token 添加不同的“模态 ID embedding”，帮助网络区分信息来源；</li>
<li>在 cross-attention 中往往保留这些模态 embedding，使网络学习到“对不同模态应该采用不同的查询策略”。</li>
</ul>
</li>
<li><strong>尺度与下采样。</strong>
<ul>
<li>如果直接用全部视觉 patch 做 Key/Value，成本过高，因此多数系统会在视觉侧做下采样或压缩，例如：
<ul>
<li>使用 [CLS] 或若干 pooled token；</li>
<li>使用稀疏注意力，只保留最有信息的 patch；</li>
<li>采用 FPN/多尺度金字塔，只在部分尺度上做 cross-attention。</li>
</ul>
</li>
</ul>
</li>
<li><strong>参数与训练策略。</strong>
<ul>
<li>实践中，往往会<strong>冻结视觉–语言 backbone</strong>，只训练 cross-attention 和策略头，以保护预训练知识，一些“知识隔离（knowledge insulating）”的工作更系统地研究了这一点(<a href="https://www.physicalintelligence.company/download/pi05_KI.pdf?utm_source=chatgpt.com">physicalintelligence.company</a>)；</li>
<li>对 cross-attention 层使用比 backbone 更小的学习率，或采用分层学习率，减少训练初期的“剧烈破坏”。</li>
</ul>
</li>
<li><strong>复杂度与实时性权衡。</strong>
<ul>
<li>Cross-attention 的复杂度是 (O(T_Q \cdot T_K))。在机器人应用中，往往控制 Query 长度（例如只用少数动作 token 作为 Query），并压缩 Key/Value，确保在目标控制频率下可以实时运行。</li>
</ul>
</li>
</ol>
<p>这些实现细节与第 10 章中“在线推理与部署”的实时性要求有关，设计 cross-attention 时需要兼顾表达能力与计算开销。</p>
<hr>
<h3 id="843-使用语言作为条件instruction-conditioning"><a class="header" href="#843-使用语言作为条件instruction-conditioning">8.4.3 使用语言作为条件（instruction-conditioning）</a></h3>
<p>前面第 4.4 节讨论了“语言作为任务描述、约束和解释”的角色，本节进一步聚焦在**“如何把语言指令形式化为 VLA 模型的条件”**上——也就是所谓的 <em>instruction-conditioned policy</em>。
许多研究已经证明，将机器人策略显式地条件化在自然语言指令上，可以得到可泛化、可重用的控制策略(<a href="https://proceedings.neurips.cc/paper/2020/file/9909794d52985cbc5d95c26e31125d1a-Paper.pdf?utm_source=chatgpt.com">NeurIPS 会议论文集</a>)。</p>
<h4 id="8431-条件编码"><a class="header" href="#8431-条件编码">8.4.3.1 条件编码</a></h4>
<p>第一步是把自然语言指令 (x) 编码为模型可用的“条件表示”。典型做法包括：</p>
<ol>
<li><strong>全局指令向量（sentence embedding）。</strong>
<ul>
<li>使用语言编码器（如 BERT、轻量 Transformer 或大型 LLM 的编码部分）对整句指令编码，得到一个向量 (c \in \mathbb{R}^d)；</li>
<li>这个向量可以看作“任务 ID 的连续版本”，比手工 one-hot 任务标签表达更丰富的语义(<a href="https://proceedings.neurips.cc/paper/2020/file/9909794d52985cbc5d95c26e31125d1a-Paper.pdf?utm_source=chatgpt.com">NeurIPS 会议论文集</a>)。</li>
</ul>
</li>
<li><strong>指令 token 序列。</strong>
<ul>
<li>直接保留子词级 token 序列 ({l_i})，供 Transformer 进一步处理；</li>
<li>与视觉 token、动作 token 串联或通过 cross-attention 交互，可以实现更精细的对齐（如“最大杯子”“最右边的物体”）。</li>
</ul>
</li>
<li><strong>前缀 / 提示（prompt）形式。</strong>
<ul>
<li>在统一 Transformer 中，可以将语言 token 放在序列开头，作为“prompt”；</li>
<li>后续的视觉 / 动作 token 在自注意力中，可以随时读取这个 prompt 的信息。</li>
</ul>
</li>
<li><strong>特征调制（Feature-wise conditioning）。</strong>
<ul>
<li>使用类似 FiLM（Feature-wise Linear Modulation）的方式：
$$
h’ = \gamma(c) \odot h + \beta(c)
$$
其中 (h) 是视觉或状态特征，(\gamma(c),\beta(c)) 由指令向量生成，用于对特征进行按通道缩放和偏移；</li>
<li>直观理解为“指令决定网络的工作模式”，例如“收拾桌面”模式、“分类整理”模式等(<a href="https://clip-rt.github.io/?utm_source=chatgpt.com">clip-rt.github.io</a>)。</li>
</ul>
</li>
</ol>
<p>无论采用哪种方式，目标都是构造一个**“语义条件”**，能够在不同任务之间平滑插值：</p>
<ul>
<li>“把红杯子放进盒子”和“把蓝杯子放进盒子”对应的条件向量应该“相近”；</li>
<li>“打开抽屉”和“关上抽屉”既有相似部分（对象是抽屉），又在动作方向上有明显差异。</li>
</ul>
<h4 id="8432-控制方法"><a class="header" href="#8432-控制方法">8.4.3.2 控制方法</a></h4>
<p>有了“条件编码”之后，下一步是<strong>让语言条件真正影响策略</strong>。这里可以理解为“如何在网络内部给语言一个有效的控制通道”：</p>
<ol>
<li><strong>输入级控制：拼接 / 加和。</strong>
<ul>
<li>最简单的方式是把指令向量 (c) 与其他模态特征直接拼接，或在输入层相加：
$$
z_0 = [c,\ v,\ s,\ \text{history}]
$$</li>
<li>或者对每个视觉 / 状态 token 都加上同一个条件向量（广播），使整个网络在“有条件”的空间中工作。</li>
</ul>
</li>
<li><strong>门控与加权（gating）。</strong>
<ul>
<li>使用语言条件输出门控系数，控制不同子策略或专家网络的权重：
$$
\pi(a|o,x) = \sum_k \alpha_k(x),\pi_k(a|o)
$$</li>
<li>在多任务、多 robot 的 VLA 中，常见“语言 + robot ID”双门控的 Mixture-of-Experts 结构，用以在联邦场景下共享部分参数，同时根据指令和平台自动选择专家(<a href="https://openaccess.thecvf.com/content/ICCV2025/papers/Miao_FedVLA_Federated_Vision-Language-Action_Learning_with_Dual_Gating_Mixture-of-Experts_for_Robotic_ICCV_2025_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)。</li>
</ul>
</li>
<li><strong>Cross-Attention 级控制。</strong>
<ul>
<li>如前节所述，让动作解码器在 cross-attention 中以“语言 + 历史动作 token”为 Query，对视觉特征进行选择性检索；</li>
<li>指令的不同部分会导致注意力模式变化，从而显式地改变策略关注的视觉区域。</li>
</ul>
</li>
<li><strong>层级控制（高层语言 + 低层动作）。</strong>
<ul>
<li>一些工作将语言用于高层策略：先由语言模型或语言条件策略输出一个<strong>子任务序列</strong>或“skill ID”，再由每个 skill 对应的低层策略负责具体控制；</li>
<li>这种“语言 → 动作原语”层级结构，会在第 6.3 和第 11 章“动作原语与层级策略”部分进一步展开。</li>
</ul>
</li>
</ol>
<p>从控制角度看，instruction-conditioning 实际是在做一种“<strong>条件化策略 (\pi(a|s,x))</strong>”，其中 (x) 不再是一个离散任务索引，而是一个包含丰富语义的自然语言向量。</p>
<h4 id="8433-多任务场景"><a class="header" href="#8433-多任务场景">8.4.3.3 多任务场景</a></h4>
<p>在多任务、多环境的 VLA 系统中，语言条件发挥的作用尤为关键(<a href="https://hulc.cs.uni-freiburg.de/?utm_source=chatgpt.com">hulc.cs.uni-freiburg.de</a>)：</p>
<ol>
<li><strong>用语言统一表示任务。</strong>
<ul>
<li>传统多任务 RL 或 IL 往往为每个任务分配一个整数 ID 或 one-hot 编码；</li>
<li>语言条件则将任务描述提升为自然语言空间，例如：
<ul>
<li>“把桌面上的所有杯子收集到托盘中”；</li>
<li>“只整理蓝色的物体”；</li>
</ul>
</li>
<li>这样模型在训练时就学习到“不同任务之间的相似性”，而不是完全独立的标签。</li>
</ul>
</li>
<li><strong>长尾任务和零样本任务。</strong>
<ul>
<li>对于训练数据中只出现少数样本的长尾任务，通过共享语言空间，模型可以从其他相似指令中迁移知识；</li>
<li>在极端情况下，即使<strong>从未见过某个具体指令</strong>，只要其语义可以用已知词汇组合表达，模型也可能进行零样本推理和执行（zero-shot instruction following）。</li>
</ul>
</li>
<li><strong>多机器人、多环境共享策略。</strong>
<ul>
<li>在 Open X-Embodiment 这类跨机器人多任务数据集上，语言指令不仅描述任务，还往往隐含环境信息（“厨房中把盘子放到架子上” vs “实验台上整理试管”）；</li>
<li>结合第 8.5.2 节的“多机器人共享策略”，语言条件可以与“embodiment encoding（机器人 ID / 描述）”组合，形成在不同机器人、不同场景下的统一策略表示。</li>
</ul>
</li>
<li><strong>与反馈 / 偏好学习结合。</strong>
<ul>
<li>在 RLHF 或人类偏好标注场景中，语言不仅作为任务输入，还可以作为<strong>反馈通道</strong>（例如人类用语言指出“不够小心”“动作太快”）(<a href="https://www.mdpi.com/2673-2688/6/4/75?utm_source=chatgpt.com">MDPI</a>)；</li>
<li>VLA 模型可以同时条件化在“任务指令 + 风格 / 安全偏好”，实现更细致的人机协同。</li>
</ul>
</li>
</ol>
<p>【插图占位 8.4-4：二维 embedding 可视化图，展示不同语言指令在条件空间中的分布，同一类任务（如收拾桌面）聚成簇，不同任务簇之间有一定距离】</p>
<hr>
<h3 id="844-历史动作--状态作为上下文的编码方式"><a class="header" href="#844-历史动作--状态作为上下文的编码方式">8.4.4 历史动作 / 状态作为上下文的编码方式</a></h3>
<p>现实机器人任务往往是<strong>部分可观测的长时序过程</strong>：</p>
<ul>
<li>单帧图像看不出“这个抽屉是被我刚刚打开过，还是原来就开着”；</li>
<li>单次力觉读数也难判断“这是刚接触到物体，还是已经推了很久”。</li>
</ul>
<p>因此，VLA 模型通常需要将<strong>历史观察与历史动作</strong>纳入上下文，学习策略 (\pi(a_t | o_{\le t}, a_{&lt; t}, x))。近年来大量基于 Transformer / SSM 的机器人策略都探索了如何编码历史序列(<a href="https://papers.nips.cc/paper_files/paper/2024/file/ff887781480973bd3cb6026feb378d1e-Paper-Conference.pdf?utm_source=chatgpt.com">NeurIPS 会议论文</a>)。</p>
<h4 id="8441-序列串联"><a class="header" href="#8441-序列串联">8.4.4.1 序列串联</a></h4>
<p>最直接的方式，就是<strong>把过去若干步的观察–动作对直接作为更长的输入序列</strong>，交给 Transformer 处理：</p>
<p>$$
\underbrace{[x]}<em>{\text{指令}} ;; \underbrace{[o</em>{t-K}, a_{t-K}, \dots, o_{t-1}, a_{t-1}, o_t]}_{\text{历史 + 当前}} \rightarrow \text{Transformer} \rightarrow a_t
$$</p>
<p>实现上的常见选择：</p>
<ul>
<li>每个时刻 (t’) 的观察 (o_{t’})（图像 + 状态）编码为若干 token；</li>
<li>动作 (a_{t’})（离散或离散化后的关节命令）编码为一个或多个 action token；</li>
<li>然后将这些 token 按时间顺序串联，送入 Transformer 解码器或统一 Transformer。</li>
</ul>
<p>相关工作表明，这种“简单串联 + 位置编码”的方式，在多任务策略学习中相当有效，如 BAKU 等工作会把一段观察历史一起输入 Transformer，用以预测下一步动作(<a href="https://papers.nips.cc/paper_files/paper/2024/file/ff887781480973bd3cb6026feb378d1e-Paper-Conference.pdf?utm_source=chatgpt.com">NeurIPS 会议论文</a>)。</p>
<p><strong>优点：</strong></p>
<ul>
<li>架构非常统一，与第 2 章中的序列建模完全一致；</li>
<li>不需要 hand-crafted 特征，只要定义好每个时刻的编码方式即可；</li>
<li>对于中等长度任务（几十步到上百步）已经足够。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>序列长度随历史窗口线性增长，很快达到上百甚至上千 token，计算和显存压力激增；</li>
<li>长期依赖依然难以完全捕获，模型可能只利用最近几步信息。</li>
</ul>
<p>在工程实践中，序列串联通常与“滑动窗口”和“时间编码”结合使用（见本节后两小节）。</p>
<p>【插图占位 8.4-5：时间轴示意图，将过去 K 步的图像+动作拼成 token 序列输入 Transformer，箭头指向当前时刻动作输出】</p>
<h4 id="8442-时间编码"><a class="header" href="#8442-时间编码">8.4.4.2 时间编码</a></h4>
<p>为了让模型区分“哪一步更早、哪一步更近”，必须显式或隐式地引入<strong>时间信息</strong>。在第 2.4.3 节介绍位置编码时我们已经看到，位置编码本质上就是一种时间标记，这里在 VLA 语境下强调几个实践要点：</p>
<ol>
<li><strong>绝对时间步编码。</strong>
<ul>
<li>为每个 token 加上一个表示其时间步的 embedding（如 sinusoidal 或可学习位置编码）：
$$
h_{t’}^{(0)} = \text{Embed}(o_{t’}) + p(t’)
$$</li>
<li>这样模型可以“知道”哪些是最近的观察、哪些是更久之前的观察。</li>
</ul>
</li>
<li><strong>相对时间 / 时间间隔编码。</strong>
<ul>
<li>有些任务中，动作间的时间间隔并不一致，需要编码“delta time”；</li>
<li>可以为每个时刻增加一个额外的“时间间隔 token”或把时间差作为数值特征拼接。</li>
</ul>
</li>
<li><strong>token 类型编码。</strong>
<ul>
<li>除了时间，还需要区分“语言 token / 视觉 token / 动作 token / 历史摘要 token”等，常用<strong>type embedding</strong> 来实现；</li>
<li>在一些 history-aware 的策略中，会为“历史 token”和“当前 token”使用不同的类型 embedding，帮助网络在注意力中重点关注最近几步(<a href="https://arxiv.org/html/2509.17141v1?utm_source=chatgpt.com">arXiv</a>)。</li>
</ul>
</li>
<li><strong>压缩历史的时间编码。</strong>
<ul>
<li>对于非常长的轨迹，不可能保留全部细节，部分工作会先将历史通过对象跟踪、点轨迹（point tracking）等方式压缩成少量“历史 token”，再给这些 token 添加时间或顺序编码(<a href="https://arxiv.org/html/2509.17141v1?utm_source=chatgpt.com">arXiv</a>)；</li>
<li>这可以理解为“对时间维做一次降维”，详见第 12 章世界模型与记忆部分的讨论。</li>
</ul>
</li>
</ol>
<p>在设计时间编码时，应与动作离散化、控制频率相协调：例如控制频率较高时，更需要精细的时间表示；频率较低时，则可以把若干步合并视为一个“宏步长”。</p>
<h4 id="8443-滑动窗口与记忆"><a class="header" href="#8443-滑动窗口与记忆">8.4.4.3 滑动窗口与记忆</a></h4>
<p>单纯增加历史步数会迅速推高复杂度，因此实践中常结合<strong>滑动窗口（sliding window）<strong><strong>和</strong></strong>记忆（memory）机制</strong>，在“保留必要历史信息”和“控制计算成本”之间做折中(<a href="https://arxiv.org/html/2505.12410v1?utm_source=chatgpt.com">arXiv</a>)。</p>
<ol>
<li><strong>滑动窗口：只看最近 (K) 步。</strong>
<ul>
<li>设定一个窗口长度 (K)，模型每一步只接收最近 (K) 步的观察–动作历史，其余更久的历史被丢弃；</li>
<li>对于很多桌面操作、短程导航任务，几步到几十步的窗口就足够；</li>
<li>优点是实现简单，与序列串联方式直接兼容；缺点是无法捕获“极长时间跨度”的依赖（如几分钟之前做过的准备工作）。</li>
</ul>
</li>
<li><strong>显式记忆单元：压缩历史。</strong>
<ul>
<li>为模型引入一个“记忆向量”或“记忆 token”，在每个时间步根据当前观察 / 动作和之前记忆更新：
$$
m_t = f(m_{t-1}, o_t, a_{t-1})
$$</li>
<li>一些工作采用 RNN、LSTM、Transformer-XL 样式的记忆；更多近期方法使用<strong>状态空间模型（SSM）或 Mamba</strong>这类结构，将整条历史轨迹编码为一个压缩隐状态，用于条件化当前动作预测(<a href="https://arxiv.org/html/2505.12410v1?utm_source=chatgpt.com">arXiv</a>)；</li>
<li>这样可以在计算复杂度可控的前提下利用更长的历史。</li>
</ul>
</li>
<li><strong>分层记忆：短期窗口 + 长期记忆。</strong>
<ul>
<li>短期内使用滑动窗口（例如最近 10 步）保留细节；</li>
<li>长期则通过记忆模块存储更加抽象的信息，如“抽屉已经打开”“那只杯子已经被放进盒子里”等；</li>
<li>在世界模型或长序列 VLA 中，这种“局部细节 + 全局摘要”的模式越来越普遍，也是未来统一具身基础模型的重要方向之一。</li>
</ul>
</li>
<li><strong>历史与指令的联合建模。</strong>
<ul>
<li>在指令导向的历史感知策略中，还会将语言指令和历史一起写入记忆，形成“instruction-oriented memory”，例如 History-aware multimodal instruction-oriented policies 这类工作(<a href="https://www.mdpi.com/2673-2688/6/4/75?utm_source=chatgpt.com">MDPI</a>)；</li>
<li>这使得模型可以理解“我之前执行的是哪个子指令、现在到了哪一步”，为长任务分解和进度跟踪提供基础。</li>
</ul>
</li>
</ol>
<p>【插图占位 8.4-6：一张时间轴+滑动窗口+记忆示意图。时间轴上标出一长串时刻，窗口覆盖最近 K 步，窗口前的历史被压缩为一个“Memory token”，在当前决策时既读窗口内 token，也读 Memory token】</p>
<hr>
<p>本节从<strong>融合时机（早/中/晚）</strong>、<strong>cross-attention 的具体角色</strong>、<strong>语言条件化策略</strong>和<strong>历史序列编码</strong>四个维度，补足了 VLA 在“多模态融合与条件建模”层面的核心设计要素。后续 8.5 节会以完整架构为例，把这些组件组合起来，形成贯通视觉–语言–动作的统一 Transformer 视角，与第 9 章的训练范式共同构成一个从“架构设计”到“数据与优化”的完整闭环。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="典型-vla-架构案例分析理论层"><a href="#典型-vla-架构案例分析理论层" class="header">典型 VLA 架构案例分析（理论层）</a></h1>
<h3 id="851-视觉语言动作统一-transformer-架构抽象"><a class="header" href="#851-视觉语言动作统一-transformer-架构抽象">8.5.1 “视觉–语言–动作”统一 Transformer 架构抽象</a></h3>
<p>在前面的章节里，我们已经分别从“视觉–语言多模态”“动作解码”与“条件建模”的角度拆开讨论了 VLA 的各个部件。本小节尝试把这些内容重新“合体”，抽象出一类越来越主流的统一 Transformer 架构——把<strong>视觉、语言、动作、状态统统看成一个长序列</strong>，交给<strong>单个 Transformer</strong> 做统一建模。</p>
<p>代表性的工作包括 RT-2、PaLM-E、RT-X / Open X-Embodiment、OpenVLA 等，它们都在不同程度上体现了这种“所有东西都是 token”的思路。(<a href="https://arxiv.org/abs/2307.15818?utm_source=chatgpt.com">arXiv</a>)</p>
<blockquote>
<p>【图 8-5-1 占位】
统一 Transformer 架构示意图：语言 token、视觉 patch token、机器人状态 token、历史动作 token 被串成一条长序列，输入同一个 Transformer；输出为下一步动作 token。</p>
</blockquote>
<hr>
<h4 id="8511-序列建模扩展"><a class="header" href="#8511-序列建模扩展">8.5.1.1 序列建模扩展</a></h4>
<p><strong>基本想法：把机器人问题改写成“下一个 token 预测”问题。</strong></p>
<p>在经典自回归语言模型中，输入是一串文本 token，模型学习“给定前面所有 token，预测下一个 token”。统一 VLA 的思路是：</p>
<ul>
<li>先把<strong>视觉帧</strong>拆成 patch，再嵌入成一串视觉 token；</li>
<li>把<strong>语言指令</strong>分词，得到一串文本 token；</li>
<li>把<strong>机器人状态</strong>（关节角、末端位姿、夹爪开合、是否抓到物体等）编码成若干状态 token；</li>
<li>把<strong>历史动作</strong>离散化或量化成动作 token；</li>
<li>最后把它们按某种规则<strong>串联成一条长序列</strong>，交给 Transformer 处理，预测“下一步动作 token”。</li>
</ul>
<p>典型的实现方式是构造一条“多模态句子”，例如（只示意结构）：</p>
<blockquote>
<p><code>[LANG …] [IMG …] [STATE …] [ACT_t-1 …] → [ACT_t …]</code></p>
</blockquote>
<p>其中语言指令通常是固定前缀（例如一开始给出“把红色杯子放到盘子里”），视觉 token 和状态 token 随时间更新，动作 token 被自回归地逐步生成。RT-2 就是将机器人的连续动作编码成“伪文本 token”，和自然语言答案一起作为统一的输出空间，在同一个序列上做下一个 token 预测。(<a href="https://arxiv.org/abs/2307.15818?utm_source=chatgpt.com">arXiv</a>)</p>
<p>PaLM-E 更进一步直接把<strong>图像特征、机器人状态向量嵌入到语言模型的 token 序列里</strong>，形成“多模态句子”，由一个巨大的 LLM 主干统一处理。(<a href="https://arxiv.org/abs/2303.03378?utm_source=chatgpt.com">arXiv</a>)</p>
<p>在实践中，序列通常还会带有以下辅助信息：</p>
<ul>
<li><strong>模态嵌入（modality embedding）</strong>：指示当前 token 属于视觉、语言、动作还是状态；</li>
<li><strong>时间步嵌入（timestep / position embedding）</strong>：编码“这是第几步控制”“这是最近 N 帧中的第几帧”；</li>
<li><strong>机器人/任务嵌入（embodiment / task embedding）</strong>：在多机器人、多任务场景下加入全局条件，这部分在 8.5.2 详细展开。</li>
</ul>
<p><strong>序列组织方式的变体。</strong></p>
<p>统一序列并不意味着只有一种排法，常见有两类：</p>
<ol>
<li><strong>按时间展开</strong>：
$$
\underbrace{[\text{LANG}, \text{IMG}<em>t, \text{STATE}<em>t, \text{ACT}</em>{t-1}]}</em>{\text{第 }t\text{ 步}} \quad
\underbrace{[\text{IMG}<em>{t+1}, \text{STATE}</em>{t+1}, \text{ACT}<em>{t}]}</em>{\text{第 }t+1\text{ 步}} \quad \dots
$$
每个时间步是一个“小句子”，所有时间步再串联。这样强调时序结构，类似“视频 + 控制命令”的联合建模。</li>
<li><strong>按模态分块</strong>：
<code>[LANG 全部] + [若干帧 IMG] + [若干 STATE] + [若干 ACT]</code>。
这种更接近 RT-1/RT-2 的做法：指令常常一次性给出，视觉帧也可以只取最近几张，动作 token 在尾部自回归生成。(<a href="https://research.google/blog/rt-1-robotics-transformer-for-real-world-control-at-scale/?utm_source=chatgpt.com">谷歌研究</a>)</li>
</ol>
<p>注意还需要在注意力掩码上做区分：</p>
<ul>
<li><strong>语言与视觉 token</strong> 通常允许双向注意力（类似 Encoder），便于充分融合视觉–语言信息；</li>
<li><strong>动作 token</strong> 常使用因果掩码，不能看到未来的动作，以满足“预测下一步动作”的因果性要求。</li>
</ul>
<hr>
<h4 id="8512-单-transformer-优势"><a class="header" href="#8512-单-transformer-优势">8.5.1.2 单 Transformer 优势</a></h4>
<p>用单个 Transformer 承担“感知–语言–决策”三件事，乍看有些暴力，但在实际系统里已经被证明非常有吸引力。</p>
<ol>
<li><strong>统一表示空间，天然跨模态对齐。</strong>
当视觉、语言、动作 token 一起在同一堆 self-attention 层里反复交互时，模型自然会学到“哪些图像区域与哪些文字、哪些动作有关”。RT-2 的结果表明，经过互联网视觉–语言数据与机器人轨迹的联合训练后，模型能<strong>把 web 上学到的语义知识迁移到现实机器人动作中</strong>，在未见场景上的成功率由 RT-1 的 32% 提升到 62%。(<a href="https://deepmind.google/blog/rt-2-new-model-translates-vision-and-language-into-action/?utm_source=chatgpt.com">Google DeepMind</a>)</li>
<li><strong>共享一个大模型，跨任务和多模态正迁移。</strong>
PaLM-E 显示，随着参数规模从几十亿扩展到 562B，同一个模型在视觉问答、文本任务和机器人任务上的表现同时提升，而且不同任务之间存在明显的正迁移——更多的互联网多模态数据可以帮助机器人任务，机器人数据反过来也不会破坏语言能力。(<a href="https://arxiv.org/abs/2303.03378?utm_source=chatgpt.com">arXiv</a>)
这一点对“从网络知识走向具身智能”非常关键。</li>
<li><strong>工程上结构简单、接口干净。</strong>
统一 Transformer 的架构非常接近“LLM + 视觉前端 + 动作头”的模板，如 OpenVLA 在一个 7B 级别的开源 VLM 主干上仅增加了少量输入适配层和动作解码头，就实现了多机器人、多任务的控制能力。(<a href="https://arxiv.org/abs/2406.09246?utm_source=chatgpt.com">arXiv</a>)
这意味着：
<ul>
<li>可以直接复用主流 LLM/VLM 的工程基础（分布式训练、推理框架等）；</li>
<li>模型升级（比如换一个更强的 LLM 主干）时，只需相对局部的改动。</li>
</ul>
</li>
<li><strong>训练范式统一，易于“混合数据”。</strong>
把一切都当 token 后，网络训练目标本质上就是“预测下一个 token 或填补被 mask 的 token”，和语言模型完全一致。RT-2 就是在 VLM 的 web 预训练任务（描述图像、问答）上<strong>插入机器人轨迹数据</strong>，以几乎相同的损失函数联合训练，从而复用成熟的 LM 训练流水线。(<a href="https://arxiv.org/abs/2307.15818?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>为后续扩展留出空间。</strong>
一旦序列接口确定，未来加入新的模态（深度图、触觉、力传感器）、新的控制信号，只需要定义新的 token 类型和嵌入方式，而不用重新发明整套网络结构。这与第 12 章讨论的“统一感知–语言–动作–记忆大模型”是完全一致的设计哲学。(<a href="https://vla-survey.github.io/?utm_source=chatgpt.com">VLA Models Survey</a>)</li>
</ol>
<hr>
<h4 id="8513-挑战"><a class="header" href="#8513-挑战">8.5.1.3 挑战</a></h4>
<p>统一 Transformer 非常“优雅”，但现实里要在机器人上真正跑起来，还会遇到不少硬骨头。</p>
<ol>
<li><strong>序列过长带来的计算瓶颈。</strong>
自注意力复杂度是 (O(N^2))。视觉 patch（几十到几百个）、语言 token（几十个）、状态和动作 token，再乘上时间维度，很容易就堆出几百乃至上千长度的序列。
对于需要 10–30 Hz 实时控制的机器人，这会迅速压垮显存和算力。最近的 VLA 综述也把“计算约束”列为走向真实部署的一大障碍。(<a href="https://arxiv.org/html/2510.07077v1?utm_source=chatgpt.com">arXiv</a>)
实际系统中常用的折中包括：
<ul>
<li>只保留最近 1–2 帧图像，远历史用压缩状态代替；</li>
<li>降采样视觉 token（更粗的 patch、更小的分辨率）；</li>
<li>使用稀疏注意力或分块注意力，只在局部时间窗口做完全注意力。</li>
</ul>
</li>
<li><strong>模态频率与时间尺度不匹配。</strong>
<ul>
<li>视觉：通常 5–15 Hz，信息密度高但刷新慢；</li>
<li>状态与动作：可以高达 50–1000 Hz；</li>
<li>语言指令：大多是“低频、几乎静态”的条件。
如果一股脑儿全塞进同一序列，要么<strong>动作过度压缩</strong>（影响控制精度），要么<strong>视觉/语言 token 被大量重复</strong>（增加冗余计算）。
工程中常见的做法是：</li>
<li>在统一 Transformer 前加一个**“低频感知、高频控制”分层**：高频控制层只看最近一次感知和短历史动作；</li>
<li>或者在统一序列内部，引入只更新子序列的机制（例如每 K 帧插入一次视觉 token，其余时间只滚动动作和状态）。</li>
</ul>
</li>
<li><strong>从“相关”到“因果”的困难。</strong>
统一 Transformer 通常使用自监督或模仿学习目标（BC），擅长捕捉“统计相关性”：某种图像+语言组合对应某种动作序列。但在长时间任务中，需要模型理解<strong>动作对未来结果的因果影响</strong>，这在纯“下一个 token 预测”框架中并不直接体现。
因此，很多工作把统一 Transformer 视作<strong>强表示 + 先验</strong>，再在其上做 RL 微调或规划（详见第 9 章），以弥补长期 credit assignment 的不足。(<a href="https://vla-survey.github.io/?utm_source=chatgpt.com">VLA Models Survey</a>)</li>
<li><strong>数据分布与模态对齐问题。</strong>
互联网数据中的图像与文本，和机器人场景下的相机画面、操作轨迹分布完全不同：
<ul>
<li>web 图像多为拍照、插图；机器人视角则是“俯视桌面”“贴近物体”；</li>
<li>自然语言描述关注“是什么”“好不好看”，而机器人指令要求“怎么做”“具体动哪”。
RT-2 通过<strong>共同微调（co-fine-tuning）</strong>，在训练时同时保留部分 web 视觉–语言任务与机器人数据，以减少灾难性遗忘和分布错位；但要做到完美对齐仍是开放问题。(<a href="https://arxiv.org/abs/2307.15818?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>安全与可控性。</strong>
把动作 token 当作“语言的一部分”虽然统一了接口，也把语言模型那种“有时很会瞎编”的特性原封不动带到机器人控制中：
<ul>
<li>在“开放式指令”下模型可能产生意料之外的动作序列；</li>
<li>统一 Transformer 很难自带强约束（如速度上限、禁入区域等）。
因此，在实际系统部署时，通常会在统一 Transformer 外再包一层<strong>动作约束与安全检查</strong>（第 10.3 节），在解码时限制动作范围或直接过滤掉危险动作，仅让统一 Transformer 在安全的“可行域”内发挥聪明才智。(<a href="https://arxiv.org/html/2510.07077v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ol>
<hr>
<h3 id="852-单模型多机器人多任务共享的设计原则"><a class="header" href="#852-单模型多机器人多任务共享的设计原则">8.5.2 单模型多机器人、多任务共享的设计原则</a></h3>
<p>统一 Transformer 只是“脑袋长成什么样”的问题。如果我们希望 <strong>“一个脑袋带 N 个身体”</strong>——同一模型可以控制多种机器人、执行成百上千种任务，那就必须进一步考虑：输入输出如何“对齐”、参数如何共享、怎样避免互相干扰。</p>
<p>近期的 Open X-Embodiment / RT-X、OpenVLA 等工作，已经在 <strong>22 种机器人、百万量级轨迹</strong> 上验证了多机器人统一策略的可行性，并给出了相对成熟的“多机器人工程模式”。(<a href="https://arxiv.org/html/2310.08864v4?utm_source=chatgpt.com">arXiv</a>)</p>
<blockquote>
<p>【图 8-5-2 占位】
多机器人共享 VLA：左侧是不同形态的机器人（多关节机械臂、双臂、移动底盘＋机械臂等），通过“输入适配器”映射到统一 token 序列；右侧是共享的 Transformer 主干和若干“输出适配器”，分别产生各机器人可执行的动作。</p>
</blockquote>
<hr>
<h4 id="8521-输入适配"><a class="header" href="#8521-输入适配">8.5.2.1 输入适配</a></h4>
<p>多机器人输入的关键，是把“千奇百怪的传感器和坐标系”映射到<strong>统一、规范化的表示</strong>中，同时显式告诉模型“我现在是哪个机器人”。</p>
<ol>
<li><strong>统一视觉与状态坐标系。</strong>
虽然每个机器人相机的安装位置、视场角、分辨率各不相同，但我们可以在预处理时强制统一到某种规范：
<ul>
<li>统一图像尺寸和颜色空间（如全部缩放到 256×256、RGB）；</li>
<li>尽量使用相似的视角配置（例如“手眼相机俯视桌面”）；</li>
<li>把关节角、末端位姿、夹爪状态等归一化到统一量纲（例如 ([-1,1])）。
Open X-Embodiment 在整合 22 种机器人数据时，把观测统一为“相机图像 + 7-DoF 末端状态 + 夹爪开合”等少数字段，作为所有模型的公共输入界面。(<a href="https://arxiv.org/html/2310.08864v4?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>Embodiment 编码（机器人身份与形态嵌入）。</strong>
模型必须知道“我现在是那只机器人”，否则统一表示会混淆不同机械结构。常见做法包括：
<ul>
<li>为每个机器人分配一个<strong>离散的 ID token</strong>，类似语言模型里的 <code>[ROBOTA]</code>、<code>[ROBOTB]</code>，学习一个对应的 embedding；</li>
<li>使用更细致的<strong>形态描述向量</strong>，编码关节数、关节类型（旋转/移动）、连杆长度等，甚至直接从 URDF 中提取。
PaLM-E 实验表明，在同一模型中同时训练多种 embodiment 时，适当的形态/模态嵌入有助于实现正迁移，而不是互相拖累。(<a href="https://arxiv.org/abs/2303.03378?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>任务与场景条件嵌入。</strong>
多任务场景下，还需要通过语言+任务 ID 来告诉模型“现在该做什么”：
<ul>
<li>主通道使用自然语言指令（例如“把蓝色杯子放在盘子里”）；</li>
<li>也可以附加一个<strong>任务类别 token</strong>（例如来自 Open X-Embodiment 中 527 种 skill 的 ID），帮助模型在长尾任务上稳定收敛。(<a href="https://arxiv.org/html/2310.08864v4?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>输入适配器（input adapters）。</strong>
在工程实现上，经常会在统一 Transformer 之前加一层轻量的输入适配模块：
<ul>
<li>对不同分辨率的相机使用独立的 CNN/ViT backbone，然后都投影到统一维度；</li>
<li>对不同类型的状态向量（仅机械臂 / 机械臂+底盘）使用不同 MLP，再concat 到统一长度。
这些适配器可以视作“硬件驱动层”，而后面的 Transformer 主干则是“共享算法层”。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="8522-输出适配"><a class="header" href="#8522-输出适配">8.5.2.2 输出适配</a></h4>
<p>输入统一之后，还需要解决更棘手的一个问题：<strong>不同机器人动作空间完全不同</strong>。有的 7 自由度机械臂，有的多加一个滑轨，有的带移动底盘，还有夹爪、吸盘、双臂等各种组合。</p>
<ol>
<li><strong>优先统一到“任务空间动作”。</strong>
当前多机器人工作中比较成功的一条路线，是把动作统一定义为<strong>末端位姿或其增量（Delta pose）+ 夹爪开合</strong>：
<ul>
<li>模型输出一个规范化的 (\Delta x, \Delta y, \Delta z, \Delta \text{roll/pitch/yaw}, \Delta g) 向量或对应 token；</li>
<li>每个机器人本地再用 IK 或已有控制器把这个末端增量转换成实际关节命令。
Open X-Embodiment 的 RT-X 系列就采用了类似思路，将不同机器人动作粗略对齐为“7-DoF + 夹爪”格式，再训练统一策略。(<a href="https://deepmind.google/blog/scaling-up-learning-across-many-different-robot-types/?utm_source=chatgpt.com">Google DeepMind</a>)</li>
</ul>
</li>
<li><strong>共享动作头 + 机器人特定投影。</strong>
更一般的结构是：
<ul>
<li>Transformer 主干输出一个<strong>共享动作向量 (a_\text{shared})</strong> 或一串动作 token；</li>
<li>对每个机器人 (r) 配一个小型的<strong>输出适配器 (g_r)</strong>（通常是 1–2 层 MLP），将 (a_\text{shared}) 转换为该机器人的实际命令：
$$
u_r = g_r(a_\text{shared}),
$$
其中 (u_r) 可以是关节速度、关节位置、底盘速度等。
如此一来，大部分决策能力都在共享主干中，输出适配器仅负责“单位换算 + 形态映射”，既保留可移植性，又允许适配差异较大的平台。</li>
</ul>
</li>
<li><strong>离散化动作空间下的适配。</strong>
若采用 RT-1、RT-2 类“离散动作 token”设计，输出适配问题会有不同表现：(<a href="https://research.google/blog/rt-1-robotics-transformer-for-real-world-control-at-scale/?utm_source=chatgpt.com">谷歌研究</a>)
<ul>
<li>可以为不同机器人定义一套<strong>统一的 token vocabulary</strong>，例如每个 token 对应“末端沿 X 轴 +1cm”“夹爪闭合 10%”等；</li>
<li>或者为每个机器人单独定义 token 集合，但将它们嵌入到统一的动作 embedding 空间（共享 embedding 矩阵 + 部分专用行），用机器人 ID 来选择子集。
RT-2 把动作表示为文本样式的 token，是一种更极端的形式：输出空间事实上就是自然语言词表的子集；真正的低层控制由外部解析器负责解释这些 token 并转换为关节命令。(<a href="https://arxiv.org/abs/2307.15818?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>安全范围与单位归一化。</strong>
无论采用哪种表示，都应当在输出适配层中处理：
<ul>
<li>单位换算（如归一化到 ([-1,1]) 再按各机器人上限缩放）；</li>
<li>限幅与裁剪（保证速度、加速度、力矩在允许范围内）；</li>
<li>特定自由度屏蔽（例如对不带底盘的机器人，将底盘相关维度强制为 0）。
这部分内容在第 10 章关于安全与系统部署中会再详细展开，这里只提醒读者：<strong>输出适配既是形态问题，也是安全问题。</strong></li>
</ul>
</li>
</ol>
<hr>
<h4 id="8523-参数共享与分支"><a class="header" href="#8523-参数共享与分支">8.5.2.3 参数共享与分支</a></h4>
<p>实现多机器人、多任务的单模型共享时，一大难题是：</p>
<ul>
<li>共享太多：容易互相干扰，导致“谁都学不好”；</li>
<li>分得太开：又失去了跨任务、跨平台正迁移的好处。</li>
</ul>
<p>现有工作逐渐形成了一些实践经验。</p>
<ol>
<li><strong>“大共享，小特化”的基本格局。</strong>
多数成功的 VLA 系统采用类似模式：
<ul>
<li><strong>完全共享</strong>视觉 backbone、语言 backbone 和大部分 Transformer 层；</li>
<li>只在<strong>靠近输入/输出</strong>的少数层中加入机器人或任务特定分支。
例如 OpenVLA 使用一个 7B 的统一 VLA 模型，在多机器人数据上预训练后，通过 <strong>LoRA / Adapter 等参数高效微调方法</strong> 为新机器人或新任务添加极少量额外参数，就能快速适配而不破坏已有能力。(<a href="https://arxiv.org/abs/2406.09246?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>多机器人共享的经验：RT-X 与 Open X-Embodiment。</strong>
RT-X 在 Open X-Embodiment 数据集上训练统一模型，实验表明：
<ul>
<li>统一模型在多种机器人上的平均表现<strong>优于</strong>分别为每个机器人训练单独模型；</li>
<li>特别是在数据较少的机器人上，能从其他机器人数据中获得显著增益。(<a href="https://arxiv.org/html/2310.08864v4?utm_source=chatgpt.com">arXiv</a>)
这说明适当共享确实能带来“数据放大效应”，是构建通用机器人大脑的关键。</li>
</ul>
</li>
<li><strong>MoE / gating 与任务分支。</strong>
为了进一步减轻“互相拖累”的问题，可以考虑在统一 Transformer 中加入<strong>专家混合（Mixture-of-Experts）</strong> 或软门控结构：
<ul>
<li>为不同机器人、任务准备若干组专家 FFN / 注意力子层；</li>
<li>根据机器人 ID、任务嵌入或当前观察自动选择或加权这些专家；</li>
<li>这样既保持参数共享，又允许模型在不同场景下使用不同子网络。
这类结构目前在大语言模型中已经被广泛使用，在 VLA 领域也逐渐开始探索（可参考第 12 章对“更通用具身基础模型”的讨论）。(<a href="https://arxiv.org/html/2510.07077v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>训练策略：采样均衡与防止灾难性遗忘。</strong>
多机器人、多任务训练容易出现“大数据任务压死小数据任务”的现象。实践中常用手段有：
<ul>
<li><strong>分任务/分机器人均衡采样</strong>：保证每个 batch 中各机器人数据比例相对均衡；</li>
<li>对长尾任务或少样本机器人给予更高 loss 权重；</li>
<li>逐步解冻策略：先在大数据机器人上预训练主干，再逐步加入其他机器人数据和适配参数，避免一开始就“乱拉扯”。
OpenVLA 和后续基于它的实验都报告，合理的采样与微调策略可以显著提升在长尾任务和新机器人上的表现。(<a href="https://medium.com/correll-lab/paper-notes-openvla-17540381187e?utm_source=chatgpt.com">Medium</a>)</li>
</ul>
</li>
</ol>
<p>总的来说，多机器人共享的设计哲学可以概括为：<strong>用尽可能统一的输入/输出接口和大规模共享主干，叠加尽可能小的特化分支</strong>。这与后续第 10 章中讨论的“云端大模型 + 端侧小适配”的系统架构，也是高度一致的。</p>
<hr>
<h3 id="853-模型尺度参数量与性能--部署成本权衡"><a class="header" href="#853-模型尺度参数量与性能--部署成本权衡">8.5.3 模型尺度（参数量）与性能 / 部署成本权衡</a></h3>
<p>统一 Transformer + 多机器人共享听上去很美，但实现“从 zero 到 hero”的另一块硬约束，就是<strong>模型规模</strong>：</p>
<ul>
<li>做得太小，学不会复杂语义和泛化能力；</li>
<li>做得太大，机器人本体根本带不动，或者控制频率降到不能用。</li>
</ul>
<p>这一节不追求给出具体“最佳参数量”的数字，而是希望帮助读者形成一套<strong>思考模型规模的框架</strong>：</p>
<ul>
<li>**性能潜力：**大模型究竟在 VLA 里带来了什么？</li>
<li>**成本约束：**训练与推理各花在哪里？</li>
<li>**实践决策：**面对真实硬件和任务，我们如何选一个“够用而不过度”的规模。</li>
</ul>
<hr>
<h4 id="8531-大模型性能潜力"><a class="header" href="#8531-大模型性能潜力">8.5.3.1 大模型性能潜力</a></h4>
<p>大模型的优势，在 VLA 场景中已经通过多个代表性工作得到实证。</p>
<ol>
<li><strong>更强的语言与视觉理解能力。</strong>
PaLM-E 把一个数百亿甚至 562B 参数的 LLM 与视觉、机器人模态结合，结果显示：
<ul>
<li>在视觉问答基准（OK-VQA、VQAv2）上达到或超过专门微调模型的水平；</li>
<li>在机器人任务上，比仅在单一任务上训练的小模型表现更优；</li>
<li>随着参数规模增大，语言能力几乎不被破坏，甚至还能继续提升。(<a href="https://arxiv.org/abs/2303.03378?utm_source=chatgpt.com">arXiv</a>)
这说明，<strong>“大脑更大”并不一定会被“机器人任务”拖累，相反多任务联合训练可以利用规模优势。</strong></li>
</ul>
</li>
<li><strong>更强的零样本 / 组合泛化。</strong>
RT-1、RT-2 等工作一再强调：当模型容量足够大、训练数据足够多时，机器人策略在未见任务和未见物体上的成功率显著提高：</li>
</ol>
<p>这类“模糊指令 + 复杂语义”的能力，很难用小规模、专用型模型手工编码出来。</p>
<pre><code>- RT-1 在未见指令上的成功率可达到 76%，比下一最佳基线高出 24 个百分点；([arXiv](https://arxiv.org/html/2212.06817?utm_source=chatgpt.com))
- RT-2 在 unseen 场景上的成功率从 RT-1 的 32% 提升到 62%，大量例子表明模型能理解“最小的”“离 X 最近的”“可以当锤子用的东西”等抽象语义并正确选择物体。([Google DeepMind](https://deepmind.google/blog/rt-2-new-model-translates-vision-and-language-into-action/?utm_source=chatgpt.com))
</code></pre>
<ol start="3">
<li><strong>更强的多机器人、多任务正迁移能力。</strong>
Open X-Embodiment / RT-X 表明，在 22 种机器人、百万轨迹上训练的统一模型，相比单机器人模型不仅没有退步，反而在平均性能上提升，并显著提高数据稀缺机器人上的表现。(<a href="https://arxiv.org/html/2310.08864v4?utm_source=chatgpt.com">arXiv</a>)
OpenVLA 进一步展示，单个 7B 级 VLA 模型在多个机器人、多个场景上的成功率可以超过一些 50B+ 封闭模型和 diffusion policy 方法。(<a href="https://arxiv.org/abs/2406.09246?utm_source=chatgpt.com">arXiv</a>)</li>
</ol>
<p>从理论与经验上看，<strong>在数据足够丰富、训练做得好的前提下，增加参数量确实能换来更强的泛化与综合能力</strong>。但问题在于：机器人不是搜索引擎或聊天系统，它对<strong>实时性与能耗</strong>的约束远严苛得多。</p>
<hr>
<h4 id="8532-训练推理成本"><a class="header" href="#8532-训练推理成本">8.5.3.2 训练推理成本</a></h4>
<p>要把一个 VLA 模型从“纸上谈兵”训练到能在真实机器人上跑，需要分别面对<strong>训练成本</strong>和<strong>推理成本</strong>两座大山。</p>
<ol>
<li><strong>训练成本：算力、数据与工程复杂度。</strong></li>
</ol>
<p>工程上，这意味着：</p>
<p>对研究生或小团队而言，通常需要借助已经预训练好的大模型（如开源的 OpenVLA-7B）来降低前期成本。(<a href="https://arxiv.org/abs/2406.09246?utm_source=chatgpt.com">arXiv</a>)</p>
<pre><code>- **预训练阶段**通常在大规模图文数据（CLIP 风格）与纯文本（LLM）上进行，这部分已经是工业级别的算力消耗；([arXiv](https://arxiv.org/abs/2307.15818?utm_source=chatgpt.com))
- **机器人阶段**往往需要在百万级轨迹、上万小时的机器人交互记录上进行微调或共同训练，例如 Open X-Embodiment 的 100 万+ 真实轨迹、RT-1 的 13 万集真实操作等。([arXiv](https://arxiv.org/html/2310.08864v4?utm_source=chatgpt.com))
- 必须使用**分布式训练**、混合精度（FP16/BF16）、流水线并行等技术；
- 数据管线须支持从多源数据集中高吞吐读取、在线随机化与过滤；
- 只为训练这样一个模型就可能需要数十到上百张 GPU/TPU，持续数天甚至数周。
</code></pre>
<ol start="2">
<li>**推理成本：时延、频率与硬件约束。**机器人控制对推理有几个硬约束：</li>
</ol>
<p>现实里，一台带中高端 GPU 的桌面工作站可以勉强实时运行 1–7B 级别的 VLA 模型（视输入长度而定）；几十亿以上的模型很难在本地高频控制（RT-2 这类通常采用云端推理或较低频规划式控制）。(<a href="https://www.cs.utexas.edu/~yukez/cs391r_fall2023/slides/pre_10-24_Ming.pdf?utm_source=chatgpt.com">得克萨斯大学计算机科学系</a>)</p>
<p>因此：</p>
<pre><code>- **控制频率**：典型操作任务希望 VLA 在 5–10 Hz 输出高层命令（低层由控制器插值）；
- **端到端时延**（从采集图像到输出动作）要远小于机器人动态变化时间常数，通常希望在几十毫秒到一两百毫秒内；
- **边缘设备资源有限**：很多机器人仅搭载 8–32 GB 显存的嵌入式 GPU 或移动 GPU。
- 统一 Transformer 的**层数、宽度、注意力头数与序列长度**必须一起考虑，不能简单照搬语言模型配置；
- 需要结合 10.4 节中的量化、蒸馏、模型剪枝等手段，把训练好的“大脑”压缩到机器人能吃得下的规模。OpenVLA 就展示了 7B 模型在 4bit 量化后，成功率几乎不降（71.9% vs 71.3%），显存占用却下降了一半以上。([alphaXiv](https://www.alphaxiv.org/overview/2406.09246v3?utm_source=chatgpt.com))
</code></pre>
<hr>
<h4 id="8533-最优规模选择"><a class="header" href="#8533-最优规模选择">8.5.3.3 最优规模选择</a></h4>
<p>在具体项目中，如何决定“我的 VLA 模型要做多大”？这个问题没有一个放之四海皆准的数字，但可以用几条实用原则来指导决策。</p>
<ol>
<li>**先从“实时性预算”反推模型规模。**可以做一个简化思路：</li>
</ol>
<p>对于实验室早期研究，可以先不管硬件约束，直接在大 GPU 上试验较大模型，等验证方法有效后再做压缩和架构优化。</p>
<pre><code>- 目标控制频率为 (f)（例如 10 Hz），则**单次推理允许的最大时延**约为 (T = 1/f) 的一半到三分之一（预留传感与通信开销）；
- 在目标硬件上测量不同大小 Transformer（不同层数、隐藏维度、序列长度）的前向时间；
- 选一个既能满足时延预算，又能放入显存的规模。
</code></pre>
<ol start="2">
<li><strong>任务复杂度和开放度越高，模型越需要“宽一点”。</strong></li>
</ol>
<p>此外，可以采用“两级架构”：</p>
<pre><code>- 若任务场景较封闭（固定工厂产线、物体种类有限、指令模式固定），通常几十到几百 M 级别的模型就足以胜任；
- 若目标是**开放环境 + 自然语言 + 新物体/新任务泛化**（类似 RT-2、OpenVLA 的定位），则实践上会倾向 1B–10B 范围的模型作为“机器人大脑”，并辅以大规模多模态预训练。([arXiv](https://arxiv.org/abs/2307.15818?utm_source=chatgpt.com))
- 大模型负责**高层规划、子任务分解与自然语言理解**（可以云端或离线执行）；
- 小模型负责**本地实时控制与安全执行**（在机器人上部署），二者通过中间表示（子目标、动作原语）交互。第 10 章和 12 章会再次讨论这种分层模式。
</code></pre>
<ol start="3">
<li>**善用蒸馏与量化：大模型“教”，小模型“跑”。**一种越来越常见的工程套路是：</li>
</ol>
<p>这样，<strong>模型的表达上限由大模型决定，而实际运行成本由小模型承担</strong>，两者之间通过知识蒸馏建立联系。这与第 10.4 节中的“教师–学生”模型压缩框架是一致的。</p>
<pre><code>- **先用大模型（如 OpenVLA-7B） + 大数据训练一个强策略**，在仿真和少量真实环境中获得满意表现；
- 再通过**行为蒸馏**把大模型在大量状态上的动作分布“蒸馏”到一个小模型（例如 200M–1B），让小模型模仿大模型的策略；([Medium](https://medium.com/correll-lab/paper-notes-openvla-17540381187e?utm_source=chatgpt.com))
- 最后对小模型进行量化、结构优化（如减少层数、使用更高效注意力）以满足机器人部署的硬件约束。
</code></pre>
<ol start="4">
<li>**围绕数据和团队能力做现实选择。**最后，规模选择还必须考虑非常朴素的现实因素：
<ul>
<li>你手上有多少<strong>高质量机器人数据</strong>？如果只有几千条示范，那么上十亿参数只会带来严重过拟合和无端复杂度；</li>
<li>团队是否有足够工程能力维护一个超大模型的训练与调参流程？
在很多学校/实验室场景里，一个<strong>数亿级参数、结构简洁、训练可控的 VLA</strong>，往往比盲目追逐巨模型更能帮助你快速完成科研闭环，并为将来对接更大基础模型打好接口。</li>
</ul>
</li>
</ol>
<hr>
<p>综上，本小节从理论抽象与工程实践两个角度，介绍了统一 Transformer 架构、多机器人共享设计以及模型规模权衡这三块“结构性问题”。
在接下来的第 9 章，我们会转向“训练范式”的视角，讨论在这样的架构之上，如何通过预训练、模仿学习、强化学习以及人类反馈等方式，把一个“空壳的统一模型”真正训练成具备通用操作能力的 VLA 系统。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="预训练阶段"><a href="#预训练阶段" class="header">预训练阶段</a></h1>
<h3 id="91-预训练阶段概述承上启下小结"><a class="header" href="#91-预训练阶段概述承上启下小结">9.1 预训练阶段概述（承上启下小结）</a></h3>
<p>在上一章我们主要从结构上讨论了 VLA 模型“长什么样”。从本节开始，我们转向一个更工程化的问题：<strong>如何让这样一个模型“有东西可用”</strong>——也就是预训练阶段。</p>
<p>由于机器人真实交互数据昂贵、危险且难以规模化，当前主流做法是先依托互联网海量图文数据，把模型训练成一个强大的视觉–语言基础模型，再在机器人数据上做模仿学习和 RL 微调。(<a href="https://arxiv.org/abs/2103.00020?utm_source=chatgpt.com">arXiv</a>)</p>
<p>本小节聚焦四个问题：</p>
<ol>
<li>用什么样的互联网图文语料来做预训练？</li>
<li>视觉 backbone 和语言 backbone 应该如何初始化？</li>
<li>自监督 / 半监督任务如何提升预训练效果？</li>
<li>如何在多任务预训练中合理设计和加权损失？</li>
</ol>
<hr>
<h3 id="911-利用互联网图文数据进行视觉语言预训练"><a class="header" href="#911-利用互联网图文数据进行视觉语言预训练">9.1.1 利用互联网图文数据进行视觉–语言预训练</a></h3>
<h4 id="9111-图文语料"><a class="header" href="#9111-图文语料">9.1.1.1 图文语料</a></h4>
<p><strong>1）互联网图文数据的来源形式</strong></p>
<p>互联网提供了大规模的“天然多模态数据”：</p>
<ul>
<li>图片 + alt 文本（HTML 中的 alt 属性）</li>
<li>图片 + 标题 / 正文片段（新闻、博客、商品页面）</li>
<li>图片 + 用户评论（社交媒体）</li>
<li>图片 + 自动生成的弱描述（如搜索引擎爬虫产生的元数据）</li>
</ul>
<p>早期数据集如 <strong>Conceptual Captions</strong>、<strong>YFCC100M</strong> 等，就是从网页中抽取“图片 + 描述文字”对，经过一定规则过滤构建而成。ALIGN 工作沿用了类似流程，但减少了清洗程度，用极大规模弥补噪声问题。(<a href="https://arxiv.org/abs/2102.05918?utm_source=chatgpt.com">arXiv</a>)</p>
<p>近几年，<strong>LAION 系列数据集</strong>将这一思路推向了“互联网级”规模：</p>
<ul>
<li><strong>LAION-400M</strong>：约 4 亿图文对，通过 CLIP 过滤保证基本语义相关性。(<a href="https://arxiv.org/abs/2111.02114?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>LAION-5B</strong>：扩展到约 58 亿多语种图文对，是目前公开可用的最大多模态数据集之一。(<a href="https://laion.ai/laion-5b-a-new-era-of-open-large-scale-multi-modal-datasets/?utm_source=chatgpt.com">laion.ai</a>)</li>
</ul>
<p>这些数据集的共同特点：</p>
<ul>
<li><strong>规模极大</strong>：使模型可以在非常多样的场景中看到各种物体、动作、风格。</li>
<li><strong>标注极弱且含噪</strong>：文本并不是精心写的“图像描述”，而往往只是上下文碎片。</li>
<li><strong>覆盖面广</strong>：从生活照片到截图、表格、梗图、漫画，应有尽有。</li>
</ul>
<p>对机器人而言，这类数据为“理解世界长什么样”提供了极其丰富的先验，为之后的具身学习打下语义基底。</p>
<p><strong>2）数据清洗与安全过滤</strong></p>
<p>大规模网络语料必然包含：</p>
<ul>
<li>不相关的图文对（图和文完全不匹配）</li>
<li>噪声文字（乱码、广告、SEO 垃圾）</li>
<li>不适宜内容（成人、暴力、隐私等）</li>
</ul>
<p>典型清洗步骤包括：</p>
<ul>
<li>文本层面：去掉过短或过长的文本，过滤非自然语言、广告模板等。</li>
<li>图像层面：约束分辨率范围，去掉纯色图、损坏图。</li>
<li>语义相关性过滤：用一个已训练好的 CLIP 模型，对图文对打分，只保留相似度超过阈值的样本（LAION 系列采用此类方法）。(<a href="https://arxiv.org/abs/2111.02114?utm_source=chatgpt.com">arXiv</a>)</li>
<li>安全过滤：利用专门模型过滤 NSFW、暴力或隐私内容。</li>
</ul>
<blockquote>
<p>【图 9-1 占位：互联网图文数据预处理流程示意图。从“原始网页抓取”到“图像/文本预筛选”“CLIP 相似度过滤”“安全过滤”，最后得到干净的图文对。】</p>
</blockquote>
<p>在面向机器人应用时，还可以增加额外的“领域过滤”，例如优先保留包含室内场景、桌面物体、工具、人体日常动作等图像，以提高对后续操作任务的相关性。</p>
<h4 id="9112-预训练任务"><a class="header" href="#9112-预训练任务">9.1.1.2 预训练任务</a></h4>
<p>在具备大规模图文语料后，关键问题是：<strong>用什么任务来驱动模型学习有用的视觉–语言特征？</strong></p>
<p>当前主流预训练目标大致分为三类：对比式、匹配式和生成式。</p>
<p><strong>1）对比式预训练：CLIP / ALIGN / LiT</strong></p>
<p>典型代表是 OpenAI 的 <strong>CLIP（Contrastive Language–Image Pre-training）</strong> 和 Google 的 <strong>ALIGN</strong>、<strong>LiT</strong> 等。(<a href="https://arxiv.org/abs/2103.00020?utm_source=chatgpt.com">arXiv</a>)</p>
<p>核心思想是：</p>
<ul>
<li>使用一个图像编码器 (f_\text{img}) 和一个文本编码器 (f_\text{text})。</li>
<li>对于一个 batch 中的 (N) 个图文对 ((I_i, T_i))，分别编码得到向量 (\mathbf{v}<em>i = f</em>\text{img}(I_i))，(\mathbf{u}<em>i = f</em>\text{text}(T_i))。</li>
<li>将匹配的 ((I_i, T_i)) 作为<strong>正样本</strong>，不匹配的组合作为<strong>负样本</strong>。</li>
<li>使用 InfoNCE 形式的对比损失：
$$
\mathcal{L}_\text{img2text}
= - \frac{1}{N} \sum_i
\log \frac{\exp(\text{sim}(\mathbf{v}_i,\mathbf{u}_i)/\tau)}
{\sum_j \exp(\text{sim}(\mathbf{v}_i,\mathbf{u}_j)/\tau)}
$$
文本到图像方向类似，(\text{sim}) 通常为向量点积，(\tau) 为温度系数。</li>
</ul>
<p>直观理解：模型被迫将<strong>语义上相关的图像和文本“拉近”到同一个向量空间</strong>，而把不相关的推远。训练完成后，我们可以：</p>
<ul>
<li>用一句文本在图像库中检索匹配图片（文本→图像）</li>
<li>用一张图像在文本库中检索匹配描述（图像→文本）</li>
<li>甚至做零样本分类：将类别名称转为文本，编码后与图像特征做相似度比较。(<a href="https://arxiv.org/abs/2103.00020?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>ALIGN 则证明，即便图文配对噪声较大，只要数据规模足够大，对比学习仍然能够学到非常强的视觉表示。(<a href="https://arxiv.org/abs/2102.05918?utm_source=chatgpt.com">arXiv</a>)</p>
<p>LiT（Locked-image Text Tuning）进一步提出：<strong>锁死一个强大的预训练图像模型，只训练文本侧</strong>，用对比目标将文本 embedding 对齐到图像 embedding 空间中，从而极高效地获得强大的图文模型。(<a href="https://arxiv.org/abs/2111.07991?utm_source=chatgpt.com">arXiv</a>)
这一思路在 9.1.2 节会再次出现。</p>
<blockquote>
<p>【图 9-2 占位：CLIP/ALIGN 双塔结构示意图。左侧为图像编码器，右侧为文本编码器，中间用对比损失对齐。】</p>
</blockquote>
<p><strong>2）匹配式预训练：图文匹配（ITM）</strong></p>
<p>除了软对比损失，还可以显式训练一个二分类任务：给定一对 ((I, T))，预测它们是否匹配（Image–Text Matching, ITM）。许多单流 VLM（如 ViLBERT、UNITER 等）都使用类似目标。</p>
<p>优点：</p>
<ul>
<li>学习更细粒度的对齐（部分错误描述也会被判为“不匹配”）。</li>
<li>匹配得分可以直接用作检索排序或后续模块的置信度。</li>
</ul>
<p><strong>3）生成式预训练：BLIP 等统一理解–生成模型</strong></p>
<p>对机器人尤其重要的一类目标，是<strong>从图像生成自然语言描述</strong>，以及反过来<strong>从文本生成与图像一致的语言/特征</strong>。</p>
<p>BLIP（Bootstrapping Language-Image Pre-training）提出了一个统一的 VLP 框架，同时支持理解和生成任务：它使用多模态编码–解码架构，联合优化图文对比、图文匹配和语言建模等多个目标，并通过“生成新 caption + 过滤噪声 caption”的方式提升 Web 图文数据质量。(<a href="https://arxiv.org/abs/2201.12086?utm_source=chatgpt.com">arXiv</a>)</p>
<p>对于机器人而言，这类生成能力可以用于：</p>
<ul>
<li>让模型<strong>给自己看到的场景配上语言描述</strong>，帮助理解操作环境；</li>
<li>利用语言模型对机器人执行过程进行解释（第 4.4.3 节会展开）。</li>
</ul>
<h4 id="9113-通用语义特征"><a class="header" href="#9113-通用语义特征">9.1.1.3 通用语义特征</a></h4>
<p>对比式 / 匹配式 / 生成式预训练的共同目标，是获得一个 <strong>“通用视觉–语言语义空间”</strong>：</p>
<ul>
<li>空间中的每个向量既有“视觉含义”，又对应“语言含义”；</li>
<li>相似向量对应相近的语义概念（如“杯子”“coffee mug”“水杯”会聚在一起）。</li>
</ul>
<p>CLIP 类模型已经展示出强大的零样本迁移能力：在未见过标注的分类任务上，仅通过语言描述类别名称，就能接近甚至匹敌监督训练的 ResNet-50。(<a href="https://arxiv.org/abs/2103.00020?utm_source=chatgpt.com">arXiv</a>)</p>
<p>ALIGN、LiT 等工作证明，<strong>只要视觉 backbone 足够强、图文对齐做得好，这一语义空间即可广泛迁移到下游任务</strong>。(<a href="https://arxiv.org/abs/2102.05918?utm_source=chatgpt.com">arXiv</a>)</p>
<p>对具身智能而言，这一通用语义空间有几种直接用途：</p>
<ol>
<li><strong>作为视觉 encoder 初始化</strong>：将机器人摄像头图像送入预训练的图像编码器，得到语义丰富的特征，再供下游决策网络使用。</li>
<li><strong>作为语言条件接口</strong>：用户的自然语言指令编码后与视觉特征处于同一空间，方便 VLA 模型进行“以文找物”的对齐（第 8.4 节）。</li>
<li><strong>作为跨任务共享表示</strong>：同一语义空间既可以支持分类/检测，也可以支持操作策略学习，避免为每类任务单独训练视觉模型。</li>
</ol>
<blockquote>
<p>【图 9-3 占位：通用图文语义空间示意图。不同类别图像与对应文本在高维空间中形成簇，机器人操作任务在该空间中选取目标对象。】</p>
</blockquote>
<hr>
<h3 id="912-视觉-backbone-与语言-backbone-的初始化策略"><a class="header" href="#912-视觉-backbone-与语言-backbone-的初始化策略">9.1.2 视觉 backbone 与语言 backbone 的初始化策略</a></h3>
<p>真实机器人项目通常<strong>不会从随机初始化训练一个 VLA 模型</strong>，而是高度依赖预训练好的视觉 / 语言 backbone。合理的初始化策略可以显著降低数据需求、提高收敛速度。</p>
<h4 id="9121-视觉模型初始化"><a class="header" href="#9121-视觉模型初始化">9.1.2.1 视觉模型初始化</a></h4>
<p>可以大致分为三种来源：</p>
<p><strong>1）纯视觉预训练模型</strong></p>
<ul>
<li><strong>监督预训练</strong>：如在 ImageNet 上监督训练的 ResNet、ViT 等。</li>
<li><strong>自监督预训练</strong>：如对比学习（SimCLR、MoCo、DINO）、掩码图像建模（MAE、BEiT 等）。MAE 通过随机遮挡高比例图像 Patch，并让模型重建被遮挡区域，学习到泛化性很强的视觉特征。(<a href="https://arxiv.org/abs/2111.06377?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>优点：</p>
<ul>
<li>表征偏向纯几何/纹理/语义信息，对语言分布不过度依赖；</li>
<li>适合作为“中性”的视觉基石，再与语言对齐（如 LiT 的做法）。</li>
</ul>
<p><strong>2）视觉–语言联合预训练的视觉 encoder</strong></p>
<p>CLIP、ALIGN、BLIP 等模型内置的视觉编码器，已经在图文任务上做过对齐训练，通常更擅长“对着语言找对应区域”。</p>
<p>例如：</p>
<ul>
<li>使用 CLIP-ViT 作为视觉 backbone，可以直接获得与文本空间对齐的特征，方便后续指令条件控制。(<a href="https://arxiv.org/abs/2103.00020?utm_source=chatgpt.com">arXiv</a>)</li>
<li>InternVL 等近期大模型则从头联合训练大规模视觉 encoder 和 LLM，使视觉 backbone 更适配下游多模态任务。(<a href="https://openaccess.thecvf.com/content/CVPR2024/papers/Chen_InternVL_Scaling_up_Vision_Foundation_Models_and_Aligning_for_Generic_CVPR_2024_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</li>
</ul>
<p><strong>3）如何为机器人场景做选择？</strong></p>
<p>实践中常见的几种组合：</p>
<ul>
<li><strong>桌面操作 / 室内服务机器人</strong>：环境与互联网图片相似度较高，可优先选择 CLIP / BLIP 类视觉 backbone。</li>
<li><strong>专业领域（手术机器人、工业检查等）</strong>：可以先用自监督方法在领域内的无标注图像上做额外预训练，再与语言对齐。</li>
<li><strong>资源受限平台</strong>：可能需要从较小的 CNN/ViT 结构开始，再通过知识蒸馏等手段迁移大模型的表示（见 10.4 节）。</li>
</ul>
<h4 id="9122-语言模型初始化"><a class="header" href="#9122-语言模型初始化">9.1.2.2 语言模型初始化</a></h4>
<p>语言侧的选择更加多样，大致可以分为两类：</p>
<p><strong>1）轻量级文本编码器</strong></p>
<p>如 BERT / RoBERTa 风格的编码器，输入为子词 token 序列，输出句子 embedding 或每个 token 的 contextual 表示。特点：</p>
<ul>
<li>模型尺寸中等，适合嵌入式部署；</li>
<li>适合作为“指令编码器”，将任务描述转为固定维向量，供决策模块条件使用。</li>
</ul>
<p>这类模型通常已经在大规模文本语料上预训练，具备较强的语义理解能力，对于“把红色方块放进盒子”这类简单指令完全够用。</p>
<p><strong>2）大语言模型（LLM）作为语言 backbone</strong></p>
<p>更激进的路线是直接使用 GPT/T5/LLAMA 级别的大语言模型作为语言 backbone：</p>
<ul>
<li>优点：具备丰富世界知识和推理能力，可对任务指令做更复杂的改写、分解和解释。</li>
<li>缺点：推理开销较大，延迟和内存压力重，对实时控制是挑战。</li>
</ul>
<p>许多最新 VLM / VLA 工作的做法是：<strong>冻结大部分 LLM 参数，只在其输入侧或中间插入少量可训练模块（如 LoRA、Adapter）</strong>，在保证语言能力的前提下调节其对视觉和动作信号的响应（第 2.5.3 节已介绍参数高效微调思想，这里不再赘述）。</p>
<h4 id="9123-冻结-vs-微调"><a class="header" href="#9123-冻结-vs-微调">9.1.2.3 冻结 vs 微调</a></h4>
<p>初始化只是第一步，接下来要决定：<strong>这些预训练的 backbone，要不要继续训练？如何训练？</strong></p>
<p>可以从以下几个层次理解：</p>
<p><strong>1）完全冻结（全冻结）</strong></p>
<p>做法：</p>
<ul>
<li>视觉 encoder 和文本 encoder 完全不更新；</li>
<li>仅在其上方训练一个较小的多模态融合 + 动作解码头。</li>
</ul>
<p>优点：</p>
<ul>
<li>最稳定、安全，不会破坏预训练好的通用能力；</li>
<li>计算和显存开销小，适合数据非常少的场景。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对特定机器人视角、噪声形态、指令风格的适应能力有限；</li>
<li>对具有明显领域偏移的场景（工业、医疗）效果可能较差。</li>
</ul>
<p>LiT 的结果表明，在某些情况下，“锁死图像模型，只训练文本侧”可以达到很强的零样本性能，这对机器人提示我们：<strong>合理的冻结策略本身就是一种强有力的先验</strong>。(<a href="https://arxiv.org/abs/2111.07991?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>2）部分微调 / 分层解冻</strong></p>
<ul>
<li>只微调 backbone 的高层（靠近输出的几层），保留底层边缘/纹理特征；</li>
<li>或者采用“逐层解冻”（逐步解冻）：先只训练新增头部，稳定后再逐层解冻 backbone 深层。</li>
</ul>
<p>优点：在保持大体分布的同时，让模型适应机器人视角、相机畸变、特定语言风格。</p>
<p><strong>3）参数高效微调（PEFT）</strong></p>
<p>如 LoRA、Adapter、Prefix Tuning 等，只在 backbone 内部插入小规模可训练参数。优点：</p>
<ul>
<li>几乎不改变原有权重，避免灾难性遗忘；</li>
<li>可以为不同机器人 / 任务维护多套“适配器”，共用同一个基础模型。</li>
</ul>
<p>在机器人 VLA 中常见做法是：</p>
<ul>
<li>冻结大部分 CLIP/LLM 参数；</li>
<li>在跨模态对齐层或动作解码层插入 LoRA/Adapter；</li>
<li>使用机器人多模态数据训练这些轻量参数。</li>
</ul>
<p><strong>4）如何选择策略？一个实用经验</strong></p>
<ul>
<li>机器人数据极少（几十到几百条演示）：倾向<strong>冻结 backbone + 仅训练头部或 PEFT</strong>。</li>
<li>有中等规模数据（上万条演示）：可以<strong>部分微调高层</strong>，尤其是靠近动作解码器的一侧。</li>
<li>仿真可生成极大规模数据：可以尝试<strong>全模型微调</strong>，甚至在仿真中从强初始化开始继续预训练。</li>
</ul>
<hr>
<h3 id="913-自监督--半监督任务在预训练中的作用"><a class="header" href="#913-自监督--半监督任务在预训练中的作用">9.1.3 自监督 / 半监督任务在预训练中的作用</a></h3>
<p>互联网图文预训练提供的是**“人类视角的语义先验”**，而机器人自身的传感数据（机器人的第一人称视角、低机位、特定传感器噪声等）往往分布不同。</p>
<p>为了充分利用大量 <strong>无标注或弱标注的机器人数据</strong>，自监督与半监督任务成为连接互联网预训练与具身学习的重要桥梁。</p>
<h4 id="9131-掩码建模"><a class="header" href="#9131-掩码建模">9.1.3.1 掩码建模</a></h4>
<p>掩码建模（Masked Modeling）是一类非常通用的自监督方法，包含两种典型形式：</p>
<p><strong>1）掩码语言建模（MLM）</strong></p>
<ul>
<li>在输入句子中随机遮盖部分 token（例如用 <code>[MASK]</code> 替代）；</li>
<li>训练模型根据上下文预测被遮盖 token；</li>
<li>BERT 系列模型就是通过 MLM 预训练的代表。</li>
</ul>
<p>对机器人而言，MLM 可用于让模型熟悉<strong>任务描述的语言模式</strong>，并强化对动作说明、约束条件等关键字的敏感度。</p>
<p><strong>2）掩码图像建模（MIM）：以 MAE 为代表</strong></p>
<p>MAE（Masked Autoencoders）将掩码思想引入图像：</p>
<ul>
<li>将图像分割为多个 Patch，随机遮挡其中大部分（例如 75%）；</li>
<li>编码器只处理可见 Patch，解码器从潜在表示 + 掩码 token 中重建完整图像；(<a href="https://arxiv.org/abs/2111.06377?utm_source=chatgpt.com">arXiv</a>)</li>
<li>通过重建误差作为训练信号。</li>
</ul>
<p>这类方法的直觉是：
要填补被遮挡区域，模型必须学会图像中物体的<strong>结构与上下文关系</strong>，而不是仅仅记住局部纹理。</p>
<p>进一步地，还有同时对图像和文本做掩码建模的多模态 MAE（如 M3AE 等），在 awesome-VLP 汇总中可以找到一系列工作，它们利用多模态掩码任务学习可迁移的视觉–语言表示。(<a href="https://github.com/fawazsammani/awesome-vision-language-pretraining?utm_source=chatgpt.com">GitHub</a>)</p>
<p>在机器人场景中，可以将<strong>机器人第一视角摄像头的连续画面</strong>作为 MIM 的训练对象，让模型更好地适应真实硬件和环境下的视觉分布，为后续 VLA 预训练提供“贴地气”的视觉基座。</p>
<blockquote>
<p>【图 9-4 占位：多模态掩码建模示意图。一侧是被遮挡 Patch 的图像，另一侧是遮挡 token 的指令文本，解码器联合重建。】</p>
</blockquote>
<h4 id="9132-顺序预测"><a class="header" href="#9132-顺序预测">9.1.3.2 顺序预测</a></h4>
<p>具身智能本质上是<strong>时序决策问题</strong>，因此“顺序预测”（Sequential Prediction）类自监督任务与机器人高度契合。</p>
<p>常见形式包括：</p>
<p><strong>1）语言序列的下一个 token 预测</strong></p>
<p>这是自回归语言模型（GPT 类）的经典预训练目标：给定前面一串 token，预测下一个 token。它让模型习得语法、知识及一定程度的推理能力（第 4.2 节已详细介绍）。</p>
<p><strong>2）视觉 / 视频序列预测</strong></p>
<ul>
<li>未来帧预测（Future Frame Prediction）：给定过去几帧图像，预测下一帧图像或其特征；</li>
<li>视频片段顺序判别：打乱一段视频的帧顺序，让模型判断是否在正确顺序或恢复正确顺序。</li>
</ul>
<p>对机器人而言，这类任务相当于训练一个粗略的“世界模型”：<strong>在不执行真实动作的情况下，想象环境会怎样变化</strong>。</p>
<p><strong>3）动作 / 轨迹序列预测</strong></p>
<p>在拥有大量机器人交互轨迹（甚至无任务标签）的情况下，可以构造纯自监督任务：</p>
<ul>
<li>给定过去若干步的观察和动作，预测下一步动作（或状态）；</li>
<li>给定轨迹的前半段，预测后半段动作 / 状态。</li>
</ul>
<p>这些任务不需要外部奖励或成功标注，但能让模型学习到<strong>动作–状态之间的因果结构</strong>，后续行为克隆或 RL 微调会更高效。</p>
<h4 id="9133-半监督学习"><a class="header" href="#9133-半监督学习">9.1.3.3 半监督学习</a></h4>
<p>在许多领域，<strong>图像远多于配对文本</strong>，或者只有少量专家标注的图文或轨迹。半监督学习的目标是：</p>
<blockquote>
<p>利用少量标注 + 大量未标注数据，获得接近全监督的效果。</p>
</blockquote>
<p>在视觉–语言预训练中，典型例子包括：</p>
<p><strong>1）S-CLIP：少量 caption + 大量无标注图像</strong></p>
<p>S-CLIP 针对专业领域（遥感、时尚、科学图表等）提出了一种半监督 CLIP 训练方法：</p>
<ul>
<li>有少量带 caption 的图像，以及大量没有 caption 的图像；</li>
<li>通过最优传输和部分标签学习等策略，为未标注图像生成“伪 caption”或关键词；</li>
<li>结合对比学习和伪标签训练，大幅提升目标领域的零样本性能。(<a href="https://arxiv.org/abs/2305.14095?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>这一思路可以直接迁移到机器人：
例如，在一个工厂或家庭环境中，只为少数场景人工编写多模态说明，其余大量相似场景通过 VLM 自动生成伪标签，作为额外训练信号。</p>
<p><strong>2）VLM 辅助伪标注：BLIP 的 Caption Bootstrapping</strong></p>
<p>BLIP 提出用已经训练好的 captioner 为 Web 图像生成新描述，并利用过滤器剔除明显不可信的 caption，从而在“噪声 Web 文本”之上**“自举”出更干净的监督信号**。(<a href="https://arxiv.org/abs/2201.12086?utm_source=chatgpt.com">arXiv</a>)</p>
<p>在机器人数据上可以采取类似做法：</p>
<ul>
<li>用预训练 VLM / LLM 自动为机器人轨迹打上语言标签（任务描述、错误原因等）；</li>
<li>使用人工审核少部分样本，训练一个过滤模型；</li>
<li>将高置信度伪标注加入训练，充当“廉价的弱监督”。</li>
</ul>
<p><strong>3）一致性正则与教师–学生模型</strong></p>
<p>与图像分类中的半监督类似，VLA 预训练也可以引入：</p>
<ul>
<li>对未标注样本做多种数据增强（不同视角、裁剪、颜色变换等），要求模型输出的一致性；</li>
<li>使用 teacher–student 架构（例如 EMA 均值教师），teacher 生成伪标签，student 学习，并不断更新 teacher。</li>
</ul>
<p>总的来说，自监督 / 半监督任务使我们能充分压榨<strong>机器人摄像头全天候采集的海量未标注数据</strong>，在不增加太多标注成本的情况下显著增强预训练效果。</p>
<hr>
<h3 id="914-多任务预训练与损失加权"><a class="header" href="#914-多任务预训练与损失加权">9.1.4 多任务预训练与损失加权</a></h3>
<p>到目前为止，我们分别介绍了对比学习、掩码建模、顺序预测、半监督等任务。实际系统中，往往不会只训练一个目标，而是<strong>在同一个模型上并行优化多个任务</strong>，形成多任务预训练框架。</p>
<p>这带来两个问题：</p>
<ol>
<li>如何设计多任务结构？</li>
<li>多个损失之间如何加权？</li>
</ol>
<h4 id="9141-多任务预训练"><a class="header" href="#9141-多任务预训练">9.1.4.1 多任务预训练</a></h4>
<p>多任务预训练（Multi-Task Pre-training）的基本思路是：<strong>共享一个主干网络，并在其上附着多个任务头，同时优化多种损失。</strong></p>
<p>以 BLIP 为例，它在一个多模态编码–解码架构上同时优化：(<a href="https://arxiv.org/abs/2201.12086?utm_source=chatgpt.com">arXiv</a>)</p>
<ul>
<li>图文对比损失（Image–Text Contrastive, ITC）</li>
<li>图文匹配损失（Image–Text Matching, ITM）</li>
<li>语言建模损失（LM）</li>
</ul>
<p>部分工作还会加入：</p>
<ul>
<li>掩码语言建模（MLM）或掩码多模态建模（M3AE、SIMLA 等）；</li>
<li>视觉侧的分类或检测辅助任务；</li>
<li>动作预测或行为克隆损失（在已经拥有机器人轨迹数据时）。</li>
</ul>
<blockquote>
<p>【图 9-5 占位：多任务预训练结构示意图。底部为共享视觉–语言编码器，顶部挂接 ITC、ITM、MLM、动作预测等多个任务头。】</p>
</blockquote>
<p>对于 VLA 预训练，一个典型的多任务组合可能是：</p>
<ul>
<li>任务 A：图文对比，学习通用图文对齐；</li>
<li>任务 B：掩码建模（图像 / 文本 / 视频），学习局部结构和长程依赖；</li>
<li>任务 C：行为克隆预训练，输入（图像，指令，历史动作），预测下一步动作；</li>
<li>任务 D：离线 RL 或奖励预测（如果有奖励信号）。</li>
</ul>
<p>通过共享 backbone，模型在优化任务 C/D 时可以同时利用任务 A/B 学到的<strong>概念和物理直觉</strong>；反过来，任务 A/B 的泛化能力也会因接触“动作和后果”的数据而增强。</p>
<h4 id="9142-损失函数加权"><a class="header" href="#9142-损失函数加权">9.1.4.2 损失函数加权</a></h4>
<p>多任务预训练中的难点在于：<strong>不同任务的损失尺度、收敛速度、难度都不同</strong>，如果简单地把它们相加，可能导致：</p>
<ul>
<li>某个损失主导梯度更新，其他任务几乎“学不到东西”；</li>
<li>有的损失指数级下降，有的基本不动，训练不稳定。</li>
</ul>
<p>常见的损失加权策略包括：</p>
<p><strong>1）手工设定固定权重</strong></p>
<p>最朴素也最常见的做法：
$$
\mathcal{L}<em>\text{total}
= \lambda_1 \mathcal{L}</em>\text{ITC}</p>
<ul>
<li>\lambda_2 \mathcal{L}_\text{ITM}</li>
<li>\lambda_3 \mathcal{L}_\text{MLM}</li>
<li>\lambda_4 \mathcal{L}_\text{BC}</li>
<li>\cdots
$$</li>
</ul>
<p>优点是实现简单；缺点是需要大量实验调参，且不同数据规模、模型大小下最佳权重不同。</p>
<p><strong>2）基于不确定性的动态加权（Kendall 等）</strong></p>
<p>Kendall 等提出了一种基于<strong>任务 homoscedastic 不确定性</strong>的加权方式，把不同任务的损失缩放系数视为需要学习的参数：(<a href="https://openaccess.thecvf.com/content_cvpr_2018/papers/Kendall_Multi-Task_Learning_Using_CVPR_2018_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</p>
<p>对任务 (i) 的损失 (\mathcal{L}<em>i)，总损失可写为
$$
\mathcal{L}</em>\text{total}
= \sum_i \left( \frac{1}{2\sigma_i^2} \mathcal{L}_i + \log\sigma_i \right)
$$
其中 (\sigma_i) 是可学习的“任务不确定性”，训练过程中会自动调整，使得：</p>
<ul>
<li>损失较大的任务（噪声大或难学）获得相对较小权重；</li>
<li>损失较小、易优化的任务权重相对更大。</li>
</ul>
<p>这一方法的优势在于：</p>
<ul>
<li>不需要手动指定各任务权重；</li>
<li>可以自适应不同任务在不同训练阶段的重要性。</li>
</ul>
<p><strong>3）梯度平衡与学习进度驱动的加权</strong></p>
<p>其他方法（如 GradNorm、基于任务学习进度的动态权重等）通过平衡不同任务的梯度范数或收敛速度，让每个任务都能“公平地”参与训练。</p>
<p>在 VLA 预训练中，常见的实际工作流是：</p>
<ol>
<li>先采用简单的固定权重，快速跑通训练流水线；</li>
<li>在较稳定的基础上，引入不确定性加权或梯度平衡方法，进一步提升性能；</li>
<li>在特定阶段（如开始加入 RL 目标时）动态调整权重，避免新目标“毁掉”已有能力。</li>
</ol>
<h4 id="9143-课程学习"><a class="header" href="#9143-课程学习">9.1.4.3 课程学习</a></h4>
<p>多任务预训练之外，**课程学习（Curriculum Learning）**强调的是“<strong>任务顺序</strong>”而不是单步的损失加权。</p>
<p>直觉：先让模型学习简单的任务与样本，再逐步提高难度，可以获得更稳定、更好的训练效果。</p>
<p>在 VLA 预训练中，可以从 <strong>任务维度</strong> 和 <strong>数据维度</strong> 设计课程。</p>
<p><strong>1）按任务复杂度分阶段</strong></p>
<p>一个典型的课程可以是：</p>
<ul>
<li><strong>阶段 1：单模态预训练</strong>
视觉侧做 MAE / 对比学习，语言侧做 LM / MLM，训练出各自稳定的 backbone。</li>
<li><strong>阶段 2：图文对齐</strong>
加入 CLIP 式对比任务和 ITM，让图像与文本进入统一语义空间。</li>
<li><strong>阶段 3：加入动作预测 / 行为克隆</strong>
在共享 backbone 上添加动作解码头，开始使用机器人轨迹数据，学习“视觉 + 语言 → 动作”的映射。</li>
<li><strong>阶段 4：加入奖励或 RL 目标（第 9.3 节）</strong>
在已有策略基础上引入奖励优化，细化策略的稳定性和效率。</li>
</ul>
<p>各阶段之间也可以有重叠，例如阶段 2 后期就少量混入阶段 3 的损失，使过渡平滑。</p>
<p><strong>2）按样本难度设计数据课程</strong></p>
<p>例如：</p>
<ul>
<li>在图文对齐时，先使用“描述比较准确、文字较规范”的网络数据（如精挑的 caption），再逐渐加入噪声更大的 alt 文本；</li>
<li>在机器人数据上，先训练简单场景（物体少、布局固定），再逐步引入复杂场景（遮挡、多物体、动态干扰）；</li>
<li>在动作预测上，先用短轨迹、任务步骤清晰的数据，再加入长序列或包含失败案例的数据。</li>
</ul>
<blockquote>
<p>【图 9-6 占位：VLA 预训练课程学习时间轴示意图，展示预训练阶段如何从“单模态”逐步走向“多模态 + 动作 + RL”。】</p>
</blockquote>
<p>通过多任务预训练和课程学习的组合，我们可以将“互联网世界”中的视觉–语言知识与“机器人世界”中的物理–动作经验逐步融合，为后续模仿学习和强化学习阶段打下坚实基础。这也是当下具身基础模型研究的一个核心思路：<strong>先尽量在离线数据中把能学的都学掉，再把机器人宝贵的在线交互用在“最后那一点点差距”的弥合上。</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="模仿学习阶段"><a href="#模仿学习阶段" class="header">模仿学习阶段</a></h1>
<h3 id="921-使用机器人示教轨迹进行行为克隆"><a class="header" href="#921-使用机器人示教轨迹进行行为克隆">9.2.1 使用机器人示教轨迹进行行为克隆</a></h3>
<p>这一小节把前面第 5 章中比较抽象的“行为克隆（BC）”真正落到 VLA 训练流水线上：有了多模态示教轨迹（视觉、语言、状态、动作），如何把它们组织好、喂给模型、再检查模型输出是否“像个靠谱的机器人”。</p>
<hr>
<h4 id="9211-准备示范数据"><a class="header" href="#9211-准备示范数据">9.2.1.1 准备示范数据</a></h4>
<p><strong>1）示教轨迹的基本结构</strong></p>
<p>在 VLA 场景下，一条完整的示教轨迹通常可以写成：</p>
<p>$$
\tau = \left{(o_t, x_t, a_t, c)\right}_{t=1}^T
$$</p>
<ul>
<li>(o_t)：时刻 (t) 的视觉观测（RGB 图像、深度图，甚至多相机画面）</li>
<li>(x_t)：机器人状态（关节角、末端位姿、夹爪开合、是否抓到物体等）</li>
<li>(a_t)：专家给出的动作（关节指令、末端增量、动作 token 等）</li>
<li>(c)：与整条轨迹关联的条件信息，如自然语言任务指令、任务 ID、机器人 ID、环境参数等</li>
</ul>
<p>第 7 章已经介绍了遥操作（Teleoperation）、人手带动（Kinesthetic teaching）和程序生成三种主流示教方式，这里可以认为我们已经通过这些手段获得了大量轨迹，现在的重点是<strong>标准化和对齐</strong>。</p>
<p><strong>2）时间同步与多模态对齐</strong></p>
<p>实际采集时，各模态的时间频率并不统一：相机 10–30 Hz，关节控制 100–1000 Hz，语言指令可能只有一条。常见做法是：</p>
<ul>
<li>为所有消息打时间戳</li>
<li>按目标训练频率（例如 10 Hz）建立一个统一时间轴</li>
<li>对每个时间点，找到最接近的图像帧和状态；动作通常记录为上一控制周期发出的指令</li>
</ul>
<p>这样可以得到一条<strong>对齐好的时间序列</strong>，供行为克隆模型直接使用。大规模机器人数据集（如 RT-1、Open X-Embodiment 等）都会采用类似的标准化设计，使不同实验室、不同机器人采集的数据能放到同一个训练池里使用。(<a href="https://www.researchgate.net/publication/372803068_RT-1_Robotics_Transformer_for_Real-World_Control_at_Scale?utm_source=chatgpt.com">ResearchGate</a>)</p>
<p><strong>3）轨迹切片与窗口化</strong></p>
<p>行为克隆往往不是“一条轨迹当成一个样本”，而是把轨迹切成许多长度为 (K) 的小片段：</p>
<p>$$
{(o_{t:t+K-1}, x_{t:t+K-1}, a_{t:t+K-1}, c)}
$$</p>
<ul>
<li>这样做可以让模型在一个窗口内看到<strong>短期历史</strong>，而不是只看当前帧</li>
<li>也方便使用 Transformer 这类序列模型统一处理“多帧视觉 + 历史动作”</li>
</ul>
<p>窗口长度 (K) 的选择与任务时间尺度相关：抓取类任务可能十几步即可，开门、抽屉这类长时任务可能需要更长窗口，或者再引入记忆机制。</p>
<p><strong>4）元数据与质量标注</strong></p>
<p>为了后续采样策略（见 9.2.2）和长尾处理（见 9.2.3），示范数据在存储时最好附带以下元信息：</p>
<ul>
<li>机器人 ID、机械结构信息（自由度数、是否带移动底盘等）</li>
<li>任务 ID、任务类别（抓取、插入、开合容器等）</li>
<li>环境配置（物体类别、摆放布局、光照条件等）</li>
<li>成功 / 失败标记，必要时添加“部分成功”标签（仅抓取成功、放置失败等）</li>
</ul>
<p>近年来的示教学习综述工作都强调：<strong>数据的结构化和标注质量，比单纯堆量更关键</strong>。否则大量“脏数据”只会拖慢训练，让模型学到错误的偏好。(<a href="https://www.sciencedirect.com/science/article/pii/S0921889024001969?utm_source=chatgpt.com">科学直通车</a>)</p>
<blockquote>
<p>【图 9-1 占位：示教轨迹数据结构示意图。时间轴横向展开，上方是图像帧，下方是机器人状态与动作，轨迹整体关联一条自然语言指令和任务 ID。】</p>
</blockquote>
<hr>
<h4 id="9212-行为克隆训练"><a class="header" href="#9212-行为克隆训练">9.2.1.2 行为克隆训练</a></h4>
<p><strong>1）从模仿学习到有条件的 VLA 行为克隆</strong></p>
<p>有了清洗好的示教数据，VLA 的行为克隆本质上是一个<strong>有条件的监督学习问题</strong>：</p>
<p>$$
\min_\theta \mathbb{E}<em>{\tau \sim \mathcal{D}}
\left[ \sum</em>{t} \ell\big(f_\theta(o_{1:t}, x_{1:t}, c), a_t\big) \right]
$$</p>
<ul>
<li>(f_\theta) 是 VLA 模型，输入为历史观测、机器人状态和任务条件（语言指令等），输出当前动作</li>
<li>(\ell) 是损失函数，动作是离散 token 时多用交叉熵；是连续向量时多用 L2/MSE</li>
</ul>
<p>像 RT-1、RT-X 等大规模机器人 Transformer，本质上就是在几十万条示教轨迹上做这样的大规模行为克隆，只不过它们把动作离散化为 token 序列，与语言 token 一并用 Transformer 处理。(<a href="https://www.researchgate.net/publication/372803068_RT-1_Robotics_Transformer_for_Real-World_Control_at_Scale?utm_source=chatgpt.com">ResearchGate</a>)</p>
<p><strong>2）Teacher Forcing 与动作 token</strong></p>
<p>实际训练时，最常用的是 <strong>teacher forcing</strong>：</p>
<ul>
<li>解码器在预测 (a_t) 时，条件中用的是<strong>专家的历史动作</strong> (a_{1:t-1})，而不是模型自己先前预测的动作</li>
<li>好处：梯度路径清晰稳定，训练过程完全在“专家分布”下进行，便于优化</li>
<li>代价：上线执行时，模型只能看到自己以前的动作，会产生分布偏移（这一点在第 5 章 DAgger 中已经讨论过）</li>
</ul>
<p>如果动作被量化为序列 token（例如“关节 1 的档位”“末端 x 方向增量档位”等），可以直接借用语言模型工具链：</p>
<ul>
<li>把“视觉 token + 语言 token + 历史动作 token”拼成一个长序列</li>
<li>用自回归方式预测下一个动作 token</li>
<li>损失函数就是标准的 token-level 交叉熵</li>
</ul>
<p><strong>3）冻结与解冻：利用预训练骨干</strong></p>
<p>在第 9.1 节中我们已经通过图文数据对视觉和语言 backbone 做了预训练。行为克隆阶段常见的实践是：</p>
<ol>
<li><strong>阶段一：冻 backbone，只训决策头</strong>
<ul>
<li>视觉和语言编码器参数冻结，仅训练动作解码头和少量多模态融合层</li>
<li>好处是训练稳定，防止少量机器人数据把大规模预训练知识“洗掉”</li>
</ul>
</li>
<li><strong>阶段二：逐层解冻</strong>
<ul>
<li>在行为克隆 loss 稳定下降后，逐层解冻靠后的视觉 / 语言层，允许模型为机器人任务做适度“特化”</li>
<li>解冻时要<strong>减小学习率</strong>，避免对 backbone 做过猛更新</li>
</ul>
</li>
</ol>
<p>多任务机器人策略的研究（如基于多任务 Transformer 的 BAKU、LBM 系列）都表明，合理利用预训练骨干并控制解冻节奏，可以在相同示教数据量下显著提升性能和泛化。(<a href="https://papers.nips.cc/paper_files/paper/2024/file/ff887781480973bd3cb6026feb378d1e-Paper-Conference.pdf?utm_source=chatgpt.com">NeurIPS 会议论文</a>)</p>
<p><strong>4）数据加载与 batch 构造要点</strong></p>
<ul>
<li>同一 batch 中的样本可以来自不同机器人、不同任务（多任务学习模式），也可以暂时限制为相同任务做 curriculum 学习</li>
<li>序列模型训练时，通常会对每段轨迹随机选择起始时间 (t)，避免模型只在固定时间段看到类似情形</li>
<li>对于长轨迹，可使用“子序列重叠采样”：相邻窗口部分重叠，提高数据利用率并保持时序连续性</li>
</ul>
<blockquote>
<p>【图 9-2 占位：行为克隆训练流程示意图。从轨迹池抽取一批窗口，经过视觉 / 语言编码器和 Transformer 决策头，计算动作 token 交叉熵 loss、反向传播更新。】</p>
</blockquote>
<hr>
<h4 id="9213-模型输出验证"><a class="header" href="#9213-模型输出验证">9.2.1.3 模型输出验证</a></h4>
<p>行为克隆完成后，不能只看 loss 数值“好不好看”，更关键的是：<strong>模型在闭环控制下是否真的能完成任务</strong>。</p>
<p><strong>1）离线指标：一步预测 vs 轨迹层面</strong></p>
<p>离线评估时，常用指标包括：</p>
<ul>
<li><strong>一步动作预测准确率 / Top-k 准确率</strong>：
模型在验证集上对专家动作的预测是否正确或落在前 k 个候选中</li>
<li><strong>连续动作误差</strong>：
若动作是连续的，可统计平均 L2 误差、角度误差等</li>
<li><strong>负对数似然（NLL）</strong>：
尤其在动作是概率分布（例如高斯）时，用来评估动作分布拟合程度</li>
</ul>
<p>这些指标<strong>只衡量“模仿得像不像”</strong>，并不能保证闭环执行时不会“越走越偏”。</p>
<p><strong>2）回放评估与闭环模拟</strong></p>
<p>更实际的办法是进行两种回放实验：</p>
<ul>
<li><strong>离线回放（open-loop replay）</strong>
<ul>
<li>使用记录好的观测 (o_t)、状态 (x_t)，让模型在每一步输出动作 (\hat a_t)</li>
<li>把 (\hat a_t) 与专家动作 (a_t) 比较，看轨迹整体偏差</li>
<li>适合快速检查“模型有没有学错行为风格”（例如方向完全相反）</li>
</ul>
</li>
<li><strong>仿真闭环执行（closed-loop rollout）</strong>
<ul>
<li>把模型部署到仿真环境中，从与示教轨迹相同的初始状态出发</li>
<li>每一步用模型输出作用于环境，观测新状态，再继续决策</li>
<li>统计任务成功率、完成时间等指标，这才真正反映<strong>策略可执行性</strong></li>
</ul>
</li>
</ul>
<p>从大规模机器人 BC 系统（如 RT-1、Open X-Embodiment 上的 RT-X）经验看，<strong>离线行为克隆指标与实际成功率只有部分相关</strong>：有时 NLL 改善不多，但成功率提升显著，反之亦然。因此必须保留一套“闭环验证 protocol”。(<a href="https://robotics-transformer-x.github.io/?utm_source=chatgpt.com">robotics-transformer-x.github.io</a>)</p>
<p><strong>3）错误分析与可视化</strong></p>
<p>建议在验证阶段刻意构建一些“典型失败案例”进行可视化分析：</p>
<ul>
<li>关键帧对比：同一时间点下，人类示教 vs 模型执行的末端位姿、物体位置</li>
<li>轨迹叠加：在 2D/3D 中画出示教轨迹和模型轨迹，观察偏差模式（是否总是靠近桌边、抓高了等）</li>
<li>任务分解层面：看是出错在“找物体”、“对准”还是“放置”阶段</li>
</ul>
<blockquote>
<p>【图 9-3 占位：闭环评估可视化示意图。左列是示教轨迹关键帧，右列是模型执行关键帧；下方叠加两条末端轨迹曲线，标记偏差最大的时刻。】</p>
</blockquote>
<hr>
<h3 id="922-混合多机器人多任务数据训练的采样策略"><a class="header" href="#922-混合多机器人多任务数据训练的采样策略">9.2.2 混合多机器人、多任务数据训练的采样策略</a></h3>
<p>随着 Open X-Embodiment 等数据集的公开，研究者开始尝试在<strong>二十多个机器人、上百甚至上千个任务</strong>的数据上训练单一通用策略。(<a href="https://robotics-transformer-x.github.io/?utm_source=chatgpt.com">robotics-transformer-x.github.io</a>)
这带来的好处显而易见：模型能共享知识、提升泛化；但随之而来的是一个现实问题——<strong>怎么抽数据？</strong></p>
<hr>
<h4 id="9221-数据混杂问题"><a class="header" href="#9221-数据混杂问题">9.2.2.1 数据混杂问题</a></h4>
<p>如果我们粗暴地把所有轨迹混在一起，每个时间步都“从全集中等概率采样”，会遇到至少三个问题：</p>
<ol>
<li><strong>机器人分布极不均匀</strong>
某些实验室贡献了大量某一款机械臂的数据，另一些机器人只有少量轨迹。如果不加区分，模型会几乎完全“变成”那台主流机械臂的专家，对其他机器人性能堪忧。</li>
<li><strong>任务分布严重倾斜</strong>
像“抓取桌面物体”这样的基础任务数据常常巨多，而复杂任务（抽屉、插销、开盖）数据很少。模型自然而然会学会在任何情境下“抓个东西再说”，而忽略长尾任务的细节。</li>
<li><strong>动作空间与标度差异</strong>
不同机器人使用的动作定义可能不同：有的输出关节增量，有的输出末端速度，有的还带移动底盘。即便经过统一 token 化，原始分布差异仍然存在，会导致梯度更新被某些高方差任务主导。</li>
</ol>
<p>多任务机器人策略研究已经反复观察到，这类<strong>分布不均匀 + 异质性</strong>会让“多任务训练”从理论上的利好，变成实践中的“互相拖后腿”。(<a href="https://openreview.net/forum?id=LqhorpRLIm&amp;utm_source=chatgpt.com">OpenReview</a>)</p>
<hr>
<h4 id="9222-分布均衡采样"><a class="header" href="#9222-分布均衡采样">9.2.2.2 分布均衡采样</a></h4>
<p>为缓解上述问题，可以在 DataLoader 层面设计更聪明的采样策略。</p>
<p><strong>1）任务 / 机器人均衡采样</strong></p>
<p>最直接的做法是分层采样：</p>
<ul>
<li>先<strong>均匀采样任务 ID 或（机器人，任务）二元组</strong></li>
<li>再在所选任务的轨迹池中随机采样一个时间窗口</li>
</ul>
<p>这样，每个 batch 中不同任务、不同机器人出现的概率大致相近，避免“头部任务独占梯度”。</p>
<p>具体实现上，可以为每个任务维护一个索引列表，并在每个 epoch 重新随机打乱，实现类似“per-task round-robin”的采样方式。</p>
<p><strong>2）温度重标采样（temperature-based sampling）</strong></p>
<p>严格均衡并不总是理想：样本极少的任务如果被采得过多，容易过拟合；样本极多的任务被采得过少，又浪费了宝贵数据。因此可以使用“温度采样”：</p>
<p>$$
p_i \propto n_i^\alpha,\quad 0 &lt; \alpha &lt; 1
$$</p>
<ul>
<li>(n_i)：任务 (i) 的样本数</li>
<li>(\alpha) 越接近 0，越接近完全均衡；越接近 1，越接近原始按样本数比例采样</li>
</ul>
<p>在自动驾驶和机器人长尾学习中，这类“次线性重标”的采样策略已经被证明在“利用大量头部数据”和“照顾长尾任务”之间做出了比较合理的折中。(<a href="https://arxiv.org/html/2509.21961v1?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>3）重采样 vs 重加权</strong></p>
<p>除了改变“抽样概率”，也可以保持抽样不变，只在 loss 中给不同任务加权（这一点在 9.2.3 中会详细展开）。实践中常见的组合是：</p>
<ul>
<li>适度均衡采样（例如温度采样）</li>
<li>再叠加一个较温和的 loss 权重（例如对真正极少样本的任务略微放大 loss）</li>
</ul>
<p>这样避免单一手段过度极端，导致 training dynamics 不稳定。</p>
<hr>
<h4 id="9223-元学习思路"><a class="header" href="#9223-元学习思路">9.2.2.3 元学习思路</a></h4>
<p>前面讨论的采样策略，本质上是在“让各任务在训练中被看到得更公平”。进一步的思路是：<strong>让模型学会“见到一个任务就知道该怎么快速适应”</strong>，即引入元学习（meta-learning）视角。</p>
<p><strong>1）任务级 episode 训练</strong></p>
<p>可以把“一个任务的数据子集”看成一个 episode：</p>
<ol>
<li>在该任务数据上做若干步“内循环”更新（inner loop），模拟在新任务上微调</li>
<li>再在多个任务 episode 上做“外循环”（outer loop）梯度更新，让模型参数偏向于“对任何任务都易于适应”的状态</li>
</ol>
<p>这类似于第 12 章会提到的 MAML 风格元学习，只不过这里的任务条件通常以<strong>语言指令 + 任务 ID + 机器人 ID embedding</strong> 的形式输入模型，而不是单纯的标签。</p>
<p><strong>2）检索增强与“学会选数据”</strong></p>
<p>近年来一些工作尝试从大规模示教库中为特定目标任务<strong>智能检索</strong>最相关的示范，再用这些数据做 BC 微调，本质上是一种“数据级元学习”。例如 COLLAGE 会根据少量目标任务 demo，从大库中检索语义相似的轨迹，构成增强训练集。(<a href="https://openreview.net/pdf/9f617181e2dd6d985675d7710b45bc7d00409138.pdf?utm_source=chatgpt.com">OpenReview</a>)</p>
<p>这种方法在 VLA 场景中非常自然：语言指令本身就是任务描述，可以直接用作检索 query，让模型在训练和测试时都“带着记忆中的类似经验”做决策。</p>
<blockquote>
<p>【图 9-4 占位：多任务 / 多机器人采样与元学习示意图。一侧是按任务均衡的 DataLoader，另一侧是以任务为单位的内外循环元学习流程。】</p>
</blockquote>
<hr>
<h3 id="923-数据不平衡与长尾任务的处理"><a class="header" href="#923-数据不平衡与长尾任务的处理">9.2.3 数据不平衡与长尾任务的处理</a></h3>
<p>现实世界的数据几乎都会呈现 <strong>长尾分布（long-tail）</strong>：大量普通场景 + 少量复杂罕见场景。这在视觉领域早已是经典问题，在机器人领域则显得更敏感，因为尾部任务往往正是“难但关键”的场景（例如障碍物突然出现、物体滑落、夹爪打滑）。(<a href="https://www.lgresearch.ai/blog/view?page=1&amp;pageSize=12&amp;seq=250&amp;utm_source=chatgpt.com">LG AI Research</a>)</p>
<hr>
<h4 id="9231-数据长尾现象"><a class="header" href="#9231-数据长尾现象">9.2.3.1 数据长尾现象</a></h4>
<p>在具身数据中，长尾可以出现在多个层面：</p>
<ul>
<li><strong>任务层面</strong>：
“抓起桌面方块”之类简单任务数据巨大，而“开门”、“插销”、“从抽屉里取物”数据稀缺</li>
<li><strong>环境层面</strong>：
标准光照、整齐摆放的数据极多，杂乱桌面、暗光、遮挡严重的数据极少</li>
<li><strong>动作 / 状态层面</strong>：
正常操作姿态是高频状态，而“接近碰撞边缘”“夹爪半滑落”等微妙状态十分罕见</li>
</ul>
<p>如果直接在原始长尾数据上做行为克隆，模型的策略等价于“尽量在头部场景表现好”，在尾部场景则容易<strong>完全失常</strong>，甚至表现得比简单的手工策略还差。近期针对不平衡数据的行为克隆研究也证明，<strong>不做 rebalancing 的 BC 会显著偏向频繁行为模式</strong>。(<a href="https://arxiv.org/pdf/2508.06319?utm_source=chatgpt.com">arXiv</a>)</p>
<hr>
<h4 id="9232-重采样或重加权"><a class="header" href="#9232-重采样或重加权">9.2.3.2 重采样或重加权</a></h4>
<p><strong>1）重采样（resampling）</strong></p>
<ul>
<li><strong>过采样尾部任务</strong>：
在 DataLoader 中人为提高尾部任务被采到的概率，甚至允许同一条轨迹多次出现在不同 epoch</li>
<li><strong>欠采样头部任务</strong>：
对样本过多的任务有意识地丢弃一部分，防止它们压倒一切</li>
</ul>
<p>这一做法的优势是简单直观，缺点是容易导致尾部任务过拟合（总是同几条轨迹），而头部任务信息浪费严重。</p>
<p><strong>2）损失重加权（loss re-weighting）</strong></p>
<p>另一条路径是保持抽样大致按原始分布，只对 loss 加权：</p>
<p>$$
\mathcal{L} = \sum_{k} w_{c(k)} \cdot \mathcal{L}_k
$$</p>
<ul>
<li>(\mathcal{L}_k)：第 (k) 个样本的 BC 损失</li>
<li>(c(k))：该样本所属任务 / 类别</li>
<li>(w_{c})：对应类别的权重</li>
</ul>
<p>常见的权重选择包括：</p>
<ul>
<li>反频率权重：(w_c \propto 1 / n_c)</li>
<li>平滑反频率权重：(w_c \propto 1 / \sqrt{n_c}) 或使用类似温度调节的形式</li>
<li>动态 reweighting：根据训练过程中各类任务的当前性能动态调整权重，使模型更关注“当前表现差”的任务 (<a href="https://openaccess.thecvf.com/content/WACV2023/papers/Peng_Dynamic_Re-Weighting_for_Long-Tailed_Semi-Supervised_Learning_WACV_2023_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</li>
</ul>
<p>在大规模机器人 BC 中，经验表明“<strong>适度</strong>的重加权最稳妥”——把尾部权重调大一两级通常有益，但过度放大会导致梯度噪声急剧变大，引发训练不稳定。</p>
<hr>
<h4 id="9233-数据增强"><a class="header" href="#9233-数据增强">9.2.3.3 数据增强</a></h4>
<p>因为尾部数据常常数量极少，仅靠重采样与重加权仍然容易过拟合，这时**数据增强（augmentation）**是必要补充。</p>
<p><strong>1）视觉层增强</strong></p>
<ul>
<li>经典图像增强：随机裁剪、平移、旋转、色彩抖动、噪声等</li>
<li>机器人特有增强：在仿真中做域随机化——改变光照、材质、背景等，从有限尾部场景生成多样视觉变体（与第 5 章 Sim2Real 内容呼应）</li>
</ul>
<p>注意：增强必须保证<strong>语义和任务标签不变</strong>。例如，把“开抽屉”的视频旋转 180° 就完全改变了语义，不再是原任务。</p>
<p><strong>2）动作 / 轨迹层增强</strong></p>
<ul>
<li>对动作轻度加噪：在不破坏任务成功的前提下，给专家动作加小扰动，让模型见到更丰富的“近似 optimal”的行为</li>
<li>轨迹时间裁剪 / 拼接：截取长轨迹的中间部分作为独立训练样本；或将一些标准“接近 + 抓取”子序列库重用到其他类似任务</li>
<li>在仿真中针对尾部任务设计大量<strong>程序化演示</strong>，再与少量真实示教混合使用</li>
</ul>
<p>最新的大规模驾驶与机器人策略工作表明，在数据量巨大时，简单的视觉增强很难触及真正的“规则尾部行为”，这时<strong>需要有针对性的行为层增强和仿真合成</strong>，才可能让 BC 策略在尾部任务上有像样表现。(<a href="https://link.springer.com/article/10.1007/s44336-025-00020-1?utm_source=chatgpt.com">SpringerLink</a>)</p>
<blockquote>
<p>【图 9-5 占位：长尾任务处理示意图。左侧是头–尾分布直方图，中间展示重采样 / 重加权示意，右侧展示模拟增强生成的大量尾部任务变体。】</p>
</blockquote>
<hr>
<h3 id="924-训练稳定性梯度尺度loss-爆炸收敛诊断"><a class="header" href="#924-训练稳定性梯度尺度loss-爆炸收敛诊断">9.2.4 训练稳定性：梯度尺度、loss 爆炸、收敛诊断</a></h3>
<p>VLA 模型通常是<strong>大参数量 + 长序列 + 多模态</strong>的组合，对优化器来说压力不小。略微调错学习率、初始化或归一化，就可能看到 loss 曲线“离谱起飞”或者“纹丝不动”。</p>
<p>本节不再重复第 2 章的优化基础，而是聚焦于：<strong>在大规模行为克隆中，如何监控梯度、避免 loss 爆炸，并判断模型是否真的在收敛。</strong></p>
<hr>
<h4 id="9241-梯度规范"><a class="header" href="#9241-梯度规范">9.2.4.1 梯度规范</a></h4>
<p><strong>1）梯度范数监控</strong></p>
<p>在每次反向传播后，我们可以计算整体梯度的 L2 范数：</p>
<p>$$
|\nabla_\theta|_2 = \sqrt{\sum_i g_i^2}
$$</p>
<p>其中 (g_i) 为每个参数的梯度。实际工程中，常见做法是：</p>
<ul>
<li>在日志中记录每个训练 step 或每 N 个 step 的梯度范数</li>
<li>建立一个“合理区间”（例如在初期根据试验经验设定）</li>
<li>一旦出现持续的异常尖峰或长期过小，就需要检查是否有 bug 或超参数不合理</li>
</ul>
<p>最近关于大模型训练稳定性的经验也指出，<strong>长期不稳定的梯度峰值往往与损失突然爆炸高度相关</strong>，及早发现能避免浪费训练预算。(<a href="https://arxiv.org/html/2502.17055v1?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>2）梯度裁剪（gradient clipping）</strong></p>
<p>应对梯度爆炸的经典办法是梯度裁剪，常用的是<strong>按全局范数裁剪</strong>：</p>
<p>$$
\tilde g =
\begin{cases}
g &amp; \text{if } |g|_2 \le c
\dfrac{c}{|g|_2} g &amp; \text{if } |g|_2 &gt; c
\end{cases}
$$</p>
<ul>
<li>(c) 是设定的阈值（如 1.0 或 5.0），可根据实验调整</li>
<li>裁剪只改变梯度的“长度”，不改变方向</li>
</ul>
<p>大量深度学习实践表明，梯度裁剪可以在<strong>不明显影响最终性能</strong>的前提下，显著降低 loss 爆炸、参数发散的概率，尤其是 RNN / Transformer 和大 batch 训练中几乎是标配。(<a href="https://neptune.ai/blog/understanding-gradient-clipping-and-how-it-can-fix-exploding-gradients-problem?utm_source=chatgpt.com">neptune.ai</a>)</p>
<p><strong>3）与混合精度和归一化的配合</strong></p>
<p>在 VLA 训练中经常使用混合精度（FP16/BF16），此时要注意：</p>
<ul>
<li>宜搭配 <strong>loss scaling</strong>，防止小梯度在 FP16 下下溢为 0</li>
<li>与 LayerNorm、BatchNorm 配合时，可在归一化之后监控激活值 range，避免中间激活过大导致梯度过大</li>
</ul>
<p>简单的经验法则是：<strong>先看激活再看梯度</strong>。如果中间某层激活已明显发散，那么裁剪梯度只是“止血”，仍需要从网络结构和输入归一化上找原因。</p>
<hr>
<h4 id="9242-loss-爆炸"><a class="header" href="#9242-loss-爆炸">9.2.4.2 Loss 爆炸</a></h4>
<p><strong>1）什么是 loss 爆炸</strong></p>
<p>loss 爆炸通常表现为：</p>
<ul>
<li>训练 loss 在若干 step 内突然大幅上升</li>
<li>出现 <code>Inf</code> 或 <code>NaN</code>，训练中断</li>
<li>同时伴随梯度范数的异常尖峰</li>
</ul>
<p>这在深层网络和长序列模型中非常常见，尤其是学习率过大或初始化不当时。(<a href="https://www.ultralytics.com/glossary/exploding-gradient?utm_source=chatgpt.com">ultralytics.com</a>)</p>
<p><strong>2）常见成因与排查顺序</strong></p>
<p>工程上可以按以下顺序排查：</p>
<ol>
<li><strong>学习率过大</strong>
<ul>
<li>尝试降低一个数量级（例如从 1e-4 降到 1e-5），观察 loss 是否恢复正常下降</li>
<li>确认是否正确使用了 warmup，避免刚开始就大步更新</li>
</ul>
</li>
<li><strong>输入 / 标签异常</strong>
<ul>
<li>检查是否存在输入为 <code>Inf</code> / <code>NaN</code> 的样本（例如传感器异常、数据预处理错误）</li>
<li>检查 loss 计算是否有 <code>log(0)</code>、除 0 或指数溢出（例如 <code>exp()</code> 过大）</li>
</ul>
</li>
<li><strong>梯度未裁剪</strong>
<ul>
<li>添加全局梯度裁剪，监控裁剪比例，如果经常被裁剪说明学习率或模型设计需要进一步调整</li>
</ul>
</li>
<li><strong>不合适的初始化或归一化</strong>
<ul>
<li>检查是否使用了针对 Transformer 的推荐初始化</li>
<li>在模型中适度增加 LayerNorm 或残差连接位置调整，避免某些路径累积过多放大</li>
</ul>
</li>
</ol>
<p><strong>3）回滚与恢复训练</strong></p>
<p>一旦出现 loss 爆炸，最稳妥的做法是：</p>
<ul>
<li>回滚到最近一个<strong>健康的 checkpoint</strong></li>
<li>根据排查结果调整超参数（学习率、clip 阈值等）</li>
<li>从该 checkpoint 继续训练，而不是从头再来</li>
</ul>
<p>从大规模 BC 系统经验看，<strong>从“坏掉的 checkpoint”硬撑着继续训</strong>往往得不偿失，模型参数已经跑到不靠谱区域，继续训练只会越修越乱。</p>
<hr>
<h4 id="9243-收敛诊断"><a class="header" href="#9243-收敛诊断">9.2.4.3 收敛诊断</a></h4>
<p>行为克隆的“收敛”有两层含义：
一是优化意义上的 loss 收敛；二是任务意义上的<strong>成功率收敛</strong>。二者不必严格一致。</p>
<p><strong>1）典型曲线形态</strong></p>
<p>训练过程中至少应该同时监控以下曲线：</p>
<ul>
<li>训练集 loss vs step</li>
<li>验证集 loss vs step（按任务分解更好）</li>
<li>部分代表性任务的离线成功率 / 动作预测准确率</li>
</ul>
<p>常见情形：</p>
<ul>
<li><strong>正常收敛</strong>：训练 loss 平稳下降，验证 loss 在某个点后进入平台期；对应的任务成功率逐步上升后趋于稳定</li>
<li><strong>过拟合</strong>：训练 loss 持续下降，而验证 loss 与成功率在某个时间点后恶化</li>
<li><strong>不收敛或欠拟合</strong>：训练 loss 长期高位波动或缓慢下降，验证指标几乎无明显改善</li>
</ul>
<p>针对过拟合，可以使用第 2 章介绍的早停、正则化、数据增强等手段；针对欠拟合，则需考虑加大模型容量、改进结构或收集更多高质量数据。</p>
<p><strong>2）行为克隆的“低 loss 并不等于好策略”</strong></p>
<p>与传统分类略有不同，BC 的损失是<strong>局部一步一步的模仿误差</strong>，而我们真正关心的是<strong>长轨迹上的累计效果</strong>。因此有几个易踩的坑：</p>
<ul>
<li>在数据分布上，模型可以在每一步都“略微偏离”专家动作，但长时间滚动后偏差累积成“完全做错事”</li>
<li>这类偏差在一步预测 loss 中表现不明显，但在闭环 rollout 成功率上极为明显</li>
</ul>
<p>因此在收敛诊断时，建议：</p>
<ul>
<li>每隔固定步数，从验证集随机选取若干起始场景，在仿真中执行固定长度的 rollout</li>
<li>对比相同 checkpoint 下的成功率曲线，而不仅仅看 loss 曲线</li>
</ul>
<p><strong>3）多任务情境下的收敛</strong></p>
<p>在多任务、多机器人场景中，还需要关注<strong>任务间干扰</strong>：</p>
<ul>
<li>某些任务的性能突然下降，可能是训练后期在别的任务上“学坏了”</li>
<li>可以在日志中记录每个任务的 loss / 成功率，观察是否有任务长期处于“被遗忘”状态</li>
</ul>
<p>如果出现这种现象，可以考虑：</p>
<ul>
<li>调整 9.2.2 和 9.2.3 中的采样 / 重加权策略，加强对这些任务的关注</li>
<li>或者在训练后期采用“task-wise fine-tuning”，在保持多任务能力的前提下，对重要任务单独做几轮小学习率微调</li>
</ul>
<blockquote>
<p>【图 9-6 占位：训练稳定性与收敛诊断图。上半部分展示训练 / 验证 loss 曲线，下半部分展示若干任务的成功率随 checkpoint 变化的折线图，用不同颜色表示不同任务。】</p>
</blockquote>
<hr>
<p>到这里，本节从<strong>示教轨迹 → 行为克隆训练 → 多机器人多任务采样 → 长尾处理 → 训练稳定性</strong>打通了一条完整路径。接下来的 9.3 节会在此基础之上，引入强化学习、自监督和人类反馈等进阶范式，把一个“会模仿”的 VLA 模型逐步打磨成“会试错、会总结”的更强智能体。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="进阶训练rl自监督与反馈学习"><a href="#进阶训练rl自监督与反馈学习" class="header">进阶训练：RL、自监督与反馈学习</a></h1>
<h3 id="931-在仿真环境中对-vla-进行-rl-微调的思路"><a class="header" href="#931-在仿真环境中对-vla-进行-rl-微调的思路">9.3.1 在仿真环境中对 VLA 进行 RL 微调的思路</a></h3>
<p>已经有了基于示教 / BC 训练好的 VLA 模型，本节讨论下一步：如何在仿真环境中用强化学习做“有目标的微调”，把模型从“能做”推到“做得更好、更稳、更符合约束”。</p>
<hr>
<h4 id="9311-场景搭建"><a class="header" href="#9311-场景搭建">9.3.1.1 场景搭建</a></h4>
<p><strong>（1）观测与动作接口对齐 VLA</strong></p>
<p>对 VLA 做 RL 微调的第一前提，是仿真环境暴露出的“观测–动作”接口，与模型训练时的输入输出严格对齐：</p>
<ul>
<li><strong>观测侧</strong>：
<ul>
<li>视觉：仿真中的相机分辨率、视角、FOV 尽量贴近示教数据（第 7 章中采集的图像）；</li>
<li>机器人状态：关节角、末端位姿、夹爪开合状态等按同样的编码方式拼到输入；</li>
<li>语言：每个 episode 开始时给出一条指令，编码为文本 token 或指令 embedding，整个 episode 内保持不变，作为条件。</li>
</ul>
</li>
<li><strong>动作侧</strong>：
<ul>
<li>若前面章节采用离散动作 token（例如 7 个关节的离散速度档位），则仿真环境需要一个“token→物理控制命令”的解码层；</li>
<li>若采用末端 Δ pose / 速度指令，同样需要在环境侧实现将这些增量命令映射到关节控制器。</li>
</ul>
</li>
</ul>
<p>很多开源 VLA 框架（如 OpenVLA）在代码层面已经实现了这类“统一的 Env wrapper”，既能喂 BC 数据，也能在同样接口上进行 RL 交互，这一点值得参考。(<a href="https://arxiv.org/html/2406.09246v3?utm_source=chatgpt.com">arXiv</a>)</p>
<p>【图片占位：一个方框图，左边是“仿真环境（MuJoCo/Isaac Gym）”，中间是“Env Wrapper（观测打包 + 动作解码）”，右边是“VLA 模型”，箭头表示数据流。】</p>
<p><strong>（2）任务实例与重置逻辑</strong></p>
<p>RL 需要大量 episode，因此要把“任务”刻画得足够清晰：</p>
<ul>
<li>设计<strong>初始随机化</strong>：物体摆放位置、姿态、颜色微扰，甚至背景纹理、光照随机化，为后续的 sim2real 泛化铺路（与 7.1.4 呼应）；</li>
<li>定义 <strong>终止条件</strong>：
<ul>
<li>成功：例如目标物体进入目标区域、门完全关闭、按钮被按下；</li>
<li>失败：例如超过最大步数、物体掉落桌面之外、发生严重碰撞；</li>
</ul>
</li>
<li>重置逻辑：提供 <code>reset()</code> 函数，能自动将环境回到新的初始随机状态，支撑成千上万次 RL episode。</li>
</ul>
<p><strong>（3）并行环境与多任务场景</strong></p>
<p>为提高样本效率，通常会采用<strong>向量化环境</strong>：一次并行运行几十甚至上百个仿真实例，每一步将所有实例的观测批量喂入 VLA，再把动作批量返回，使 GPU  / TPU 利用率更高。很多多阶段操作任务的 RL 工作都是在这种并行环境下完成的。(<a href="https://openreview.net/pdf/3599c43148b13fd821ac6abe4629c9baf0a97a23.pdf?utm_source=chatgpt.com">OpenReview</a>)</p>
<p>对于通用 VLA，还需要在同一个仿真框架内注册多个任务（如“抓取并放置”“开门”“拉抽屉”）。不同任务可以通过不同的语言指令区分，也可以通过额外的任务 ID embedding 作为条件输入（与 8.5 中的多任务 VLA 架构呼应）。</p>
<p>【图片占位：多任务仿真场景示意图：同一机器人在不同环境中执行“抓取”“开门”“按钮”等任务，每个环境上方标注一条语言指令。】</p>
<hr>
<h4 id="9312-奖励设计"><a class="header" href="#9312-奖励设计">9.3.1.2 奖励设计</a></h4>
<p>强化学习阶段的“目标”通过奖励函数体现。对 VLA 而言，奖励不只是“成功/失败”，还会影响动作风格（是否平稳、安全、节能）。</p>
<p><strong>（1）稀疏奖励 vs. 稠密奖励</strong></p>
<ul>
<li><strong>稀疏奖励</strong>：只有成功时给 +1，其余为 0。实现简单，但是探索难度大；</li>
<li><strong>稠密奖励</strong>：在成功奖励之外，增加“离目标的距离缩短多少”“把手接近目标物体多少”之类的中间信号，帮助策略更快学会合理路径。多阶段操作任务往往会设计分阶段形状奖励，例如：
<ul>
<li>接近阶段：末端到目标物体的距离减少给正奖励；</li>
<li>抓取阶段：夹爪与物体对齐、闭合后仍保持接触给予奖励；</li>
<li>放置阶段：物体在目标区域停稳、没有过大速度时给终止奖励。(<a href="https://openreview.net/pdf/3599c43148b13fd821ac6abe4629c9baf0a97a23.pdf?utm_source=chatgpt.com">OpenReview</a>)</li>
</ul>
</li>
</ul>
<p><strong>（2）语言条件与任务判定</strong></p>
<p>在 VLA 场景中，奖励必须与<strong>语言指令所指定的任务</strong>对齐，而不是只看某个几何条件。例如指令是“把红色积木放进蓝色盒子”，奖励不能在机器人把绿色积木放进盒子时给成功信号。常见手法包括：</p>
<ul>
<li>环境中维护“语义对象 ID”（颜色、类别等），成功判定时检查是否符合指令；</li>
<li>对于多物体任务，可以让环境根据语言解析结果自动选中“目标物体集合”，仅对这些对象的状态计算奖励。</li>
</ul>
<p><strong>（3）安全与舒适性奖励</strong></p>
<p>机器人 RL 不能只追求成功率，还要考虑安全性与动作质量：</p>
<ul>
<li>碰撞惩罚：与桌面、大力撞击目标物体时给予负奖励；</li>
<li>动作惩罚：对过大的关节速度、加速度施加 L2 正则，鼓励平滑动作；</li>
<li>力/扭矩正则：约束末端作用力，避免损坏物体。</li>
</ul>
<p><strong>（4）手工奖励 vs. 学习奖励</strong></p>
<p>手工奖励设计对简单任务足够，但对“整洁、自然、让人放心”这类高层目标很难写成公式，这正是 9.3.3 将要讨论的**“基于人类偏好的奖励模型”**的作用：用 RLHF 思路让模型直接学“人喜欢什么样的行为”，再在仿真中用这个学习到的奖励进行 RL 微调。(<a href="https://papers.neurips.cc/paper/7017-deep-reinforcement-learning-from-human-preferences.pdf?utm_source=chatgpt.com">NeurIPS论文集</a>)</p>
<hr>
<h4 id="9313-微调流程"><a class="header" href="#9313-微调流程">9.3.1.3 微调流程</a></h4>
<p><strong>（1）总体流程概览</strong></p>
<p>在实践中，一个典型的“BC + RL 微调”流程大致如下：</p>
<ol>
<li><strong>加载预训练 VLA</strong>：视觉、语言编码器和决策 Transformer 已经在大规模示教数据上通过 BC 训练好；</li>
<li><strong>搭建 RL 仿真环境</strong>：如前小节，保证观测–动作接口一致；</li>
<li><strong>选定 RL 算法</strong>：常用 PPO（近端策略优化）或 SAC 等连续控制方法；</li>
<li><strong>确定可训练参数范围</strong>：
<ul>
<li>全量更新（高算力场景）；</li>
<li>只更新动作解码头或部分层；</li>
<li>使用 LoRA / Adapter 等参数高效微调，仅在少量插入矩阵上做 RL 更新。(<a href="https://arxiv.org/html/2502.19645v2?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ol>
<p>【图片占位：RL 微调流程时间轴：左边“BC 预训练模型”，中间“仿真交互采样 + 经验池”，右边“策略更新 + 新策略部署”，循环箭头表示迭代。】</p>
<p><strong>（2）一次 RL 更新的细节</strong></p>
<p>以 PPO 为例，一次更新循环可以分解为：</p>
<ul>
<li><strong>采样阶段</strong>：
<ul>
<li>在并行环境中用当前 VLA 策略执行若干步，收集序列 ((o_t, a_t, r_t, \log\pi_\theta(a_t|o_t)))；</li>
<li>为了兼顾历史动作和语言条件，把完整的“视觉–语言–动作历史”都打包成 VLA 的输入（与 8.4 中的条件建模保持一致）；</li>
</ul>
</li>
<li><strong>优势估计</strong>：
<ul>
<li>通过一个值函数头（可以复用 VLA 的 backbone）估计各状态价值 (V_\theta(o_t))，再计算优势 (A_t)；</li>
</ul>
</li>
<li><strong>策略更新</strong>：
<ul>
<li>按 PPO 损失对策略参数做若干次梯度下降，同时限制新旧策略的 KL 距离不超过阈值，避免更新过猛导致行为崩溃；</li>
</ul>
</li>
<li><strong>（可选）价值头更新</strong>：
<ul>
<li>单独优化值函数，使其更好地拟合长期回报。</li>
</ul>
</li>
</ul>
<p><strong>（3）保持“模仿锚点”：BC + RL 联合损失</strong></p>
<p>如果只用 RL 损失更新，大模型容易在探索过程中学出“奇怪但高奖励”的动作，偏离人类示范分布过远。一个常用技巧是，在 RL 微调时<strong>继续加入少量 BC 损失</strong>：</p>
<p>$$
\mathcal{L} = \mathcal{L}<em>{\text{RL}} + \lambda</em>{\text{BC}}\mathcal{L}_{\text{BC}} ,
$$</p>
<p>其中 (\mathcal{L}<em>{\text{BC}}) 在随机抽取的一部分示教样本上计算“动作交叉熵”，(\lambda</em>{\text{BC}}) 控制 RL 与模仿之间的平衡。这种做法在多阶段 manipulation 任务中被证明可以显著稳定训练、提高成功率。(<a href="https://openreview.net/pdf/3599c43148b13fd821ac6abe4629c9baf0a97a23.pdf?utm_source=chatgpt.com">OpenReview</a>)</p>
<p><strong>（4）课程式 RL 微调</strong></p>
<p>复杂任务（例如多阶段装配）的 RL 微调往往采用<strong>课程学习</strong>：</p>
<ul>
<li>第一阶段只在相对简单的子任务上微调（如“接近目标物体”）；</li>
<li>达到一定成功率后解锁更难子任务（如“抓取 + 放置”）；</li>
<li>最终在完整任务上进行微调。</li>
</ul>
<p>这类“分阶段微调 + 课程设计”的思想，与多阶段 RL 和层级策略训练的工作是一致的，会在 9.3.4 中与多范式联合调度一起讨论。(<a href="https://www.sciencedirect.com/science/article/abs/pii/S0952197625008668?utm_source=chatgpt.com">科学直通车</a>)</p>
<hr>
<h3 id="932-利用未标注视频做未来预测--掩码建模等自监督任务"><a class="header" href="#932-利用未标注视频做未来预测--掩码建模等自监督任务">9.3.2 利用未标注视频做未来预测 / 掩码建模等自监督任务</a></h3>
<p>示教数据和 RL 交互数据通常是昂贵的，而机器人在实验室或现实环境中运行时，会自然产生大量“未标注视频”。这一节讨论如何把这些视频变成 VLA 的“自监督教材”，让模型在不额外依赖人工标注的情况下，获取更强的时空表征与物理直觉。</p>
<hr>
<h4 id="9321-未来帧预测"><a class="header" href="#9321-未来帧预测">9.3.2.1 未来帧预测</a></h4>
<p><strong>（1）为什么要预测未来？</strong></p>
<p>直观理解：一个懂“物理”的模型，应该能看到几帧视频就猜到“下一帧会发生什么”。未来帧预测就是把这种直觉变成训练目标：</p>
<ul>
<li>输入：过去若干帧图像 / 视频片段，以及（可选的）动作序列；</li>
<li>输出：下一帧图像，或接下来若干帧的压缩 latent 表示；</li>
<li>损失：像素级 L1 / L2、感知损失（如在预训练视觉 backbone 上的特征差异）等。</li>
</ul>
<p>大量工作表明，先学会预测视频，再在此基础上学习控制，可以显著提升机器人策略的样本效率，例如“先训练视频预测模型，再训练逆运动学 / 控制模块”的方法。(<a href="https://raw.githubusercontent.com/mlresearch/v267/main/assets/hu25g/hu25g.pdf?utm_source=chatgpt.com">GitHub</a>)</p>
<p>【图片占位：世界模型示意图：左侧输入若干历史帧和动作，中间是动态模型，右侧是未来帧或未来 latent 的预测。】</p>
<p><strong>（2）显式像素预测 vs. 潜变量预测</strong></p>
<ul>
<li>显式预测：直接生成下一帧图像，适合展示效果，但易出现模糊、训练开销大；</li>
<li>潜变量预测：只在压缩后的特征空间中预测下一步 latent（例如 VAE / Transformer latent），不必重建像素，效率更高，也更容易与 VLA 的视觉 encoder 对接。</li>
</ul>
<p>在实际系统中，常见做法是：</p>
<ol>
<li>把视频帧送入视觉 backbone（CNN/ViT）得到特征；</li>
<li>在这些特征上用一个时序模型（RNN / Transformer）做未来 latent 预测；</li>
<li>只在训练时加一个预测损失，推理时则把预测模块当作<strong>辅助的“物理感知”结构</strong>，不一定需要显式解码出图像。(<a href="https://arxiv.org/abs/2210.04154?utm_source=chatgpt.com">arXiv</a>)</li>
</ol>
<p><strong>（3）与 VLA 的结合方式</strong></p>
<p>未来预测可以与 VLA 结合为：</p>
<ul>
<li><strong>预训练阶段</strong>：
<ul>
<li>冻结或共享视觉 encoder，在海量机器人或人类操作视频上做未来预测；</li>
<li>训练好的 encoder 再被用作 VLA 的视觉 backbone，比 ImageNet 或 CLIP 的表征在控制任务上更有效。(<a href="https://proceedings.mlr.press/v205/nair23a/nair23a.pdf?utm_source=chatgpt.com">Proceedings of Machine Learning Research</a>)</li>
</ul>
</li>
<li><strong>微调阶段的辅助头</strong>：
<ul>
<li>在 RL 或 BC 训练时，加一个共享 backbone 的“未来 latent 预测头”，用自监督损失稳定视觉表示，减少由于策略变化带来的分布偏移。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="9322-时间掩码建模"><a class="header" href="#9322-时间掩码建模">9.3.2.2 时间掩码建模</a></h4>
<p><strong>（1）从图像 MAE 到视频 MAE</strong></p>
<p>在第 3 章中已经介绍过掩码图像建模（MAE）的思想：随机遮挡图像的一部分，让模型重建缺失区域，从而学到结构化表征。对于视频和机器人任务，可以把这个思想推广到<strong>时间维度</strong>：(<a href="https://www.researchgate.net/publication/364222617_Real-World_Robot_Learning_with_Masked_Visual_Pre-training?utm_source=chatgpt.com">ResearchGate</a>)</p>
<ul>
<li>随机遮挡某一帧内部的一部分 patch（空间掩码）；</li>
<li>或完全遮掉若干连续帧（时间掩码），要求模型根据前后上下文恢复它们。</li>
</ul>
<p><strong>（2）时间掩码建模的训练形式</strong></p>
<p>典型的时间掩码建模流程：</p>
<ol>
<li>从未标注视频中切出长度为 (T) 的序列；</li>
<li>随机选择若干时间步 (t_1,\dots,t_k) 和空间 patch，设为掩码；</li>
<li>用一个视频 Transformer（或 3D CNN）对完整序列编码；</li>
<li>在被掩盖的位置上预测对应的像素 / 特征；</li>
<li>用 MSE 或交叉熵等损失优化。</li>
</ol>
<p>这类方法已经在通用视频表征学习和 3D 点云表征中被证明对下游机器人任务非常有帮助，如针对点云的 Masked Point Modeling 可以提供强大的 3D 几何感知能力。(<a href="https://openaccess.thecvf.com/content/CVPR2024/papers/Chen_SUGAR_Pre-training_3D_Visual_Representations_for_Robotics_CVPR_2024_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</p>
<p><strong>（3）扩展到“视觉–动作–语言”的跨模态掩码</strong></p>
<p>在 VLA 中，我们不仅有视频帧，还有动作 token 和语言 token。可以进一步设计<strong>跨模态掩码建模任务</strong>：</p>
<ul>
<li>掩码某些时间步的动作 token，让模型根据前后观察与语言推测出缺失动作；</li>
<li>掩码部分语言指令（例如物体颜色），逼迫模型从视频中“反向推理”被掩盖信息；</li>
<li>同时对视觉、动作、语言做联合掩码，让模型学会模态间的约束关系。</li>
</ul>
<p>这种“统一序列的掩码重建”形式，与 8.5.1 中的“视觉–语言–动作统一 Transformer”结构天然契合：把所有模态统一看作 token 序列，在预训练阶段用掩码建模，微调阶段改为输出动作策略。(<a href="https://arxiv.org/abs/2210.04154?utm_source=chatgpt.com">arXiv</a>)</p>
<hr>
<h4 id="9323-多视角一致"><a class="header" href="#9323-多视角一致">9.3.2.3 多视角一致</a></h4>
<p>在机器人实验室中，常常会为同一个任务布置多个相机视角（俯视、侧视、腕部手眼相机等）。多视角视频不一定都有人工标注，但非常适合做<strong>自监督的几何一致性学习</strong>。</p>
<p><strong>（1）对比式多视角一致</strong></p>
<p>最直接的思路是：</p>
<ul>
<li>把同一时间戳的不同视角帧视为“正样本”，不同时间或不同任务的帧视为“负样本”；</li>
<li>通过对比学习（类似 CLIP / SimCLR）拉近正样本的嵌入距离、推远负样本；</li>
<li>最终得到“对多视角不敏感、但对物体和动作语义敏感”的视觉表征。(<a href="https://proceedings.mlr.press/v205/nair23a/nair23a.pdf?utm_source=chatgpt.com">Proceedings of Machine Learning Research</a>)</li>
</ul>
<p><strong>（2）基于几何的视角变换任务</strong></p>
<p>如果相机外参已知，可以要求模型完成更强的任务，例如：</p>
<ul>
<li>给定 A 视角的图像和相机位姿，预测同一时刻 B 视角的图像（视图合成）；</li>
<li>在 3D 点云场景中，对某一视角点云做掩码建模，同时要求在另一视角下也能进行一致的重建。</li>
</ul>
<p>这类方法在 3D 视觉预训练中被证明可以学到与抓取、定位相关的几何信息，对机器人操作尤为重要。(<a href="https://openaccess.thecvf.com/content/CVPR2024/papers/Chen_SUGAR_Pre-training_3D_Visual_Representations_for_Robotics_CVPR_2024_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</p>
<p><strong>（3）与 VLA 的集成</strong></p>
<p>多视角一致性损失可以作为 VLA 视觉 backbone 的自监督正则：</p>
<ul>
<li>在预训练阶段，把来自不同视角的图像都送入同一个视觉 encoder；</li>
<li>通过一致性损失约束 encoder 输出，使其在不同视角上形成“同一物体 / 状态”的聚类；</li>
<li>微调到 VLA 任务时，即使部署环境只保留一个视角，模型也会对视点变化更鲁棒。</li>
</ul>
<p>需要注意的是，视频自监督表征未必自动适合控制任务，一些工作专门分析了“视频预训练分布与控制任务分布不匹配”的问题，强调需要在数据选择和任务设计上谨慎，避免学到与机器人决策无关的特征。(<a href="https://tonyzhaozh.github.io/data/Video_Pretraining_Distribution_Shift.pdf?utm_source=chatgpt.com">tonyzhaozh.github.io</a>)</p>
<p>【图片占位：多相机围绕操作工作区的俯视示意图，箭头表示多视角图像映射到同一特征空间。】</p>
<hr>
<h3 id="933-人类偏好--反馈数据在机器人任务中的采集方式"><a class="header" href="#933-人类偏好--反馈数据在机器人任务中的采集方式">9.3.3 人类偏好 / 反馈数据在机器人任务中的采集方式</a></h3>
<p>即使有了精心设计的奖励函数和大量自监督预训练，机器人行为仍可能与人类期望有偏差：动作过快、看起来危险、虽然完成任务但“很别扭”等。为此，需要把“人觉得好不好”直接变成数据 —— 这就是机器人领域中的 RLHF / 偏好学习。(<a href="https://www.ibm.com/think/topics/rlhf?utm_source=chatgpt.com">IBM</a>)</p>
<hr>
<h4 id="9331-人类偏好标注"><a class="header" href="#9331-人类偏好标注">9.3.3.1 人类偏好标注</a></h4>
<p><strong>（1）基本范式：轨迹片段对比</strong></p>
<p>最经典的偏好标注模式源自“深度强化学习来自人类偏好”（Deep RL from Human Preferences）。(<a href="https://papers.neurips.cc/paper/7017-deep-reinforcement-learning-from-human-preferences.pdf?utm_source=chatgpt.com">NeurIPS论文集</a>) 核心形式是：</p>
<ul>
<li>让机器人在仿真或真实环境中执行策略，记录许多 episode；</li>
<li>自动将每条轨迹切成短片段（例如 1–3 秒的视频片）；</li>
<li>向标注者展示成对片段（A vs. B），并提供对应指令文本；</li>
<li>让标注者选择“哪个更符合指令 / 更安全 / 更平稳”。</li>
</ul>
<p>只要能收集到足够多这类“偏好对”，就可以训练奖励模型（见 9.3.3.2）。</p>
<p>【图片占位：标注界面示意图：两段机器人视频并排播放，下方有“更好 / 一样好 / 更差”的选项按钮。】</p>
<p><strong>（2）多种标注形式</strong></p>
<p>除了二选一，还可以设计不同形式的偏好：</p>
<ul>
<li><strong>排序标注</strong>：一次展示 3–4 个短片段，标注者按好坏排序；</li>
<li><strong>打分标注</strong>：对每个片段给 1–5 星的评分，评价“自然度”“安全感”等维度；</li>
<li><strong>文本反馈</strong>：允许标注者写一句简短文字，如“太快”“夹爪撞到杯子”，后续可以用语言模型把这些评论转为奖励信号或规则。</li>
</ul>
<p>实践中，为了减轻标注负担，通常倾向于<strong>成对比较 + 简单按钮</strong>，这也是当前 RLHF 系统中使用最广的形式。(<a href="https://github.com/opendilab/awesome-RLHF?utm_source=chatgpt.com">GitHub</a>)</p>
<p><strong>（3）谁来标注？标注质量如何控制？</strong></p>
<ul>
<li>机器人领域的偏好标注可以由实验室成员完成，也可以通过众包平台收集非专家标注；</li>
<li>为保证质量，可以：
<ul>
<li>设计“金标准”片段，偶尔混入标注界面，用来检测标注者是否认真；</li>
<li>计算标注者间一致性，过滤掉与多数人差异极大的标注；</li>
<li>使用简单的界面提示说明标注标准，例如“更接近目标、更少多余动作、更安全”。</li>
</ul>
</li>
</ul>
<hr>
<h4 id="9332-反馈融入训练"><a class="header" href="#9332-反馈融入训练">9.3.3.2 反馈融入训练</a></h4>
<p><strong>（1）奖励模型：从偏好到标量奖励</strong></p>
<p>偏好数据本身是“谁更好”的相对信息，需要通过**奖励模型（Reward Model）**转成标量奖励。典型做法是：(<a href="https://intuitionlabs.ai/articles/reinforcement-learning-human-feedback?utm_source=chatgpt.com">IntuitionLabs</a>)</p>
<ol>
<li>复用 VLA 的视觉–语言–动作 encoder，对每个候选片段输出一个标量 (R_\phi(\tau))；</li>
<li>用<strong>偏好交叉熵损失</strong>训练：
<ul>
<li>若人类偏好片段 A 胜过 B，则让模型输出的 (R_\phi(\tau_A)) 大于 (R_\phi(\tau_B))，通过 logistic / softmax 形式拟合“被选中概率”；</li>
</ul>
</li>
<li>训练完成后，奖励模型即可对任意新轨迹估计“人类偏好程度”。</li>
</ol>
<p><strong>（2）基于人类奖励的 RL 微调（RLHF for Robotics）</strong></p>
<p>得到奖励模型后，可以像在语言模型 RLHF 中那样，对机器人策略进行第二阶段 RL 微调：</p>
<ul>
<li>在仿真环境中执行当前策略，记录轨迹；</li>
<li>用奖励模型 (R_\phi) 评估轨迹，并将输出作为奖励信号；</li>
<li>使用 PPO / SAC 等算法优化 VLA 策略，使其倾向于产生高奖励轨迹。</li>
</ul>
<p>有研究系统性分析了 RLHF 和偏好奖励在机器人任务中的作用，表明在缺少精确手工奖励，或手工奖励难以刻画人类主观标准时，这种方式更加灵活。(<a href="https://arxiv.org/html/2507.13171v1?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>（3）偏好直接约束策略 / 过滤数据</strong></p>
<p>除了用奖励模型做 RL，还可以更直接地把偏好用于监督或数据过滤：</p>
<ul>
<li><strong>偏好加权 BC</strong>：在行为克隆损失中对“人类喜爱的轨迹”加大权重，对被判定为糟糕的轨迹降权甚至直接丢弃；</li>
<li><strong>采样时过滤</strong>：在从虚拟回放缓冲区采样 RL 数据时，用奖励模型筛选掉奖励明显过低的样本；</li>
<li><strong>动作后验过滤</strong>：在策略输出候选动作后，用奖励模型预估短期走势，将明显不符合偏好的动作拒绝掉（类似“安全过滤器”）。</li>
</ul>
<p>这些方式在工程上往往比全量 RLHF pipeline 更简单，适合资源有限的实验环境。(<a href="https://github.com/opendilab/awesome-RLHF?utm_source=chatgpt.com">GitHub</a>)</p>
<hr>
<h4 id="9333-实践难点"><a class="header" href="#9333-实践难点">9.3.3.3 实践难点</a></h4>
<p>在机器人任务中应用人类偏好 / 反馈，常见问题主要集中在以下几点：</p>
<p><strong>（1）反馈成本高、样本效率低</strong></p>
<ul>
<li>每次偏好标注都需要人观看视频并作出判断，尤其是长任务会极大消耗时间；</li>
<li>解决思路包括：
<ul>
<li>将轨迹切成 1–3 秒短片段，减少每次评估的认知负担；</li>
<li>对策略变化不大的阶段减少标注频率，只在模型行为发生明显变化时采集新偏好；</li>
<li>使用主动学习策略，从大量候选片段中挑选“最有信息量”的少数来标注。(<a href="https://papers.neurips.cc/paper/7017-deep-reinforcement-learning-from-human-preferences.pdf?utm_source=chatgpt.com">NeurIPS论文集</a>)</li>
</ul>
</li>
</ul>
<p><strong>（2）偏好不一致、奖励模型不稳定</strong></p>
<p>不同人对“好行为”的理解不完全一致，甚至同一个人在不同时间的判断也会摇摆，从而造成奖励模型训练的不稳定。解决办法包括：</p>
<ul>
<li>在奖励模型中加入正则化或先验约束，使其在未充分观测区域不过度自信；</li>
<li>显式建模“不同人群的多样偏好”，例如在 latent 空间对奖励模型的输出做平滑，减小少数极端标注的影响。(<a href="https://www.ijcai.org/proceedings/2024/0586.pdf?utm_source=chatgpt.com">IJCAI</a>)</li>
</ul>
<p><strong>（3）奖励黑客与安全风险</strong></p>
<p>如果奖励模型定义得不够全面，策略可能学会“骗奖励模型”而非真正做好任务，这在 RLHF 文献中被反复强调。(<a href="https://intuitionlabs.ai/articles/reinforcement-learning-human-feedback?utm_source=chatgpt.com">IntuitionLabs</a>)</p>
<p>在机器人场景下的表现形式包括：</p>
<ul>
<li>看起来“勉强完成任务”但动作很危险，如幅度过大、距离人体过近；</li>
<li>过度追求奖励模型看中的某个指标（如速度），牺牲其它重要方面。</li>
</ul>
<p>因此在实践中，通常需要将人类偏好奖励与<strong>安全硬约束</strong>（第 10.3 节）结合：即使奖励模型高分，只要触碰安全界限，动作仍然会被硬件 / 规划层拒绝。</p>
<hr>
<h3 id="934-多范式联合训练的调度先-bc-再-rl再自监督等组合"><a class="header" href="#934-多范式联合训练的调度先-bc-再-rl再自监督等组合">9.3.4 多范式联合训练的调度（先 BC 再 RL，再自监督等组合）</a></h3>
<p>前面几节分别讨论了 BC、RL、自监督、偏好学习等单一范式。本节的重点，是如何把这些范式在时间轴上合理编排，使 VLA 在有限算力和数据下高效成长，而不是“先做一堆预训练，再做一堆 RL”这么粗糙。</p>
<hr>
<h4 id="9341-阶段划分"><a class="header" href="#9341-阶段划分">9.3.4.1 阶段划分</a></h4>
<p>一种典型的“分阶段”训练 pipeline 可以概括为：</p>
<ol>
<li><strong>阶段 0：自监督 / 多模态预训练</strong>
<ul>
<li>使用海量未标注视频、图文数据做掩码建模、对比学习、未来帧预测等，得到通用视觉–语言–时序表示（对应 9.1 节）；(<a href="https://proceedings.mlr.press/v205/nair23a/nair23a.pdf?utm_source=chatgpt.com">Proceedings of Machine Learning Research</a>)</li>
</ul>
</li>
<li><strong>阶段 1：行为克隆（BC）</strong>
<ul>
<li>在机器人示教轨迹上训练 VLA，使其基本能完成各类任务（对应 9.2）；</li>
</ul>
</li>
<li><strong>阶段 2：RL 微调</strong>
<ul>
<li>在仿真环境或部分真实环境中，根据手工或学习的奖励进一步优化策略，提升成功率和鲁棒性（9.3.1）；(<a href="https://openreview.net/pdf/3599c43148b13fd821ac6abe4629c9baf0a97a23.pdf?utm_source=chatgpt.com">OpenReview</a>)</li>
</ul>
</li>
<li><strong>阶段 3：基于人类反馈的对齐</strong>
<ul>
<li>通过 RLHF 或偏好加权 BC，使策略更符合人类主观标准（9.3.3）。</li>
</ul>
</li>
</ol>
<p>每个阶段可以有自己的“收敛判据”：例如自监督阶段看重自监督损失与线性探针性能，BC 阶段关注离线动作预测准确率与离线成功率，RL 阶段关注在线成功率曲线。</p>
<p>【图片占位：时间轴示意图：Stage0 自监督 → Stage1 BC → Stage2 RL → Stage3 RLHF，每个阶段标注输入数据类型和主要目标。】</p>
<hr>
<h4 id="9342-交替训练"><a class="header" href="#9342-交替训练">9.3.4.2 交替训练</a></h4>
<p>现实中，完全“分块训练”往往利用不充分，越来越多的工作采用<strong>交替式 / 迭代式</strong>训练策略：</p>
<p><strong>（1）BC 与 RL 的交替</strong></p>
<p>常见模式是：</p>
<ul>
<li>先用 BC 训练一个可用的初始策略；</li>
<li>然后在 RL 微调时，每隔若干更新 iteration 插入一段 BC 训练：
<ul>
<li>要么在同一个模型上加一个 BC 损失；</li>
<li>要么维护一个“演示缓存”，用较高权重回放演示数据，防止策略严重偏离人类行为。</li>
</ul>
</li>
</ul>
<p>这类“示教–自我探索–再示教”的循环，在多阶段 manipulation 和层级 RL 方法中已经得到验证。(<a href="https://proceedings.mlr.press/v164/palo22a/palo22a.pdf?utm_source=chatgpt.com">Proceedings of Machine Learning Research</a>)</p>
<p><strong>（2）RL 与自监督的交替</strong></p>
<p>另一种交替是<strong>RL 更新策略，自监督更新表征</strong>：</p>
<ul>
<li>当策略收集到新的交互数据后，不仅用它来做 RL，也将视觉帧加入自监督训练（如新的掩码建模、未来预测）；</li>
<li>自监督更新后的视觉 backbone 再惠及 RL 策略，使其在新的环境配置上仍能提取有效特征。</li>
</ul>
<p>这类“自生成数据 + 自监督表征”的循环，有助于缓解“互联网视频分布与机器人真实分布不一致”的问题。(<a href="https://tonyzhaozh.github.io/data/Video_Pretraining_Distribution_Shift.pdf?utm_source=chatgpt.com">tonyzhaozh.github.io</a>)</p>
<p><strong>（3）在线偏好收集与 RLHF 交替</strong></p>
<p>偏好学习也可以与 RL 交替进行：</p>
<ul>
<li>在策略更新一定轮次后，采样新的轨迹片段，收集新一轮人类偏好标注；</li>
<li>用新数据微调奖励模型，再用更新后的奖励模型对策略进行 RLHF；</li>
<li>反复迭代，使奖励模型和策略一起逐步逼近人类期望。(<a href="https://arxiv.org/html/2507.13171v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<hr>
<h4 id="9343-动态权衡"><a class="header" href="#9343-动态权衡">9.3.4.3 动态权衡</a></h4>
<p>多范式联合训练的核心困难，是如何<strong>动态地平衡各个损失项和训练信号</strong>，避免某一范式“压倒性主导”，导致模型遗忘或偏科。</p>
<p><strong>（1）多目标损失的基本形式</strong></p>
<p>一个典型的联合损失可以写成：</p>
<p>$$
\mathcal{L} =
\lambda_{\text{BC}}\mathcal{L}<em>{\text{BC}} +
\lambda</em>{\text{RL}}\mathcal{L}<em>{\text{RL}} +
\lambda</em>{\text{SSL}}\mathcal{L}<em>{\text{SSL}} +
\lambda</em>{\text{reg}}\mathcal{L}_{\text{reg}} ,
$$</p>
<p>其中：</p>
<ul>
<li>(\mathcal{L}_{\text{BC}})：来自示教数据的行为克隆损失；</li>
<li>(\mathcal{L}_{\text{RL}})：策略梯度 / 值函数相关损失；</li>
<li>(\mathcal{L}_{\text{SSL}})：掩码建模、未来预测、对比学习等自监督损失；</li>
<li>(\mathcal{L}_{\text{reg}})：正则化 / KL 约束等。</li>
</ul>
<p>关键在于如何设置并动态调整这些 (\lambda)。</p>
<p><strong>（2）基于训练阶段的权重调度</strong></p>
<p>最简单的做法是“手工调度”：</p>
<ul>
<li>训练早期：(\lambda_{\text{BC}}) 较大，强调模仿示范，保证基本可行；</li>
<li>中期：逐步增大 (\lambda_{\text{RL}})，鼓励策略在安全范围内探索更优解；</li>
<li>自监督项 (\lambda_{\text{SSL}}) 则保持相对稳定，作为“表征稳定器”；</li>
<li>如果观察到策略出现严重偏离人类演示（例如动作风格明显怪异），可以暂时提升 (\lambda_{\text{BC}}) 或对策略施加更严格的 KL 正则，使其回到演示附近。(<a href="https://openreview.net/pdf/3599c43148b13fd821ac6abe4629c9baf0a97a23.pdf?utm_source=chatgpt.com">OpenReview</a>)</li>
</ul>
<p><strong>（3）基于统计信号的自适应权衡</strong></p>
<p>更高级的做法是让系统<strong>根据训练信号自动调整权重</strong>：</p>
<ul>
<li>使用多任务学习中的“梯度归一化”技巧，根据各损失项的梯度范数动态调整 (\lambda)，防止其中某个损失的梯度过大或过小；</li>
<li>根据验证集性能（例如离线成功率、在线 RL 成功率）做闭环控制：
<ul>
<li>若发现 RL 奖励持续上升而偏好评分下降，则适当增加 BC / 偏好相关损失的权重；</li>
<li>反之，如果 BC 准确率很高但 RL 成功率停滞，则增加 RL 损失权重或探索强度。(<a href="https://www.sciencedirect.com/science/article/abs/pii/S0952197625008668?utm_source=chatgpt.com">科学直通车</a>)</li>
</ul>
</li>
</ul>
<p><strong>（4）“策略先验”视角：BC / 自监督作为正则，而非单独阶段</strong></p>
<p>从更抽象的角度看，BC 和自监督都可以视作对策略施加的“先验”：</p>
<ul>
<li>BC 先验：鼓励策略保持接近人类示范（在策略空间上的 KL 正则或 L2 正则）；</li>
<li>自监督先验：鼓励视觉–语言–动作表征保持对结构 / 物理规律的良好刻画；</li>
<li>RL 则在这些先验下寻找“在任务目标下最优”的后验策略。</li>
</ul>
<p>这样理解，多范式联合训练就不再是“几个阶段拼接”，而是一个统一的贝叶斯视角：先用自监督与 BC 捕获强先验，再用 RL 和人类偏好进行后验更新。未来更通用的具身基础模型，很可能会在一个超长时间尺度上不断循环这个过程 —— 永远一边观察世界、一边接受指令、一边在行动中调整自己。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="数据工程与-mlops"><a href="#数据工程与-mlops" class="header">数据工程与 MLOps</a></h1>
<h3 id="941-数据版本管理与元数据记录"><a class="header" href="#941-数据版本管理与元数据记录">9.4.1 数据版本管理与元数据记录</a></h3>
<p>在前面几节里，我们更多讨论“如何训练一个好模型”。从本节开始，我们关注的是另一半：<strong>如何保证这些训练过程在一年之后还能被别人、甚至是你自己可靠地重现</strong>。对具身智能 / VLA 来说，这意味着要能追踪：某一次机器人“翻车”或表现很强，是用的哪一版数据、哪一版代码、哪一版模型。</p>
<blockquote>
<p>【图 9-A 占位：一个“训练谱系”示意图——从“数据版本”→“预处理流水线”→“训练配置”→“模型版本”的有向图，用箭头连起来，表示可追溯关系】</p>
</blockquote>
<hr>
<h4 id="9411-数据版本"><a class="header" href="#9411-数据版本">9.4.1.1 数据版本</a></h4>
<p>**数据版本（Data Versioning）**的目标，是做到对数据“像对代码那样”进行版本管理：任何一次训练用的是哪一批轨迹、哪一批视频、哪一批语言指令，都可以精确地定位与恢复。(<a href="https://labelyourdata.com/articles/machine-learning/data-versioning?utm_source=chatgpt.com">labelyourdata.com</a>)</p>
<h5 id="1为什么具身智能特别需要数据版本"><a class="header" href="#1为什么具身智能特别需要数据版本">（1）为什么具身智能特别需要数据版本</a></h5>
<p>对于 VLA / 机器人数据，这个需求比传统 CV/NLP 更强，原因包括：</p>
<ul>
<li><strong>数据成本高</strong>：真实机器人收集一条轨迹的成本远高于从互联网抓一张图。删错一批、覆盖一批，等于烧了一堆硬件与人力。</li>
<li><strong>分布变动大</strong>：你会不断增加新场景（不同桌面、不同物体）、新机器人（不同自由度）、新任务，数据分布会明显随时间演化。</li>
<li><strong>安全与合规</strong>：一旦机器人产生危险行为，需要追溯“是哪一版数据教的”，版本可追踪是基本前提。(<a href="https://www.labellerr.com/blog/top-model-versioning-tools-for-your-ml-workflow/?utm_source=chatgpt.com">Labellerr</a>)</li>
</ul>
<h5 id="2版本粒度与命名"><a class="header" href="#2版本粒度与命名">（2）版本粒度与命名</a></h5>
<p>实践中常见的版本粒度包括：</p>
<ul>
<li><strong>数据集级</strong>：例如 <code>openx_kit_real_v1.0</code>、<code>lab_panda_drawer_v2.3</code>，一版对应一次较大的采集 / 清洗周期。</li>
<li><strong>子集级</strong>：按机器人平台、任务、场景划分子版本，例如：
<ul>
<li><code>openx_kit_real_v1.0/panda/pick_place/…</code></li>
<li><code>openx_kit_real_v1.0/franka/drawer_open/…</code></li>
</ul>
</li>
<li><strong>时间切片</strong>：按采集窗口切分，如 <code>2025Q1</code>、<code>2025-10-week2</code>，便于定位问题到某一批采集活动。</li>
</ul>
<p>一个简单而实用的做法是：<strong>为每个可训练的数据集维护“语义化版本号”</strong>（如 SemVer：<code>MAJOR.MINOR.PATCH</code>），并且在任何训练配置里都写明“数据集名称 + 版本号”，而不是模糊的 “latest”。(<a href="https://labelyourdata.com/articles/machine-learning/data-versioning?utm_source=chatgpt.com">labelyourdata.com</a>)</p>
<h5 id="3实现方式从手工到专门工具"><a class="header" href="#3实现方式从手工到专门工具">（3）实现方式：从手工到专门工具</a></h5>
<ol>
<li><strong>最基础的文件夹+README 做法</strong></li>
</ol>
<p>优点是门槛低；缺点是难以自动追踪“文件级别”的变化，也难以和实验管理工具自动打通。</p>
<pre><code>- 每个版本一个独立目录：
    * `data/openx/v1.0/…`
    * `data/openx/v1.1/…`
- 在 `data/README.md` 中记录各版本的：
    * 创建时间
    * 主要差异（新增任务、修复标注、过滤了哪些异常）
    * 对应的采集脚本 / 仿真配置哈希
</code></pre>
<ol start="2">
<li><strong>DVC / lakeFS / Pachyderm 等数据版本工具</strong>这类工具本质上是“Git for data”，会为每次数据变更创建“提交（commit）”，存储在对象存储或分布式文件系统中，并保留可回滚的历史。(<a href="https://labelyourdata.com/articles/machine-learning/data-versioning?utm_source=chatgpt.com">labelyourdata.com</a>)</li>
</ol>
<p>在具身智能项目中，一个常见模式是：</p>
<pre><code>- **DVC**：通过 `.dvc` 文件将数据的哈希写入 Git 仓库本身，数据本体存到 S3 / OSS / NFS 等；优点是与现有 Git 工作流兼容。
- **Pachyderm / lakeFS**：直接把数据湖当成“可提交的仓库”，天然支持数据血缘和审计追踪，非常适合大型 MLOps 平台。
- 原始轨迹（如 ROS bag）和视频存入对象存储；
- 用 DVC / Pachyderm 对“已清洗 + 对齐 + 标注完成的训练子集”做版本管理；
- 在训练代码里，仅通过逻辑名字引用数据版本，例如 `dataset: openx_kit_real@2.1.0`。
</code></pre>
<blockquote>
<p>【图 9-B 占位：对比“文件夹命名式版本管理”与“DVC/Pachyderm 提交式版本管理”的简化示意图】</p>
</blockquote>
<hr>
<h4 id="9412-元数据"><a class="header" href="#9412-元数据">9.4.1.2 元数据</a></h4>
<p><strong>元数据（Metadata）就是“关于数据的数据”</strong>：当你只看一条轨迹的图像与动作时，很难知道它是哪台机器人、在什么场景、执行什么任务、是否成功。元数据承担的就是这个“说明书”的角色。(<a href="https://medium.com/data-science/a-comprehensive-comparison-of-ml-experiment-tracking-tools-9f0192543feb?utm_source=chatgpt.com">Medium</a>)</p>
<p>在具身智能场景中，元数据大致可以分为三层：</p>
<ol>
<li>**数据集层元数据（dataset-level）**描述某一版数据集的全局信息，可以用 YAML/JSON manifest 文件表示，例如 <code>openx_kit_real_v1.2.0/meta.yaml</code>：
<ul>
<li>基本信息：名称、版本号、维护者、发布时间、许可证；</li>
<li>适用机器人：支持的机器人型号列表（如 <code>franka_panda</code>, <code>ur5</code>, <code>aloha</code>）；</li>
<li>任务分布：每种任务的轨迹数量、成功率大致统计；</li>
<li>采集环境：真实/仿真、主要场景类型（桌面、货架、抽屉）、主要光照条件；</li>
<li>预处理信息：是否进行过时间对齐、下采样、坐标变换、归一化等。</li>
</ul>
</li>
<li>**轨迹层元数据（episode-level / trajectory-level）**对于单条轨迹，典型的元数据字段包括：
<ul>
<li><code>trajectory_id</code>：唯一 ID（通常是 UUID）；</li>
<li><code>task_id / task_name</code>：例如 <code>pick_place_block</code>、<code>drawer_open</code>；</li>
<li><code>robot_id</code> 与硬件信息：机械臂型号、末端夹爪类型、固件版本；</li>
<li><code>env_params</code>：仿真时的摩擦系数、物体质量范围，现实中可记录手眼标定版本号；</li>
<li><code>success</code>：任务是否成功，以及失败原因标签（碰撞、抓取失败、超时等）；</li>
<li><code>language_instruction_ids</code>：该轨迹所关联的指令文本 ID，便于多语言指令对齐。</li>
</ul>
</li>
<li>**样本层元数据（step-level）**对于对时间非常敏感的任务，可以在每个 time step 记录：
<ul>
<li>时间戳（与图像帧、力觉、关节状态统一）；</li>
<li>传感器同步状态（是否丢帧、是否插值）；</li>
<li>特殊事件标记（接触发生、抓取闭合、抽屉开启瞬间等）。</li>
</ul>
</li>
</ol>
<p>良好的元数据设计可以显著简化后续的数据筛选、子集构建与可视化分析，也是构建可靠审计追踪的前提。</p>
<hr>
<h4 id="9413-审计追踪"><a class="header" href="#9413-审计追踪">9.4.1.3 审计追踪</a></h4>
<p>**审计追踪（Audit Trail）**的目标是：给定某个模型版本或机器人行为，你能一路“倒推”到：</p>
<blockquote>
<p>哪次实验 → 用了哪份代码 → 哪份配置 → 哪一版数据 → 哪些预处理步骤。</p>
</blockquote>
<p>这在金融、医疗等高监管行业已经是常态，在“会真的撞到人的机器人”上，只会更重要。(<a href="https://verifywise.ai/lexicon/ai-model-audit-trail?utm_source=chatgpt.com">VerifyWise</a>)</p>
<h5 id="1审计追踪需要记录什么"><a class="header" href="#1审计追踪需要记录什么">（1）审计追踪需要记录什么</a></h5>
<p>一个最低限度的“可用审计条目”通常包含：</p>
<ul>
<li><strong>模型信息</strong>：模型名称、版本号、训练时间、模型文件的哈希（如 SHA256）；</li>
<li><strong>代码版本</strong>：Git 仓库 URL + commit hash + 分支 / tag；</li>
<li><strong>数据版本</strong>：数据集逻辑名 + 数据版本号（或 DVC/Pachyderm commit）；(<a href="https://dagshub.com/blog/mastering-version-control-for-ml-models-best-practices-you-need-to-know/?utm_source=chatgpt.com">DagsHub</a>)</li>
<li><strong>训练配置</strong>：完整的超参数配置文件快照；</li>
<li><strong>实验环境</strong>：主机类型、GPU 型号、深度学习框架版本、操作系统等；</li>
<li><strong>责任人</strong>：触发训练的用户、触发方式（手动运行 / CI 作业）；</li>
<li><strong>关键训练指标</strong>：最终验证集指标、训练过程中的异常（NaN / 恶性发散等）。</li>
</ul>
<p>这些信息通常由 <strong>实验追踪工具 + 数据版本工具 + Git</strong> 共同提供，稍后 9.4.2、9.4.3 会展开。</p>
<h5 id="2如何落地可查账的链路"><a class="header" href="#2如何落地可查账的链路">（2）如何落地“可查账”的链路</a></h5>
<p>一个常用的工程实践是：</p>
<ol>
<li><strong>每一次实验 run 都生成一个全局唯一 run_id</strong>（例如 <code>2025-10-20_23-15-42_franka_bc_v3</code> 或直接 UUID）。</li>
<li>在实验追踪系统中，以 <code>run_id</code> 为主键，写入：
<ul>
<li>训练脚本所在的 Git commit；</li>
<li>使用的数据集逻辑名与数据版本号；</li>
<li>完整的配置文件内容（或其哈希）；</li>
<li>模型 checkpoint 的存储路径和哈希。</li>
</ul>
</li>
<li>在部署系统中，同样把 <code>run_id</code> 随模型一起记录下来：
<ul>
<li>部署日志中记录“当前线上版本 <code>model_deploy_id</code> 对应 <code>run_id</code>”；</li>
<li>机器人执行日志中写入“当前使用模型 run_id”。</li>
</ul>
</li>
</ol>
<p>这样，当现实世界中发生任何“异常行为”时，你就可以沿着 <code>run_id → 训练记录 → 数据版本 → 原始轨迹</code> 的路径逐步排查。</p>
<blockquote>
<p>【图 9-C 占位：一个“从机器人行为日志回溯到数据与代码”的审计链路图，展示 run_id 在各系统间贯穿的示意】</p>
</blockquote>
<hr>
<h3 id="942-大规模训练的参数配置与日志记录"><a class="header" href="#942-大规模训练的参数配置与日志记录">9.4.2 大规模训练的参数配置与日志记录</a></h3>
<p>大规模 VLA / 具身模型训练的一个典型特征是：<strong>配置项多到肉眼记不住，日志多到肉眼看不过来</strong>。靠“记住我大概怎么设的学习率”已完全不现实，这一节的目标，是给出一套稳健的“配置 + 日志”体系。</p>
<hr>
<h4 id="9421-超参数配置"><a class="header" href="#9421-超参数配置">9.4.2.1 超参数配置</a></h4>
<p><strong>超参数配置管理</strong>的核心要求只有一句话：<strong>任何一次训练，必须能够被一份“可复用的配置文件 + 某个代码版本”完全描述</strong>。(<a href="https://neptune.ai/blog/best-ml-experiment-tracking-tools?utm_source=chatgpt.com">neptune.ai</a>)</p>
<h5 id="1配置内容的分层"><a class="header" href="#1配置内容的分层">（1）配置内容的分层</a></h5>
<p>建议把配置拆成几个层次（在 YAML / JSON 中体现）：</p>
<ul>
<li><code>data</code>: 数据相关
<ul>
<li>数据集名与版本号</li>
<li>训练/验证/测试划分方式</li>
<li>数据增强参数（随机裁剪、颜色扰动、域随机化范围等）</li>
</ul>
</li>
<li><code>model</code>: 模型结构
<ul>
<li>视觉 backbone 类型（ResNet/ViT）及其预训练权重版本</li>
<li>语言模型选择及其冻结/解冻策略</li>
<li>动作解码器结构（自回归 / 并行、token 词表大小等）</li>
</ul>
</li>
<li><code>train</code>: 训练流程
<ul>
<li>学习率、学习率调度策略</li>
<li>batch size、梯度累积步数</li>
<li>优化器种类（AdamW / LAMB 等）、权重衰减</li>
<li>训练轮数、warmup 步数、梯度裁剪阈值</li>
</ul>
</li>
<li><code>rl</code>: 若包含 RL 微调
<ul>
<li>奖励系数、折扣因子</li>
<li>收集样本的并行环境数</li>
<li>每步更新的采样与更新频率等</li>
</ul>
</li>
<li><code>env</code>: 运行环境
<ul>
<li>GPU 数量、每块卡的 batch</li>
<li>分布式后端（NCCL、Gloo）</li>
<li>混合精度 / 全精度开关</li>
</ul>
</li>
</ul>
<h5 id="2配置系统与工具"><a class="header" href="#2配置系统与工具">（2）配置系统与工具</a></h5>
<p>简单起步可以用 <strong>纯 YAML + argparse/JSON 解析</strong>。在项目复杂之后，可以考虑使用专门的配置管理库，例如 Hydra、Sacred 等，它们支持：</p>
<ul>
<li>多个基础配置的组合（例如 <code>robot=franka</code> + <code>task=drawer_open</code> + <code>backbone=vit</code>）；</li>
<li>命令行覆写单个字段，同时自动记录覆写内容；</li>
<li>为每次 run 自动生成一个“已展开的完整配置快照”。(<a href="https://github.com/awesome-mlops/awesome-ml-experiment-management?utm_source=chatgpt.com">GitHub</a>)</li>
</ul>
<p>这样可以极大降低“忘了某个参数到底是默认值还是手动改过”的风险。</p>
<h5 id="3配置与实验追踪的绑定"><a class="header" href="#3配置与实验追踪的绑定">（3）配置与实验追踪的绑定</a></h5>
<p>最后一条实践经验是：<strong>把“配置文件快照”当作实验日志的一部分</strong>，而不是只写在磁盘上。多数实验管理工具（如 MLflow、Weights &amp; Biases、Neptune 等）都支持将配置作为 JSON/YAML artifact 上传，并可在网页界面中直接浏览和对比不同实验的配置差异。(<a href="https://mlflow.org/classical-ml/experiment-tracking?utm_source=chatgpt.com">mlflow.org</a>)</p>
<hr>
<h4 id="9422-日志系统"><a class="header" href="#9422-日志系统">9.4.2.2 日志系统</a></h4>
<p>日志系统（logging）承担两件事：</p>
<ol>
<li><strong>短期内帮助你 debug 与监控训练</strong>；</li>
<li><strong>长期为你提供可视化对比、审计追踪与论文作图素材</strong>。</li>
</ol>
<h5 id="1记录什么"><a class="header" href="#1记录什么">（1）记录什么</a></h5>
<p>典型需要记录的内容包括：(<a href="https://jfrog.com/learn/mlops/experiment-tracking-tool/?utm_source=chatgpt.com">JFrog</a>)</p>
<ul>
<li><strong>标量指标</strong>：
<ul>
<li>训练 loss、验证 loss；</li>
<li>每个任务的成功率、平均回报；</li>
<li>学习率、梯度范数、参数范数；</li>
</ul>
</li>
<li><strong>直方图 / 分布</strong>：
<ul>
<li>模型权重分布、梯度分布（有助于发现梯度消失/爆炸）；</li>
</ul>
</li>
<li><strong>图像与视频</strong>（具身智能项目非常重要）：
<ul>
<li>训练过程中随机抽取的观察帧、分割结果、注意力热力图；</li>
<li>每若干 steps 的 rollout 视频，展示机器人在仿真 / 现实中的行为；</li>
</ul>
</li>
<li><strong>文本日志</strong>：
<ul>
<li>关键阶段的摘要（比如“第 1000 步成功率首次超过 80%”）；</li>
<li>异常信息（Loss 爆炸、NaN、训练重启等）；</li>
</ul>
</li>
<li><strong>系统指标</strong>：
<ul>
<li>GPU 利用率、显存占用、CPU/内存压力，方便判断是否受限于 I/O 或算力瓶颈。</li>
</ul>
</li>
</ul>
<h5 id="2工具选择"><a class="header" href="#2工具选择">（2）工具选择</a></h5>
<p>在工程实践中，常见的组合是：</p>
<ul>
<li><strong>基础日志</strong>：用 <code>logging</code> 模块写入本地文件（如 <code>train.log</code>），用于快速 grep 与排错；</li>
<li><strong>可视化日志</strong>：使用 TensorBoard、MLflow、Weights &amp; Biases、Comet 等工具记录标量、图像和模型参数，支持在网页中对比多次实验的曲线；(<a href="https://mlflow.org/classical-ml/experiment-tracking?utm_source=chatgpt.com">mlflow.org</a>)</li>
<li><strong>基础设施监控</strong>：对于大型集群训练，引入 Prometheus + Grafana 等监控 GPU/节点状态，避免训练“悄悄挂掉”。</li>
</ul>
<h5 id="3日志频率与成本控制"><a class="header" href="#3日志频率与成本控制">（3）日志频率与成本控制</a></h5>
<ul>
<li>标量指标（loss、成功率）可以每几步记录一次；</li>
<li>高成本对象（视频、整张图像）的记录频率要谨慎，一般每 N 个 step 或每轮训练只记录少量样本；</li>
<li>日志文件要限制大小并定期归档或上传到对象存储，避免占满磁盘导致训练中断。</li>
</ul>
<blockquote>
<p>【图 9-D 占位：一个典型训练日志仪表盘截图示意——上方是 loss/成功率曲线，下方是若干机器人 rollout 视频缩略图】</p>
</blockquote>
<hr>
<h4 id="9423-模型检查点"><a class="header" href="#9423-模型检查点">9.4.2.3 模型检查点</a></h4>
<p>**模型检查点（checkpoint）**是大规模训练的“存档点”：既是故障恢复的安全带，也是模型选择的样本库。(<a href="https://mlflow.org/classical-ml/experiment-tracking?utm_source=chatgpt.com">mlflow.org</a>)</p>
<h5 id="1检查点内容"><a class="header" href="#1检查点内容">（1）检查点内容</a></h5>
<p>一个“完整”的 checkpoint 通常包含：</p>
<ul>
<li>模型参数（<code>state_dict</code>）；</li>
<li>优化器状态（包括动量、二阶矩估计等）；</li>
<li>学习率调度器状态（当前步数、当前学习率）；</li>
<li>训练进度（当前 epoch / step）；</li>
<li>重要随机数生成器状态（PyTorch、NumPy、Python <code>random</code> 等）；</li>
<li>若为 RL 训练，还可包括 replay buffer 片段、归一化参数等。</li>
</ul>
<p>这样，在断电或 Crash 后，可以尽可能“无损地”恢复训练。</p>
<h5 id="2命名与保留策略"><a class="header" href="#2命名与保留策略">（2）命名与保留策略</a></h5>
<ul>
<li>建议使用包含 <strong>run_id + step/epoch + 关键指标</strong> 的命名方式，例如：
<code>ckpt_run1234_step200k_valSucc0.81.pt</code></li>
<li>一般会保留：
<ul>
<li>最新 checkpoint（便于继续训练）；</li>
<li>若干个基于验证指标排序的“最优 checkpoint”（比如前 3 名）；</li>
<li>若干“里程碑 checkpoint”（例如每 100k steps 一份，用于分析训练过程）。</li>
</ul>
</li>
</ul>
<p>对于大模型，checkpoint 本身可能非常大（数十 GB），这就需要：</p>
<ul>
<li>使用压缩格式（如 fp16 权重、分 shard 存储）；</li>
<li>使用云端 / 对象存储，并在实验日志中记录其路径和哈希，以便后续校验完整性。</li>
</ul>
<blockquote>
<p>【图 9-E 占位：时间轴上按训练 step 排列的一系列 checkpoint 图标，其中部分被标记为“best”/“latest”/“milestone”】</p>
</blockquote>
<hr>
<h3 id="943-实验管理工具配置对比实验可视化"><a class="header" href="#943-实验管理工具配置对比实验可视化">9.4.3 实验管理工具（配置、对比实验、可视化）</a></h3>
<p>如果说 9.4.2 讲的是“你在代码里手动 log 的东西”，那么本节的重点是：<strong>把这些日志、配置、结果，用一套统一的实验管理工具“捆绑成一个故事”</strong>。这样，无论是自己复盘，还是给别人解释，都能“点开一个实验就看到全貌”。(<a href="https://jfrog.com/learn/mlops/experiment-tracking-tool/?utm_source=chatgpt.com">JFrog</a>)</p>
<hr>
<h4 id="9431-配置管理"><a class="header" href="#9431-配置管理">9.4.3.1 配置管理</a></h4>
<p>配置管理在这里的含义略有扩大：不仅是本地的 YAML 文件，还包括与实验追踪工具的联动。</p>
<h5 id="1单一信息源single-source-of-truth"><a class="header" href="#1单一信息源single-source-of-truth">（1）单一信息源（Single Source of Truth）</a></h5>
<p>建议建立“单一信息源”的理念：</p>
<ul>
<li><strong>所有实验都必须由配置文件驱动</strong>（即便是简单实验，最好也有一个最小配置）；</li>
<li>所有配置变化，要么通过修改配置文件 + Git 提交，要么通过命令行覆写并在实验追踪工具中自动记录；</li>
<li>禁止将关键超参数硬编码在训练脚本中（magic numbers）。</li>
</ul>
<h5 id="2与实验追踪工具结合"><a class="header" href="#2与实验追踪工具结合">（2）与实验追踪工具结合</a></h5>
<p>以 Sacred、MLflow、Weights &amp; Biases 等为例，常见做法是：</p>
<ul>
<li>在 <code>main()</code> 函数入口处初始化实验追踪器；</li>
<li>将配置对象完整地 <code>log</code> 进去；</li>
<li>让工具自动为本次 run 建立目录 / 面板，后续的所有日志、checkpoint 路径都挂在这个 run 名下。(<a href="https://mlflow.org/classical-ml/experiment-tracking?utm_source=chatgpt.com">mlflow.org</a>)</li>
</ul>
<p>这样，当你浏览某个 run 时，可以随时查看其完整配置并与其他 run 做逐字段对比。</p>
<hr>
<h4 id="9432-对比实验"><a class="header" href="#9432-对比实验">9.4.3.2 对比实验</a></h4>
<p>**对比实验（experiment comparison）**是整套体系的核心产出之一：你不是单独看一条曲线，而是同时比较“不同设计决策”对训练与最终性能的影响。</p>
<h5 id="1变量控制与标签体系"><a class="header" href="#1变量控制与标签体系">（1）变量控制与标签体系</a></h5>
<p>要做可解释的对比实验，必须做到：</p>
<ul>
<li>每次 run 只改变少数几个超参数（如 backbone 从 ResNet50 换成 ViT-B）；</li>
<li>为 run 打上清晰的标签（如 <code>robot=franka</code>, <code>task=drawer</code>, <code>algo=BC</code>, <code>backbone=ViT</code>），方便后续在 UI 中筛选子集对比。</li>
</ul>
<p>多数实验管理工具都原生支持为 run 添加 key–value 形式的标签，并提供基于标签的筛选与分组统计。(<a href="https://neptune.ai/blog/best-ml-experiment-tracking-tools?utm_source=chatgpt.com">neptune.ai</a>)</p>
<h5 id="2典型对比维度以-vla-为例"><a class="header" href="#2典型对比维度以-vla-为例">（2）典型对比维度（以 VLA 为例）</a></h5>
<ul>
<li><strong>架构对比</strong>：纯视觉→视觉+语言→完整 VLA 模型，观察各自对多任务成功率的提升；</li>
<li><strong>预训练策略对比</strong>：无预训练 vs 纯视觉预训练 vs 视觉-语言对比学习预训练；</li>
<li><strong>训练范式对比</strong>：纯 BC vs BC+RL 微调 vs BC+自监督预训练+RL；</li>
<li><strong>数据版本对比</strong>：<code>dataset_v1.0</code> vs <code>dataset_v1.1</code>（加入 domain randomization 或新增场景）对泛化性能的影响。</li>
</ul>
<p>对比实验的结果，既是论文中消融实验（ablation study）的来源，也是工程决策（上线哪个模型版本）的依据。</p>
<hr>
<h4 id="9433-可视化"><a class="header" href="#9433-可视化">9.4.3.3 可视化</a></h4>
<p>在具身智能项目中，“看曲线”只是可视化的一部分，**“看机器人行为”**同样重要。</p>
<h5 id="1训练过程可视化"><a class="header" href="#1训练过程可视化">（1）训练过程可视化</a></h5>
<p>常规的训练曲线包括：</p>
<ul>
<li>全任务平均成功率 vs 训练步数；</li>
<li>按任务拆分的成功率曲线（看是否某些任务明显学得更慢）；</li>
<li>Loss、梯度范数随时间变化；</li>
</ul>
<p>实验管理工具（如 MLflow、W&amp;B、TensorBoard 等）都提供实时曲线绘制与导出功能。(<a href="https://mlflow.org/classical-ml/experiment-tracking?utm_source=chatgpt.com">mlflow.org</a>)</p>
<h5 id="2具身任务特有的可视化"><a class="header" href="#2具身任务特有的可视化">（2）具身任务特有的可视化</a></h5>
<ul>
<li><strong>rollout 视频墙</strong>：将不同模型版本在相同任务上的执行视频，拼成网格对比。可以直观看出模型是否学会了更“柔和”的操作、更稳健的路径。</li>
<li><strong>注意力热力图</strong>：对于 Transformer 类模型，可视化语言 token 对视觉 patch 的注意力，观察模型是否“看到了”正确的区域（比如“红色杯子”）。</li>
<li><strong>状态分布可视化</strong>：对于大量轨迹，可以用 PCA / t-SNE 对高维状态表示降维，绘制散点图，直观展示数据覆盖哪些状态区域。</li>
</ul>
<blockquote>
<p>【图 9-F 占位：一页“实验管理 dashboard”示意图，上方为按任务分组的成功率曲线，下方为不同模型版本在同一任务上的视频缩略图对比】</p>
</blockquote>
<hr>
<h3 id="944-可复现性与代码结构规范"><a class="header" href="#944-可复现性与代码结构规范">9.4.4 可复现性与代码结构规范</a></h3>
<p>**可复现性（Reproducibility）**是现代机器学习、尤其是具身智能研究的“硬门槛”：如果你自己在不同时间、不同机器上都复现不了结果，那无论模型多 fancy，都很难说服别人相信。(<a href="https://docs.pytorch.org/docs/stable/notes/randomness.html?utm_source=chatgpt.com">docs.pytorch.org</a>)</p>
<p>本节从三个层面保障复现：随机性控制、代码版本控制、项目结构规范。</p>
<hr>
<h4 id="9441-随机种子控制"><a class="header" href="#9441-随机种子控制">9.4.4.1 随机种子控制</a></h4>
<p>深度学习中的“不确定性”来源很多，包括：</p>
<ul>
<li>参数初始化；</li>
<li>数据打乱 / 数据增强；</li>
<li>mini-batch 分配；</li>
<li>GPU 并行的非确定性算子；</li>
<li>仿真环境中的随机扰动（域随机化）。</li>
</ul>
<p>完全做到“比特级稳定”在某些平台上并不现实，但可以做到<strong>主导因素可控</strong>。(<a href="https://docs.pytorch.org/docs/stable/notes/randomness.html?utm_source=chatgpt.com">docs.pytorch.org</a>)</p>
<h5 id="1基础做法统一设定随机种子"><a class="header" href="#1基础做法统一设定随机种子">（1）基础做法：统一设定随机种子</a></h5>
<p>以 PyTorch 为例，典型的“set_seed” 函数会：</p>
<ul>
<li>设置 Python <code>random</code> 的种子；</li>
<li>设置 NumPy 的随机种子；</li>
<li>设置 PyTorch CPU/GPU 的随机种子；</li>
<li>配置 DataLoader 的 <code>worker_init_fn</code> 和 <code>generator</code>，确保数据加载进程也使用可控种子；</li>
<li>配置 cuDNN 的 deterministic / benchmark 选项，避免非确定性算子（以牺牲一些性能为代价）。</li>
</ul>
<blockquote>
<p>注意：PyTorch 官方文档明确指出，<strong>即便这样做也不能保证百分百确定性</strong>，尤其是在使用某些特定 GPU 算子或多机多卡训练时。你需要根据具体框架版本与硬件情况阅读最新的 reproducibility 指南。(<a href="https://docs.pytorch.org/docs/stable/notes/randomness.html?utm_source=chatgpt.com">docs.pytorch.org</a>)</p>
</blockquote>
<h5 id="2仿真与域随机化的种子"><a class="header" href="#2仿真与域随机化的种子">（2）仿真与域随机化的种子</a></h5>
<p>在具身智能场景中，还有一层：<strong>仿真环境的随机数</strong>。例如：</p>
<ul>
<li>把物体初始位置、摩擦系数、光照等做域随机化；</li>
<li>将传感器噪声随机化。</li>
</ul>
<p>这里的建议是：</p>
<ul>
<li>在训练时，保存每次 roll-out 所用的“环境随机种子”或“随机参数向量”，以便复现同一条轨迹；</li>
<li>在分析某一失败案例时，可以用相同环境种子、相同 policy 与相同初始状态复现问题。</li>
</ul>
<hr>
<h4 id="9442-代码版本控制"><a class="header" href="#9442-代码版本控制">9.4.4.2 代码版本控制</a></h4>
<p>代码版本控制的“默认选项”就是 Git，这里不再赘述用法，而是强调 <strong>与实验、数据、模型的联动</strong>。(<a href="https://dagshub.com/blog/mastering-version-control-for-ml-models-best-practices-you-need-to-know/?utm_source=chatgpt.com">DagsHub</a>)</p>
<h5 id="1每个实验必须绑定一个-git-commit"><a class="header" href="#1每个实验必须绑定一个-git-commit">（1）每个实验必须绑定一个 Git commit</a></h5>
<ul>
<li>要求所有训练都在“干净的工作区”上运行（<code>git status</code> 无修改），否则很难知道实际运行的代码究竟是什么；</li>
<li>在运行训练脚本时自动记录当前的 commit hash、分支与 tag；</li>
<li>建议在针对论文或重要结果时，为对应 commit 打上 tag，例如 <code>paper_icra25_v1</code>。</li>
</ul>
<h5 id="2git--数据--模型版本工具"><a class="header" href="#2git--数据--模型版本工具">（2）Git + 数据 / 模型版本工具</a></h5>
<p>对于大文件（数据与模型权重），有几种常见组合方式：</p>
<ul>
<li>代码在 Git 中管理，数据用 DVC / Pachyderm 等工具版本化，并在 Git 中记录数据指针；(<a href="https://medium.com/%40aryanjadon/analysis-of-data-versioning-tools-for-machine-learning-operations-1cb27146ce49?utm_source=chatgpt.com">Medium</a>)</li>
<li>模型参数可以：
<ul>
<li>存在对象存储，比如 S3 <code>s3://lab-models/vla/openx/v1/run1234.pt</code>；</li>
<li>使用模型版本工具（如 MLflow Model Registry）维护“当前生产版本”和历史版本映射。</li>
</ul>
</li>
</ul>
<p>实验追踪工具一般会同时记录“Git commit + 数据版本 ID + 模型 artifact 路径”，形成完整链路。(<a href="https://mlflow.org/classical-ml/experiment-tracking?utm_source=chatgpt.com">mlflow.org</a>)</p>
<hr>
<h4 id="9443-项目结构规范"><a class="header" href="#9443-项目结构规范">9.4.4.3 项目结构规范</a></h4>
<p>最后一块，是<strong>让整个项目看起来“不像一堆随手写的脚本”</strong>。一个良好的项目结构能显著降低新成员上手成本，也让你在一年后回来看代码时不至于完全迷路。(<a href="https://dev.to/luxdevhq/generic-folder-structure-for-your-machine-learning-projects-4coe?utm_source=chatgpt.com">DEV Community</a>)</p>
<h5 id="1典型目录结构"><a class="header" href="#1典型目录结构">（1）典型目录结构</a></h5>
<p>以一个中大型 VLA / 机器人项目为例，可以采用类似结构：</p>
<pre><code class="language-latex">project_root/
  configs/          # 所有 YAML/JSON 配置（模型、数据、训练、部署等）
  src/
    data/           # 数据加载与预处理（含 ROS bag/视频解析等）
    models/         # 模型定义（编码器、解码器、VLA 主体架构）
    training/       # 训练循环、loss 计算、分布式封装
    eval/           # 评估脚本与指标实现
    deployment/     # 在线推理、与 ROS/机器人接口的封装
    utils/          # 通用工具函数（日志、seed、配置解析等）
  scripts/
    train_vla.py    # 训练入口脚本
    eval_vla.py     # 离线评估脚本
    collect_data.py # 数据采集或仿真数据生成脚本
  notebooks/
    exploration/    # 数据探索、可视化用 notebook
    reports/        # 生成图表与论文结果的 notebook
  data/
    raw/            # 原始数据（通常不直接进 Git，可由 DVC 管理）
    processed/      # 预处理后用于训练的数据
  experiments/      # 本地运行产生的日志、checkpoint（线上可迁移到远程存储）
  tests/            # 单元测试与简单集成测试
  docs/             # 使用说明、API 文档、设计文档
  requirements.txt / environment.yml / pyproject.toml
  README.md
</code></pre>
<p>在机器人项目里，还会额外有：</p>
<ul>
<li><code>robot/</code>：URDF/XACRO、机械臂/夹爪参数；</li>
<li><code>simulation/</code>：仿真环境配置、场景模型、任务脚本；</li>
<li><code>ros_ws/</code>：若使用 ROS/ROS2，对应的工作空间与包结构。</li>
</ul>
<h5 id="2环境与依赖管理"><a class="header" href="#2环境与依赖管理">（2）环境与依赖管理</a></h5>
<p>要实现可复现性，<strong>仅仅有源代码远远不够</strong>，你还需要描述清楚：</p>
<ul>
<li>Python 依赖版本（<code>requirements.txt</code> 或 <code>poetry/conda</code> 环境）；</li>
<li>C/C++/系统依赖（某些仿真库或驱动版本）；</li>
<li>CUDA / cuDNN / GPU 驱动版本。</li>
</ul>
<p>一个常见做法是使用 Docker / 容器来封装环境：为每个主要版本的系统构建一个基础镜像（如 <code>vla-base:cuda12.2-py310</code>），在镜像中固定所有依赖版本，再在容器内运行训练与评估脚本。(<a href="https://hackmd.io/%40Ingonyama/reproducible-ai?utm_source=chatgpt.com">hackmd.io</a>)</p>
<hr>
<p>本节从数据、配置、日志、代码和项目结构五个维度，搭建了一套“<strong>能查、能复现、能对比</strong>”的工程框架。后续第 10 章在讨论部署与评测时，会在此基础上进一步要求：不仅训练过程可复现，<strong>线上行为与线下实验之间的差异也要尽量可解释和可控</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="模型集成与系统架构"><a href="#模型集成与系统架构" class="header">模型集成与系统架构</a></h1>
<h3 id="1011-高层策略vla与低层控制器之间的接口"><a class="header" href="#1011-高层策略vla与低层控制器之间的接口">10.1.1 高层策略（VLA）与低层控制器之间的接口</a></h3>
<p>这一小节的核心问题是：<strong>“大脑”（VLA 模型）怎么跟“肌肉”（伺服控制器、电机驱动）说话？</strong>
如果接口设计不好，要么 VLA 决策很聪明但落不了地，要么控制很稳定但能力被严重浪费。</p>
<p>在本书前面，第 6 章已经介绍过机器人运动学和控制基础，这里默认读者已经理解关节空间 / 笛卡尔空间、位置 / 速度 / 力矩控制等概念，本节重点放在<strong>系统层面的“约定与协作”</strong>。</p>
<h4 id="10111-接口定义"><a class="header" href="#10111-接口定义">10.1.1.1 接口定义</a></h4>
<p>从工程角度看，“接口”就是一份<strong>清晰的契约</strong>，约定：</p>
<ul>
<li>VLA 输出什么格式的命令；</li>
<li>低层控制器接受什么、如何解释；</li>
<li>双方在坐标系、单位、频率、约束上的共同假设。</li>
</ul>
<p>可以把接口分成几类维度来理解。</p>
<p><strong>（1）命令空间：控制“什么”</strong></p>
<p>典型选择包括：</p>
<ul>
<li><strong>关节空间命令</strong>
<ul>
<li>目标关节位置：<code>q_target</code>（位置模式）</li>
<li>关节速度：<code>dq_target</code>（速度模式）</li>
<li>关节力矩 / 电流：<code>τ_target</code>（力矩模式）</li>
</ul>
</li>
<li><strong>末端空间命令</strong>
<ul>
<li>绝对位姿：<code>T_target</code>（齐次变换或 position + orientation）</li>
<li>增量位姿：<code>ΔT</code>（Delta Pose）</li>
<li>末端速度 / 扭矩：<code>twist_target</code>（线速度 + 角速度）</li>
</ul>
</li>
</ul>
<p>在 VLA 场景中，<strong>最常见的是“增量式”命令</strong>（Δ pose / Δ joint）和<strong>末端速度命令</strong>：
高层每一帧给出“往桌子中心再移动一点”“手爪再向下 1 cm”，低层控制在高频率下把这些增量平滑跟踪。</p>
<p><strong>（2）坐标系与单位：防止“说的不是一个世界”</strong></p>
<p>接口必须明确：</p>
<ul>
<li>坐标系：
<ul>
<li>世界坐标系（map / world）</li>
<li>机器人基座坐标系（base）</li>
<li>工具坐标系（TCP / end-effector）</li>
</ul>
</li>
<li>单位：
<ul>
<li>位置（m / mm）、角度（rad / degree）、速度（m/s、rad/s）、力矩（N·m）</li>
</ul>
</li>
<li>方向约定：
<ul>
<li>右手坐标系，旋转正方向的定义等</li>
</ul>
</li>
</ul>
<p><strong>实际工程中，许多“莫名其妙”的事故（机械臂猛然乱动）都来自单位或坐标系搞错。</strong>
因此接口规范里通常会明确列出：</p>
<blockquote>
<p>“所有角度使用弧度制；位置在 base 坐标系下，以米为单位；姿态采用四元数 (w, x, y, z) 表示。”</p>
</blockquote>
<p><strong>（3）命令约束与安全边界</strong></p>
<p>接口还要规定 VLA <strong>绝对不能越界的范围</strong>：</p>
<ul>
<li>最大关节速度 / 加速度 / 力矩</li>
<li>允许的工作空间（例如机械臂末端在某个立方体范围内）</li>
<li>力 / 速度安全阈值（用于人机协作）</li>
</ul>
<p>低层控制器通常在 500 Hz–1 kHz 的频率下运行闭环控制，这样可以对约束做非常快的监控与裁剪。(<a href="https://robotics.stackexchange.com/questions/38056/why-control-at-1-khz?utm_source=chatgpt.com">Robotics Stack Exchange</a>)
VLA 在接口层面不必实现全部安全逻辑，但必须<strong>承认</strong>这些约束，接受低层“削减命令”的权利。</p>
<p><strong>（4）接口形式：消息结构与调用方式</strong></p>
<p>在 ROS/ROS2 等系统中，接口往往体现为：</p>
<ul>
<li>一条“动作命令”话题（Topic）或 Action：
<ul>
<li>消息中包含：时间戳、机器人 ID、目标位姿 / 增量、手爪开合状态等；</li>
</ul>
</li>
<li>一条“状态反馈”话题（见 10.1.1.3）；</li>
<li>可选服务 / Action：执行复杂技能（如“抓取”原语）。</li>
</ul>
<p>此处不再重复第 6.4 章中对 ROS 节点 / 话题的概念，而更强调：<strong>VLA 作为一个“高层节点”，只要完全遵守这份契约，就可以在不同机器人上复用。</strong></p>
<p>【图 10-1 占位：
“VLA–控制器接口契约示意图”。
左侧是 VLA 模型（输入视觉与语言），输出一个结构化动作消息；右侧是控制器堆栈（轨迹生成器 + 伺服 + 驱动），中间用一条“动作命令”消息通道连接，并在旁边标注坐标系、单位、约束等。】</p>
<h4 id="10112-时序协调"><a class="header" href="#10112-时序协调">10.1.1.2 时序协调</a></h4>
<p>高层策略与低层控制最大的不一致在于<strong>时间尺度</strong>：</p>
<ul>
<li>低层伺服：
<ul>
<li>控制周期典型为 0.5–1 ms（1–2 kHz），对控制稳定性和安全性负责。(<a href="https://robotics.stackexchange.com/questions/38056/why-control-at-1-khz?utm_source=chatgpt.com">Robotics Stack Exchange</a>)</li>
</ul>
</li>
<li>运动规划 / MPC：
<ul>
<li>运行频率常在 10–100 Hz 之间，受限于规划 / 优化计算开销。(<a href="https://www.tandfonline.com/doi/full/10.1080/01691864.2023.2168134?utm_source=chatgpt.com">Taylor &amp; Francis Online</a>)</li>
</ul>
</li>
<li>VLA 决策：
<ul>
<li>受限于深度模型推理，在边缘 GPU 上通常 5–20 Hz（50–200 ms 一次前向），复杂模型在 CPU 或云端可能更低。</li>
</ul>
</li>
</ul>
<p>因此，接口必须解决两个问题：</p>
<ol>
<li><strong>命令插值与保持（hold）</strong>
<ul>
<li>VLA 每隔 100 ms 输出一条“末端速度 / 增量位姿”；</li>
<li>中间 99 个伺服周期怎么办？</li>
<li>常见做法：
<ul>
<li>低层控制器对高层给出的目标轨迹做<strong>时间插值</strong>，生成更高频率的中间参考点；</li>
<li>如果高层暂时没更新，就保持上一条命令（zero-order hold），但要设定<strong>超时机制</strong>，超时后自动减速或停车。</li>
</ul>
</li>
</ul>
</li>
<li><strong>异步与实时性</strong>
<ul>
<li>VLA 通常运行在非实时操作系统或 GPU 上，推理时间存在抖动；</li>
<li>低层控制必须在硬实时线程中运行，以保证周期固定。(<a href="https://discourse.openrobotics.org/t/question-regarding-ros2-control-design/38751?utm_source=chatgpt.com">Open Robotics Discourse</a>)</li>
<li>典型工程做法：
<ul>
<li>使用<strong>共享内存或无锁环形缓冲区</strong>传递 VLA 输出；</li>
<li>低层在每个伺服周期读取“最新一条合法命令”，避免受上层抖动影响；</li>
<li>VLA 线程则尽可能在软实时约束下完成前向推理。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>一个简单的<strong>时间线心智模型</strong>：</p>
<ul>
<li>t = 0 ms：相机采集图像，关节状态打上时间戳；</li>
<li>t = 5–10 ms：预处理完成，送入 VLA；</li>
<li>t = 15–80 ms：VLA 推理完成，写入共享缓冲；</li>
<li>t = 80–100+ ms：低层控制周期读取该命令，插值并输出力矩；</li>
<li>下一帧图像再开始新一轮推理。</li>
</ul>
<p>接口定义中往往会明确<strong>两个参数</strong>：</p>
<ul>
<li>高层决策周期 <code>T_policy</code>（如 100 ms）；</li>
<li>低层控制周期 <code>T_control</code>（如 1 ms）；</li>
</ul>
<p><strong>设计目标：在 <strong><code>T_policy</code></strong> 这一时间尺度上，系统仍然“像一个闭环控制系统”那样稳定。</strong></p>
<h4 id="10113-状态反馈"><a class="header" href="#10113-状态反馈">10.1.1.3 状态反馈</a></h4>
<p>高层策略要实现闭环，必须获得足够的<strong>状态反馈</strong>。
但不需要把所有传感器原始数据都推给 VLA，否则带宽和推理负担都无法承受。</p>
<p>可以按“层级”来组织状态反馈：</p>
<p><strong>（1）底层反馈：供控制与安全使用</strong></p>
<ul>
<li>关节级：<code>q, dq, τ</code></li>
<li>末端位姿：<code>T_ee</code></li>
<li>触觉 / 力觉：末端力 / 力矩</li>
<li>安全信号：急停状态、碰撞触发标志</li>
</ul>
<p>这类反馈在 100–1000 Hz 下被低层控制器使用，VLA 一般只看到被<strong>下采样</strong>或<strong>摘要化</strong>后的结果，例如每 100 ms 读取一次当前关节角和末端位姿。</p>
<p><strong>（2）高层反馈：供策略与语义决策使用</strong></p>
<ul>
<li>场景级：当前图像 / 语义分割 / 物体检测结果；</li>
<li>任务级：
<ul>
<li>当前是否已抓住目标物体；</li>
<li>当前子任务完成度（例如“已清理 4/5 个碗”）；</li>
</ul>
</li>
<li>机器人内部状态：
<ul>
<li>当前执行的子技能名称（grasp / move / place）；</li>
<li>VLA 上一次输出动作的执行结果（成功 / 被裁剪 / 因碰撞中止等）。</li>
</ul>
</li>
</ul>
<p>从接口的角度，常见设计是：</p>
<ul>
<li>输出接口：<code>ActionCommand</code>（高层 → 低层）；</li>
<li>输入接口：<code>Observation</code>（低层 + 感知 → 高层）；</li>
<li>二者保持结构上的<strong>对称性</strong>：
<ul>
<li>Observation 中也包含与 VLA 动作空间相同的坐标系与单位。</li>
</ul>
</li>
</ul>
<p>在实现中，Observation 通常会统一打包为 VLA 模型的输入张量（如 stacked images + 状态向量），细节在第 8 章架构部分已经展开；本节更强调一点：<strong>Observation 不是“随便往里堆数据”，而是由接口契约约束的、与动作空间配套的反馈。</strong></p>
<p>【图 10-2 占位：
“闭环接口与状态反馈示意图”。
画出 VLA、低层控制器、机器人本体三个模块，VLA → Controller 为 ActionCommand 箭头，Controller + Robot 回到 VLA 为 Observation 箭头，其中 Observation 分为“高频硬件反馈”与“低频抽象反馈”两层。】</p>
<hr>
<h3 id="1012-在线推理框架从传感器到动作命令的数据流"><a class="header" href="#1012-在线推理框架从传感器到动作命令的数据流">10.1.2 在线推理框架：从传感器到动作命令的数据流</a></h3>
<p>这一节从“流水线”的角度看 VLA 部署：
<strong>一帧图像从相机出来，到机器人真的动起来，中间到底发生了什么？</strong></p>
<p>我们可以把整个在线推理过程拆成三段：</p>
<ol>
<li>感知输入管道；</li>
<li>模型推理；</li>
<li>执行输出与闭环。</li>
</ol>
<h4 id="10121-感知输入管道"><a class="header" href="#10121-感知输入管道">10.1.2.1 感知输入管道</a></h4>
<p>感知输入管道是从<strong>物理世界 → 数字表示</strong>的过程，目标是为 VLA 提供<strong>时间对齐、格式统一、噪声可控</strong>的观测。</p>
<p><strong>（1）数据采集与时间戳</strong></p>
<ul>
<li>摄像头：RGB / RGB-D 图像，分辨率与帧率根据任务选择（如 640×480 @ 30 FPS）；</li>
<li>机器人状态：关节角、末端位姿、手爪状态等；</li>
<li>其他传感器：力矩传感器、激光雷达等（若参与决策）。</li>
</ul>
<p>关键是：<strong>所有数据必须带有时间戳</strong>，以便在后端进行对齐。
在 ROS2 等中间件里，这通常通过统一时钟（/use_sim_time / 系统时钟）实现。(<a href="https://discourse.openrobotics.org/t/question-regarding-ros2-control-design/38751?utm_source=chatgpt.com">Open Robotics Discourse</a>)</p>
<p><strong>（2）预处理与同步</strong></p>
<p>预处理常见步骤：</p>
<ul>
<li>几何校正：去畸变、裁剪无用区域；</li>
<li>尺度调整：缩放到模型接受的分辨率（如 224×224）；</li>
<li>归一化：减均值 / 除方差、通道换序 (HWC → CHW)；</li>
<li>传感器融合：如相机 + 深度图对齐，拼到同一坐标系中。</li>
</ul>
<p>时间同步通常有两种方式：</p>
<ul>
<li><strong>硬同步</strong>：硬件触发多个传感器同时采样；</li>
<li><strong>软同步</strong>：在软件层根据时间戳在附近时间窗口内找“最近帧匹配”。</li>
</ul>
<p>对于 VLA 来说，最关键的不是毫秒级同步，而是<strong>语义上的一致</strong>：
同一 Observation 中的图像与状态，应对应同一物理时刻，这样 VLA 才能把语言目标、视觉场景和机器人的身体状态联系起来。</p>
<p><strong>（3）数据裁剪与带宽控制</strong></p>
<p>在第 7 章我们讨论了数据采集与存储，这里强调在线推理时，还要考虑：</p>
<ul>
<li>不必把<strong>全分辨率图像</strong>送入模型，可以先做 ROI 裁剪（例如只截取桌面区域）；</li>
<li>对于云端推理场景，可以在本地做部分编码（JPEG、H.264）或特征提取，再上传；</li>
<li>通过合理压缩减少网络带宽占用。(<a href="https://rocketmeup.medium.com/edge-computing-reducing-latency-in-future-ai-systems-679ed3b8910a?utm_source=chatgpt.com">Medium</a>)</li>
</ul>
<p>【图 10-3 占位：
“感知输入管道数据流示意图”。
从左到右：Camera / Joint States / Force Sensor → 时间戳标注 → 预处理模块（校正、缩放、裁剪）→ 构造 Observation 张量 → 输入到 VLA。】</p>
<h4 id="10122-模型推理"><a class="header" href="#10122-模型推理">10.1.2.2 模型推理</a></h4>
<p>这一部分是 VLA 的“前向过程”，但在部署场景下，需要额外关注<strong>资源、时间预算和并发</strong>。</p>
<p><strong>（1）推理拓扑</strong></p>
<p>常见设计是：</p>
<ul>
<li>一个<strong>前端进程</strong>负责接收感知数据、构造模型输入；</li>
<li>一个<strong>推理进程 / 线程</strong>负责加载模型权重，在 GPU / NPU 上执行前向；</li>
<li>中间用队列或共享内存传递 batch。</li>
</ul>
<p>为了降低延迟，在线 VLA 推理一般采用：</p>
<ul>
<li>batch size = 1（单样本推理），减少排队等待；</li>
<li>固定图像分辨率与张量尺寸，避免频繁重新分配内存。(<a href="https://arxiv.org/abs/2209.11880?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p><strong>（2）时间预算与监控</strong></p>
<p>在线控制场景中，每一步决策都有严格的<strong>时间上限</strong>，例如：</p>
<ul>
<li>规划 / MPC：50 Hz，即 20 ms 内必须完成一次优化；(<a href="https://www.tandfonline.com/doi/full/10.1080/01691864.2023.2168134?utm_source=chatgpt.com">Taylor &amp; Francis Online</a>)</li>
<li>VLA 决策：假设设定为 10 Hz（100 ms 一次），则必须保证**“图像进来 → 动作输出”**整体在 100 ms 内完成，并留出裕度。</li>
</ul>
<p>工程上通常会：</p>
<ul>
<li>记录每次前向推理耗时，统计平均值、最大值；</li>
<li>设定超时策略：
<ul>
<li>如果单次推理超时，则放弃当前输出，用上一帧动作；</li>
<li>若连续多次超时，系统进入降级模式（减速、停止等），参见 10.3 节安全性讨论。</li>
</ul>
</li>
</ul>
<p><strong>（3）模型版本与热更新</strong></p>
<p>在实际系统中，VLA 模型可能在云端持续改进，需要<strong>热更新</strong>到机器人上：</p>
<ul>
<li>接口约定保持稳定（动作 / 状态格式不变）；</li>
<li>使用版本号标记 VLA 模型（v1, v2…）；</li>
<li>更新流程：先在仿真 / 数字孪生环境验证，再灰度部署到少量机器人，最后全量更新。(<a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC12349443/?utm_source=chatgpt.com">PMC</a>)</li>
</ul>
<p>这里不展开 MLOps 细节，读者可结合第 9.4 节一起理解。</p>
<h4 id="10123-执行输出"><a class="header" href="#10123-执行输出">10.1.2.3 执行输出</a></h4>
<p>VLA 输出的是<strong>抽象动作</strong>（token 序列 / 连续向量），要变成电机电流，至少还要经过三层处理：</p>
<ol>
<li><strong>动作解码与约束裁剪</strong></li>
<li><strong>轨迹生成与平滑</strong></li>
<li><strong>发送命令与结果反馈</strong></li>
</ol>
<p><strong>（1）动作解码与约束裁剪</strong></p>
<p>在第 8.3 节我们讨论了动作 token 的设计，这里从系统角度看：</p>
<ul>
<li>将模型输出的 token 序列还原为：
<ul>
<li>末端位姿增量 ΔT；</li>
<li>或关节增量 Δq / 速度命令；</li>
</ul>
</li>
<li>对结果进行：
<ul>
<li><strong>数值裁剪</strong>（clip 到物理允许范围）；</li>
<li><strong>安全检查</strong>：若某一维度超出设定阈值（例如瞬时速度过大），可直接拒绝并记录日志。</li>
</ul>
</li>
</ul>
<p><strong>（2）轨迹生成与平滑</strong></p>
<p>直接执行“阶跃命令”容易导致机器人动作生硬甚至振荡，需要在接口下游加入<strong>轨迹生成模块</strong>：</p>
<ul>
<li>使用插值（线性、三次样条）在两个高层命令之间生成平滑轨迹；</li>
<li>结合动力学约束（最大速度、加速度、jerk）优化轨迹，例如使用 MPC 或时间缩放方法。(<a href="https://arxiv.org/abs/2209.11880?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>轨迹生成模块很像一个“传统规划器的缩小版”，主要目标是把 VLA 的高层意图转化为<strong>可执行的、物理可行的微小动作</strong>。</p>
<p><strong>（3）命令发送与执行结果回流</strong></p>
<p>最后一步是：</p>
<ul>
<li>将轨迹（或当前目标点）封装为机器人控制器的原生命令：
<ul>
<li>如 ROS 中的 <code>FollowJointTrajectory</code> / Twist 命令；</li>
</ul>
</li>
<li>底层控制器执行后，每个周期更新当前状态；</li>
<li>VLA 模块在下一次前向时，将“上一条命令的实际执行结果”作为 Observation 的一部分，形成<strong>真正的闭环</strong>（而不是假设输出动作一定被成功执行）。</li>
</ul>
<p>【图 10-4 占位：
“在线推理完整数据流：从传感器到动作命令”。
左侧多源传感器，经预处理后进入 VLA；中间为 VLA 推理模块；右侧是“动作解码 → 轨迹生成 → 控制器 → 机器人”的执行链路，整个流程形成闭环箭头。】</p>
<hr>
<h3 id="1013-本地推理-vs-云端推理延迟与带宽问题"><a class="header" href="#1013-本地推理-vs-云端推理延迟与带宽问题">10.1.3 本地推理 vs 云端推理、延迟与带宽问题</a></h3>
<p>在较大的 VLA 模型出现后，“模型放哪里跑”变成一个系统架构的核心设计问题。</p>
<ul>
<li><strong>本地推理（on-board / edge）</strong>：部署在机器人自身或附近的边缘计算节点；</li>
<li><strong>云端推理（cloud）</strong>：部署在数据中心 GPU 集群；</li>
<li><strong>混合模式（hybrid）</strong>：高频 / 安全关键逻辑本地，低频 / 重计算逻辑云端。</li>
</ul>
<p>边缘计算和云机器人（cloud robotics）的文献已经系统讨论过这一问题：
边缘侧提供低延迟和更好的隐私与带宽利用，而云侧提供大规模算力与集中学习能力。(<a href="https://www.mdpi.com/2224-2708/14/4/65?utm_source=chatgpt.com">MDPI</a>)</p>
<h4 id="10131-本地推理"><a class="header" href="#10131-本地推理">10.1.3.1 本地推理</a></h4>
<p><strong>优势：</strong></p>
<ol>
<li><strong>低延迟、低抖动</strong>
<ul>
<li>数据在本地采集、本地推理，本地执行，链路仅包括设备内部总线和局域通信；</li>
<li>避免公网不稳定带来的长尾延迟，对于抓取、避障等闭环控制至关重要。(<a href="https://www.mdpi.com/2224-2708/14/4/65?utm_source=chatgpt.com">MDPI</a>)</li>
</ul>
</li>
<li><strong>安全性与可用性</strong>
<ul>
<li>即使断网，机器人仍可执行基础功能；</li>
<li>敏感数据（室内环境、人员信息）可以不出本地网络，降低隐私风险。(<a href="https://rocketmeup.medium.com/edge-computing-reducing-latency-in-future-ai-systems-679ed3b8910a?utm_source=chatgpt.com">Medium</a>)</li>
</ul>
</li>
<li><strong>简化带宽需求</strong>
<ul>
<li>不需要持续上传高分辨率视频流，只在必要时上传摘要或统计信息。</li>
</ul>
</li>
</ol>
<p><strong>劣势：</strong></p>
<ul>
<li>算力受限：嵌入式 GPU / NPU 的功耗和算力与数据中心差距较大；</li>
<li>模型大小受约束：需要在第 10.4 节中所说的压缩、量化和蒸馏后才能部署；(<a href="https://promwad.com/news/edge-ai-embedded-devices-2025?utm_source=chatgpt.com">promwad.com</a>)</li>
<li>维护复杂：大量机器人各自部署模型，版本管理、更新和监控的工程成本较高。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>高速移动机器人（无人机、移动底盘）需要 50–100 Hz 以上的决策；(<a href="https://www.sciencedirect.com/science/article/pii/S0743731524000133?utm_source=chatgpt.com">科学直通车</a>)</li>
<li>人机协作、与人近距离接触的机械臂，要求可预测、可控的反应时间；</li>
<li>网络质量不可保证（工厂、家庭 Wi-Fi 环境）的场景。</li>
</ul>
<h4 id="10132-云端推理"><a class="header" href="#10132-云端推理">10.1.3.2 云端推理</a></h4>
<p><strong>优势：</strong></p>
<ol>
<li><strong>强大算力与模型规模</strong>
<ul>
<li>云端可以部署百亿甚至千亿参数的综合 VLA / 多模态模型，提供更强的推理与规划能力；(<a href="https://www.researchgate.net/publication/384083738_Cloud_Robotics_Scalable_AI_And_Robotic_Systems_For_The_Cloud_Age?utm_source=chatgpt.com">ResearchGate</a>)</li>
<li>支持复杂的长时规划、多机器人协同调度等。</li>
</ul>
</li>
<li><strong>集中管理与协同学习</strong>
<ul>
<li>多台机器人共享云端模型与经验，云端可根据海量日志持续训练 / 微调模型，再统一下发更新；(<a href="https://www.researchgate.net/publication/384083738_Cloud_Robotics_Scalable_AI_And_Robotic_Systems_For_The_Cloud_Age?utm_source=chatgpt.com">ResearchGate</a>)</li>
<li>支持跨机器人联合学习、联邦学习等机制。</li>
</ul>
</li>
<li><strong>运维便利</strong>
<ul>
<li>模型部署、版本回滚在云端统一进行，对终端设备影响较小。</li>
</ul>
</li>
</ol>
<p><strong>劣势：</strong></p>
<ol>
<li><strong>延迟与抖动</strong>
<ul>
<li>端到端延迟包括上传数据、队列排队、推理、下行返回；</li>
<li>在复杂网络环境下，延迟和抖动难以控制，很难用在 20 Hz 以上的硬实时控制。(<a href="https://berkeleyautomation.github.io/FogROS2/cloud_robotics?utm_source=chatgpt.com">伯克利自动化</a>)</li>
</ul>
</li>
<li><strong>网络依赖与故障模式</strong>
<ul>
<li>一旦网络中断或拥塞，云端推理不可用，需要本地有应急策略；</li>
<li>安全关键任务不能完全依赖云端决策。</li>
</ul>
</li>
<li><strong>隐私与带宽成本</strong>
<ul>
<li>持续上传高分辨率视频与传感数据消耗大量带宽，并带来隐私与安全风险。(<a href="https://rocketmeup.medium.com/edge-computing-reducing-latency-in-future-ai-systems-679ed3b8910a?utm_source=chatgpt.com">Medium</a>)</li>
</ul>
</li>
</ol>
<p><strong>适用场景：</strong></p>
<ul>
<li>决策频率可较低的任务，如高层任务规划、策略生成、任务解释；</li>
<li>机器人队列规模较大，希望在云端做<strong>全局调度和优化</strong>；</li>
<li>对模型能力要求极高，而本地算力不足以运行完整大模型。</li>
</ul>
<h4 id="10133-混合模式"><a class="header" href="#10133-混合模式">10.1.3.3 混合模式</a></h4>
<p>实际工程中，越来越多系统采用<strong>云–边–端的混合架构</strong>：</p>
<ul>
<li><strong>端（robot）</strong>：机器人本体及其嵌入式控制器；</li>
<li><strong>边（edge）</strong>：靠近机器人部署的边缘服务器 / 网关；</li>
<li><strong>云（cloud）</strong>：远端数据中心。</li>
</ul>
<p>FogROS2、混合机器人平台等系统都强调：让<strong>低延迟、安全关键决策留在边 / 端，高层策略和学习放在云侧</strong>。(<a href="https://berkeleyautomation.github.io/FogROS2/cloud_robotics?utm_source=chatgpt.com">伯克利自动化</a>)</p>
<p>典型分工模式：</p>
<ol>
<li><strong>端：基础控制 + 安全保护</strong>
<ul>
<li>1 kHz 伺服控制、碰撞检测、急停逻辑；</li>
<li>简单的动作原语执行（如固定抓取、固定放置）；</li>
<li>网络断开时的降级策略（缓慢停止、原地等待）。</li>
</ul>
</li>
<li><strong>边：中等规模 VLA 推理 + 局部规划</strong>
<ul>
<li>在边缘 GPU 上运行压缩版 VLA 模型（10–100M 参数级）；</li>
<li>执行视觉感知 + 短期动作决策，如“抓起桌上的杯子”；</li>
<li>与端设备通过有线或局域网通信，延迟可控制在 10–20 ms 级别。</li>
</ul>
</li>
<li><strong>云：大模型推理 + 全局优化 + 持续学习</strong>
<ul>
<li>接收略下采样的感知数据和执行日志；</li>
<li>给出长期任务分解、策略建议或新模型版本；</li>
<li>不直接参与闭环控制，而是作为<strong>策略更新与知识源</strong>。</li>
</ul>
</li>
</ol>
<p>【图 10-5 占位：
“云–边–端混合架构示意图”。
底部是机器人本体（servo + safety），中间是边缘计算节点（运行轻量 VLA、局部规划），顶部是云端（大模型、策略学习）。箭头标注高频低延迟数据流与低频高层策略流。】</p>
<hr>
<h3 id="1014-模块化系统感知规划控制与-vla-的关系"><a class="header" href="#1014-模块化系统感知规划控制与-vla-的关系">10.1.4 模块化系统：感知、规划、控制与 VLA 的关系</a></h3>
<p>在传统机器人软件架构中，已形成比较成熟的模块划分：<strong>感知 → 规划 → 控制</strong>。(<a href="https://www.sciencedirect.com/science/article/am/pii/S0164121221000662?utm_source=chatgpt.com">科学直通车</a>)</p>
<p>VLA 的出现，并不意味着这些模块会被完全替代，而是带来一个新问题：</p>
<blockquote>
<p>“VLA 究竟站在什么位置？怎样与已有模块协同，而不是互相掣肘？”</p>
</blockquote>
<p>可以把系统想象成一个多层结构：</p>
<ul>
<li>底层：控制（Control）——电机级控制、轨迹跟踪；</li>
<li>中层：运动规划（Motion Planning）——生成无碰撞轨迹；</li>
<li>上层：任务 / 策略（Task / Policy）——决定做什么、怎么做；</li>
<li>侧向：感知（Perception）——不断提供对环境的理解。</li>
</ul>
<p>VLA 最自然的位置是**“上层任务 / 策略”的新实现方式**，但它可能渗透到中层与侧向模块。</p>
<h4 id="10141-感知模块"><a class="header" href="#10141-感知模块">10.1.4.1 感知模块</a></h4>
<p>前面第 3 章已经详细介绍过视觉感知，这里从系统架构角度总结一下感知模块的角色：</p>
<ul>
<li><strong>构建环境的多层表示</strong>：
<ul>
<li>几何层：地图、障碍物位置、物体 6D 位姿；</li>
<li>语义层：物体类别、“可放置区域”、“可抓取区域”等语义信息；</li>
</ul>
</li>
<li><strong>提供统一的世界模型接口</strong>：
<ul>
<li>规划器与 VLA 不直接操作原始图像，而是使用“物体列表 + 语义标签 + 几何信息”等结构化表示。</li>
</ul>
</li>
</ul>
<p>在与 VLA 的关系上，有三种典型模式：</p>
<ol>
<li><strong>VLA 直接读取原始感知（端到端）</strong>
<ul>
<li>图像直接送入 VLA 的视觉 backbone；</li>
<li>感知模块仅负责相机标定与基础预处理；</li>
<li>优点：模型可以学到任务相关特征；缺点：可解释性差，难以复用传统感知成果。</li>
</ul>
</li>
<li><strong>VLA 读取感知模块的中间表示</strong>
<ul>
<li>感知模块输出目标检测框、物体位姿等；</li>
<li>VLA 接收这些结构化信息，结合语言和历史，输出动作；</li>
<li>这是经典模块化与 VLA 的折中：部分端到端，部分符号化 / 结构化。</li>
</ul>
</li>
<li><strong>VLA 指导感知模块</strong>
<ul>
<li>VLA 可以输出“关注区域”（attention ROI）、“要识别的物体类别”等，反过来驱动感知模块调整算法重点；</li>
<li>特别是在计算资源有限时，VLA 可以作为“感知调度器”。</li>
</ul>
</li>
</ol>
<p>在系统实现中，感知模块与 VLA 之间同样通过明确的接口契约联系：
例如定义统一的<strong>场景图（scene graph）或物体列表结构</strong>，包含 ID、类别、位姿、尺寸等信息。</p>
<h4 id="10142-规划模块"><a class="header" href="#10142-规划模块">10.1.4.2 规划模块</a></h4>
<p>规划模块是“把目标变成可执行路径”的那一层。
包括：</p>
<ul>
<li>运动规划（如 RRT / PRM / TrajOpt / MPC）；(<a href="https://arxiv.org/abs/2209.11880?utm_source=chatgpt.com">arXiv</a>)</li>
<li>任务规划（如基于 PDDL 的符号规划，或基于图模型的多步任务分解）。</li>
</ul>
<p>VLA 与规划模块的关系大致有三种：</p>
<ol>
<li><strong>VLA 取代任务规划，但保留运动规划</strong>
<ul>
<li>VLA 接受语言指令与场景信息，输出一系列<strong>子目标 / 子任务</strong>：
<ul>
<li>例如：“先移开杯子，再擦桌子”；</li>
</ul>
</li>
<li>运动规划器负责把每个子任务转化为无碰撞轨迹；</li>
<li>优点：兼顾 VLA 的通用性和传统规划的可靠性；</li>
<li>缺点：需要为 VLA 设计清晰的“子任务接口”（类似 skill API）。</li>
</ul>
</li>
<li><strong>VLA 与规划器并联，互为备选</strong>
<ul>
<li>对于简单场景，传统规划器可以独立完成任务；</li>
<li>对于复杂、模糊目标（如“收拾桌面”）由 VLA 产生更鲁棒的动作序列；</li>
<li>系统可以根据环境状态（拥挤、障碍复杂）、性能指标（时间 / 成功率）动态选择调用哪个规划来源。</li>
</ul>
</li>
<li><strong>VLA 内部隐式实现规划能力</strong>
<ul>
<li>对某些简单任务，经过大量示教 + RL，VLA 可以近似实现一个端到端的“学习型规划器”；</li>
<li>例如学会在各种桌面布局下抓取、排序物体，而无需显式调用 RRT；</li>
<li>此时传统规划模块更多作为<strong>安全 fallback</strong> 或<strong>特殊场景的补充</strong>。</li>
</ul>
</li>
</ol>
<p>无论采用哪种模式，工程上一个重要思想是：<strong>不要把传统规划直接废掉，而是让它在系统中保留“安全网”的角色</strong>——在 VLA 输出的动作可能导致碰撞时，规划器可以给出安全替代方案或拒绝执行。(<a href="https://www.sciencedirect.com/science/article/pii/S259012302503717X?utm_source=chatgpt.com">科学直通车</a>)</p>
<h4 id="10143-vla-集成"><a class="header" href="#10143-vla-集成">10.1.4.3 VLA 集成</a></h4>
<p>综合前几小节，可以把 VLA 在整个模块化系统中的位置总结为三种典型集成模式（它们并不互斥，可以在同一系统中共存）：</p>
<p><strong>模式 A：VLA 作为“高层策略模块”</strong></p>
<ul>
<li>输入：
<ul>
<li>语言指令；</li>
<li>感知模块输出的场景表示；</li>
<li>机器人当前任务状态；</li>
</ul>
</li>
<li>输出：
<ul>
<li>子任务序列（调用现有 skill / motion primitive）；</li>
<li>或短期子目标（某个物体的目标位姿）；</li>
</ul>
</li>
<li>运动规划与低层控制保持原样，只是把原来手工编写的规则 / 状态机换成了 VLA 学到的策略。</li>
</ul>
<p>这种模式对已有工业系统最友好：<strong>只替换最上层的大脑，不动底层“肌肉和脊髓”。</strong></p>
<p><strong>模式 B：VLA 作为“端到端控制策略”，传统模块做安全监护</strong></p>
<ul>
<li>VLA 直接从图像和任务语言输出末端速度 / delta pose；</li>
<li>运动规划器主要做“离线验证”和“在线可行性检查”：
<ul>
<li>异步预估 VLA 输出在多少步后是否可能碰撞；</li>
<li>一旦检测到危险，修改或打断 VLA 的动作序列；</li>
</ul>
</li>
<li>感知模块仍可以为 VLA 提供高级语义，例如标签、可抓取区域。</li>
</ul>
<p>很多最近的具身智能系统在实验室阶段采用这种模式：<strong>主角是 VLA，但背后仍有一套“影子规划与监控系统”在兜底。</strong>(<a href="https://arxiv.org/html/2509.06819v1?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>模式 C：VLA 与传统模块高度融合的“混合系统”</strong></p>
<ul>
<li>部分子任务完全由 VLA 决策（如整理桌面中的抓取顺序）；</li>
<li>部分子任务仍由传统模块负责（如全局导航、SLAM 建图）；</li>
<li>VLA 与传统模块互相调用：
<ul>
<li>VLA 通过 API 请求“移动到某个导航目标”；</li>
<li>规划模块通过 API 请求 VLA 生成“下一步操作建议”。</li>
</ul>
</li>
</ul>
<p>这种系统往往更复杂，但有更好的可扩展性：
新任务可以通过增加新的技能模块 + 训练 VLA 如何调用这些技能来实现，而不必完全重新训练一个端到端策略。</p>
<p>【图 10-6 占位：
“模块化系统中 VLA 的三种集成模式”。
画出三个小图：</p>
<ul>
<li>左图：VLA 在感知之上、规划之下；</li>
<li>中图：VLA 直接输出控制，规划器作为“安全监护”包裹在旁边；</li>
<li>右图：VLA、感知、规划之间有双向箭头，表示互相调用的混合系统。】</li>
</ul>
<hr>
<p>本节从接口、数据流、部署位置和模块化架构四个角度，讨论了 VLA 如何“落地”到真实机器人系统中。
与前面章节的区别在于：不再只关注模型本身，而是把它视为整个机器人软件栈中的一个**“高层智能组件”**，强调与感知、规划、控制以及边缘 / 云基础设施的协同关系。</p>
<p>理解这一层，对后续在第 10.2 节设计评测协议、在第 10.3 节系统性考虑安全与鲁棒性，都是必要的铺垫。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="实验场景与评测协议"><a href="#实验场景与评测协议" class="header">实验场景与评测协议</a></h1>
<h3 id="1021-单任务-vs-多任务评测场景设计"><a class="header" href="#1021-单任务-vs-多任务评测场景设计">10.2.1 单任务 vs 多任务评测场景设计</a></h3>
<p>本节讨论“<strong>评什么</strong>”的问题：在真实机器人或高保真仿真上，如何设计合理的评测场景，既能看清模型长处，也能暴露其短板。你可以把它理解为给 VLA 模型设计“期末考试卷子”：是只考一道大题，还是一整套综合题，还是一个完整项目。</p>
<hr>
<h4 id="10211-单任务评测"><a class="header" href="#10211-单任务评测">10.2.1.1 单任务评测</a></h4>
<p><strong>（1）概念与适用场景</strong></p>
<p>单任务评测指：在<strong>固定任务定义</strong>下（例如“抓取桌面上的杯子并放进盒子”），对同一个模型进行多次重复试验，只改变一些随机因素（初始位姿、噪声等）。这类评测特别适合：</p>
<ul>
<li>新模型/新模块的<strong>功能验证与调试</strong>；</li>
<li>与传统方法（经典规划器、手工策略）的<strong>对比基准</strong>；</li>
<li>分析 VLA 系统中某一环节（视觉、语言或动作解码）的<strong>瓶颈</strong>。</li>
</ul>
<p><strong>（2）任务要素的形式化</strong></p>
<p>设计单任务时，建议写成一个清晰的“任务规范”，包括：</p>
<ul>
<li><strong>初始条件</strong>：
<ul>
<li>机器人初始状态（关节角、底盘位置等）；</li>
<li>环境状态（物体摆放、门是开是关等）；</li>
</ul>
</li>
<li><strong>允许的动作空间</strong>：例如只允许关节速度命令，不允许直接 teleop 接管；</li>
<li><strong>终止条件</strong>：
<ul>
<li>成功：目标物体到达目标集合内（位置、姿态、接触关系满足容差）；</li>
<li>失败：超时、碰撞、明显离题（执行到安全区域外）等；</li>
</ul>
</li>
<li><strong>约束与安全规则</strong>：禁止进入某些区域、力矩/速度上限等。</li>
</ul>
<p>这些信息在后续定义成功率、完成时间等指标时会反复用到。</p>
<p><strong>（3）随机性与重复次数</strong></p>
<p>单任务评测并不意味着“场景完全不变”。通常为了避免模型记住某个特定初始状态，需要：</p>
<ul>
<li>在合理范围内<strong>随机化初始条件</strong>（例如物体位置在一个矩形区域内均匀采样）；</li>
<li>对每个策略至少运行几十到上百次实验，估计成功率及其置信区间。</li>
</ul>
<p>在 embodied AI 的导航与操作基准中，普遍采用“同一任务定义，多随机种子反复试验”的方式汇总统计量。(<a href="https://www.researchgate.net/publication/349913606_A_Survey_Of_Embodied_AI_From_Simulator_To_Research_Tasks?utm_source=chatgpt.com">ResearchGate</a>)</p>
<p><strong>（4）示意图建议</strong></p>
<blockquote>
<p>[图 10.2-1：单任务评测示意图。同一张桌面上，杯子初始位置在一个小区域内随机采样，机器人多次尝试抓取并放入盒子，用不同颜色轨迹表示不同试验的手爪路径。]</p>
</blockquote>
<hr>
<h4 id="10212-多任务评测"><a class="header" href="#10212-多任务评测">10.2.1.2 多任务评测</a></h4>
<p>单任务只能回答“这个模型是不是在这一件事上很强”；而 VLA 的目标，是<strong>在一套任务家族上表现稳定</strong>。多任务评测就是给模型一整张“卷子”。</p>
<p><strong>（1）任务集设计</strong></p>
<p>多任务评测中，通常需要构造一个<strong>任务集合</strong>：</p>
<ul>
<li>类型多样：包含抓取、放置、推拉、开关、开门、导航到目标等不同操作类型；</li>
<li>难度分层：从简单（单步动作）到复杂（多步骤组合），方便分析模型在不同难度上的退化情况；</li>
<li>语义多样：任务指令覆盖不同对象、属性（颜色、大小）和空间关系。</li>
</ul>
<p>例如 RLBench、ProcTHOR 等框架中，都提供了几十甚至上百种操作/导航子任务，用于训练和评测多任务策略。(<a href="https://openreview.net/forum?id=4-bV1bi74M&amp;utm_source=chatgpt.com">OpenReview</a>)</p>
<p><strong>（2）采样与汇总方式</strong></p>
<p>常见的做法：</p>
<ul>
<li><strong>均匀采样</strong>：每个任务在评测时被选择的概率相同，避免模型“刷分”只靠擅长的任务拉高平均成功率；</li>
<li><strong>分任务统计</strong>：
<ul>
<li>每个任务单独统计成功率/时间等；</li>
<li>再计算宏平均（每任务等权）与微平均（每条轨迹等权）两个指标。</li>
</ul>
</li>
</ul>
<p><strong>（3）指令与场景的联动</strong></p>
<p>在多任务设置中，任务通常通过自然语言指令体现：</p>
<ul>
<li>一种做法：每条指令隐含任务 ID（如 “open the drawer” 对应开抽屉任务）；</li>
<li>更通用的做法：同一任务可以有多种自然表述，后面 10.2.3.3 会专门讨论新指令泛化。</li>
</ul>
<p><strong>（4）示意图建议</strong></p>
<blockquote>
<p>[图 10.2-2：多任务评测任务集示意图。横轴为不同任务（抓取、开门、推拉等），纵轴为评测指标（成功率、时间），通过柱状图展示同一 VLA 模型在多任务上的性能分布。]</p>
</blockquote>
<hr>
<h4 id="10213-复杂场景"><a class="header" href="#10213-复杂场景">10.2.1.3 复杂场景</a></h4>
<p>复杂场景可以理解为“把多个任务拼成一条剧情线”。它更接近真实应用中的长程任务，例如“从厨房拿一瓶水端到客厅桌上”。</p>
<p><strong>（1）多阶段任务与子目标</strong></p>
<p>复杂场景通常由多个<strong>子任务</strong>顺序构成：</p>
<ol>
<li>导航到冰箱；</li>
<li>打开冰箱门；</li>
<li>找到并抓起水瓶；</li>
<li>关闭冰箱门；</li>
<li>导航到客厅桌子旁；</li>
<li>放下水瓶。</li>
</ol>
<p>评测时既要记录<strong>整体任务是否完成</strong>，也可以记录每个子任务的成功率、平均用时，形成一个“阶段成绩单”，帮助分析模型在哪个环节失误最多。许多交互式 3D 仿真平台（如 iGibson、AI2-THOR）都支持这类长程交互场景，并以阶段式任务评估复杂行为。(<a href="https://jimfan.me/publication/igibson/igibson-IROS2021.pdf?utm_source=chatgpt.com">Jim Fan</a>)</p>
<p><strong>（2）动态环境与多主体</strong></p>
<p>复杂场景中还可以引入：</p>
<ul>
<li><strong>动态环境</strong>：人类或其他机器人在场景中移动，导致遮挡与动态障碍；</li>
<li><strong>人机交互</strong>：人在任务中插入新指令、纠偏，要求模型在运行中理解语言变化；</li>
<li><strong>多机器人协作</strong>：多个机器人共享环境，相互避障甚至协同完成任务。</li>
</ul>
<p>这类设置更接近现实，但评测协议也更复杂，往往需要单独章节（可与第 12 章“多机器人协作与群体智能”呼应）。</p>
<p><strong>（3）示意图建议</strong></p>
<blockquote>
<p>[图 10.2-3：复杂场景任务流程图。用流程图展示从“接收任务指令”到“多阶段执行”的状态转移，每个节点标注对应的子任务与可能失败点。]</p>
</blockquote>
<hr>
<h3 id="1022-成功率完成时间路径质量等指标"><a class="header" href="#1022-成功率完成时间路径质量等指标">10.2.2 成功率、完成时间、路径质量等指标</a></h3>
<p>有了任务场景，还需要<strong>量尺</strong>来比较不同方法。本节给出几类在 embodied AI 中高度通用的指标，并解释其计算方式与优缺点。</p>
<hr>
<h4 id="10221-成功率success-rate-sr"><a class="header" href="#10221-成功率success-rate-sr">10.2.2.1 成功率（Success Rate, SR）</a></h4>
<p><strong>（1）定义与计算公式</strong></p>
<p>对于第 (i) 次试验（episode），定义一个二值变量 (S_i)：</p>
<ul>
<li>若在最大步数/时间内满足任务成功条件，则 (S_i = 1)；</li>
<li>否则 (S_i = 0)。</li>
</ul>
<p>在总共 (N) 次试验中，<strong>成功率</strong>定义为</p>
<p>$$
\text{SR} = \frac{1}{N} \sum_{i=1}^{N} S_i.
$$</p>
<p>这一定义被大量导航和操作基准采用，例如 Habitat、ObjectNav 等任务都是以成功率作为首要指标。(<a href="https://vladlen.info/papers/habitat.pdf?utm_source=chatgpt.com">Vladlen Koltun</a>)</p>
<p><strong>（2）成功条件的设计</strong></p>
<p>关键在于：<strong>“什么算成功？”</strong></p>
<ul>
<li>导航任务：
<ul>
<li>目标条件通常是机器人停止时与目标位置的距离小于某阈值（例如 0.2–0.5 m），且无碰撞。(<a href="https://orca.cardiff.ac.uk/id/eprint/167432/1/ObjectGoalNavigationSurveyTASE.pdf?utm_source=chatgpt.com">ORCA</a>)</li>
</ul>
</li>
<li>操作任务：
<ul>
<li>物体到达目标区域且姿态满足要求（如杯子底面在桌面上、未倾倒）；</li>
<li>抓取任务可用“物体离开原位并稳定在夹爪或目标容器内”作为成功。(<a href="https://www.themoonlight.io/en/review/robotic-manipulation-via-imitation-learning-taxonomy-evolution-benchmark-and-challenges?utm_source=chatgpt.com">themoonlight.io</a>)</li>
</ul>
</li>
</ul>
<p>当任务更复杂时，可以采用<strong>层级成功</strong>：</p>
<ul>
<li>“完全成功”：所有子目标都完成；</li>
<li>“部分成功”：完成部分子目标，例如仅成功抓取但未成功放置。</li>
</ul>
<p>在报告结果时，应尽量区分这两类，以免把“半拉子工程”算作成功。</p>
<p><strong>（3）不确定性与置信区间</strong></p>
<p>由于评测次数有限，SR 本身有统计波动。建议：</p>
<ul>
<li>报告 SR 的同时给出<strong>置信区间</strong>（例如 95% CI，可用二项分布或正态近似估计）；</li>
<li>在比较不同方法时，注意统计显著性，而非只看小数点后三位的差异。</li>
</ul>
<hr>
<h4 id="10222-完成时间completion-time"><a class="header" href="#10222-完成时间completion-time">10.2.2.2 完成时间（Completion Time）</a></h4>
<p>成功率告诉我们“能不能做成”，完成时间则回答“做得快不快”。</p>
<p><strong>（1）定义与测量方式</strong></p>
<p>对于一次成功的试验，记录从 episode 开始到满足成功条件的时间 (T_i)：</p>
<ul>
<li>在仿真中通常用<strong>步数</strong>或<strong>仿真时间</strong>；</li>
<li>在真实机器人中用<strong>壁钟时间</strong>（秒）更直观。</li>
</ul>
<p>可以报告：</p>
<ul>
<li>平均完成时间 (\bar{T})；</li>
<li>中位数时间（更鲁棒于极端慢的样本）；</li>
<li>完成时间分布的直方图或 CDF。</li>
</ul>
<p>如果某次试验失败或超时，一般将其排除在平均完成时间之外，同时在 SR 中体现失败。</p>
<p><strong>（2）效率相关复合指标</strong></p>
<p>类似导航基准提出的 SPL（Success weighted by Path Length），也可以构造<strong>按时间加权的成功指标</strong>：</p>
<p>$$
\text{SWT} = \frac{1}{N} \sum_{i=1}^{N} S_i \cdot \frac{T_i^<em>}{\max(T_i, T_i^</em>)},
$$</p>
<p>其中 (T^{*}_i) 是在该场景下的最短可行完成功能时间（例如用规划器或人工脚本计算）。这样既鼓励成功，又鼓励接近最优时间。类似思想已在多种导航与社交机器人评测中使用。(<a href="https://eval.ai/web/challenges/challenge-page/2650/evaluation?utm_source=chatgpt.com">EvalAI</a>)</p>
<p><strong>（3）安全与舒适度的权衡</strong></p>
<p>完成时间越短不总是越好：</p>
<ul>
<li>机器人过快动作可能导致<strong>安全风险</strong>（更容易碰撞）；</li>
<li>在人机共存场景，动作过快可能降低人的<strong>舒适度</strong>。(<a href="https://dl.acm.org/doi/10.1145/3700599?utm_source=chatgpt.com">ACM Digital Library</a>)</li>
</ul>
<p>因此在报告中通常：</p>
<ul>
<li>把完成时间作为<strong>次级指标</strong>，在相近成功率的策略之间比较；</li>
<li>同时报告碰撞率、最小安全距离等指标。</li>
</ul>
<p><strong>（4）示意图建议</strong></p>
<blockquote>
<p>[图 10.2-4：完成时间分布示意图。横轴是完成时间，纵轴是累计比例（CDF），对比两种策略的曲线，一条整体偏左代表更快完成。]</p>
</blockquote>
<hr>
<h4 id="10223-路径--动作质量"><a class="header" href="#10223-路径--动作质量">10.2.2.3 路径 / 动作质量</a></h4>
<p>即使成功、时间也合理，机器人“走得好不好”仍然是一个维度。这里主要关注<strong>轨迹质量</strong>。</p>
<p><strong>（1）路径长度与 SPL</strong></p>
<p>对导航与末端执行器轨迹，可以定义：</p>
<ul>
<li><strong>路径长度</strong> (L_i)：轨迹上相邻位置的欧氏距离累加；</li>
<li><strong>最短路径长度</strong> (L^{*}_i)：由规划器或图搜索得到的最短可行路径。</li>
</ul>
<p>SPL（Success weighted by Path Length）定义为：(<a href="https://vladlen.info/papers/habitat.pdf?utm_source=chatgpt.com">Vladlen Koltun</a>)</p>
<p>$$
\text{SPL} = \frac{1}{N} \sum_{i=1}^{N}
S_i \cdot \frac{L^{<em>}_i}{\max(L_i, L^{</em>}_i)}.
$$</p>
<ul>
<li>若成功且走的是最短路径，则该项为 1；</li>
<li>若路径更长，则按比例衰减；</li>
<li>若失败，则该项为 0。</li>
</ul>
<p>SPL 在多种 embodied navigation 基准中已成为标准指标，也可以自然扩展到机械臂末端路径。</p>
<p><strong>（2）轨迹平滑度与控制质量</strong></p>
<p>从控制角度看，<strong>平滑、连贯</strong>的轨迹有利于减少机械冲击和能耗，也更接近人类动作习惯。常见做法：</p>
<ul>
<li>使用<strong>关节空间轨迹平滑度指标</strong>：
<ul>
<li>例如总加速度或总 jerk（加速度的导数）
(\sum_t |\ddot{q}_t|^2), (\sum_t |\dddot{q}_t|^2)；</li>
</ul>
</li>
<li>统计<strong>速度/加速度的极值</strong>：越少“骤停-急动”越好；</li>
<li>测量<strong>碰撞次数、接触过载</strong>等安全相关指标。(<a href="https://www.researchgate.net/publication/394524708_Robot_Policy_Evaluation_for_Sim-to-Real_Transfer_A_Benchmarking_Perspective?utm_source=chatgpt.com">ResearchGate</a>)</li>
</ul>
<p>在最新的机器人策略评测工作中，常将成功率、时间、轨迹平滑度等组合为一组指标，全面刻画策略质量。(<a href="https://www.researchgate.net/publication/394524708_Robot_Policy_Evaluation_for_Sim-to-Real_Transfer_A_Benchmarking_Perspective?utm_source=chatgpt.com">ResearchGate</a>)</p>
<p><strong>（3）能耗与硬件友好度</strong></p>
<p>对真实机器人来说，微小的轨迹差异可能意味着非常不同的<strong>能耗与磨损</strong>：</p>
<ul>
<li>可以对每个关节积分 (\int \tau_t^2 dt) 或 (\int |\tau_t \cdot \dot{q}_t| dt) 作为能量 proxy；</li>
<li>长期评测中，能耗更低的策略意味着电池续航、材料寿命更好。</li>
</ul>
<p><strong>（4）示意图建议</strong></p>
<blockquote>
<p>[图 10.2-5：路径质量对比示意图。展示同一导航任务中两条路径：一条接近最短路径且平滑，另一条绕行、频繁转向；同时给出相应的路径长度与 SPL 指标。]</p>
</blockquote>
<hr>
<h3 id="1023-泛化评测新物体新布局新任务指令"><a class="header" href="#1023-泛化评测新物体新布局新任务指令">10.2.3 泛化评测：新物体、新布局、新任务指令</a></h3>
<p>VLA 模型真正有价值的地方，在于<strong>泛化</strong>：训练时见过的只是有限案例，部署时面对的是无穷变化。本节从三个维度构造“看新东西”的考题。</p>
<p>很多 embodied AI 基准（Habitat、iGibson 等）已经形成了一套惯例：将训练和测试在<strong>对象类别、场景布局和指令分布</strong>上进行明确分离。(<a href="https://www.researchgate.net/publication/349913606_A_Survey_Of_Embodied_AI_From_Simulator_To_Research_Tasks?utm_source=chatgpt.com">ResearchGate</a>)</p>
<hr>
<h4 id="10231-新物体unseen-objects"><a class="header" href="#10231-新物体unseen-objects">10.2.3.1 新物体（Unseen Objects）</a></h4>
<p><strong>（1）实例级 vs 类别级泛化</strong></p>
<ul>
<li><strong>实例级泛化</strong>：
<ul>
<li>训练见过“红色杯子 A、B、C”，测试时出现“红色杯子 D”；</li>
<li>类别相同、属性相似，但几何细节不同；</li>
</ul>
</li>
<li><strong>类别级泛化</strong>：
<ul>
<li>训练阶段从未出现“剪刀”，测试时间接收到指令“把剪刀放进抽屉”；</li>
<li>要求模型基于语言/视觉语义理解新类别。</li>
</ul>
</li>
</ul>
<p>前者更多依赖于视觉“类内泛化”能力，后者则依赖于大模型对语言与世界知识的掌握，在 VLA 中越来越重要。(<a href="https://www.researchgate.net/publication/391460110_A_Survey_of_Navigation_and_Manipulation_with_Physics_Simulators_in_the_Era_of_Embodied_AI?utm_source=chatgpt.com">ResearchGate</a>)</p>
<p><strong>（2）物理属性变化</strong></p>
<p>除了外观形状，物体的<strong>质量、摩擦系数、刚度</strong>等物理属性变化同样重要：</p>
<ul>
<li>对抓取任务，可通过改变物体重量、表面材料（光滑/粗糙）来构造测试集；</li>
<li>对推拉任务，可改变地面摩擦系数、物体底面材料。</li>
</ul>
<p>相关评测设计在近期操作与模拟综述中被反复强调，用于检验策略对物理不确定性的鲁棒性。(<a href="https://www.researchgate.net/publication/391460110_A_Survey_of_Navigation_and_Manipulation_with_Physics_Simulators_in_the_Era_of_Embodied_AI?utm_source=chatgpt.com">ResearchGate</a>)</p>
<p><strong>（3）评测协议建议</strong></p>
<ul>
<li>明确列出“训练物体集合”和“测试物体集合”；</li>
<li>报告在<strong>仅使用训练物体</strong>与<strong>完全替换为新物体</strong>两种条件下的成功率对比；</li>
<li>若使用语言描述新物体（“把刀状物体放入盒子”），可额外考查模型的知识迁移能力。</li>
</ul>
<blockquote>
<p>[图 10.2-6：新物体泛化示意图。一列为训练中见过的杯子/碗/瓶子，另一列为测试时出现的新款式，通过箭头标注“类别已见/类别未见”。]</p>
</blockquote>
<hr>
<h4 id="10232-新布局unseen-layouts--scenes"><a class="header" href="#10232-新布局unseen-layouts--scenes">10.2.3.2 新布局（Unseen Layouts / Scenes）</a></h4>
<p><strong>（1）场景级拆分</strong></p>
<p>在导航类 embodied AI 中，已经很常见的做法是：按<strong>场景 ID</strong>划分训练/验证/测试集合，例如 HM3D、Habitat 中的“训练房屋”和“测试房屋”完全不同。(<a href="https://datasets-benchmarks-proceedings.neurips.cc/paper/2021/file/34173cb38f07f89ddbebc2ac9128303f-Paper-round2.pdf?utm_source=chatgpt.com">datasets-benchmarks-proceedings.neurips.cc</a>)</p>
<p>对操作任务也可以类似处理：</p>
<ul>
<li>训练时在若干桌面/台面布局上采集数据；</li>
<li>测试时更换家具布局、桌子高度、物体摆放模式。</li>
</ul>
<p><strong>（2）静态 vs 动态布局变化</strong></p>
<ul>
<li><strong>静态布局泛化</strong>：场景几何结构不同，但在一个 episode 内不变化；</li>
<li><strong>动态布局泛化</strong>：在任务执行过程中，其他实体（人类、机器人）在环境中移动，导致布局实时改变。</li>
</ul>
<p>前者主要评估<strong>视觉与策略对位置关系变化的适应</strong>，后者进一步检验策略的<strong>在线感知与 replanning 能力</strong>。(<a href="https://openreview.net/forum?id=4-bV1bi74M&amp;utm_source=chatgpt.com">OpenReview</a>)</p>
<p><strong>（3）难度控制与分层</strong></p>
<p>完全随机生成新布局可能导致难度分布失控，评测时应注意：</p>
<ul>
<li>使用与训练集类似复杂度的测试场景（房间大小、障碍物数量等参数尽量匹配）；</li>
<li>或者明确划出“简单/中等/困难”三档场景，分别报告泛化性能。</li>
</ul>
<blockquote>
<p>[图 10.2-7：新布局泛化示意图。左侧为训练时使用的几个房间平面图，右侧为测试时的不同房间布局，标注门、障碍物和目标位置变化。]</p>
</blockquote>
<hr>
<h4 id="10233-新指令unseen-instructions"><a class="header" href="#10233-新指令unseen-instructions">10.2.3.3 新指令（Unseen Instructions）</a></h4>
<p>对于 VLA 模型，语言是“任务接口”。单纯在训练 seen 指令上表现良好，不能代表真正理解语言。</p>
<p><strong>（1）表达多样性：同义改写与风格变化</strong></p>
<p>最基础的一类测试是：</p>
<ul>
<li>训练指令： “把红色杯子放进盒子里。”</li>
<li>测试指令：
<ul>
<li>“请把红色的杯子放到盒子里面。”</li>
<li>“把那个红色杯子移到盒子中。”</li>
<li>“能帮我把红杯放进盒子吗？”</li>
</ul>
</li>
</ul>
<p>也可以引入口语化、礼貌句、倒装句等风格变化，考查模型是否真正依赖语义，而非死记模板。</p>
<p><strong>（2）组合与逻辑结构泛化</strong></p>
<p>更进一层的，是<strong>组合式新指令</strong>：</p>
<ul>
<li>训练时只见过单步指令：“拿起 A”、“放下 A”；</li>
<li>测试时出现组合：“先拿起 A 放到 B 上，再把 C 放到 A 左边”。</li>
</ul>
<p>这要求模型具备一定的<strong>任务分解与时序逻辑理解</strong>能力，而不仅是逐句映射为动作。有关基准通常会构造“seen 组合”和“unseen 组合”两个分布，对比泛化性能。(<a href="https://www.researchgate.net/publication/391460110_A_Survey_of_Navigation_and_Manipulation_with_Physics_Simulators_in_the_Era_of_Embodied_AI?utm_source=chatgpt.com">ResearchGate</a>)</p>
<p><strong>（3）评测注意点</strong></p>
<ul>
<li>尽量将<strong>词表覆盖</strong>控制在训练/测试交集大，但在<strong>句法与组合</strong>上保持差异；</li>
<li>在报告结果时，区分：
<ul>
<li>语义等价改写上的泛化；</li>
<li>真正新组合（未见过的步骤序列）上的泛化。</li>
</ul>
</li>
</ul>
<blockquote>
<p>[图 10.2-8：新指令泛化示意图。用一个图示展示：训练阶段只有简单单步指令，测试阶段出现“先……再……”的多步指令，并用箭头表示模型需要在内部拆解成两个子任务。]</p>
</blockquote>
<hr>
<h3 id="1024-跨机器人迁移能力评估"><a class="header" href="#1024-跨机器人迁移能力评估">10.2.4 跨机器人迁移能力评估</a></h3>
<p>通用 VLA 的一个重要愿景，是“<strong>一个大脑，多种身体</strong>”：同一模型在不同机械臂、移动平台甚至多足机器人上工作。如何评估这种<strong>跨机器人（跨具身）迁移能力</strong>，是近几年出现的一个新问题。(<a href="https://robotics-transformer-x.github.io/paper.pdf?utm_source=chatgpt.com">Open X-Embodiment</a>)</p>
<hr>
<h4 id="10241-模型迁移测试"><a class="header" href="#10241-模型迁移测试">10.2.4.1 模型迁移测试</a></h4>
<p><strong>（1）基本设定：train-on-A, test-on-B</strong></p>
<p>最经典的跨具身评测方式是：</p>
<ul>
<li>训练阶段：主要在机器人 A（或若干机器人）上收集数据并训练模型；</li>
<li>测试阶段：不再改变模型参数，直接部署到机器人 B 上执行相同或相似任务。</li>
</ul>
<p>例如 Open X-Embodiment、AnyBody 等工作中，采用“留一机器人（或类）不训练，只在其上评测”的方式，系统性研究跨具身性能。(<a href="https://www.robot-learning.ml/2023/files/paper18.pdf?utm_source=chatgpt.com">Robot Learning</a>)</p>
<p>评价时通常：</p>
<ul>
<li>报告 A 上的基准性能（例如 SR_A）；</li>
<li>报告 B 上的零样本性能（SR_B-zero-shot）；</li>
<li>比较两者差值或比值。</li>
</ul>
<p><strong>（2）插值 vs 外推场景</strong></p>
<p>最新的 cross-embodiment 基准会细分：(<a href="https://arxiv.org/html/2505.14986v1?utm_source=chatgpt.com">arXiv</a>)</p>
<ul>
<li><strong>插值（interpolation）</strong>：
<ul>
<li>测试机器人与训练机器人在<strong>连杆结构、自由度</strong>上相似，只是参数略有变化（长度、质量等）；</li>
</ul>
</li>
<li><strong>外推（extrapolation）</strong>：
<ul>
<li>测试机器人有不同的连杆拓扑或完全不同形态（例如从 6-DOF 机械臂迁移到 7-DOF，甚至从轮式移动平台迁移到腿足机器人）。</li>
</ul>
</li>
</ul>
<p>在报告结果时，区分插值/外推有助于理解模型在“细微差异”与“形态突变”上的表现。</p>
<p><strong>（3）少样本适应（few-shot adaptation）</strong></p>
<p>更实际的设定是：允许在新机器人 B 上收集少量数据进行微调或校准：</p>
<ul>
<li>给定 K 条 B 的示教轨迹，用 BC 或 LoRA 微调 VLA；</li>
<li>记录成功率随 K 的变化曲线（sample-efficiency curve）；</li>
<li>比较不同模型的<strong>适应速度</strong>。</li>
</ul>
<p>这一 protocol 在跨具身 RL 与 imitation 工作中越来越常见，用于衡量“从 0 到可用”所需的示例数量。(<a href="https://papers.nips.cc/paper_files/paper/2024/file/62203a74e233e933b160711e791e1a02-Paper-Conference.pdf?utm_source=chatgpt.com">NeurIPS 论文集</a>)</p>
<blockquote>
<p>[图 10.2-9：跨机器人迁移测试示意图。左侧是训练时使用的机器人 A（例如 UR5），右侧是测试机器人 B（例如 Franka Panda），中间用箭头表示“零样本迁移”和“少样本适应”的两种路径。]</p>
</blockquote>
<hr>
<h4 id="10242-适应性指标"><a class="header" href="#10242-适应性指标">10.2.4.2 适应性指标</a></h4>
<p>光看“能不能迁移”还不够，还要定量回答“<strong>迁移得有多好、多快、多安全</strong>”。</p>
<p><strong>（1）性能保持率与性能跌落</strong></p>
<p>可以定义：</p>
<ul>
<li><strong>性能保持率</strong>
$$
R_{\text{keep}} = \frac{\text{SR}_B}{\text{SR}_A}
$$</li>
<li>或<strong>性能跌落</strong>
$$
\Delta_{\text{SR}} = \text{SR}_A - \text{SR}_B.
$$</li>
</ul>
<p>其中 SR_A 是在源机器人 A 上的成功率，SR_B 是零样本或适应后的成功率。</p>
<p><strong>（2）适应速度与样本效率</strong></p>
<p>对少样本微调情形，可用：</p>
<ul>
<li>达到某目标成功率（如恢复到 SR_A 的 80%）所需的<strong>轨迹数量</strong>或<strong>交互步数</strong>；</li>
<li>成功率随训练轮次的曲线下面积（AUC），衡量整体学习效率。</li>
</ul>
<p>在 RL 与 cross-embodiment 基准中，通常会报告“在固定预算内的最终性能”与“达到某性能门槛所需时间”两个数字。(<a href="https://papers.nips.cc/paper_files/paper/2024/file/62203a74e233e933b160711e791e1a02-Paper-Conference.pdf?utm_source=chatgpt.com">NeurIPS 论文集</a>)</p>
<p><strong>（3）安全与稳定性指标</strong></p>
<p>迁移过程中，策略可能产生不少失败甚至危险动作，因此还需统计：</p>
<ul>
<li>适应期内的<strong>碰撞率</strong>、严重错误次数；</li>
<li>每 episode 的最大关节超限程度、力矩超限次数；(<a href="https://www.researchgate.net/publication/394524708_Robot_Policy_Evaluation_for_Sim-to-Real_Transfer_A_Benchmarking_Perspective?utm_source=chatgpt.com">ResearchGate</a>)</li>
<li>在现实机器人上，可额外统计急停触发次数等。</li>
</ul>
<p>这些指标可以看作“迁移过程中付出的代价”，与最终性能共同构成迁移能力的评估。</p>
<blockquote>
<p>[图 10.2-10：适应性曲线示意图。横轴为在目标机器人上使用的示教轨迹数量，纵轴为成功率，比较两个模型的上升速度，并在图中标注达到 80% 性能所需的样本点。]</p>
</blockquote>
<hr>
<h4 id="10243-差异因素"><a class="header" href="#10243-差异因素">10.2.4.3 差异因素</a></h4>
<p>最后，需要认识到：跨机器人迁移难度高度依赖于<strong>机器人之间的差异</strong>。没有理解这些差异，仅凭一个“平均成功率”会非常误导。</p>
<p><strong>（1）运动学结构差异</strong></p>
<ul>
<li>自由度数量不同（6-DOF vs 7-DOF）；</li>
<li>关节类型不同（转动、伸缩关节）；</li>
<li>机械臂关节排列不同，导致某些方向的工作空间更受限。</li>
</ul>
<p>例如，AnyBody 与 PEAC 等基准会精确记录各机器人连杆拓扑，并区分“同类结构的插值迁移”和“跨拓扑外推迁移”。(<a href="https://arxiv.org/html/2505.14986v1?utm_source=chatgpt.com">arXiv</a>)</p>
<p><strong>（2）动力学与控制接口差异</strong></p>
<ul>
<li>质量分布、惯量、摩擦、关节刚度不同；</li>
<li>最大速度/加速度、扭矩上限不同；</li>
<li>控制接口不同：有的接受关节位置目标，有的接受速度或力矩命令，还有的只有末端空间控制接口。</li>
</ul>
<p>这会直接影响“相同动作 token”在不同机器人上的实际效果，因此许多跨具身方法会显式引入<strong>具身描述向量</strong>或“universal action”中间表示，减弱这种差异的影响。(<a href="https://openaccess.thecvf.com/content/CVPR2025/papers/Zheng_Universal_Actions_for_Enhanced_Embodied_Foundation_Models_CVPR_2025_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</p>
<p><strong>（3）感知与几何差异</strong></p>
<ul>
<li>相机位置与视野不同（头顶相机 vs 末端相机 vs 外部相机）；</li>
<li>分辨率、噪声水平、深度传感器种类不同；</li>
<li>末端执行器几何差异（两指夹爪、三指夹爪、吸盘）。</li>
</ul>
<p>这些都会改变“看到的世界”和“能做的动作”。跨机器人评测时，建议：</p>
<ul>
<li>在基准说明中清晰给出各机器人传感器配置与末端几何；</li>
<li>如果使用统一的视觉输入（例如场景固定相机），要说明这是为了隔离感知差异，只考察控制迁移。</li>
</ul>
<blockquote>
<p>[图 10.2-11：差异因素示意图。在一张图中列出几个典型机器人（移动底盘、7 自由度机械臂、双臂系统），分别标注其自由度、相机安装位置、末端执行器类型，用箭头指示它们在任务空间中的差异。]</p>
</blockquote>
<hr>
<p>本节从<strong>场景设计</strong>到<strong>指标体系</strong>，再到<strong>泛化维度</strong>与<strong>跨具身迁移</strong>，构成了 VLA 系统“如何考试”的整体框架。前面的训练范式（第 9 章）更多回答“如何教会学生”，而本节则搭好了“如何判卷”的标准。接下来在 10.3 节，我们会进一步关注<strong>安全性与鲁棒性</strong>，讨论当模型做错事、环境出问题时，系统应该如何设计防护与降级机制。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="安全性与鲁棒性"><a href="#安全性与鲁棒性" class="header">安全性与鲁棒性</a></h1>
<h3 id="1031-动作约束与可行性检查"><a class="header" href="#1031-动作约束与可行性检查">10.3.1 动作约束与可行性检查</a></h3>
<p>在一个由 VLA 驱动的机器人系统中，高层模型生成的是“倾向动作”（preferred action），而真正送到电机上的控制信号必须经过一层“安全外壳（safety shell）”。这一层的核心工作就是：给动作加上清晰的约束，并在执行前做可行性检查，必要时进行纠正或拒绝。</p>
<blockquote>
<p>【图片占位：一张“VLA 输出 → 动作约束与可行性检查模块 → 机器人控制器”的框图，标出各类约束（关节、速度、碰撞、安全区等）】</p>
</blockquote>
<h4 id="10311-动作约束"><a class="header" href="#10311-动作约束">10.3.1.1 动作约束</a></h4>
<p>“动作约束”可以理解为：在机器人的状态 (x) 与控制输入 (u) 上定义的一组条件
$$
g_i(x, u) \le 0,\quad h_j(x, u) = 0
$$
只要不满足，就视为“不安全”或“不可执行”。</p>
<p>可以从几个层次来理解这些约束：</p>
<ol>
<li><strong>本体级约束（robot-level constraints）</strong>
来自机械结构和驱动能力，是最基础、最“硬”的约束：
<ul>
<li><strong>关节位置范围</strong>：每个关节有最小 / 最大角度（或伸缩量），越界可能撞到机体或损坏丝杠。</li>
<li><strong>速度与加速度上限</strong>：限制关节运动的最大速度、加速度和加加速度（jerk），避免机械冲击和超出驱动能力。</li>
<li><strong>力 / 力矩上限</strong>：对末端执行器或者各关节输出的力矩做限制，协作机器人标准（如 ISO 10218 与 ISO/TS 15066）会对与人接触时的最大力、最大压力给出建议范围，以降低夹伤、撞击风险。(<a href="https://www.iso.org/obp/ui/es/?utm_source=chatgpt.com">国际标准化组织</a>)</li>
</ul>
</li>
<li><strong>工作空间与区域约束（workspace &amp; zone constraints）</strong>
<ul>
<li><strong>可达工作空间</strong>：根据机械结构，给出末端可达的体积区域；超出区域的目标位姿应当直接判定为不可达。</li>
<li><strong>禁入区域（keep-out zones）</strong>：例如人工作区域、精密仪器区域、危险设备附近；在规划时强制不生成穿越这些区域的轨迹。</li>
<li><strong>速度分区</strong>：靠近人或狭窄环境时自动切换到低速区域；部分协作机器人控制器就是通过“安全区 + 限速”配置来满足标准。(<a href="https://www.sick.com/kr/ko/w/blog-safety-collaborative-robot-applications/?utm_source=chatgpt.com">sick.com</a>)</li>
</ul>
</li>
<li><strong>任务级约束（task-level constraints）</strong>
<ul>
<li>姿态约束：比如端执行器抓杯子时要保持基本竖直，不让液体洒出；装配时保持插销与孔大致同轴。</li>
<li>接触约束：插入、打磨、擦拭等任务要求接触力在一定范围内，不得对工件或环境施加过大压力。</li>
<li>序列约束：某些动作必须在前置条件满足后才能执行（例如“只有抓取成功，才允许移动到远处放置”），可以在高层任务图或时序逻辑中显式表达。(<a href="https://h2r.cs.brown.edu/wp-content/uploads/yang24.pdf?utm_source=chatgpt.com">h2r.cs.brown.edu</a>)</li>
</ul>
</li>
<li><strong>舒适与质量约束（soft constraints）</strong>
这些约束不是“违法就报错停机”，而是进入代价函数，例如：
<ul>
<li>尽量减少频繁的大幅度关节摆动；</li>
<li>让运动轨迹更平滑、对人类观感更自然；</li>
<li>避免在用户附近进行“过于激烈”的动作。</li>
</ul>
</li>
</ol>
<p>在实现上，通常会把这些约束参数化并配置在机器人控制器或中间件中（很多协作机器人产品的“功能限制 / functional limits”页面就列出了电流、扭矩、速度的安全上限和相关模式）。(<a href="https://manual.doosanrobotics.com/en/user/2.10.3/3.-E-Series/functional-limits-of-each-robot-series?utm_source=chatgpt.com">manual.doosanrobotics.com</a>)</p>
<h4 id="10312-可行性检查"><a class="header" href="#10312-可行性检查">10.3.1.2 可行性检查</a></h4>
<p>有了约束，还需要检查一个候选动作是否满足这些约束。典型流程可以理解为：</p>
<blockquote>
<p>VLA 输出动作候选 (\hat{u}) → <strong>可行性检查器</strong> → 通过则执行，否则纠正 / 拒绝。</p>
</blockquote>
<p>常见的可行性检查包括：</p>
<ol>
<li><strong>几何与运动学检查</strong>
<ul>
<li><strong>关节约束检查</strong>：例如 VLA 输出的是关节增量 (\Delta q)，先计算 (q_{\text{new}} = q_{\text{current}} + \Delta q)，然后检查每个关节是否超出范围。</li>
<li><strong>逆运动学可行性</strong>：当 VLA 输出末端位姿目标时，需要求解逆运动学。若无解，或者唯一解处在奇异位形附近，则认为该动作不可行。</li>
<li><strong>路径内插检查</strong>：不仅要看起点和终点，线性插值或更细时间步的路径上，是否有中间状态违反关节或工作空间约束。</li>
</ul>
</li>
<li><strong>动力学与执行能力检查</strong>
<ul>
<li>根据当前状态与目标动作，估算所需关节扭矩、功率等，判断是否超出电机与驱动器的额定能力（这部分可利用动力学模型，也可用经验上限）。</li>
<li>对于高速操作或重载操作，尤其要检查制动距离和制动扭矩是否足够，否则在紧急停止时会出现“刹不住车”的风险。</li>
</ul>
</li>
<li><strong>碰撞与接触预测</strong>
<ul>
<li>运行一个简化的短时仿真（few steps look-ahead），利用当前环境的几何模型判断新的动作是否会导致与环境或自身发生碰撞、越过安全距离等。</li>
<li>一些工作会把形式化验证和时序逻辑（LTL）结合，利用“安全约束模块”在任务层就排除任何可能导致违反碰撞 / 区域限制的行为，使动作“先天安全”。(<a href="https://h2r.cs.brown.edu/wp-content/uploads/yang24.pdf?utm_source=chatgpt.com">h2r.cs.brown.edu</a>)</li>
</ul>
</li>
<li><strong>实时性考虑</strong>
可行性检查通常必须在毫秒级完成，因此不能用过于复杂的大规模仿真；工程上常采用：
<ul>
<li>预先离线生成查表（look-up table）；</li>
<li>把检查问题转化为一个小规模的二次规划（QP），快速求解最近的可行动作；</li>
<li>对 VLA 输出只做局部微调，而不是从零重新规划。</li>
</ul>
</li>
</ol>
<h4 id="10313-违约处理"><a class="header" href="#10313-违约处理">10.3.1.3 违约处理</a></h4>
<p>当某个候选动作违反约束或无法通过可行性检查时，系统需要有“违约处理策略”，而不是简单崩溃。常见做法可以分为三个层级：</p>
<ol>
<li><strong>投影 / 裁剪到安全集合（action projection）</strong>
最温和的做法是把不安全动作“拉回”安全区域，例如：
<ul>
<li>对速度、加速度进行裁剪（clipping）；</li>
<li>用一个带约束的优化问题寻找距离原动作最近的安全动作：
$$
u^* = \arg\min_{u} |u - \hat{u}|^2 \quad \text{s.t. } g_i(x, u)\le 0
$$
这样可以最大程度保持 VLA 原意，同时满足安全条件。</li>
</ul>
</li>
<li><strong>切换到安全策略（fallback policy）</strong>
当动作严重违反约束，或连续多次无法找到可行修正时，系统应切换到预定义的安全策略，例如：
<ul>
<li>停止当前任务，缓慢收回机械臂至“安全姿态”；</li>
<li>对移动机器人执行原地制动，然后缓慢退回到安全区域；</li>
<li>不再接受新的自动命令，等待人工确认或重置。</li>
</ul>
</li>
<li><strong>解释与人机交互</strong>
对于具身智能系统，仅仅“拒绝执行”是不够的，还应向用户解释原因并给出建议：
<ul>
<li>例如：“我无法把箱子放在这个位置，因为会超出工作空间，请选择离机器人近一点的位置。”</li>
<li>有研究专门探讨如何用自然语言解释任务不可达或违反约束的原因，从而帮助非专业用户理解机器人局限。(<a href="https://roboticsproceedings.org/rss09/p23.pdf?utm_source=chatgpt.com">Robotics Proceedings</a>)</li>
</ul>
</li>
</ol>
<p>这一节与 4.4.2 中“语言作为约束”的思想呼应：高层语言中隐含的安全规范，最终会在动作层体现为清晰可检查的约束与违约处理逻辑。</p>
<hr>
<h3 id="1032-碰撞检测与紧急停止机制"><a class="header" href="#1032-碰撞检测与紧急停止机制">10.3.2 碰撞检测与紧急停止机制</a></h3>
<p>动作约束与可行性检查主要针对“事前预防”。然而现实世界总是有意外：某个物体突然闯入轨迹、传感器读数失真、人的干预不在模型预期之内。因此，还需要“事后防御”：一旦发生异常接触，要在极短时间内检测出来并采取紧急措施。</p>
<blockquote>
<p>【图片占位：时间轴示意图：正常运动 → 外力接触 → 传感器检测 → 控制器触发碰撞事件 → 减速 / 停机。对比有/无紧急停止机制的区别】</p>
</blockquote>
<h4 id="10321-被动碰撞检测"><a class="header" href="#10321-被动碰撞检测">10.3.2.1 被动碰撞检测</a></h4>
<p>“被动”是指：机器人并不主动规划绕开障碍，而是在碰撞发生或即将发生时，通过本体传感器感知异常，从而触发反应。</p>
<p>典型的信息来源包括：</p>
<ol>
<li><strong>关节扭矩 / 电流残差</strong>
<ul>
<li>在理想无接触状态下，关节扭矩可以由动力学模型计算得到；实际测量的电机电流或扭矩与模型预测值之间的差异称为<strong>外力残差</strong>。</li>
<li>当这类残差超过某个阈值、并且持续一定时间，就可以判定发生了非计划的接触或碰撞。大量工作使用基于关节扭矩传感器或电流残差的碰撞检测与碰撞定位方法。(<a href="https://www.researchgate.net/publication/338939131_Collision_Detection_and_Isolation_on_a_Robot_using_Joint_Torque_Sensing?utm_source=chatgpt.com">ResearchGate</a>)</li>
<li>工业协作机械臂中，“力限位”“冲击检测”等功能，往往正是基于这种方法实现。</li>
</ul>
</li>
<li><strong>末端力 / 力矩传感器</strong>
<ul>
<li>在末端安装六维力 / 力矩传感器，可以直接测量手爪受到的外力。</li>
<li>只要外力超过安全阈值，就可以触发“力控模式”或紧急停止，避免持续压迫人体或损坏工件。</li>
</ul>
</li>
<li><strong>行为模式异常检测</strong>
<ul>
<li>通过学习正常运行时的轨迹、速度、扭矩模式，构建典型分布；当实时数据出现明显偏离时，即可视为异常。</li>
<li>类似的思想也常见于传感器故障检测与预测性维护中（利用深度学习或统计模型识别异常模式）。(<a href="https://www.mdpi.com/1424-8220/21/7/2547?utm_source=chatgpt.com">MDPI</a>)</li>
</ul>
</li>
</ol>
<p>工程上，被动碰撞检测的设计关键在于：**尽量快地检测真实碰撞，又要尽量少误报。**阈值过低会让系统频繁误停；过高则无法保证人机协作安全。</p>
<h4 id="10322-主动避障"><a class="header" href="#10322-主动避障">10.3.2.2 主动避障</a></h4>
<p>“主动避障”是事前预防的一部分，但它通常运行在比 VLA 更低的一层，与安全直接相关，因此放在本节一起讨论。</p>
<ol>
<li><strong>环境感知与距离场</strong>
<ul>
<li>利用深度相机、激光雷达等传感器构建周围环境的点云或网格地图，并计算到障碍物表面的最小距离。</li>
<li>将机器人本体简化为若干碰撞几何体（球体、圆柱等），实时估算机器人各部分与环境之间的最小距离，并与安全距离阈值比较。</li>
</ul>
</li>
<li><strong>速度与距离耦合（speed &amp; separation monitoring）</strong>
<ul>
<li>在协作机器人应用中，常用“速度与分离监控”：人与机器人之间距离越近，机器人允许的最大速度越小，当小于某个阈值时必须停止。相关原则在 ISO 10218 与 ISO/TS 15066 等标准中有明确讨论。(<a href="https://www.sick.com/kr/ko/w/blog-safety-collaborative-robot-applications/?utm_source=chatgpt.com">sick.com</a>)</li>
<li>简单实现方式是基于激光扫描或安全光幕进行“区域触发”，高级实现则结合 3D 视觉与人体关键点检测动态估计人位置。</li>
</ul>
</li>
<li><strong>局部避障与轨迹修正</strong>
<ul>
<li>即使 VLA 给出的高层动作不考虑局部障碍，低层也可以利用局部规划器在短时间范围内进行微调，例如基于势场法、动态窗口法（DWA）等。</li>
<li>对机械臂，可以在约束优化中加入障碍距离约束，让每个控制周期生成的关节速度都在“远离障碍物”的方向上。</li>
</ul>
</li>
</ol>
<h4 id="10323-紧急停止"><a class="header" href="#10323-紧急停止">10.3.2.3 紧急停止</a></h4>
<p>紧急停止（Emergency Stop, E-stop）是安全设计的最后一道防线，也是工业标准中最关键的要求之一。(<a href="https://www.automate.org/robotics/news/updated-iso-10218-major-advancements-in-industrial-robot-safety-standards-now-available?utm_source=chatgpt.com">Automate</a>)</p>
<ol>
<li><strong>硬件级紧急停止</strong>
<ul>
<li>物理急停按钮、拉绳开关、安全继电器等属于“硬件链路”，一旦触发会<strong>直接切断电机动力</strong>或使系统进入受控停机模式。</li>
<li>工程上通常采用双通道冗余设计：只要任一通道检测到急停信号，就会进入停机过程，并通过安全 PLC 或继电器确保不会被软件覆盖。</li>
</ul>
</li>
<li><strong>软件级紧急停止与安全监控线程</strong>
<ul>
<li>在机器人操作系统中，一般会有一个高优先级的“安全线程”，独立于 VLA 推理和普通任务调度，专门监控：
<ul>
<li>碰撞检测信号；</li>
<li>传感器严重失效、通信中断；</li>
<li>速度 / 位置越界；</li>
<li>语言层“立即停止”指令。</li>
</ul>
</li>
<li>一旦条件满足，该线程向底层控制器发出“紧急停止”命令，优先级高于一切普通指令。</li>
</ul>
</li>
<li><strong>停止类别与停机策略</strong>
<ul>
<li>实际系统中，常区分“立即断电停机”和“受控减速后停机”两种类别，以兼顾安全性和机械寿命。</li>
<li>对具身智能机器人而言，还应考虑停机后的状态：是保持当前位置锁死，还是缓慢回到安全姿态，以及如何在语言层向用户说明“刚刚发生了什么”。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1033-对传感器噪声遮挡失效的鲁棒性设计"><a class="header" href="#1033-对传感器噪声遮挡失效的鲁棒性设计">10.3.3 对传感器噪声、遮挡、失效的鲁棒性设计</a></h3>
<p>具身智能系统高度依赖多种传感器：相机、激光雷达、IMU、关节编码器、力觉……这些传感器现实中会被噪声、遮挡、老化、故障等问题困扰。如果不做鲁棒性设计，VLA 决策再聪明也可能被“垃圾输入”误导。</p>
<p>这一节可以与 3.4（视觉工程考虑）以及 7.3（数据清洗与异常轨迹）形成呼应：前者强调“如何获得好输入”，本节强调“输入变坏时系统如何自保”。</p>
<blockquote>
<p>【图片占位：一个状态机图：正常模式 →（轻微异常）受限模式 →（严重异常）安全停机；旁边标注不同传感器异常的触发条件】</p>
</blockquote>
<h4 id="10331-传感器校验"><a class="header" href="#10331-传感器校验">10.3.3.1 传感器校验</a></h4>
<p>校验的目标很简单：<strong>先判断“这路传感器是否还可信”，再考虑怎么用。</strong></p>
<ol>
<li><strong>数值范围与物理一致性检查</strong>
<ul>
<li>对每类传感器配置合理的数值范围与变化速率：例如距离传感器不可能突然从 1m 跳到 -5m，图像亮度直方图不应长期为全零或全饱和。</li>
<li>利用简单的物理关系进行交叉校验：
<ul>
<li>轮速计与视觉里程计对比；</li>
<li>IMU 测得重力方向与机器人姿态估计比对；</li>
<li>关节编码器与末端位姿之间的几何关系是否一致。</li>
</ul>
</li>
</ul>
</li>
<li><strong>时序和刷新率监控</strong>
<ul>
<li>每条数据带时间戳，可以检测是否长期不更新（“卡帧”），或者更新频率突然下降（网络或驱动异常）。</li>
<li>对实时性要求高的控制回路，一旦传感器数据延迟或丢包超过阈值，应立即触发降级或停机。</li>
</ul>
</li>
<li><strong>故障检测与隔离（FDI）机制</strong>
<ul>
<li>在控制与自动化领域，多传感器故障检测与 Isolation（FDI）是一门成熟方向，常使用残差分析、统计检测或深度学习模型识别异常传感器。(<a href="https://www.mdpi.com/1424-8220/21/7/2547?utm_source=chatgpt.com">MDPI</a>)</li>
<li>关键思想是：与其直接信任某个传感器，不如先学一个“正常模式”的统计模型，偏离模型的传感器数据就被标记为可疑。</li>
</ul>
</li>
</ol>
<h4 id="10332-多传感器融合"><a class="header" href="#10332-多传感器融合">10.3.3.2 多传感器融合</a></h4>
<p>多传感器融合不仅提升估计精度，更重要的是：<strong>当某一个传感器变差时，系统仍能依靠其他传感器维持一个“够用”的认知。</strong></p>
<p>可以从三层来看融合方式：(<a href="https://www.sciencedirect.com/science/article/abs/pii/S1566253517300246?utm_source=chatgpt.com">科学直通车</a>)</p>
<ol>
<li><strong>数据层融合（raw data fusion）</strong>
<ul>
<li>典型如把 LiDAR 点云投影到相机图像上，得到带语义标签的彩色点云；或者把多路麦克风信号合成波束。</li>
<li>此时 FDI 也可直接在原始数据上进行：例如同一物体在不同传感器视角下的几何形状应当一致。</li>
</ul>
</li>
<li><strong>特征层融合（feature-level fusion）</strong>
<ul>
<li>各传感器分别用神经网络编码为特征，再在后续网络中拼接或加权。</li>
<li>如果某个传感器被判定为异常，可以降低或清零它的特征权重，从而减小对决策的影响。</li>
</ul>
</li>
<li><strong>决策层融合（decision-level fusion）</strong>
<ul>
<li>不同传感器流水线各自给出独立判断（例如“前方 1.2m 有障碍物” vs “前方安全”），再由一个上层逻辑做投票或加权决策。</li>
<li>这种方式实现较简单，适合在已有“黑盒模块”基础上加一层安全逻辑。</li>
</ul>
</li>
</ol>
<p>在具身智能场景中，一种常见架构是：<strong>底层定位与地图构建由传统滤波或图优化方法负责（如 EKF / SLAM），上层 VLA 读取的是经过滤波、融合后的状态估计</strong>，从而减少大模型与传感器噪声直接打交道的机会。</p>
<h4 id="10333-降级模式"><a class="header" href="#10333-降级模式">10.3.3.3 降级模式</a></h4>
<p>即便已经做了校验与融合，仍需承认：<strong>某些情况下，系统无法再安全地完成原定任务</strong>——这时就需要“降级模式（degraded modes）”。</p>
<ol>
<li><strong>分级运行模式设计</strong>
<ul>
<li><strong>正常模式</strong>：所有关键传感器工作正常，允许全功能操作。</li>
<li><strong>受限模式</strong>：某一路关键传感器退化或失效，但其余传感器仍可支撑基本安全；此时限制速度、缩小工作空间、停止高风险任务（如人与机器人紧密协作的操作）。</li>
<li><strong>安全停机模式</strong>：多路传感器失效或定位严重不可靠，只允许执行“收回机械臂、关闭夹爪、停止移动”等保守动作，最终停机等待人工介入。</li>
</ul>
</li>
<li><strong>故障容错与控制重构</strong>
<ul>
<li>对移动机器人或多机器人系统，可以针对某类传感器（例如 LiDAR）设计专门的<strong>容错控制（fault-tolerant control）</strong>，在检测到某个机器人雷达故障时，通过其他传感器或队友信息重构控制律。(<a href="https://www.nature.com/articles/s41598-024-75500-3?utm_source=chatgpt.com">Nature</a>)</li>
<li>对单机器人来说，类似思路是：当视觉定位失效时，短时间内利用里程计与 IMU 进行“盲走”，同时减少动作幅度。</li>
</ul>
</li>
<li><strong>VLA 层的自适应与通告</strong>
<ul>
<li>在高层，VLA 模型应当获得当前系统“健康状态”的摘要（例如一组 health flags），从而在降级模式下自动偏向更保守的动作策略。</li>
<li>与此同时，机器人应通过语言或 UI 通知用户：“目前视觉传感器受到遮挡，我会降低速度并限制动作，仅执行简单搬运任务。”</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1034-语言层面安全禁止指令与约束模板"><a class="header" href="#1034-语言层面安全禁止指令与约束模板">10.3.4 语言层面安全：禁止指令与约束模板</a></h3>
<p>随着大语言模型融入机器人系统，越来越多的指令将直接以自然语言形式发给机器人。这极大提升了易用性，也带来了一个新问题：</p>
<blockquote>
<p><strong>并不是所有“听起来合理”的语言指令都是安全的。</strong></p>
</blockquote>
<p>例如，“把这箱电池扔到楼下垃圾桶”“你能推开那个人吗？”——这些都不应被机器人照单全收。近期有工作专门研究“利用语言模型拒绝违反社会规范或安全规范的指令”，用于机器人指令过滤与拒绝。(<a href="https://dl.acm.org/doi/fullHtml/10.1145/3687272.3688319?utm_source=chatgpt.com">ACM Digital Library</a>)</p>
<blockquote>
<p>【图片占位：一张“用户语言指令 → 语言过滤 / 约束模块 →（安全指令）VLA → 动作”流程图，旁边标出“黑名单指令”“约束模板”“安全确认”三个组件】</p>
</blockquote>
<h4 id="10341-黑名单指令"><a class="header" href="#10341-黑名单指令">10.3.4.1 黑名单指令</a></h4>
<p>**黑名单（deny-list）**是语言层安全最直接的手段：</p>
<ol>
<li><strong>显式关键词与模式</strong>
<ul>
<li>定义一批明显危险的关键词或短语，如“伤害”“攻击”“摧毁”“扔出窗外”等，在特定领域还可以加入专业危险动作（例如“解除安全围栏”“提升到最大速度运转”）。</li>
<li>一旦用户指令中出现这些模式，系统可以直接拒绝执行，或者进入更严格的审核流程。</li>
</ul>
</li>
<li><strong>语义级黑名单</strong>
<ul>
<li>关键词匹配容易被用户绕过，例如“轻轻地撞开那个人”和“让他离开”在词面上差别很大，但前者显然危险。</li>
<li>可以训练一个小型分类器或利用 LLM 对指令进行“安全性判定”，将其归类为“安全 / 不安全 / 存疑”，而不是简单字符串匹配。相关研究表明，LLM 在识别违反社会规范、暴力或违法命令方面具有一定的能力，可作为一层“道德过滤器”。(<a href="https://dl.acm.org/doi/fullHtml/10.1145/3687272.3688319?utm_source=chatgpt.com">ACM Digital Library</a>)</li>
</ul>
</li>
<li><strong>与物理约束联动</strong>
<ul>
<li>黑名单不应只停留在文本层面，而是与实际机器人能力结合，例如：
<ul>
<li>即使用户指令中没有出现“伤害”“攻击”等字样，只要推理后对应的是“用机械臂对人施加大力”，也应被判为黑名单。</li>
</ul>
</li>
<li>这就需要把动作空间中的“禁忌区域”映射回语言空间，从而构造更智能的黑名单。</li>
</ul>
</li>
</ol>
<h4 id="10342-语言过滤"><a class="header" href="#10342-语言过滤">10.3.4.2 语言过滤</a></h4>
<p>在黑名单之外，还可以通过更柔性的“语言过滤（language filtering）”来引导机器人行为落在安全范围内，而不是简单拒绝。</p>
<ol>
<li><strong>语言到形式化约束的映射</strong>
<ul>
<li>一类工作尝试将自然语言约束（如“不要进入红线以外的区域”“不要碰到桌上的易碎物品”）映射为时序逻辑（如 LTL）约束，然后在规划或控制时强制满足这些约束。(<a href="https://h2r.cs.brown.edu/wp-content/uploads/yang24.pdf?utm_source=chatgpt.com">h2r.cs.brown.edu</a>)</li>
<li>例如，“始终保持与人至少 50cm 距离”可以转为“在所有时间步上，人机距离 (d(t) \ge 0.5) m”的约束，规划器或安全芯片会自动剪除任何违反该约束的候选动作。</li>
</ul>
</li>
<li><strong>为 RL / VLA 提供文本形式的安全约束</strong>
<ul>
<li>在强化学习与决策模型中，可以把安全需求写成自然语言约束，让算法同时学习“如何完成任务”和“哪些事情不能做”。这样的算法会在策略优化时保证违反约束的概率控制在安全范围内。(<a href="https://proceedings.neurips.cc/paper/2021/file/72f67e70f6b7cdc4cc893edaddf0c4c6-Paper.pdf?utm_source=chatgpt.com">NeurIPS 会议录</a>)</li>
<li>对于 VLA 模型而言，可以把这些约束模板拼到输入 prompt 中，使模型在推理动作时自动考虑“禁止行为列表”。</li>
</ul>
</li>
<li><strong>指令重写与弱化</strong>
<ul>
<li>对于“危险但可重写”的指令，可以由语言前端先进行改写，例如：
<ul>
<li>用户：“把这瓶玻璃矿泉水砸碎试试。”
机器人重写为：“将瓶子轻放到桌上，并说明我无法安全地砸碎它。”</li>
</ul>
</li>
<li>这类“指令重写”可以有效降低误用风险，同时保持对话体验自然（不会频繁出现硬拒绝）。</li>
</ul>
</li>
</ol>
<h4 id="10343-安全确认"><a class="header" href="#10343-安全确认">10.3.4.3 安全确认</a></h4>
<p>在很多场景中，指令并非明显非法或危险，而是<strong>存在歧义或潜在风险</strong>。这时更合理的做法是：让机器人主动发起安全确认（safety confirmation），补齐上下文。</p>
<ol>
<li><strong>模糊指令的澄清</strong>
<ul>
<li>当任务目标不清晰、可能有多种实现方式，且某些方式存在风险时，机器人应回问：
<ul>
<li>“你希望我把它‘丢掉’是指放进垃圾桶，还是放回原来的盒子里？”</li>
</ul>
</li>
<li>这本质上是把“选择风险等级”的权力交还给用户，同时让人承担必要的决策责任。(<a href="https://arxiv.org/html/2406.04086v4?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>高风险操作的双重确认</strong>
<ul>
<li>对于某些“高能量、高影响”的动作（例如移动重物、靠近人脸、操作危险工具），可以强制采用“双确认”机制：
<ul>
<li>语言上用户确认一次；</li>
<li>物理按键或图形界面再确认一次（类似医疗设备和工业大机组的操作流程）。</li>
</ul>
</li>
<li>系统还可以在确认前用自然语言解释风险，比如：“执行这个操作时，机器人需要高速运动并靠近你，请确认周围无人并站在安全区域。”</li>
</ul>
</li>
<li><strong>对不可达任务的解释与替代方案</strong>
<ul>
<li>当一个命令在物理、法规或伦理层面不可执行时，直接说“不行”会让用户感到挫败。更好的方式是：
<ul>
<li>明确说明哪一条约束被违反（如安全距离、负载能力、法规限制）；</li>
<li>给出至少一个安全的替代方案（如“我可以把物体放到窗台而不是扔出窗外”）。(<a href="https://roboticsproceedings.org/rss09/p23.pdf?utm_source=chatgpt.com">Robotics Proceedings</a>)</li>
</ul>
</li>
</ul>
</li>
</ol>
<hr>
<p>本节从动作层、碰撞层、传感器层到语言层，给出了一套多层次的安全与鲁棒性设计思路。与 6 章的“机器人控制基础”和 10.1–10.2 的“系统集成与评测”相结合，你可以把具身智能机器人想象成一个被多重安全壳包裹的系统：最内层是 VLA 的“聪明大脑”，外围是一层层约束、监控、降级与解释机制，共同保证它在真实世界中既“能干事”，又“不闯祸”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="工程优化与压缩"><a href="#工程优化与压缩" class="header">工程优化与压缩</a></h1>
<h3 id="1041-模型压缩与蒸馏distillation"><a class="header" href="#1041-模型压缩与蒸馏distillation">10.4.1 模型压缩与蒸馏（distillation）</a></h3>
<p>在前面章节中，我们更多讨论了“怎么让 VLA 变强”；本节开始讨论另一面：<strong>怎么让它变“轻”、变“快”，但不变“傻”</strong>。模型压缩与知识蒸馏是目前在大模型落地中最成熟的一类技术路径。(<a href="https://www.mdpi.com/2073-431X/12/3/60?utm_source=chatgpt.com">MDPI</a>)</p>
<hr>
<h4 id="10411-压缩必要性"><a class="header" href="#10411-压缩必要性">10.4.1.1 压缩必要性</a></h4>
<p>VLA 模型通常同时包含视觉 backbone、语言 backbone 和动作解码器三部分，很多工作使用数十亿参数量级的 Transformer 作为核心，例如 7B 规模的 OpenVLA、以及更大的 RT-2 系列。(<a href="https://arxiv.org/html/2406.09246v3?utm_source=chatgpt.com">arXiv</a>) 这类模型在训练时可以依赖数据中心 GPU 集群，但在真实机器人上部署，就会遇到几个非常现实的问题：</p>
<ul>
<li><strong>算力与能耗限制</strong>：移动机器人、机械臂控制箱上常见的是 Jetson、Coral TPU、嵌入式 CPU+小 GPU 等边缘设备，其功耗和峰值算力远低于服务器级 GPU。(<a href="https://thinkrobotics.com/blogs/learn/edge-ai-accelerators-jetson-vs-coral-tpu-a-detailed-comparison-for-developers?srsltid=AfmBOoouqKn4r1ERD_lngz4q-5gOas0IBGSuSWMsOoCEQPfK8aYbVskh&amp;utm_source=chatgpt.com">ThinkRobotics.com</a>)</li>
<li><strong>时延约束</strong>：具身智能强调“感知–决策–控制”的闭环，闭环延迟需要控制在几十毫秒到百毫秒以内，否则机器人看到的永远是“过去的世界”，容易动作滞后甚至撞人。(<a href="https://www.mdpi.com/2076-3417/15/13/7533?utm_source=chatgpt.com">MDPI</a>)</li>
<li><strong>存储与内存瓶颈</strong>：一个 7B 级别全精度模型单权重就需要数十 GB 存储，更不要说中间激活占用，对 8 GB～16 GB 内存的嵌入式平台来说几乎是灾难。(<a href="https://www.mdpi.com/2073-431X/12/3/60?utm_source=chatgpt.com">MDPI</a>)</li>
<li><strong>系统级共享资源</strong>：机器人还要运行 SLAM、运动规划、传感器驱动等模块，VLA 只是其中一员，不能“独占”全部资源。</li>
</ul>
<p>综上，对于部署在机器人端的 VLA 来说，<strong>参数量、计算量和带宽</strong>都是必须正面面对的工程约束。模型压缩的目标，就是在尽量保持任务性能的前提下，系统性地降低模型复杂度。主流压缩手段可以概括为：剪枝（Pruning）、量化（Quantization）、低秩分解（Low-Rank Decomposition）、结构化轻量设计和知识蒸馏（Knowledge Distillation）。(<a href="https://papers.ssrn.com/sol3/papers.cfm?abstract_id=4893335&amp;utm_source=chatgpt.com">SSRN</a>)</p>
<blockquote>
<p>【图 10-4-1 占位：绘制“模型大小–推理延迟–任务成功率”三者关系的示意图，展示压缩之后延迟明显下降，但成功率只略有下降的趋势曲线。】</p>
</blockquote>
<p>在 VLA 场景下，知识蒸馏尤为重要，因为它不仅能“压缩参数”，更能“迁移大模型中已经学到的多模态知识和策略”，这是下一小节要重点展开的内容。(<a href="https://dl.acm.org/doi/abs/10.1007/s11263-021-01453-z?utm_source=chatgpt.com">ACM Digital Library</a>)</p>
<hr>
<h4 id="10412-蒸馏方法"><a class="header" href="#10412-蒸馏方法">10.4.1.2 蒸馏方法</a></h4>
<p>**知识蒸馏（Knowledge Distillation）**的典型形式是：用一个性能更强、规模更大的“教师模型（Teacher）”，去指导一个更小、更轻量的“学生模型（Student）”学习。学生不仅学习标注数据上的“正确答案”，还学习教师模型对各类候选答案的“偏好分布”，从而在小规模参数下尽量接近大模型性能。(<a href="https://dl.acm.org/doi/abs/10.1007/s11263-021-01453-z?utm_source=chatgpt.com">ACM Digital Library</a>)</p>
<p>从“学什么”的角度，常见蒸馏知识类型可以分为三类：(<a href="https://dl.acm.org/doi/abs/10.1007/s11263-021-01453-z?utm_source=chatgpt.com">ACM Digital Library</a>)</p>
<ol>
<li><strong>响应级（Response-based）蒸馏</strong>
<ul>
<li>直接对齐教师和学生的输出分布，例如分类任务中的 softmax 概率、VLA 中动作 token 的概率分布。</li>
<li>通常使用带温度的 KL 散度或交叉熵作为蒸馏损失，使学生模仿教师的“软标签”，而不是仅仅拟合 one-hot 的硬标签。</li>
</ul>
</li>
<li><strong>特征级（Feature-based）蒸馏</strong>
<ul>
<li>对齐中间层特征，如视觉 encoder 最后一层的特征图、融合后的多模态表示、动作解码器中间隐藏状态等。</li>
<li>通过 L2 损失、注意力矩阵对齐等方式，使学生在内部表征空间上接近教师，有利于迁移高层语义与多模态对齐能力。</li>
</ul>
</li>
<li><strong>关系级（Relation-based）蒸馏</strong>
<ul>
<li>不直接约束特征本身，而约束样本之间、模态之间的关系，例如特征相似度矩阵、注意力图、token 间的相对关系等。</li>
<li>对于 VLA 来说，可以蒸馏“视觉 token 与语言 token 之间的相关性模式”，帮助学生学会在图像和指令之间建立类似的注意力结构。</li>
</ul>
</li>
</ol>
<p>在机器人 VLA 场景中，还经常会用到两类“面向策略”的蒸馏变体：</p>
<ul>
<li><strong>策略蒸馏（Policy Distillation）</strong>：教师可以是一个使用 RL/IL 训练出来的高性能策略，学生学习在同样的状态输入下输出接近的动作分布，用于把多个任务或多个机器人上的策略压缩到一个统一学生模型中。</li>
<li><strong>多模态联合蒸馏</strong>：同时对视觉编码器、语言编码器和动作解码部分进行蒸馏，例如在视觉、语言和动作三个通道都加入蒸馏损失，保证学生不仅“会做”，还“看得懂、听得懂”。</li>
</ul>
<blockquote>
<p>【图 10-4-2 占位：教师–学生结构示意图。左侧为大 VLA，右侧为小 VLA，标注“输出蒸馏”“中间特征蒸馏”“注意力关系蒸馏”等不同连线。】</p>
</blockquote>
<hr>
<h4 id="10413-蒸馏过程"><a class="header" href="#10413-蒸馏过程">10.4.1.3 蒸馏过程</a></h4>
<p>从工程视角出发，可以把一个 VLA 的蒸馏工程拆解为几个明确步骤：</p>
<ol>
<li><strong>确定教师模型与学生模型架构</strong>
<ul>
<li>教师模型通常是已经在大规模数据上训练好的通用 VLA，例如一个 7B 级 OpenVLA 或更大的 RT-2 风格模型。(<a href="https://arxiv.org/html/2406.09246v3?utm_source=chatgpt.com">arXiv</a>)</li>
<li>学生模型采用更小的隐藏维度、更少的层数、更窄的多头注意力，甚至采用专门为嵌入式设计的轻量结构（如 MobileNet 样式视觉 encoder + 小型 Transformer 解码器）。</li>
</ul>
</li>
<li><strong>构建蒸馏数据集</strong>
<ul>
<li><strong>离线蒸馏</strong>：在已有的机器人示教数据（图像、语言指令、动作轨迹）上，额外调用教师模型生成输出分布和中间特征，作为蒸馏监督。</li>
<li><strong>在线/交互式蒸馏</strong>：在仿真环境中让教师与环境交互，教师执行策略、学生在旁“抄作业”；甚至可以采用多次 rollout，不断扩充训练集。</li>
</ul>
</li>
<li><strong>设计损失函数与权重</strong>
通常会将“任务损失”和“蒸馏损失”进行加权组合：
$$
L = \lambda_{\text{task}} L_{\text{task}} + \lambda_{\text{distill}} L_{\text{distill}}
$$
<ul>
<li>(L_{\text{task}})：来自真实标签的监督损失，如动作 token 的交叉熵、任务成功/失败的 BCE 等。</li>
<li>(L_{\text{distill}})：包括输出分布的 KL 散度、特征对齐的 L2 损失、注意力矩阵对齐等。</li>
<li>温度参数 (T) 通常会用来“软化”教师输出，让学生更容易学习类别或动作之间的细微偏好差异。(<a href="https://dl.acm.org/doi/abs/10.1007/s11263-021-01453-z?utm_source=chatgpt.com">ACM Digital Library</a>)</li>
</ul>
</li>
<li><strong>训练流程与策略</strong>
<ul>
<li>先在蒸馏数据上进行若干轮“纯蒸馏训练”，使学生快速对齐教师的整体行为。</li>
<li>再加入小批量真实环境数据或额外 BC/RL 微调，以防学生只会模仿教师的习惯，而无法适应真实机器人噪声和物理细节。</li>
<li>若目标是量化部署（见 10.4.2），可直接在蒸馏过程中采用低精度学生模型（如 int8 仿真），进行“量化感知蒸馏”，让学生一开始就适应量化带来的噪声。(<a href="https://www.researchgate.net/publication/384959628_Neural_Network_Compression_and_Knowledge_Distillation_Tutorial_and_Survey?utm_source=chatgpt.com">ResearchGate</a>)</li>
</ul>
</li>
<li><strong>评估与安全验证</strong>
<ul>
<li>在标准基准（如 VLA Bench 或实验室自建任务集）上对比教师与学生的任务成功率、泛化能力、失误类型。(<a href="https://openaccess.thecvf.com/content/ICCV2025/papers/Zhang_VLABench_A_Large-Scale_Benchmark_for_Language-Conditioned_Robotics_Manipulation_with_Long-Horizon_ICCV_2025_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</li>
<li>在真实机器人上逐步“放权”：先低速、单任务、无人体场景测试，再逐步增加复杂度，确认蒸馏过程中没有引入危险行为或异常策略。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 10-4-3 占位：蒸馏流程时序图，从“数据采集/仿真 -&gt; 教师打标签 -&gt; 学生训练 -&gt; 部署验证”的流程图。】</p>
</blockquote>
<p>蒸馏在本章后面会与量化、边缘部署结合，构成“<strong>小模型 VLA</strong>”的主力技术路线，为机器人提供可负担的智能大脑。</p>
<hr>
<h3 id="1042-quantization量化与推理效率优化"><a class="header" href="#1042-quantization量化与推理效率优化">10.4.2 Quantization（量化）与推理效率优化</a></h3>
<p>如果说蒸馏是“换一个更小的脑袋”，那么量化就是“用更节省的数字来存储和运算同一个脑袋”。在当前软硬件生态下，量化几乎是所有边缘部署流水线的标配。(<a href="https://developer.nvidia.com/blog/model-quantization-concepts-methods-and-why-it-matters/?utm_source=chatgpt.com">NVIDIA Developer</a>)</p>
<hr>
<h4 id="10421-模型量化"><a class="header" href="#10421-模型量化">10.4.2.1 模型量化</a></h4>
<p>**模型量化（Model Quantization）**指的是将模型中的权重和激活从高精度的浮点数（如 FP32）映射为低比特表示（如 FP16、INT8，甚至 4 bit），从而大幅降低存储和计算成本：(<a href="https://www.mdpi.com/2073-431X/12/3/60?utm_source=chatgpt.com">MDPI</a>)</p>
<ul>
<li><strong>存储节省</strong>：从 FP32 到 INT8，理论上权重存储可减为原来的 1/4，意味着在相同显存/内存条件下可以加载更大的模型，或者运行更多模型。</li>
<li><strong>计算加速</strong>：许多边缘硬件（如 Jetson Tensor Cores、Edge TPU）对低精度整数矩阵乘法做了专门优化，INT8 运算吞吐远高于 FP32。(<a href="https://forums.developer.nvidia.com/t/how-to-run-a-deep-learning-model-on-tpu/246350?utm_source=chatgpt.com">NVIDIA Developer Forums</a>)</li>
<li><strong>带宽降低</strong>：更短的表示意味着从内存到计算单元的数据传输压力减轻，有助于提高整体吞吐。</li>
</ul>
<p>量化本质上是在一个有限整数区间（如 ([-128, 127])）上，用一个线性比例因子（scale）和零点（zero-point）去近似原始的浮点范围。不同层、不同张量可以有不同的 scale/zero-point，以减小量化误差。(<a href="https://huggingface.co/docs/optimum/en/concept_guides/quantization?utm_source=chatgpt.com">Hugging Face</a>)</p>
<blockquote>
<p>【图 10-4-4 占位：示意一维浮点分布被线性映射到 INT8 离散格点的示意图，标出 scale 与 zero-point。】</p>
</blockquote>
<p>对于 VLA 这类 Transformer 模型，量化时还要考虑：</p>
<ul>
<li>对 <strong>Embedding 层、输出 logits 层、LayerNorm 参数</strong>等通常更敏感，往往保留在 FP16/BF16，而对大部分线性层、注意力投影层做 INT8 量化，形成**混合精度（Mixed-Precision）**方案。(<a href="https://developer.nvidia.com/blog/model-quantization-concepts-methods-and-why-it-matters/?utm_source=chatgpt.com">NVIDIA Developer</a>)</li>
<li>对视觉 backbone（CNN/ViT）则更容易采用静态 INT8 量化，因为特征分布相对稳定，硬件支持也更成熟。</li>
</ul>
<hr>
<h4 id="10422-量化方法"><a class="header" href="#10422-量化方法">10.4.2.2 量化方法</a></h4>
<p>从“在训练流程中的位置”看，常用的量化策略可以分为三大类：(<a href="https://huggingface.co/docs/optimum/en/concept_guides/quantization?utm_source=chatgpt.com">Hugging Face</a>)</p>
<ol>
<li><strong>训练后量化（Post-Training Quantization, PTQ）</strong>
不再重新训练模型，只在训练完成的 FP32/FP16 模型基础上进行转换。
<ul>
<li><strong>动态量化（Dynamic Quantization）</strong>
<ul>
<li>典型用法：权重在离线阶段量化为 INT8，激活在运行时根据当前 batch 的实际取值动态计算量化参数。</li>
<li>优点：不需要额外的“校准（calibration）”数据，适合 Transformer 和 RNN 等序列模型。(<a href="https://onnxruntime.ai/docs/performance/model-optimizations/quantization.html?utm_source=chatgpt.com">onnxruntime.ai</a>)</li>
</ul>
</li>
<li><strong>静态量化（Static Quantization）</strong>
<ul>
<li>在转换阶段使用一个小的代表性数据集，通过若干次前向推理统计各层激活的 min/max 或直方图分布，离线确定量化区间。</li>
<li>推理时权重和激活都使用固定的 INT8 区间，适合 CNN 和视觉 backbone，可获得更好的推理加速。(<a href="https://ai.google.dev/edge/litert/models/post_training_quantization?utm_source=chatgpt.com">Google AI for Developers</a>)</li>
</ul>
</li>
</ul>
</li>
<li><strong>量化感知训练（Quantization-Aware Training, QAT）</strong>
当简单的 PTQ 带来的精度下降无法接受时，可以在训练阶段“模拟量化”：
<ul>
<li>在前向中插入“假量化（fake quantization）”算子，把权重和激活“截断”为低比特表示，在反向传播时仍使用高精度更新。</li>
<li>通过这种方式，模型在训练中逐渐适应量化噪声，最终在真实 INT8/INT4 部署时精度损失更小。(<a href="https://datature.com/blog/introducing-post-training-quantization-feature-and-mechanics-explained?utm_source=chatgpt.com">datature.com</a>)</li>
<li>对 VLA 这种长序列 Transformer，QAT 成本较高，但在关键组件（如动作解码器）上进行局部 QAT，往往能取得不错的折中。</li>
</ul>
</li>
<li><strong>混合精度与分层量化</strong>
<ul>
<li>在 GPU 上常见的 FP16/BF16 + FP32 混合精度，本质上也是一种量化形式，只不过比特数仍然较高。(<a href="https://developer.nvidia.com/blog/model-quantization-concepts-methods-and-why-it-matters/?utm_source=chatgpt.com">NVIDIA Developer</a>)</li>
<li>在更激进的方案里，可以对不同层使用不同 bit-width（如主干 INT8，部分线性层 INT4），甚至结合蒸馏，让低比特学生从高精度教师中学习对量化噪声不敏感的表示。</li>
</ul>
</li>
</ol>
<p>在工程实践中，一个较为稳妥的路线是：<strong>先做 FP16 混合精度 + 图优化</strong>，如果仍无法满足实时性，再尝试 INT8 PTQ，最后针对关键模块上 QAT 或更低比特。</p>
<hr>
<h4 id="10423-推理优化"><a class="header" href="#10423-推理优化">10.4.2.3 推理优化</a></h4>
<p>量化只是“瘦身”的一部分，要真正达到实时控制的要求，还需要一整套**推理优化（Inference Optimization）**手段，从模型图到系统调度都要动手术。(<a href="https://onnxruntime.ai/docs/performance/model-optimizations/quantization.html?utm_source=chatgpt.com">onnxruntime.ai</a>)</p>
<ol>
<li><strong>图级与算子级优化</strong>
<ul>
<li>利用 TensorRT、ONNX Runtime、TVM 等工具进行图优化：算子融合（如 Conv+BN+ReLU）、常量折叠、消除冗余分支等。(<a href="https://onnxruntime.ai/docs/performance/model-optimizations/quantization.html?utm_source=chatgpt.com">onnxruntime.ai</a>)</li>
<li>针对特定硬件选择高效 kernel，例如在 Jetson 上启用 Tensor Cores 的 FP16/INT8 kernel，在 Edge TPU 上使用 TFLite 编译器生成专用计算图。(<a href="https://forums.developer.nvidia.com/t/how-to-run-a-deep-learning-model-on-tpu/246350?utm_source=chatgpt.com">NVIDIA Developer Forums</a>)</li>
</ul>
</li>
<li><strong>输入输出与批处理策略</strong>
<ul>
<li>机器人控制多为 batch=1 的在线模式，但同一时刻可以并行处理多路传感或多步规划，需合理设计异步队列。</li>
<li>适当降低图像分辨率、缩短语言上下文长度、限制历史轨迹长度，都可以有效减小 VLA 的序列长度和计算量。</li>
</ul>
</li>
<li><strong>系统级调度与并行</strong>
<ul>
<li>将视觉预处理、VLA 推理和低层控制放在不同线程/进程，用共享内存或零拷贝（zero-copy）减少数据复制开销。</li>
<li>使用优先级队列，对时延敏感的控制循环（例如避障）给予更高优先级，大模型推理则在后台或较低频率运行。(<a href="https://www.mdpi.com/2076-3417/15/13/7533?utm_source=chatgpt.com">MDPI</a>)</li>
</ul>
</li>
<li><strong>缓存与重用</strong>
<ul>
<li>对语言指令等不变部分，可以预先编码缓存，仅对每一帧变化的视觉和状态信息重新计算。</li>
<li>对长 horizon 任务，可采用增量注意力缓存（KV cache），在每一步仅对新 token 做注意力计算，减少平方级开销（具体细节可回顾 Transformer 部分的复杂度分析）。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 10-4-5 占位：机器人系统推理流水线示意图，从“相机帧 -&gt; 预处理 -&gt; VLA 推理 -&gt; 控制命令”，标注在哪些位置做量化、在哪些位置使用推理引擎优化。】</p>
</blockquote>
<p>通过“<strong>蒸馏 + 量化 + 推理优化</strong>”三板斧，往往可以把一个原本只能在服务器跑的 VLA，压缩到可以在 Jetson 级别硬件上达到 10 Hz 以上的闭环频率，为后面的边缘部署打下基础。(<a href="https://www.mdpi.com/2073-431X/12/3/60?utm_source=chatgpt.com">MDPI</a>)</p>
<hr>
<h3 id="1043-边缘设备上的部署实践要点"><a class="header" href="#1043-边缘设备上的部署实践要点">10.4.3 边缘设备上的部署实践要点</a></h3>
<p>前两小节更多聚焦于“模型本身怎么变小、变快”，这一节转到系统工程视角：<strong>在真实边缘硬件上，如何把一个 VLA 模型稳稳当当地跑起来</strong>。</p>
<hr>
<h4 id="10431-硬件选型"><a class="header" href="#10431-硬件选型">10.4.3.1 硬件选型</a></h4>
<p>边缘部署的硬件选型，本质上是在<strong>性能、功耗、成本、开发便利性</strong>之间做多目标折中。可以粗略分为以下几类：(<a href="https://thinkrobotics.com/blogs/learn/edge-ai-accelerators-jetson-vs-coral-tpu-a-detailed-comparison-for-developers?srsltid=AfmBOoouqKn4r1ERD_lngz4q-5gOas0IBGSuSWMsOoCEQPfK8aYbVskh&amp;utm_source=chatgpt.com">ThinkRobotics.com</a>)</p>
<ol>
<li><strong>嵌入式 GPU 平台（如 NVIDIA Jetson 系列）</strong>
<ul>
<li>优点：CUDA 生态成熟、TensorRT 支持良好，适合运行 CNN、Transformer、VLM/VLA 等通用深度模型。</li>
<li>典型应用：中高性能移动机器人、机械臂控制柜。(<a href="https://docs.ultralytics.com/guides/nvidia-jetson/?utm_source=chatgpt.com">Ultralytics Docs</a>)</li>
</ul>
</li>
<li><strong>专用 NPU / Edge TPU 加速器（如 Google Coral TPU）</strong>
<ul>
<li>优点：功耗极低、对 INT8 推理高度优化，适合部署压缩后的 CNN/VLM 和小型 VLA。(<a href="https://www.researchgate.net/publication/354268831_Deep_Learning_on_Edge_TPUs?utm_source=chatgpt.com">ResearchGate</a>)</li>
<li>不足：模型需转换为特定格式（如 TFLite），对模型结构限制较多（不支持某些算子或动态控制流）。</li>
</ul>
</li>
<li><strong>CPU + 小 GPU / VPU 组合</strong>
<ul>
<li>如树莓派 + USB 加速器（Movidius NCS 等），适用于简化版本政策或只在云端运行大模型、边缘执行轻量策略的场景。</li>
</ul>
</li>
<li><strong>FPGA / 定制 ASIC</strong>
<ul>
<li>对大规模量产、极致能效的商用机器人有吸引力，但开发成本高、迭代慢，目前更偏向产业界工程化方案。</li>
</ul>
</li>
</ol>
<p>对于具身智能研究者来说，常见实践路线是：<strong>实验阶段用桌面 GPU，原型部署用 Jetson，极低功耗产品再考虑 NPU/TPU/FPGA</strong>。在选型时要结合上一节的压缩方案估算：目标模型在目标硬件上的<strong>推理时延、峰值内存占用和长期散热能力</strong>。</p>
<blockquote>
<p>【图 10-4-6 占位：表格形式对比 Jetson、Coral TPU、CPU+GPU 方案的算力（TOPS）、功耗、生态支持等参数。】</p>
</blockquote>
<hr>
<h4 id="10432-内存管理"><a class="header" href="#10432-内存管理">10.4.3.2 内存管理</a></h4>
<p>即使选对了硬件，如果内存管理不到位，VLA 也可能在关键时刻因为 OOM（Out of Memory）直接崩溃。以下是边缘部署时需要重点关注的方面：(<a href="https://onnxruntime.ai/docs/performance/model-optimizations/quantization.html?utm_source=chatgpt.com">onnxruntime.ai</a>)</p>
<ol>
<li><strong>预算与分析</strong>
<ul>
<li>将运行时内存拆解为：模型权重（常驻）、中间激活（临时）、输入输出缓存、系统与其他进程占用。</li>
<li>使用框架提供的 profile 工具（如 TensorRT profiler、onnxruntime profiling）测真实峰值，而不是仅凭理论估算。</li>
</ul>
</li>
<li><strong>控制模型内存占用</strong>
<ul>
<li>利用前面介绍的量化减小权重体积，选择合适的最大序列长度（图像 patch 数、语言 token 数、历史步数）。</li>
<li>对视觉 backbone，减少特征通道数、采用分辨率自适应（近处高分辨率、远处低分辨率）策略。</li>
</ul>
</li>
<li><strong>运行时内存复用与分配策略</strong>
<ul>
<li>启用框架的内存池/缓存机制，避免频繁 malloc/free 带来的碎片化。</li>
<li>定期监控内存碎片率，在多次加载/卸载模型的场景中考虑进程级重启或使用“模型常驻 + 动态配置”架构。</li>
</ul>
</li>
<li><strong>多进程/多节点协同</strong>
<ul>
<li>对于计算负载较大的视觉和 VLA，可以单独放在一个“推理节点”中，通过 ROS topic / RPC 接口服务其他模块，清晰隔离内存与错误边界。</li>
</ul>
</li>
</ol>
<hr>
<h4 id="10433-运行监控"><a class="header" href="#10433-运行监控">10.4.3.3 运行监控</a></h4>
<p>任何长期在线的机器人系统，都必须具备一定程度的<strong>运行监控与自诊断能力</strong>，否则一旦模型在部署后出现性能衰退或异常行为，很难定位问题。(<a href="https://www.mdpi.com/2076-3417/15/13/7533?utm_source=chatgpt.com">MDPI</a>)</p>
<p>监控主要包括三个层面：</p>
<ol>
<li><strong>资源层监控</strong>
<ul>
<li>CPU/GPU/NPU 利用率、内存/显存占用、设备温度、电池电量与电流等。</li>
<li>典型工具：Jetson 上的 <code>tegrastats</code>、Linux 上的 <code>top</code>/<code>htop</code>、厂家提供的 SDK API。</li>
</ul>
</li>
<li><strong>性能指标监控</strong>
<ul>
<li>每次 VLA 推理的时延分布（平均值、P95、P99）、吞吐（每秒处理的观测步数）。</li>
<li>离线评测到的任务成功率与在线实际成功率的差异，用于监控“性能漂移”。</li>
</ul>
</li>
<li><strong>行为与安全监控</strong>
<ul>
<li>记录发生紧急停止、碰撞检测触发、动作超限的次数和上下文数据（视觉帧、状态、指令）。</li>
<li>建立简单的异常检测规则，如在短时间内连续多次发生动作规划失败或传感器异常，触发退避策略或人工介入。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 10-4-7 占位：一个简单监控面板示意图，包含 CPU/GPU 利用率、推理时延曲线、任务成功率趋势以及安全事件计数。】</p>
</blockquote>
<p>在有了这套监控基础之后，团队才能在后续迭代中<strong>量化地评估不同压缩策略、不同硬件平台对整体系统行为的影响</strong>，而不是依靠主观体验。</p>
<hr>
<h3 id="1044-小模型-vla-与大模型-vla-的协同如规划执行分离"><a class="header" href="#1044-小模型-vla-与大模型-vla-的协同如规划执行分离">10.4.4 小模型 VLA 与大模型 VLA 的协同（如规划–执行分离）</a></h3>
<p>随着 OpenVLA、RT-2 等大型 VLA 的出现，一个现实问题是：<strong>这些模型很强，但不一定适合直接“塞进”机器人里</strong>。越来越多的系统开始采用“小模型 + 大模型”的协同架构，将规划与执行、推理与控制分层。(<a href="https://en.wikipedia.org/wiki/Vision-language-action_model?utm_source=chatgpt.com">维基百科</a>)</p>
<hr>
<h4 id="10441-分级规划执行"><a class="header" href="#10441-分级规划执行">10.4.4.1 分级规划执行</a></h4>
<p>一种自然的架构是**“大模型做高层规划，小模型做低层执行”**：</p>
<ul>
<li><strong>大模型 VLA / VLM + LLM（云端或高性能本地工作站）</strong>
<ul>
<li>负责理解复杂自然语言任务、检索世界知识、推理长时序计划（例如完成一个“整理房间”的多步骤任务）。</li>
<li>可以基于互联网上的大规模图文数据和机器人数据进行训练，具有更强的泛化和推理能力，例如 RT-2 将 web 视觉–语言知识迁移到机器人动作中。(<a href="https://arxiv.org/html/2508.13073v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>小模型 VLA（部署在机器人本体）</strong>
<ul>
<li>负责将高层计划分解为连续的控制动作，如抓取、放置、移动、避障等，在几十 Hz 的频率下闭环控制。</li>
<li>通过前文介绍的蒸馏与压缩，从大模型继承视觉–语言–动作对齐能力，但参数量和延迟显著下降。</li>
</ul>
</li>
</ul>
<p>具体流程上，大模型输出的可以是：</p>
<ul>
<li>语言化的分步指令（如“先把红色杯子放到桌子右侧，再关灯”）；</li>
<li>结构化的任务图（task graph），包含一系列子任务、先后约束与条件分支；</li>
<li>关键子目标（sub-goals），如中间位姿、关键物体状态（“杯子在架子上”“杯子在桌上”）。</li>
</ul>
<p>小模型 VLA 则在每个子任务内，通过自身感知与控制实现局部闭环。这样，大模型只需低频运行（例如 0.1–1 Hz 做一次整体再规划），而小模型负责高频反馈控制。</p>
<blockquote>
<p>【图 10-4-8 占位：层级架构图，上层“大模型”接收人类语言指令并输出子任务序列，下层“小模型 VLA”连接机器人，执行每个子任务。】</p>
</blockquote>
<hr>
<h4 id="10442-信息传递"><a class="header" href="#10442-信息传递">10.4.4.2 信息传递</a></h4>
<p>大小模型之间的信息传递形式，直接决定了系统的灵活性与工程复杂度。常见的几种接口设计包括：</p>
<ol>
<li><strong>以语言为接口</strong>
<ul>
<li>大模型输出自然语言或受限模板语言（如 DSL），小模型再对其进行解析。</li>
<li>优点是通用性强、易于人类 debugging；缺点是需要保证小模型对语言的解析鲁棒性。</li>
</ul>
</li>
<li><strong>以符号 / 结构化状态为接口</strong>
<ul>
<li>大模型输出结构化的任务描述，如 JSON 形式的 <code>{"action": "pick", "object": "red_mug", "target": "table_right"}</code>。</li>
<li>小模型根据这些参数在自己的感知空间中查找对应目标（如在图像中找 <code>red_mug</code>），并规划动作。</li>
</ul>
</li>
<li><strong>以高维嵌入 / 潜变量为接口</strong>
<ul>
<li>大模型输出某种“目标嵌入”（goal embedding），小模型通过训练好的策略将当前状态推向这个目标嵌入。</li>
<li>这种方式更接近端到端学习，但可解释性较弱，多用于研究型系统。</li>
</ul>
</li>
</ol>
<p>信息传递还涉及<strong>反馈通道</strong>：</p>
<ul>
<li>小模型需要向大模型汇报子任务执行状态（成功/失败、耗时、遇到的障碍），大模型据此更新整体计划。</li>
<li>为了降低带宽与隐私风险，通常不会传输原始视频帧，而是传输压缩后的特征、关键检测结果或语言化的场景描述。(<a href="https://www.mdpi.com/2076-3417/15/13/7533?utm_source=chatgpt.com">MDPI</a>)</li>
</ul>
<hr>
<h4 id="10443-优势互补"><a class="header" href="#10443-优势互补">10.4.4.3 优势互补</a></h4>
<p>“小模型 VLA + 大模型 VLA”的协同，本质上是对单一大模型直接部署的现实折中，它带来的优势包括：</p>
<ul>
<li><strong>性能与资源的分工</strong>
<ul>
<li>大模型负责认知层面的“想”（理解复杂指令、做长程规划）；</li>
<li>小模型负责控制层面的“做”（考虑传感噪声、动力学约束、实时安全）。</li>
</ul>
</li>
<li><strong>在线学习与自适应的空间</strong>
<ul>
<li>小模型可以在部署过程中通过少量在线数据微调（例如适应新的照明环境或新机器人），而大模型保持相对稳定，避免每次环境变化都要大规模重训。</li>
</ul>
</li>
<li><strong>安全与可靠性</strong>
<ul>
<li>在网络中断或大模型不可用时，小模型仍可执行基础技能（如紧急制动、保持静止、简单避障）。</li>
<li>规划–执行分离也便于在执行层加入更多物理安全约束和形式化验证，而不必对整个巨型大模型做不可行的形式验证。</li>
</ul>
</li>
</ul>
<blockquote>
<p>【图 10-4-9 占位：比较单一大 VLA 与“大+小”协同架构的示意图，展示在性能、时延和安全性三方面的对比雷达图。】</p>
</blockquote>
<p>在长期发展视角下，随着硬件继续进步，未来某些机器人平台可能直接搭载中大型 VLA；但在可预见的一段时间内，“<strong>云端/服务器大模型 + 端侧小模型</strong>”会是非常现实、工程上可行的一条路径。本节介绍的蒸馏、量化、边缘部署与协同架构，也构成了从“VLA 论文”走向“VLA 产品”的关键工程桥梁。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="入门项目建议"><a href="#入门项目建议" class="header">入门项目建议</a></h1>
<p><img src="https://tse3.mm.bing.net/th/id/OIP.ufv2EvrYgzXc3DHs17S1ugHaFH?pid=Api" alt=""></p>
<p>下面我直接把你给出的 11.1.x 扩写成教材正文风格。整体假定读者已经看过前面关于 BC、VLA、仿真平台、ROS 等章节，这里主要做“落地项目手把手”，避免重复理论。</p>
<hr>
<h2 id="111-入门项目建议"><a class="header" href="#111-入门项目建议">11.1 入门项目建议</a></h2>
<p>本节的目标，是让读者在<strong>不依赖真实机器人硬件</strong>的前提下，走完几条完整的实践路线：
从最基础的行为克隆（BC），到一个玩具级 VLA，再到利用开源数据训练多任务策略，最终把模型部署在仿真机器人上完成抓取 / 放置任务。</p>
<p>可以把这几小节理解为四个渐进式“关卡”：</p>
<ol>
<li>会用仿真 + BC 让机器人“照着做”</li>
<li>会用简单 VLA 让机器人听懂一句话再行动</li>
<li>会在开源多任务数据集上训练一个小“通用策略”</li>
<li>会把模型真正接到仿真机械臂上跑在线控制闭环</li>
</ol>
<hr>
<h3 id="1111-在仿真环境中实现简单的-bc-控制策略"><a class="header" href="#1111-在仿真环境中实现简单的-bc-控制策略">11.1.1 在仿真环境中实现简单的 BC 控制策略</a></h3>
<p>这一小节的目标，是让读者完成第一条最基础的 pipeline：</p>
<blockquote>
<p>仿真环境搭建 → 采集示范轨迹 → 训练行为克隆策略 → 部署回仿真验证</p>
</blockquote>
<h4 id="11111-任务场景"><a class="header" href="#11111-任务场景">11.1.1.1 任务场景</a></h4>
<p>为了把复杂度压到最低，建议选用<strong>单臂 + 桌面 + 单物体</strong>的简单抓取任务，例如：</p>
<ul>
<li>机器人：Franka Panda、UR5 或仿真平台自带机械臂</li>
<li>环境：一张桌子，桌上放一个小方块或圆柱体</li>
<li>任务：从固定初始姿态出发，抓起桌上的物块并抬到空中</li>
</ul>
<p>仿真引擎可以选择：</p>
<ul>
<li><strong>MuJoCo</strong>：现代机器人强化学习中最常用之一，支持 Franka、UR 系列等模型，仿真稳定，许多 benchmark 都基于它。(<a href="https://www.sciencedirect.com/science/article/pii/S1566253523005377?utm_source=chatgpt.com">科学直通车</a>)</li>
<li><strong>Isaac Gym / Isaac Lab</strong>：适合大规模 RL，但对初学者略有上手成本。</li>
<li><strong>Gazebo / Ignition + ROS</strong>：更贴近真实机器人系统，和 ROS 集成好，但仿真效率偏低。(<a href="https://github.com/stepjam/RLBench?utm_source=chatgpt.com">GitHub</a>)</li>
</ul>
<p>为了让读者感到“看得见的进步”，可以建议如下约束：</p>
<ul>
<li>只使用单视角 RGB 图像 + 机械臂关节角作为输入</li>
<li>只做二维平面内抓取（物体固定在桌上某个区域）</li>
<li>控制指令采用关节增量（Δq）或末端位姿增量（Δpose）</li>
</ul>
<p><strong>图片占位建议：</strong></p>
<blockquote>
<p>【图 11-1】典型机械臂仿真环境示意图：Franka Panda 机械臂固定在桌旁，桌面上摆放单个方块，画出机器人基座坐标系与摄像头视场。</p>
</blockquote>
<h4 id="11112-数据采集"><a class="header" href="#11112-数据采集">11.1.1.2 数据采集</a></h4>
<p>行为克隆的核心是：<strong>有一批“好示范”，模型只要拟合它们即可</strong>。在仿真环境中采集示范相对轻松，主要方式有两种：</p>
<ol>
<li><strong>遥操作（Teleoperation）方式</strong>
<ul>
<li>用键盘 / 鼠标 / 手柄 或 VR 控制机械臂末端移动与夹爪开闭。</li>
<li>在每一个控制周期记录：
<ul>
<li>当前图像 (I_t)（RGB 或 RGB-D）</li>
<li>机器人状态 (s_t)：关节角、关节速度、夹爪状态等</li>
<li>人类给出的动作 (a_t)：比如末端速度或关节角增量</li>
</ul>
</li>
<li>数据存储成轨迹：((I_0, s_0, a_0), \dots, (I_T, s_T, a_T))</li>
</ul>
</li>
<li><strong>脚本 / 规划器生成示范</strong>
<ul>
<li>对于规则简单的任务，可以写定程序化轨迹：例如从上方垂直下降、夹紧、上抬。</li>
<li>也可以利用轨迹规划器生成碰撞安全轨迹，然后把规划出的动作当作专家示范（RLBench 就是用规划器自动生成无限示范的代表性系统）。(<a href="https://arxiv.org/abs/1909.12271?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ol>
<p><strong>记录格式</strong>建议：</p>
<ul>
<li>采用统一的结构体或字典，例如：</li>
</ul>
<pre><code class="language-python">{
    "image": &lt;H x W x 3&gt;,
    "q": &lt;n_dof&gt;,        # 关节角
    "qdot": &lt;n_dof&gt;,     # 关节速度（可选）
    "gripper": &lt;1&gt;,      # 夹爪开合
    "action": &lt;m&gt;,       # 控制命令
    "timestep": &lt;int&gt;
}
</code></pre>
<ul>
<li>保存为一系列 <code>episode_xxx.h5</code> 或 <code>npz</code> 文件，方便后续 batch 加载和随机打乱。</li>
</ul>
<p><strong>小建议：</strong></p>
<ul>
<li>尽量采集几十到上百条成功轨迹；</li>
<li>在仿真中随机扰动若干初始条件（方块位置、小幅度初始姿态变化），为后续泛化留一点空间；</li>
<li>记录任务是否成功，方便训练前筛掉明显失败示范。</li>
</ul>
<h4 id="11113-模型训练"><a class="header" href="#11113-模型训练">11.1.1.3 模型训练</a></h4>
<p>这一部分可以引导读者实现一个<strong>最朴素的 BC 模型</strong>：</p>
<ol>
<li><strong>输入设计</strong>
<ul>
<li>图像经一个轻量 CNN（如 ResNet18）或 ViT Tiny 提取特征向量 (f_{\text{img}})。</li>
<li>机器人的状态向量 (s_t)（关节角、夹爪状态）经一个小型 MLP 转为嵌入 (f_{\text{state}})。</li>
<li>拼接两者：(z_t = [f_{\text{img}}, f_{\text{state}}])。</li>
</ul>
</li>
<li><strong>输出设计</strong>
<ul>
<li>若动作是连续值（如关节角增量 (\Delta q)，末端速度），则使用回归头：多层感知机输出实数向量。</li>
<li>若动作预先离散化（例如八个方向步进 + 抓/放），则使用分类头（Softmax 输出每个离散动作的概率）。</li>
</ul>
</li>
<li><strong>损失函数</strong>
<ul>
<li>连续动作：使用均方误差（MSE）损失 (\mathcal{L} = |a_t - \hat{a}_t|^2)。</li>
<li>离散动作：使用交叉熵损失。</li>
</ul>
</li>
<li><strong>训练流程</strong>
<ul>
<li>将所有轨迹打散成样本对 ((\text{obs}_t, a_t))。</li>
<li>小批量训练，使用 Adam 优化器；</li>
<li>对图像进行基础数据增强（随机裁剪、轻微颜色抖动），增强鲁棒性。</li>
</ul>
</li>
</ol>
<p>可以明确强调：<strong>BC 本质上就是监督学习，不需要奖励函数和环境交互</strong>，这一点和前面 RL 章节做一个呼应。</p>
<p><strong>图片占位建议：</strong></p>
<blockquote>
<p>【图 11-2】简单 BC 网络结构示意图：左侧为图像输入经 CNN，右侧为关节状态输入经 MLP，两者拼接后输出动作向量。</p>
</blockquote>
<h4 id="11114-验证效果"><a class="header" href="#11114-验证效果">11.1.1.4 验证效果</a></h4>
<p>训练完模型后，需要让读者真正“看到机器人动起来”，验证步骤：</p>
<ol>
<li><strong>离线评估</strong>
<ul>
<li>在验证集轨迹上计算：
<ul>
<li>连续动作误差（MSE），</li>
<li>或动作分类准确率。</li>
</ul>
</li>
<li>可视化几条轨迹：比较专家动作与模型动作的曲线差异。</li>
</ul>
</li>
<li><strong>在线回放（仿真控制）</strong>
<ul>
<li>在仿真中重置环境：机器人回到初始位置，物体放在预定位置；</li>
<li>在每一个控制周期：
<ul>
<li>获取当前图像和机器人状态；</li>
<li>前向传播得到模型动作；</li>
<li>将动作发送给仿真控制器。</li>
</ul>
</li>
<li>重复直到终止条件（抓取成功、时间超时、仿真出界）。</li>
</ul>
</li>
<li><strong>指标与现象</strong>
<ul>
<li>任务成功率：例如在 50 次初始化中成功抓起并抬起物体的比例；</li>
<li>执行轨迹是否平滑、是否有明显震荡或发抖；</li>
<li>模型错误典型场景：对物体位置略有偏差、抓取偏边缘导致滑落等。</li>
</ul>
</li>
</ol>
<p>可以引导读者思考：</p>
<ul>
<li>模型失败时，是否进入了训练数据没覆盖到的状态分布（呼应前文 BC 的分布偏移问题）；</li>
<li>若要提高表现，可以在后续章节引入 DAgger 或强化学习微调。</li>
</ul>
<p><strong>图片占位建议：</strong></p>
<blockquote>
<p>【图 11-3】仿真中 BC 策略成功抓取物体的动作序列截图（接近 → 抓取 → 提起），配合时间轴标注。</p>
</blockquote>
<hr>
<h3 id="1112-复现一个小规模视觉--语言--动作的玩具-vla"><a class="header" href="#1112-复现一个小规模视觉--语言--动作的玩具-vla">11.1.2 复现一个小规模“视觉 + 语言 + 动作”的玩具 VLA</a></h3>
<p>在学生已经完成纯 BC 项目后，可以引导他们搭建一个最小可用的 VLA 原型——<strong>它不追求 SOTA，只追求“能跑、能看、能听话”</strong>。</p>
<h4 id="11121-场景设定"><a class="header" href="#11121-场景设定">11.1.2.1 场景设定</a></h4>
<p>场景依然建议控制在非常简单的桌面操作环境。例如：</p>
<ul>
<li>桌上有多种颜色或不同形状的积木：红色方块、蓝色圆柱、绿色长条等；</li>
<li>摄像头固定俯视桌面；</li>
<li>机械臂可以抓取并移动物体到左/右侧区域；</li>
<li>自然语言指令类似：
<ul>
<li>“把红色方块放到右边”；</li>
<li>“把蓝色圆柱移到左上角”；</li>
<li>“把绿色积木抓起来”。</li>
</ul>
</li>
</ul>
<p>这样一来，语言主要承担两个作用：</p>
<ol>
<li>指定<strong>目标物体</strong>（颜色 + 类别）；</li>
<li>指定<strong>目标区域</strong>（左/右/上/下）。</li>
</ol>
<p><strong>图片占位建议：</strong></p>
<blockquote>
<p>【图 11-4】玩具 VLA 场景示意：桌面多个彩色积木、机械臂与摄像头视角，示意不同目标区域位置。</p>
</blockquote>
<h4 id="11122-数据生成"><a class="header" href="#11122-数据生成">11.1.2.2 数据生成</a></h4>
<p>这里鼓励使用<strong>完全程序化的合成数据</strong>，方便读者生成足够多样本：</p>
<ol>
<li><strong>程序化场景采样</strong>
<ul>
<li>随机采样：
<ul>
<li>积木的颜色 / 形状 / 尺寸；</li>
<li>每个积木在桌面上的位置；</li>
<li>要执行的任务类型（抓取 / 放置位置）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>动作自动生成</strong>
<ul>
<li>使用简单几何规划：
<ul>
<li>根据物体 2D 坐标，设定机械臂末端在上方某个高度对齐；</li>
<li>垂直下降、闭合夹爪、抬起；</li>
<li>若需要放置位置，则移动到目标区中心、下降、松爪。</li>
</ul>
</li>
<li>所有这些动作都可以由脚本生成，从而形成专家轨迹。</li>
</ul>
</li>
<li><strong>语言指令生成</strong>
<ul>
<li>采用模板：
<ul>
<li>“把 {颜色} {形状} 放到 {区域}”；</li>
<li>“抓起 {颜色} 的积木”；</li>
</ul>
</li>
<li>对同一条轨迹可以生成多条同义指令，通过同义词 / 词序变化等扩充训练集；</li>
<li>若想更真实，可在模板基础上用语言模型改写，形成更自然的多样指令表达。(<a href="https://learnopencv.com/vision-language-action-models-lerobot-policy/?utm_source=chatgpt.com">OpenCV学习</a>)</li>
</ul>
</li>
<li><strong>同步与对齐</strong>
<ul>
<li>对每一条轨迹，记录：
<ul>
<li>起始时刻的场景图像 (I_0)；</li>
<li>对应语言指令文本 (L)；</li>
<li>动作序列 (a_0, \dots, a_T)。</li>
</ul>
</li>
<li>对于玩具级 VLA，可以简化成“指令 + 初始图像 → 整条动作序列”的离线映射，或“指令 + 当前图像 → 下一步动作”的在线决策。</li>
</ul>
</li>
</ol>
<h4 id="11123-模型搭建"><a class="header" href="#11123-模型搭建">11.1.2.3 模型搭建</a></h4>
<p>这里的目标是一个<strong>最小 VLA</strong>，可选架构之一：</p>
<ol>
<li><strong>视觉编码</strong>
<ul>
<li>使用一个预训练的 ResNet18 / ViT-Tiny 作为 backbone（在第 3 章已有详细介绍，在此直接引用即可）；</li>
<li>输出一个固定维度向量 (f_{\text{img}})。</li>
</ul>
</li>
<li><strong>语言编码</strong>
<ul>
<li>使用轻量 Transformer 或直接调用小型预训练文本编码器，如 MiniLM、DistilBERT 等（读者可以通过开源框架获取预训练权重）。(<a href="https://www.sciencedirect.com/science/article/pii/S1566253523005377?utm_source=chatgpt.com">科学直通车</a>)</li>
<li>将指令 (L) 转换为子词 token 序列，经嵌入和 Transformer 层，提取 [CLS] 或平均池化得到语言向量 (f_{\text{lang}})。</li>
</ul>
</li>
<li><strong>多模态融合</strong>
<ul>
<li>最简单方法：直接拼接 (z = [f_{\text{img}}, f_{\text{lang}}])，输入 MLP 输出动作。</li>
<li>稍微进阶一点，可以用一个 2 层的 Transformer，将图像特征视为一个 token、语言序列为其余 token，通过自注意力实现简单的跨模态交互。</li>
</ul>
</li>
<li><strong>动作解码</strong>
<ul>
<li>vs 11.1.1 类似，可以输出：
<ul>
<li>单步动作（Δpose 或 Δq）；</li>
<li>或固定长度的动作 token 序列。</li>
</ul>
</li>
<li>为了简单起见，建议初学项目仍采用<strong>单步决策</strong>，在仿真中循环调用模型。</li>
</ul>
</li>
</ol>
<p><strong>图片占位建议：</strong></p>
<blockquote>
<p>【图 11-5】玩具 VLA 模型结构示意：图像编码器与语言编码器分别输出特征，经过拼接与 MLP 输出动作。</p>
</blockquote>
<h4 id="11124-训练评估"><a class="header" href="#11124-训练评估">11.1.2.4 训练评估</a></h4>
<p>训练过程本质仍是行为克隆，只是输入多了一路语言：</p>
<ol>
<li><strong>训练</strong>
<ul>
<li>Loss 仍是动作监督损失（MSE 或交叉熵）；</li>
<li>在 batch 中混合不同指令与不同场景；</li>
<li>适当使用 dropout 与数据增广防止过拟合。</li>
</ul>
</li>
<li><strong>评估方式</strong>
<ul>
<li><strong>离线正确率</strong>：在验证集上，给定图像 + 指令，统计模型选出的目标物体是否正确（例如是否接近正确颜色与位置）。</li>
<li><strong>在线执行成功率</strong>：在仿真中随机生成新场景和新指令，统计任务成功率。</li>
<li><strong>指令泛化测试</strong>：
<ul>
<li>在训练中只用模板 A；</li>
<li>在测试中使用同一含义，但完全未出现过的自然表达 B（例如“请把那个红色的小方块挪到右边去”），检验语言理解泛化。</li>
</ul>
</li>
</ul>
</li>
<li><strong>现象讨论</strong>
<ul>
<li>指令缺失或模糊时（如“把它拿走”），模型会如何表现？</li>
<li>如果场景中不存在符合指令的物体（如没有红色积木），模型是否会输出无意义动作？</li>
<li>这为后续章节中“安全性”和“语言约束”埋下伏笔。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1113-使用开源数据集训练一个简单多任务策略"><a class="header" href="#1113-使用开源数据集训练一个简单多任务策略">11.1.3 使用开源数据集训练一个简单多任务策略</a></h3>
<p>在读者掌握自建数据和玩具 VLA 之后，可以把视角扩展到<strong>真正的开源机器人数据集</strong>，体会多任务学习和数据工程的味道。</p>
<h4 id="11131-选择数据"><a class="header" href="#11131-选择数据">11.1.3.1 选择数据</a></h4>
<p>目前机器人社区已有多种开放数据集可以用于多任务策略学习，比如：</p>
<ul>
<li><strong>RLBench</strong>：CoppeliaSim 上构建的多任务操作环境，包含 100 种以上任务（开抽屉、开门、插销、放物体等），每个任务有大量示教轨迹，支持视觉 + 动作学习。(<a href="https://arxiv.org/abs/1909.12271?utm_source=chatgpt.com">arXiv</a>)</li>
<li><strong>RoboNet</strong>：Berkeley 等机构联合的数据集，包含多个不同机器人平台的桌面操作数据，主要任务是物体迁移（pushing 或 grasping-and-placing），提供 1500 万帧左右的视频及状态信息。(<a href="https://bair.berkeley.edu/blog/2019/11/26/robo-net/?utm_source=chatgpt.com">bair.berkeley.edu</a>)</li>
</ul>
<p>入门阶段可以建议：</p>
<ul>
<li>从 RLBench 选取 3–5 个简单任务（如 “reach target”、“pick &amp; place”、“open drawer”）；</li>
<li>或从 RoboNet 切出一个子集，只保留若干机器人和物体类别。</li>
</ul>
<p>预处理步骤包括：</p>
<ul>
<li>统一图像尺寸和通道顺序；</li>
<li>统一状态与动作向量的格式；</li>
<li>明确每条轨迹对应的任务 id（或任务名称），为后续多任务训练提供条件标签。</li>
</ul>
<h4 id="11132-模型架构"><a class="header" href="#11132-模型架构">11.1.3.2 模型架构</a></h4>
<p>这里不强求 VLA，一种基础多任务策略可以只是视觉 + 状态 → 动作，并增加<strong>任务条件</strong>输入，形成一个小型 generalist policy：</p>
<ol>
<li><strong>视觉编码器</strong>
<ul>
<li>重用上一小节中的 CNN / ViT；</li>
<li>若数据量充足，可考虑在数据集上做自监督预训练（例如 MAE 或对比学习），再用作下游策略 backbone。(<a href="https://www.sciencedirect.com/science/article/pii/S1566253523005377?utm_source=chatgpt.com">科学直通车</a>)</li>
</ul>
</li>
<li><strong>任务编码器</strong>
<ul>
<li>将任务 id 映射为 one-hot 或 learnable embedding；</li>
<li>任务嵌入向量 (f_{\text{task}}) 与视觉特征、机器人状态特征一起拼接成总特征：
$$
z_t = [f_{\text{img}}, f_{\text{state}}, f_{\text{task}}]
$$</li>
</ul>
</li>
<li><strong>策略头</strong>
<ul>
<li>MLP 输出当前动作；</li>
<li>也可采用小型 Transformer 编码短时间窗口的历史观测与动作，实现时序建模。</li>
</ul>
</li>
</ol>
<p><strong>图片占位建议：</strong></p>
<blockquote>
<p>【图 11-6】简单多任务策略网络结构示意：视觉特征、状态特征与任务嵌入拼接后通过 MLP 输出动作。</p>
</blockquote>
<h4 id="11133-训练过程"><a class="header" href="#11133-训练过程">11.1.3.3 训练过程</a></h4>
<p>多任务训练的难点在于<strong>数据不平衡与任务干扰</strong>，本节可以指导读者做几个基本设计：</p>
<ol>
<li><strong>采样策略</strong>
<ul>
<li>按任务均匀采样：在每个 batch 内保证多任务数据均衡，避免大量数据的任务“淹没”长尾任务；</li>
<li>或使用基于任务难度的加权采样（视为进阶内容）。</li>
</ul>
</li>
<li><strong>训练目标</strong>
<ul>
<li>仍然是标准 BC 损失：(\mathcal{L} = \sum_t |a_t - \hat{a}_t|^2) 或交叉熵；</li>
<li>可以在损失中增加任务正则项，例如鼓励同一任务的行动分布更紧凑（非必需）。</li>
</ul>
</li>
<li><strong>日志与监控</strong>
<ul>
<li>为每个任务单独记录训练/验证误差与离线评估指标；</li>
<li>如果某个任务一直学不好，有可能是任务数据过少或任务本身过难，可在报告中引导学生分析原因。</li>
</ul>
</li>
<li><strong>工程注意事项</strong>
<ul>
<li>数据集可能较大，需要注意 IO 和缓存（例如提前将图像转为压缩格式，使用多进程 data loader）；</li>
<li>必要时对长轨迹进行截断或下采样，以控制训练时间。</li>
</ul>
</li>
</ol>
<h4 id="11134-测试泛化"><a class="header" href="#11134-测试泛化">11.1.3.4 测试泛化</a></h4>
<p>多任务策略真正有趣的地方在于<strong>泛化能力测试</strong>，可以设计几类实验：</p>
<ol>
<li><strong>任务内泛化</strong>
<ul>
<li>在与训练任务相同的任务 id 上，但使用新的初始姿态、物体位置、光照变化等，测试成功率；</li>
<li>观察模型是否相较单任务策略更稳健。</li>
</ul>
</li>
<li><strong>任务间迁移</strong>
<ul>
<li>在 RLBench 等系统中，选择一两个<strong>未参与训练</strong>的任务，直接使用同一模型（或者在少量示范上做快速微调），比较其学习效率与单任务基线。(<a href="https://github.com/stepjam/RLBench?utm_source=chatgpt.com">GitHub</a>)</li>
</ul>
</li>
<li><strong>分布外场景</strong>
<ul>
<li>对视觉输入做强扰动（不同桌布纹理、不同背景颜色）；</li>
<li>对任务组合做变化（例如在桌子另一侧重复相同任务），观察策略是否仍能执行关键步骤。</li>
</ul>
</li>
</ol>
<p>读者通过这一节，会第一次感受到：</p>
<blockquote>
<p>“原来我可以用同一个模型，控制不同任务甚至不同机器人，哪怕很粗糙，也算朝‘通用策略’迈了一小步。”</p>
</blockquote>
<hr>
<h3 id="1114-将模型部署在仿真机器人上完成抓取--放置任务"><a class="header" href="#1114-将模型部署在仿真机器人上完成抓取--放置任务">11.1.4 将模型部署在仿真机器人上完成抓取 / 放置任务</a></h3>
<p>前面三个项目大多停留在“训练脚本 + 离线评估”层面，本节的目标是：<strong>让模型真正以一个在线控制模块的身份，接入仿真机器人系统</strong>。这是走向真实机器人实验的前置练习。</p>
<h4 id="11141-部署准备"><a class="header" href="#11141-部署准备">11.1.4.1 部署准备</a></h4>
<p>部署的关键，是把模型包装成一个<strong>可在实时循环中调用的服务</strong>，与仿真平台对接。典型组合是：</p>
<ul>
<li>仿真平台：Gazebo / Ignition / Isaac Sim / MuJoCo + 外部控制程序；</li>
<li>中间件：ROS / ROS2，负责图像、状态与控制命令的话题传输；(<a href="https://www.sciencedirect.com/science/article/pii/S1566253523005377?utm_source=chatgpt.com">科学直通车</a>)</li>
</ul>
<p>准备步骤：</p>
<ol>
<li><strong>选择仿真机器人模型</strong>
<ul>
<li>如 Franka Panda、UR5 等已有成熟 URDF + 控制接口的机械臂模型；许多开源项目和基准都基于这些平台。(<a href="https://github.com/stepjam/RLBench?utm_source=chatgpt.com">GitHub</a>)</li>
</ul>
</li>
<li><strong>定义模型接口</strong>
<ul>
<li>输入：
<ul>
<li>相机图像（订阅 <code>/camera/rgb</code> 或类似话题）；</li>
<li>关节状态（订阅 <code>/joint_states</code>）。</li>
</ul>
</li>
<li>输出：
<ul>
<li>关节目标位置或关节速度（发布到 <code>/arm_controller/command</code> 之类的话题）；</li>
<li>或末端位姿目标，由下层控制器完成 IK 和轨迹跟踪。</li>
</ul>
</li>
</ul>
</li>
<li><strong>模型打包</strong>
<ul>
<li>将训练好的 PyTorch / JAX 模型保存为 checkpoint；</li>
<li>部署脚本在 ROS 节点中加载模型，并在回调中执行前向计算。</li>
<li>为满足实时性，可考虑使用 ONNX/TensorRT 等推理引擎进行加速（在 10 章已有详细介绍，这里只作实践提醒）。</li>
</ul>
</li>
</ol>
<p><strong>图片占位建议：</strong></p>
<blockquote>
<p>【图 11-7】模型部署架构示意：仿真器 → ROS 话题 → VLA / BC 模型节点 → 控制器 → 仿真机械臂。</p>
</blockquote>
<h4 id="11142-在线控制"><a class="header" href="#11142-在线控制">11.1.4.2 在线控制</a></h4>
<p>在线控制循环通常如下：</p>
<ol>
<li><strong>感知</strong>
<ul>
<li>以固定频率（如 5–10 Hz）从相机和关节传感读取当前状态；</li>
<li>做必要预处理：图像 resize、归一化；状态向量拼接。</li>
</ul>
</li>
<li><strong>决策</strong>
<ul>
<li>将当前观测（以及语言指令/任务 id 等条件）输入模型；</li>
<li>得到动作向量（Δpose 或 Δq）；</li>
<li>做简单约束：裁剪到关节速度 / 末端位移限制。</li>
</ul>
</li>
<li><strong>执行</strong>
<ul>
<li>将动作转为控制指令发送给仿真控制器：
<ul>
<li>若用关节空间位置控制：当前关节角 + Δq 得到目标位置。</li>
<li>若用末端速度控制：发送速度指令，由 robot controller 积分执行。</li>
</ul>
</li>
</ul>
</li>
<li><strong>循环与终止</strong>
<ul>
<li>直到检测到抓取成功 / 放置完成 / 时间超时；</li>
<li>若失败，可回到初始状态重新尝试，计算成功率。</li>
</ul>
</li>
</ol>
<p>这里可以强调<strong>高层策略与低层控制的分工</strong>（与第 6 章呼应）：VLA/BC 模型只需输出“想要往哪走”，真正的轨迹细化与电机控制由底层完成。</p>
<h4 id="11143-任务执行"><a class="header" href="#11143-任务执行">11.1.4.3 任务执行</a></h4>
<p>最后，可以要求读者把这一套部署在一个具体任务上，比如：</p>
<blockquote>
<p>“在仿真中，让机械臂根据视觉输入自动抓取桌上的物体，并将其放置到指定区域。”</p>
</blockquote>
<p>建议设置的观测与评价包括：</p>
<ol>
<li><strong>成功率统计</strong>
<ul>
<li>多次随机初始化物体位置，记录完成抓取 + 放置任务的成功率；</li>
<li>可与手工脚本或规划器生成的基线策略进行比较。</li>
</ul>
</li>
<li><strong>行为可视化</strong>
<ul>
<li>录制仿真视频，选取几条成功与失败案例；</li>
<li>在视频上叠加当前模型预测的目标点、动作向量等信息，帮助分析行为逻辑。</li>
</ul>
</li>
<li><strong>故障模式分析</strong>
<ul>
<li>例如：
<ul>
<li>张开 / 闭合夹爪时机不对；</li>
<li>接近物体路径绕来绕去，说明策略不稳定；</li>
<li>抓取过于激进导致与桌面碰撞。</li>
</ul>
</li>
<li>这些现象为后续章节关于“安全性、鲁棒性与 RL 微调”提供直观动机。</li>
</ul>
</li>
</ol>
<p><strong>图片占位建议：</strong></p>
<blockquote>
<p>【图 11-8】仿真抓取 / 放置任务执行结果对比图：上排为成功案例序列，下排为失败案例序列，并在图中标注关键失败原因（如偏移过大、夹爪没对准）。</p>
</blockquote>
<hr>
<p>综合来看，本节四个项目像是一个小型“具身智能实验通关手册”：
从最基础的单任务 BC，到加上语言组成玩具 VLA，再到利用开源多任务数据做 generalist policy，最后真正接入仿真系统跑在线闭环。
读者只要按顺序完成其中任意两三个，就已经从“纸面理解”跨到了“能把抽象 VLA 概念落成可运行系统”的阶段。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="代码阅读与复现能力"><a href="#代码阅读与复现能力" class="header">代码阅读与复现能力</a></h1>
<h3 id="1121-阅读开源-vla--机器人基础模型仓库的方式"><a class="header" href="#1121-阅读开源-vla--机器人基础模型仓库的方式">11.2.1 阅读开源 VLA / 机器人基础模型仓库的方式</a></h3>
<p>这一小节的目标，是教读者“拿到一个陌生的开源 VLA / 机器人基础模型仓库，如何从不会到能跑起来、看得懂、改得动”。可以结合前面章节对 VLA 架构与训练范式的理解，这里则更加工程化、落地化。</p>
<hr>
<h4 id="11211-选取项目"><a class="header" href="#11211-选取项目">11.2.1.1 选取项目</a></h4>
<p>并不是任何一个 GitHub 仓库都适合作为学习对象。选择起点时，可以遵循几个简单的原则。</p>
<p><strong>（1）优先选择有论文 / 网站支撑的“标志性”项目</strong>
这类项目往往有较完整的文档、清晰的实验设定和稳定的代码实现，例如：</p>
<ul>
<li><strong>OpenVLA</strong>：开源 7B 参数 VLA 模型，基于 Open X-Embodiment 约 97 万条机器人轨迹预训练，支持多机器人、多任务控制，并提供推理与 LoRA 微调脚本。(<a href="https://github.com/openvla/openvla?utm_source=chatgpt.com">GitHub</a>)</li>
<li><strong>RT-1（Robotics Transformer）</strong>：Google Robotics 提出的视觉-语言-动作 Transformer，官方及非官方仓库给出了训练与推理代码。(<a href="https://github.com/google-research/robotics_transformer?utm_source=chatgpt.com">GitHub</a>)</li>
<li><strong>Octo</strong>：开源的通用机器人策略（generalist robot policy），基于 Transformer + diffusion policy，在 80 万条 Open X-Embodiment 轨迹上训练，支持多机器人、多观测空间与多任务。(<a href="https://github.com/octo-models/octo?utm_source=chatgpt.com">GitHub</a>)</li>
<li><strong>robomimic</strong>：更偏“框架”的模仿学习平台，包含多种离线模仿 / offline RL 算法与标准数据集，适合作为训练/评测 pipeline 的参考。(<a href="https://github.com/ARISE-Initiative/robomimic?utm_source=chatgpt.com">GitHub</a>)</li>
</ul>
<p>另外，还可以参考“awesome / survey”类仓库（如 Generalist Robotic Foundation Models 列表），从中挑选代表性模型。(<a href="https://github.com/JeffreyYH/Awesome-Generalist-Robots-via-Foundation-Models?utm_source=chatgpt.com">GitHub</a>)</p>
<p><strong>（2）优先选“功能可闭环”的项目</strong></p>
<p>即：</p>
<ul>
<li><strong>至少包含</strong>：数据加载 → 模型构建 → 训练 / 微调 → 推理 / 评估 全流程代码；</li>
<li>最好提供：<strong>示例脚本</strong>（<code>examples/</code>、<code>scripts/</code>、<code>tutorials/</code> 目录）、<strong>预训练权重下载方式</strong>以及<strong>一键 demo</strong>。</li>
</ul>
<p>这类项目可以让你做到：</p>
<blockquote>
<p>读几页 README → 配好环境 → 跑通一个 demo → 再回头看代码结构，印象会清晰很多。</p>
</blockquote>
<p><strong>（3）从“小而完整”到“大而复杂”的渐进路径</strong></p>
<p>建议的学习顺序可以是：</p>
<ol>
<li><strong>单任务、单机器人项目</strong>（比如基于 robomimic 的模仿学习基线）——先熟悉最简 pipeline。(<a href="https://robomimic.github.io/docs/introduction/getting_started.html?utm_source=chatgpt.com">robomimic</a>)</li>
<li><strong>单机器人、多任务 VLA 模型</strong>（如某些 RT-1 实现、Octo 子集）。(<a href="https://github.com/google-research/robotics_transformer?utm_source=chatgpt.com">GitHub</a>)</li>
<li><strong>多机器人、多模态的大型基础模型</strong>（OpenVLA、Octo 全量等）。</li>
</ol>
<p><strong>（4）检查“可维护性信号”</strong></p>
<p>打开 GitHub 后，可以快速扫描：</p>
<ul>
<li>Star / fork 数量是否过低（过少可能仓库尚不成熟）；</li>
<li>最近是否有 commit（过于久远可能与当前依赖版本不兼容）；(<a href="https://github.com/ARISE-Initiative?utm_source=chatgpt.com">GitHub</a>)</li>
<li>README 是否有安装、数据准备、训练、评估等完整说明；</li>
<li>是否有 issue / discussion 在积极回复。</li>
</ul>
<p><strong>图片占位</strong>：</p>
<blockquote>
<p>[图 11-2-1 占位：某开源 VLA 仓库的 GitHub 首页截图，标出 README、<code>src/</code>、<code>configs/</code>、<code>scripts/</code> 等关键入口。]</p>
</blockquote>
<hr>
<h4 id="11212-入口与主流程"><a class="header" href="#11212-入口与主流程">11.2.1.2 入口与主流程</a></h4>
<p>选定项目后，第一步不是“逐文件通读”，而是找到 <strong>程序的主干流程</strong>。通常可以按下面的套路来。</p>
<p><strong>（1）从 README / 教程脚本反推入口</strong></p>
<p>大多数项目都会在 README 中给出类似命令：</p>
<pre><code class="language-bash">python train.py --config configs/openvla_libero.yaml
# 或
python -m openvla.train experiment=openvla_libero
</code></pre>
<p>这条命令中的脚本（<code>train.py</code>）或模块（<code>openvla.train</code>）就是训练主入口。(<a href="https://github.com/openvla/openvla?utm_source=chatgpt.com">GitHub</a>)</p>
<p>推理同理，例如 Octo 中的 <code>inference.py</code>、<code>demo_*</code> 脚本通常是第一站。(<a href="https://github.com/octo-models/octo?utm_source=chatgpt.com">GitHub</a>)</p>
<p><strong>（2）用“从外到内”的方式跟踪主流程</strong></p>
<p>打开入口脚本后，可以标出几个关键函数：</p>
<ul>
<li>参数 / 配置加载：<code>parse_args</code>、<code>OmegaConf.load</code>、<code>hydra.main</code> 等；</li>
<li>初始化：<code>setup_logger</code>、<code>set_seed</code>、<code>build_model</code>、<code>build_dataset</code>；</li>
<li>训练循环：<code>for epoch in ...:</code>、<code>train_one_epoch</code>、<code>evaluate</code>;</li>
<li>保存与日志：<code>save_checkpoint</code>、<code>log_metrics</code>。</li>
</ul>
<p>建议画一个简单的流程图（哪怕是纸上手绘）：</p>
<blockquote>
<p>“命令行参数 / 配置 → 构造 Dataset / DataLoader → 构造 Model → 配置 Optimizer / Scheduler → 训练循环（forward + loss + backward + step）→ 定期验证 + 保存权重”。</p>
</blockquote>
<p><strong>图片占位</strong>：</p>
<blockquote>
<p>[图 11-2-2 占位：训练主流程框图，从命令行入口到训练循环、评估与保存。]</p>
</blockquote>
<p><strong>（3）用简化伪代码重构理解</strong></p>
<p>可以尝试把入口脚本抽象成伪代码，加深对整体结构的理解，例如：</p>
<pre><code class="language-python">def main(config):
    # 1. 环境初始化
    setup_seed(config.seed)
    setup_distributed(config.dist)
    logger = setup_logger(config.log)

    # 2. 构建数据与模型
    train_loader, val_loader = build_dataloaders(config.data)
    model = build_model(config.model).to(device)
    optimizer, scheduler = build_optimizer(config.optim, model)

    # 3. 训练循环
    for epoch in range(config.optim.num_epochs):
        train_one_epoch(model, train_loader, optimizer, scheduler, logger, epoch, config)
        if (epoch + 1) % config.eval.freq == 0:
            evaluate(model, val_loader, logger, epoch, config)
        save_checkpoint_if_needed(model, optimizer, epoch, config, logger)
</code></pre>
<p>阅读仓库时，可以一边看原始代码，一边自己在笔记里写下类似伪代码，逐渐把陌生代码抽象成熟悉的结构。</p>
<p><strong>（4）优先看“数据一帧的生命周期”</strong></p>
<p>主流程的核心，是<strong>一条数据从磁盘到 loss 的路径</strong>。在入口脚本中找到：</p>
<ol>
<li><code>Dataset.__getitem__</code>：从文件中读出图像、状态、语言指令、动作等；</li>
<li><code>collate_fn</code>：将多条样本打包成 batch；</li>
<li><code>model.forward</code>：如何对视觉 / 语言 / 状态 / 历史动作编码并融合；</li>
<li><code>loss_fn</code>：如何对动作 token 或连续动作计算损失；</li>
<li><code>loss.backward()</code> → <code>optimizer.step()</code>。</li>
</ol>
<p>优先搞清楚这一条“完整 pipeline”，再去深挖细节，会更有方向感。</p>
<hr>
<h4 id="11213-模块划分"><a class="header" href="#11213-模块划分">11.2.1.3 模块划分</a></h4>
<p>当你知道“程序从哪里进、大概要干什么”之后，下一步是给仓库做一个 <strong>功能模块地图</strong>。</p>
<p><strong>（1）典型 VLA / 机器人基础模型仓库的目录结构</strong></p>
<p>很多仓库会有类似的分层（以伪目录为例）：</p>
<pre><code class="language-latex">openvla/
  configs/            # YAML / JSON 配置
  data/               # 数据相关（dataset 定义、预处理）
  models/             # VLA 模型、backbone、头部等
  train/ 或 engine/   # 训练 / 推理引擎（循环、分布式封装）
  eval/               # 评估脚本、指标实现
  envs/ 或 robots/    # 仿真环境或真实机器人接口
  utils/              # 通用工具（日志、分布式、检查点等）
  scripts/            # 命令行脚本、demo
</code></pre>
<p>Octo、RT-1 的公开实现以及 robomimic 等框架基本都采用类似的层次结构，只是在命名和粒度上略有差别。(<a href="https://github.com/octo-models/octo?utm_source=chatgpt.com">GitHub</a>)</p>
<p><strong>图片占位</strong>：</p>
<blockquote>
<p>[图 11-2-3 占位：一个典型 VLA 仓库目录树示意图，用颜色标出 config / data / models / train / eval 等模块。]</p>
</blockquote>
<p><strong>（2）按“重要性和依赖顺序”规划阅读顺序</strong></p>
<p>推荐的阅读顺序：</p>
<ol>
<li><code>configs/</code> 或 <code>conf/</code>：了解有哪些实验配置、使用了什么模型 / 数据集 / 优化器；</li>
<li><code>models/</code>：搞清楚主干网络结构（Transformer / diffusion policy / CNN + Transformer）与输入输出定义；</li>
<li><code>data/</code>：理解轨迹数据的组织形式，包括视觉帧、语言指令、动作序列、状态等；</li>
<li>**训练引擎 <strong><code>train/</code></strong> / **<code>engine/</code>：如何把 data / model / optimizer 拼接起来，如何做分布式、日志、保存；</li>
<li><code>eval/</code>** 与 <strong><code>envs/</code></strong> / **<code>robots/</code>：评估指标、仿真或真实机器人接口是怎样集成进来的；</li>
<li><code>utils/</code>：最后再看，里面通常是通用工具，对整体理解帮助较小。</li>
</ol>
<p><strong>（3）为每个模块写一行“功能注解”</strong></p>
<p>在个人笔记中，可以给每个核心模块写一句话的总结，例如：</p>
<ul>
<li><code>openvla/models/transformer_vla.py</code>：实现视觉-语言-动作统一 Transformer 的主体结构，定义输入 token 化与动作解码；</li>
<li><code>octo/data/trajectory_dataset.py</code>：负责从 Open X-Embodiment 之类数据集中读取轨迹，并打包成 transformer-friendly 的序列。(<a href="https://octo-models.github.io/?utm_source=chatgpt.com">octo-models.github.io</a>)</li>
<li><code>robomimic/algos/bc.py</code>：标准行为克隆算法实现，可作为所有模仿学习类算法的参照基线。(<a href="https://github.com/ARISE-Initiative/robomimic?utm_source=chatgpt.com">GitHub</a>)</li>
</ul>
<p>随着阅读深入，你会发现许多项目尽管细节不同，但在模块划分和数据流设计上高度相似，理解一个之后，再看新的 VLA 仓库就容易很多。</p>
<hr>
<h3 id="1122-从配置文件与训练脚本理解整体-pipeline"><a class="header" href="#1122-从配置文件与训练脚本理解整体-pipeline">11.2.2 从配置文件与训练脚本理解整体 pipeline</a></h3>
<p>前面强调了“从入口梳理主流程，本小节更系统地讲：如何仅凭配置文件和训练脚本，把一个大型项目的 <strong>训练 pipeline</strong> 在脑中“还原”为清晰的结构。</p>
<hr>
<h4 id="11221-配置文件"><a class="header" href="#11221-配置文件">11.2.2.1 配置文件</a></h4>
<p>现代 VLA / 机器人基础模型项目高度依赖配置系统（YAML + Hydra / OmegaConf，或 JSON / Python dict），这是理解 pipeline 的最好入口之一。</p>
<p><strong>（1）典型配置文件结构</strong></p>
<p>以一个假想的 <code>configs/openvla_libero.yaml</code> 为例，你通常会看到以下模块：(<a href="https://github.com/openvla/openvla?utm_source=chatgpt.com">GitHub</a>)</p>
<ul>
<li><code>experiment</code>：实验名、输出目录、随机种子；</li>
<li><code>data</code>：
<ul>
<li>数据集名称（如 <code>libero</code>、<code>robomimic_kitchen</code>）；</li>
<li>数据路径、训练 / 验证拆分；</li>
<li>图像分辨率、帧数（history length）；</li>
<li>是否使用语言指令、状态信息；</li>
</ul>
</li>
<li><code>model</code>：
<ul>
<li>视觉 backbone 类型（ResNet / ViT / FiLM EfficientNet / patch tokenizer 等）；(<a href="https://github.com/google-research/robotics_transformer?utm_source=chatgpt.com">GitHub</a>)</li>
<li>Transformer 层数、hidden dim、注意力头数；</li>
<li>动作 token 化方式（关节空间 / 末端空间 / diffusion policy 的 action embedding）；(<a href="https://github.com/octo-models/octo?utm_source=chatgpt.com">GitHub</a>)</li>
</ul>
</li>
<li><code>optim</code>：
<ul>
<li>优化器类型（AdamW 等）、学习率、权重衰减；</li>
<li>batch size、训练步数 / epoch 数；</li>
<li>学习率调度器（cosine、linear、warmup 步数）；</li>
</ul>
</li>
<li><code>train</code> / <code>dist</code>：
<ul>
<li>使用的 GPU 数量、分布式后端；</li>
<li>混合精度（fp16/bf16）、梯度累积步数；</li>
</ul>
</li>
<li><code>eval</code> / <code>logging</code>：
<ul>
<li>评估频率、保存模型的策略；</li>
<li>日志后端（TensorBoard、W&amp;B）。</li>
</ul>
</li>
</ul>
<p>阅读配置时的一个小技巧：<strong>统一标记“和你关心的科研问题直接相关的字段”</strong>，例如你要做“历史长度 ablation”，就重点关注 <code>data.history_len</code>。</p>
<p><strong>（2）练习：从配置推测训练设定</strong></p>
<p>拿到一个配置文件，可以尝试用文字复述一遍实验设定，例如：</p>
<blockquote>
<p>“本实验使用 LIBERO 仿真数据，单目 RGB 图像，输入 3 帧历史，将语言指令作为文本 token 拼入序列，采用 12 层 Transformer，hidden dim=1024，以 1e-4 学习率在 8 GPU 上训练 200k 步。”</p>
</blockquote>
<p>如果你能做到这一点，说明你已经基本“读懂”了配置文件。</p>
<p><strong>图片占位</strong>：</p>
<blockquote>
<p>[图 11-2-4 占位：标注注释后的 YAML 配置片段截图，用颜色高亮 data/model/optim/dist 等字段。]</p>
</blockquote>
<hr>
<h4 id="11222-训练脚本"><a class="header" href="#11222-训练脚本">11.2.2.2 训练脚本</a></h4>
<p>配置文件给出了“实验的静态参数”，而训练脚本则描述“这些参数如何被用来真正跑起来”。</p>
<p><strong>（1）训练脚本的典型结构</strong></p>
<p>无论是 OpenVLA、Octo 还是 robomimic，训练脚本往往包含几个固定组成部分：(<a href="https://github.com/openvla/openvla?utm_source=chatgpt.com">GitHub</a>)</p>
<ol>
<li><strong>解析配置</strong>
<ul>
<li>从命令行 / Hydra 获取 config；</li>
<li>设置随机种子、确定设备（CPU / GPU）。</li>
</ul>
</li>
<li><strong>构建数据 pipeline</strong>
<ul>
<li>调用 <code>build_dataset(config.data)</code>；</li>
<li>构建 <code>DataLoader</code>，指定 batch size、num_workers、shuffle 等。</li>
</ul>
</li>
<li><strong>构建模型与优化器</strong>
<ul>
<li>调用 <code>build_model(config.model)</code> 返回一个 VLA 模型实例；</li>
<li>将模型移动到设备；</li>
<li>使用 <code>build_optimizer(config.optim, model)</code> 创建优化器和学习率调度器。</li>
</ul>
</li>
<li><strong>（可选）分布式 / 混合精度封装</strong>
<ul>
<li>使用 <code>DistributedDataParallel</code> 或强封装（如 accelerate、Lightning）；</li>
<li>开启 AMP（自动混合精度）上下文。</li>
</ul>
</li>
<li><strong>训练 / 评估循环</strong>
<ul>
<li><code>for step in range(max_steps):</code> 或 <code>for epoch in range(num_epochs):</code>；</li>
<li>在循环中完成前向计算、loss 计算、反向传播、优化器更新；</li>
<li>定期做验证、日志记录与 checkpoint。</li>
</ul>
</li>
</ol>
<p><strong>（2）跟踪“一个 batch”在脚本中的路径</strong></p>
<p>阅读训练脚本时，可以重点追踪以下几个函数调用：</p>
<pre><code class="language-python">for batch in train_loader:
    obs = batch["obs"]          # 视觉、状态等
    lang = batch["language"]    # 语言指令
    actions = batch["actions"]  # 轨迹中下一步动作

    outputs = model(obs, lang)
    loss = compute_loss(outputs, actions)
    loss.backward()
    optimizer.step()
    scheduler.step()
</code></pre>
<p>你可以在 IDE 中用“跳转定义”功能，从 <code>model(...)</code> 追到模型源码，再从 <code>compute_loss</code> 追到 loss 实现，再从 <code>batch</code> 的结构追到 Dataset 定义。</p>
<p><strong>（3）注意训练脚本中“工程细节”的位置</strong></p>
<p>比如：</p>
<ul>
<li><strong>日志与监控</strong>：通常集中在 <code>log_metrics</code>、<code>logger.log</code> 这一类函数里；</li>
<li><strong>梯度裁剪</strong>：可能埋在单独的 <code>optimizer_step</code> 或 <code>train_one_epoch</code> 中；</li>
<li><strong>checkpoint 管理</strong>：保存 / 加载逻辑往往分散在 <code>save_checkpoint</code>、<code>load_checkpoint</code>、<code>resume_if_needed</code> 等函数。</li>
</ul>
<p>这些地方虽然看上去“业务不性感”，但对可复现性和调试至关重要（与第 9.4 节的 MLOps 内容可以互相参照）。</p>
<hr>
<h4 id="11223-pipeline-连贯性"><a class="header" href="#11223-pipeline-连贯性">11.2.2.3 Pipeline 连贯性</a></h4>
<p>当你基本理解配置和训练脚本后，需要进一步做到：<strong>在脑中形成完整、连贯的“实验 pipeline 心智模型”</strong>。</p>
<p><strong>（1）画出三条主线：数据流、模型流、优化流</strong></p>
<p>可以在笔记中画三条并行的线：</p>
<ol>
<li><strong>数据流</strong>：
<ul>
<li>磁盘 → <code>Dataset</code> → <code>DataLoader</code> → batch → 模型输入；</li>
<li>其中包括：图像解码、归一化、数据增强、token 化（语言 / 动作）。</li>
</ul>
</li>
<li><strong>模型流</strong>：
<ul>
<li>视觉编码 → 语言编码 → 多模态融合（Cross-Attention、统一 Transformer）→ 动作解码（token / diffusion）→ loss。</li>
</ul>
</li>
<li><strong>优化流</strong>：
<ul>
<li>loss → backward → 梯度规约（分布式）→ 梯度裁剪 → optimizer step → scheduler step → 更新后的模型参数。</li>
</ul>
</li>
</ol>
<p><strong>图片占位</strong>：</p>
<blockquote>
<p>[图 11-2-5 占位：三条主线（data/model/optim）的时序图，展示一次训练 step 内各模块的调用关系。]</p>
</blockquote>
<p><strong>（2）用“极简运行”检验你的理解</strong></p>
<p>一种非常有效的练习是：</p>
<ul>
<li>在配置中设置 <strong>非常小的 batch size / 步数</strong>（例如 run 10 step 就停）；</li>
<li>在关键位置打印 tensor shape、loss 数值；</li>
<li>在笔记里按顺序记录：
<ul>
<li>输入图像 / token 的维度；</li>
<li>模型内部每层输出的维度（可以用 hook 或简单 print）；</li>
<li>loss 是否随着 step 单调下降（至少在一小段上）。</li>
</ul>
</li>
</ul>
<p>如果你能解释“为何在这一层维度从 768 变成了 1024”“为何这里会多出一维表示时间步”，说明你对 pipeline 的连贯性已经比较清楚。</p>
<p><strong>（3）避免“黑盒跑通”的幻觉</strong></p>
<p>很多同学会陷入“脚本能跑 = 我理解了”的误区。一个简单的自测方法：</p>
<blockquote>
<p>关闭代码，单凭配置和你刚画出的流程图，能否准确回答：
– “训练时每步输入多少帧图像？”
– “语言指令是如何被编码并融合到 Transformer 中的？”
– “动作是 token 化还是直接回归？如果是 token 化，codebook 大小是多少？”
– “优化器与学习率调度策略是什么样的？”</p>
</blockquote>
<p>如果能回答、大致能写出伪代码，那就真正掌握了该仓库的整体 pipeline。</p>
<hr>
<h3 id="1123-debug-常见问题nan梯度爆炸收敛失败"><a class="header" href="#1123-debug-常见问题nan梯度爆炸收敛失败">11.2.3 Debug 常见问题：NaN、梯度爆炸、收敛失败</a></h3>
<p>在 VLA / 机器人基础模型的训练中，<strong>训练失败并不是例外，而是常态</strong>。本节针对最常见的三类问题，给出系统的排查思路与建议，帮助读者建立“工程级”的 debug 能力。</p>
<hr>
<h4 id="11231-遇到-nan"><a class="header" href="#11231-遇到-nan">11.2.3.1 遇到 NaN</a></h4>
<p><strong>（1）现象与第一反应</strong></p>
<p>典型症状包括：</p>
<ul>
<li>loss 突然变为 <code>NaN</code> 或 <code>inf</code>；</li>
<li>指标为 <code>nan</code>；</li>
<li>log 中出现 “gradient overflow” 或 “Detected NaN in …”；</li>
<li>参数 / 梯度中出现非有限值。</li>
</ul>
<p>第一反应：<strong>先停下来保存现场</strong>（log、配置、最近 checkpoint），不要盲目继续训练。</p>
<p><strong>（2）定位 NaN 来源的基本步骤</strong></p>
<ol>
<li><strong>检查输入数据</strong>
<ul>
<li>在 <code>Dataset.__getitem__</code> 和 <code>collate_fn</code> 中打印 / 断言：
<ul>
<li><code>torch.isfinite(img).all()</code>，<code>torch.isfinite(actions).all()</code>；</li>
</ul>
</li>
<li>特别注意：
<ul>
<li>深度图 / 点云中是否有 <code>inf</code>；</li>
<li>关节角 / 速度是否有奇异值（非常大的数 / NaN）。</li>
</ul>
</li>
</ul>
</li>
<li><strong>检查预处理与归一化</strong>
<ul>
<li>图像除以标准差时，是否有 <code>std = 0</code> 的情况；</li>
<li>对数操作 <code>log(x)</code> 是否保证 <code>x &gt; 0</code>；</li>
<li>平方根 <code>sqrt(x)</code> 是否有负数输入；</li>
<li>归一化时是否有 <code>除以样本数 0</code> 的情况。</li>
</ul>
</li>
<li><strong>分拆 loss</strong>
<ul>
<li>如果总 loss 是多个项之和（模仿 loss + 正则项 + 对比损失等），可以单独打印每一项：
<ul>
<li>哪一项先变为 NaN？</li>
</ul>
</li>
<li>在 VLA 中要特别注意：
<ul>
<li>动作 token 的 cross-entropy；</li>
<li>KL 散度 / log-likelihood 之类的项是否做了 <code>clamp</code> 防止 log(0)。</li>
</ul>
</li>
</ul>
</li>
<li><strong>开启框架的 NaN 调试工具</strong>
<ul>
<li>PyTorch 有 <code>torch.autograd.set_detect_anomaly(True)</code>，可以在出现 NaN 时给出对应的运算图堆栈（虽然会变慢）；</li>
<li>使用 <code>torch.isfinite(tensor).all()</code> 在模型关键层输出后做断言，一旦失败就报错中断。</li>
</ul>
</li>
</ol>
<p><strong>（3）典型修复手段</strong></p>
<ul>
<li><strong>降低学习率</strong>：过高学习率容易导致参数一步跳到数值不稳定区域；</li>
<li><strong>关闭或简化混合精度</strong>：FP16 / BF16 下的 underflow / overflow 更常见，可以暂时切回 FP32 验证；</li>
<li><strong>对 denominator 加 epsilon</strong>：如 <code>x / (std + 1e-6)</code>；</li>
<li><strong>对概率做 clamp</strong>：如 <code>p = p.clamp(min=1e-6, max=1-1e-6)</code> 再做 log；</li>
<li><strong>梯度裁剪</strong>：防止某一步梯度过大引发参数爆炸（与下一小节相关）。</li>
</ul>
<hr>
<h4 id="11232-梯度爆炸"><a class="header" href="#11232-梯度爆炸">11.2.3.2 梯度爆炸</a></h4>
<p><strong>（1）如何判断是梯度爆炸？</strong></p>
<ul>
<li>loss 不是逐渐 NaN，而是出现“大尖峰”：某些 step loss 突然暴涨几个数量级；</li>
<li>监控梯度范数（<code>grad_norm</code>）发现某一步骤后飙升；</li>
<li>模型权重中出现非常大的值，或者出现 “gradient overflow” 提示。</li>
</ul>
<p><strong>（2）常见原因</strong></p>
<ul>
<li>初始学习率过高；</li>
<li>使用了非常深的 Transformer / 时间序列长度很长，未配套合理的归一化；(<a href="https://arxiv.org/html/2405.12213v2?utm_source=chatgpt.com">arXiv</a>)</li>
<li>loss 赋予了极端大的权重，例如某个正则项系数设置错误；</li>
<li>reward scaling 或 advantage normalization 未处理好（在 RL 微调阶段尤为常见）；</li>
<li>分布式训练中累计梯度步数设置错误，导致有效学习率被放大。</li>
</ul>
<p><strong>（3）防治手段</strong></p>
<ol>
<li><strong>梯度裁剪（Gradient Clipping）</strong></li>
</ol>
<p>在每次反向传播后、优化器 step 之前：</p>
<pre><code class="language-python">torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=1.0)
optimizer.step()
</code></pre>
<p>可根据模型大小适当调节 <code>max_norm</code>。</p>
<ol start="2">
<li><strong>学习率与 warmup 调整</strong></li>
</ol>
<ul>
<li>先用较小初始学习率，配合 warmup 逐渐升高；</li>
<li>对大模型（如 OpenVLA / Octo 这类 10^8 ~ 10^9 级别参数）尤其重要。(<a href="https://openvla.github.io/?utm_source=chatgpt.com">openvla.github.io</a>)</li>
</ul>
<ol start="3">
<li><strong>检查输入尺度与归一化</strong></li>
</ol>
<ul>
<li>图像 / 状态是否已经做了标准化；</li>
<li>动作 / 关节命令是否做了合理 scaling（例如 [-1, 1] 范围）。</li>
</ul>
<ol start="4">
<li><strong>局部禁用“可疑模块”</strong></li>
</ol>
<ul>
<li>暂时关闭某些新加的 loss、正则或梯度增强模块（如 gradient penalty）；</li>
<li>观察是否还会爆炸，逐步恢复，以定位为哪一部分引起。</li>
</ul>
<hr>
<h4 id="11233-收敛失败"><a class="header" href="#11233-收敛失败">11.2.3.3 收敛失败</a></h4>
<p>相比 NaN 和梯度爆炸那种“明显坏掉”，收敛失败往往更隐蔽：损失在缓慢震荡，但迟迟不降到期望水平，或者训练 / 验证表现出现异常。</p>
<p><strong>（1）先做“过拟合一个小数据子集”测试</strong></p>
<p>这是调试深度学习系统非常经典的技巧：</p>
<ul>
<li>从训练集随机抽取极少量样本（如 100 条轨迹或几百个 batch）；</li>
<li>在这个小数据集上训练，观察模型能否将 loss 降到接近 0、成功率接近 100%。</li>
</ul>
<p>如果<strong>连小数据都过拟合不了</strong>，说明问题不是“模型太弱”而是<strong>实现有 bug</strong>，可能在：</p>
<ul>
<li>label / 动作 token 错位（off-by-one）；</li>
<li>mask / padding 不正确；</li>
<li>loss 计算错误（比如使用了错误的索引）等。</li>
</ul>
<p><strong>（2）系统地排查“工程层面”的可能原因</strong></p>
<ul>
<li><strong>学习率太低 / 过早衰减</strong>：
<ul>
<li>loss 一直缓慢下降但非常慢，可以尝试提高初始学习率，或者延长 warmup、推迟衰减时间；</li>
</ul>
</li>
<li><strong>batch size 太小 / 归一化失效</strong>：
<ul>
<li>BatchNorm 在 batch 太小时表现不佳，可以改用 LayerNorm 或 GroupNorm；</li>
</ul>
</li>
<li><strong>正则化过强</strong>：
<ul>
<li>例如 weight decay 过大、dropout 过多、强数据增强把任务难度拉得过高。</li>
</ul>
</li>
</ul>
<p><strong>（3）从模型与数据匹配性角度思考</strong></p>
<ul>
<li>模型容量是否足以解决任务？
<ul>
<li>对非常复杂的多任务 / 多机器人场景，用一个极小的模型可能就是欠拟合；(<a href="https://octo-models.github.io/?utm_source=chatgpt.com">octo-models.github.io</a>)</li>
</ul>
</li>
<li>数据是否足够、是否正确标注？
<ul>
<li>有无大量失败轨迹混入训练集而未区分；</li>
<li>语言指令与动作是否对齐（时间戳 / ID 是否一致）。</li>
</ul>
</li>
</ul>
<p><strong>（4）建立“调参顺序”而非盲目乱调</strong></p>
<p>可以采用固定顺序：</p>
<ol>
<li>先验证 <strong>数据 / 标签正确性</strong>（过拟合小集合）；</li>
<li>再调整 <strong>学习率 / batch size / epoch 数</strong> 等最基础超参数；</li>
<li>再调整 <strong>模型结构</strong>（层数、宽度），最后才动复杂模块（多任务权重、各种额外 loss）。</li>
</ol>
<p>这样可以避免“一次改很多项，结果更难判断问题出在哪里”的情况。</p>
<hr>
<h3 id="1124-做-ablation-study消融实验的方法"><a class="header" href="#1124-做-ablation-study消融实验的方法">11.2.4 做 ablation study（消融实验）的方法</a></h3>
<p>消融实验不仅是论文中的“标配”，也是你自己判断一个设计是否有价值的基本工具。对 VLA / 机器人基础模型而言，模块众多、数据混杂，更需要严谨的消融方法。</p>
<hr>
<h4 id="11241-确定消融点"><a class="header" href="#11241-确定消融点">11.2.4.1 确定消融点</a></h4>
<p><strong>（1）从“设计假设”出发，而非从代码细节出发</strong></p>
<p>在第 11.3 节中我们会讨论如何提出研究假设，这里你可以先给当前模型的关键设计列一个“假设清单”，例如：</p>
<ul>
<li>引入语言条件能提升多任务泛化能力；</li>
<li>使用 3D 点云相较纯 RGB 能提升抓取鲁棒性；</li>
<li>使用跨机器人混合数据能提高在新机器人上的零样本表现；</li>
<li>使用历史 4 帧，而不是 1 帧，有助于处理动态场景。</li>
</ul>
<p><strong>消融点</strong>就是这些假设对应的具体模块或配置字段。</p>
<p><strong>（2）典型的 VLA 消融点示例</strong></p>
<p>参考 OpenVLA、Octo 等工作中的实验设置，可以列出一些常见维度：(<a href="https://openvla.github.io/?utm_source=chatgpt.com">openvla.github.io</a>)</p>
<ul>
<li><strong>模态消融</strong>：
<ul>
<li>去掉语言（只用视觉 + 状态）；</li>
<li>去掉历史帧（仅用当前帧）。</li>
</ul>
</li>
<li><strong>架构消融</strong>：
<ul>
<li>不使用 Cross-Attention，仅 concat 后喂入 Transformer；</li>
<li>减少 Transformer 层数 / 隐含维度。</li>
</ul>
</li>
<li><strong>数据消融</strong>：
<ul>
<li>只使用单一机器人数据 vs 使用多机器人混合数据；</li>
<li>剪裁训练轨迹长度、减少任务种类。</li>
</ul>
</li>
<li><strong>训练范式消融</strong>：
<ul>
<li>只用行为克隆 vs 行为克隆 + RL 微调；</li>
<li>有无自监督预训练。</li>
</ul>
</li>
</ul>
<p>在确定消融点时，应优先选择 <strong>与你论文主要贡献直接相关</strong> 的设计，而不是把所有能关的开关都关一遍。</p>
<hr>
<h4 id="11242-实验对照"><a class="header" href="#11242-实验对照">11.2.4.2 实验对照</a></h4>
<p><strong>（1）保持“单变量变化”原则</strong></p>
<p>一条底线：<strong>每组对照实验之间，必须确保除了消融点之外，其余设置都尽量一致</strong>。</p>
<ul>
<li>相同的训练数据、训练步数 / epoch 数；</li>
<li>相同的优化器 / learning rate schedule；</li>
<li>相同的 batch size、分布式策略、随机种子（或在同一 seed 集合上重复）。</li>
</ul>
<p>例如，在验证“是否需要语言指令”时，实验可以是：</p>
<ul>
<li>baseline：视觉 + 语言 + 状态；</li>
<li>ablation：视觉 + 状态（完全去掉语言相关模块与输入），其它配置完全相同。</li>
</ul>
<p><strong>（2）控制随机性：多次重复、固定 seed</strong></p>
<p>机器人任务往往噪声很大，单次成功率差异可能只是运气。</p>
<p>实践中可以：</p>
<ul>
<li>设定一组固定种子（如 {0, 1, 2, 3, 4}），每个配置在这些种子上训练一次；</li>
<li>或者在同一个训练好的模型上，对每个任务环境运行多次 episode（如 50–100 次），统计平均成功率。</li>
</ul>
<p>RT-1、Octo 和 OpenVLA 等工作中，通常会在大量 episode 上报告平均成功率以及置信区间，避免单次评测带来的偶然性。(<a href="https://robotics-transformer1.github.io/?utm_source=chatgpt.com">robotics-transformer1.github.io</a>)</p>
<p><strong>（3）实验命名与管理</strong></p>
<p>结合第 9.4 节的数据工程与实验管理建议，对消融实验进行规范命名，例如：</p>
<ul>
<li><code>exp_baseline_vla_full</code></li>
<li><code>exp_ablate_lang</code></li>
<li><code>exp_ablate_history</code></li>
<li><code>exp_ablate_multirobot</code></li>
</ul>
<p>并在日志系统（如 W&amp;B / TensorBoard）中使用统一标签，便于后续可视化和对比。</p>
<p><strong>图片占位</strong>：</p>
<blockquote>
<p>[图 11-2-6 占位：一个对照实验表格示意图，列出不同消融配置与对应成功率，用颜色高亮 best / second best。]</p>
</blockquote>
<hr>
<h4 id="11243-统计显著"><a class="header" href="#11243-统计显著">11.2.4.3 统计显著</a></h4>
<p>有了多组对照实验的结果，还需要回答一个关键问题：<strong>这些差异到底是“真的有用”，还是随机波动？</strong></p>
<p><strong>（1）简单但必要的统计量</strong></p>
<p>在机器人任务评测中，可以至少做到：</p>
<ul>
<li>对每个实验配置，给出 <strong>均值 ± 标准差</strong>：
<ul>
<li>例如，在 5 个 seed 或 100 个 episode 上统计任务成功率；</li>
</ul>
</li>
<li>显式展示样本数量（如“100 episodes，5 seeds”），让读者对方差大小有直觉。</li>
</ul>
<p>例如：</p>
<blockquote>
<p>baseline：$ 76.2 \pm 3.1% $
ablate_lang：$ 59.8 \pm 4.5% $</p>
</blockquote>
<p>即便不做形式化显著性检验，这样的差距已经足以说明“语言模态确实很重要”。</p>
<p><strong>（2）t 检验 / bootstrap 的直观理解</strong></p>
<p>如果你希望更严谨一些，可以使用简单的统计检验：</p>
<ul>
<li><strong>配对 t 检验</strong>
<ul>
<li>当两个配置在同一组 seed / episode 上评测，得到两组结果 $ {x_i} $ 和 $ {y_i} $；</li>
<li>检验它们的平均差值是否显著非零；</li>
</ul>
</li>
<li><strong>bootstrap 置信区间</strong>
<ul>
<li>从 episode 结果中反复采样，构建成功率差值的分布，查看 95% 置信区间是否跨 0。</li>
</ul>
</li>
</ul>
<p>不必在书中推导公式，只要读者理解：</p>
<blockquote>
<p>“统计显著性检验是在问：
若这两个配置在本质上没差别，仅靠随机波动，我们观察到这么大的差距的概率是不是很小？”</p>
</blockquote>
<p><strong>（3）避免过度解读“小数点后”的差异</strong></p>
<p>当两个配置的平均成功率差异 <strong>小于一个标准差</strong> 时，通常不应做过多解读。例如</p>
<blockquote>
<p>A：$ 72.3 \pm 4.0% $
B：$ 74.1 \pm 3.8% $</p>
</blockquote>
<p>从工程实践角度，很难说 B 真的“压倒性更好”，更可能是波动范围内的差异。</p>
<p>相比之下，如果</p>
<blockquote>
<p>A：$ 55.0 \pm 5.0% $
B：$ 75.0 \pm 4.0% $</p>
</blockquote>
<p>则无论是否做正式检验，人眼已经可以判断：<strong>B 明显优于 A</strong>。</p>
<p><strong>（4）回到假设：不只是“谁更高”，而是“为什么”</strong></p>
<p>最后，消融实验的意义不仅在于“证明你的方法更好”；更重要的是：</p>
<ul>
<li>哪些设计是 <strong>关键贡献</strong>（删掉就明显退化）；</li>
<li>哪些设计只是 <strong>锦上添花</strong>；</li>
<li>哪些设计甚至 <strong>可以去掉以简化系统</strong>。</li>
</ul>
<p>在 VLA / 机器人基础模型这种复杂系统中，好的消融可以帮助你：</p>
<ul>
<li>理清“语义理解”“多机器人混合训练”“长时序建模”等因素各自的作用；</li>
<li>为后续迭代提供清晰路径：是优先增加数据、多模态信息，还是改进架构本身。</li>
</ul>
<hr>
<p>本节从“如何选项目、读入口、划分模块”，到“如何通过配置与训练脚本还原 pipeline”，再到“调试与消融实验”的系统方法，构成了从“会跑开源代码”迈向“能可靠复现并改进系统”的关键一环。后续 11.3 节会在此基础上，进一步讨论如何将这些工程能力与论文阅读、选题能力结合起来，完成真正的科研闭环。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="论文阅读与研究选题"><a href="#论文阅读与研究选题" class="header">论文阅读与研究选题</a></h1>
<h2 id="113-论文阅读与研究选题"><a class="header" href="#113-论文阅读与研究选题">11.3 论文阅读与研究选题</a></h2>
<p>前面在 0.2.1 中，我们从“能读懂论文”的角度讨论了理论、公式和实验理解。本节进一步往前走半步：不是“读懂一篇论文”，而是“系统地利用论文，找到自己的研究课题”。这涉及四个环节：分层阅读、利用综述和基准、提出可行的新 idea，以及设计严谨的验证实验。</p>
<hr>
<h3 id="1131-阅读论文的层次摘要--方法--实验--附录"><a class="header" href="#1131-阅读论文的层次摘要--方法--实验--附录">11.3.1 阅读论文的层次：摘要 – 方法 – 实验 – 附录</a></h3>
<p>在具身智能和 VLA 这样快速发展的领域，论文数量巨大，不可能逐篇从头到尾逐行精读。实践中更有效的是“多层次、多遍阅读”的策略：先粗读建立全局感，再针对方法和实验做有目的的精读。类似的“多 pass 阅读”方法在机器学习社区中已被反复推荐，用于降低认知负担、提高信息提取效率。(<a href="https://saiamrit.github.io/technical-blog/research/reading_papers/2021/07/31/read-papers.html?utm_source=chatgpt.com">saiamrit.github.io</a>)</p>
<p>【图 11-3-1：论文三层阅读流程示意图。第一层：标题/摘要/结论快速浏览；第二层：方法与核心公式精读；第三层：实验与附录核查，用于复现和批判性分析。】</p>
<h4 id="11311-粗读摘要与结论"><a class="header" href="#11311-粗读摘要与结论">11.3.1.1 粗读摘要与结论</a></h4>
<p>第一遍阅读的目标不是细节，而是判断“这篇论文值不值得我花时间深入”。可以按如下顺序快速浏览：</p>
<ul>
<li>标题与作者、单位：判断大致方向是否与你当前关注的 VLA / 具身智能主题相关。</li>
<li>摘要：聚焦三个问题——解决了什么问题？用了什么大致方法？比之前好在哪里？</li>
<li>引言的首段和贡献列表：确认问题背景是否确实重要，贡献是否清晰、具体，而不是空泛表述。</li>
<li>结论 / Discussion：看作者如何总结结果、承认哪些局限、提出哪些未来工作建议。</li>
</ul>
<p>粗读时可以刻意避免被公式绊住，只要能回答下面几句话即可：</p>
<blockquote>
<p>这篇论文针对 _______ 场景/任务，提出了 _______ 方法，在 _______ 数据集/平台上，相比 _______ 基线，在 _______ 指标上提升了大约 _______。</p>
</blockquote>
<p>如果连这句话都填不完整，要么你阅读不够专注，要么论文写作本身就比较混乱。对于具身智能方向，可以再加一句：“是否涉及真实机器人或只在仿真中验证？”</p>
<p>粗读的输出最好是一两行笔记，记录在自己的文献表格或笔记系统中，为之后的“方法/实验精读”做筛选。</p>
<h4 id="11312-聚焦方法"><a class="header" href="#11312-聚焦方法">11.3.1.2 聚焦方法</a></h4>
<p>当一篇论文在粗读阶段被判定为“值得投入时间”，下一步就是围绕“方法”做精读。这一层阅读的目标是：</p>
<ol>
<li><strong>弄清楚方法在做什么</strong>：从输入到输出，整个流水线是什么样。</li>
<li><strong>搞清楚它和已有工作的本质区别</strong>：是新的网络结构？新的训练目标？新的数据构造方式？还是系统工程集成？</li>
<li><strong>判断这些差异是否合理、有潜在可推广性</strong>。</li>
</ol>
<p>具体操作上，可以采用如下习惯：</p>
<ul>
<li>把方法画成一个方框图：输入（图像、语言、机器人状态）→ 编码模块 → 融合/规划模块 → 动作解码 → 输出控制指令。
【图 11-3-2：将一篇 VLA 论文方法画成“模块方框图”的示意图，可标注出与前人工作的差异模块。】</li>
<li>遇到公式时，不急于推导每一步，而是先确认每个符号代表什么量、单位是什么、在哪个模块使用。</li>
<li>对照 Related Work，确认作者自己声称的“创新点”到底对应到方法的哪些具体改动，而不是停留在写作层面的新名词。</li>
</ul>
<p>对于具身智能类论文，方法精读时尤其要注意：</p>
<ul>
<li><strong>动作空间是如何建模的</strong>（连续/离散、Delta Pose 还是关节角度）。</li>
<li><strong>与真实机器人系统的接口是什么</strong>（是否依赖某些难以获取的传感器或昂贵平台）。</li>
<li><strong>假设条件</strong>：例如是否假设精准的相机标定、完美的抓取检测、无延迟的控制等，这些都直接影响后续可复现性和扩展性。</li>
</ul>
<p>如果你能在不看论文的情况下，用自己的话把方法讲给同专业同学听并画出流程图，就说明“方法这一层”真正读懂了。</p>
<h4 id="11313-分析实验"><a class="header" href="#11313-分析实验">11.3.1.3 分析实验</a></h4>
<p>第三层阅读以实验为中心，目标不再是“搞懂作者做什么”，而是“评估这套方法到底有多可信、多有用”。</p>
<p>可以从以下几个维度系统检查：</p>
<ol>
<li><strong>任务与数据集</strong>
<ul>
<li>对于 VLA/具身智能论文，区分仿真任务 vs 真实机器人任务，单任务 vs 多任务。</li>
<li>观察任务难度：是固定初始布局，还是随机摆放？有无遮挡、光照变化、视觉噪声？</li>
</ul>
</li>
<li><strong>对比基线是否合理</strong>
<ul>
<li>是否包含当前公认的 SOTA 方法和简单但强的 baseline（例如“行为克隆 + 预训练视觉”这类标准组合），避免“欺负弱基线”的情况。</li>
<li>baseline 是否用同样的训练数据、超参数规模和计算预算，否则对比不公平。</li>
</ul>
</li>
<li><strong>评价指标与统计可靠性</strong>
<ul>
<li>具身任务中常见的是成功率、平均完成时间、路径长度等指标。注意是否报告方差或置信区间，而不是只有单个数字。</li>
<li>多次重复实验（不同随机种子、不同场景实例）是基本要求，否则结论的统计意义有限。</li>
</ul>
</li>
<li><strong>消融实验（Ablation Study）</strong>
<ul>
<li>理想情况下，每个声称的“创新部件”都应该有移除/替换实验，验证它真有贡献，而不是“锦上添花的细节”。</li>
</ul>
</li>
</ol>
<p>【图 11-3-3：实验分析示意图。左侧为不同方法在多个任务上的成功率柱状图，右侧为消融实验表格，突出关键模块的贡献。】</p>
<p>阅读实验部分时，可以刻意思考三个问题：</p>
<ul>
<li>如果让我复现实验，我还缺哪些信息？（超参数、网络宽度、数据预处理等通常在附录或开源代码中。）</li>
<li>结论能否推广到我感兴趣的机器人平台或任务？有哪些隐含前提？</li>
<li>有没有“反例场景”没有被测试，例如极端光照、物体外观分布显著不同等？这些都是潜在研究切入点。</li>
</ul>
<hr>
<h3 id="1132-如何从综述与基准工作中找到空白点"><a class="header" href="#1132-如何从综述与基准工作中找到空白点">11.3.2 如何从综述与基准工作中找到空白点</a></h3>
<p>单篇论文告诉你“局部地形”，而综述（Survey）和大规模基准（Benchmark）则提供整个领域的“地图”。要找到真正有意义的研究课题，一个常见做法是：先用综述构建全局视图，再结合基准结果，定位“尚未被攻克的高价值山头”。系统化文献综述本身就是识别研究空白的重要工具。(<a href="https://www.sciencedirect.com/science/article/pii/S2215016122002746?utm_source=chatgpt.com">科学直通车</a>)</p>
<h4 id="11321-查找-survey-综述"><a class="header" href="#11321-查找-survey-综述">11.3.2.1 查找 Survey 综述</a></h4>
<p>对于具身智能 / VLA 方向，查找综述时不必只依赖某一个数据库，而是可以采用“多渠道 + 关键词”的组合策略，例如：</p>
<ul>
<li>数据库：Google Scholar、arXiv、ACM Digital Library、IEEE Xplore 等。</li>
<li>关键词组合：
<ul>
<li>“embodied AI survey”、“robotic manipulation review”、“vision-language-action survey”；</li>
<li>中文可用“具身智能 综述”、“机器人 操作 基准”等。</li>
</ul>
</li>
<li>限定时间与 venue：优先关注近 3–5 年在顶会（NeurIPS、ICLR、ICRA、RSS、CoRL、CVPR 等）或顶刊上发表的综述，因为具身智能领域变化很快。</li>
</ul>
<p>阅读综述时，不需要一开始就逐字精读，可以重点关注：</p>
<ul>
<li>综述如何划分子方向（例如按“导航/操作”、“仿真/真实”、“视觉主导/语言主导”等）。</li>
<li>每个子方向下的代表性方法、关键数据集、通用评价指标。</li>
<li>综述作者在结尾部分总结的“开放问题”和“未来研究方向”，一般都直接点出了若干重要空白。</li>
</ul>
<p>这些信息将成为你构建“本领域知识图谱”的主结构。</p>
<h4 id="11322-比较方法优劣"><a class="header" href="#11322-比较方法优劣">11.3.2.2 比较方法优劣</a></h4>
<p>在掌握了综述中的“方法清单”后，下一步是主动比较各方法的优劣，而不是被动接受综述作者给出的评价。建议动手做一张简单的对比表，将若干代表性方法按统一的维度进行比较，例如：</p>
<ul>
<li>模型维度：是否使用预训练 VLM/VLA、参数规模、是否端到端。</li>
<li>数据维度：需要多少示教数据、是否依赖真人遥操作、是否支持多机器人。</li>
<li>任务维度：适用的任务类型（抓取、插拔、开门等）、场景复杂度。</li>
<li>工程维度：是否开源代码和模型、是否报告真实机器人实验、对硬件要求如何。</li>
</ul>
<p>【图 11-3-4：基于综述构建“方法 × 维度”对比表的示意图。行对应不同论文，列对应数据需求、泛化能力、是否支持多任务等指标。】</p>
<p>通过这种结构化比较，你会发现一些有规律的“trade-off”：</p>
<ul>
<li>某些方法在仿真中表现很好，但一到现实机器人就明显掉点——典型的 sim2real 差距问题。</li>
<li>某些方法需要大量高质量示教，难以在资源有限的实验室复制。</li>
<li>某些方法依赖特定硬件（例如稠密力觉传感），在一般平台上不现实。</li>
</ul>
<p>这些“缺点”和“限制条件”，就是潜在的改进机会和研究突破口。</p>
<h4 id="11323-寻找空白"><a class="header" href="#11323-寻找空白">11.3.2.3 寻找空白</a></h4>
<p>在综述和基准结果的基础上，我们可以更有针对性地寻找“真正的空白点”，而不仅是“给现有方法改个名字”。从宏观上看，研究空白大致可以分为几类：(<a href="https://www.phdassistance.com/academy/phd-topic-selection-computer-science/?utm_source=chatgpt.com">phdassistance</a>)</p>
<ol>
<li><strong>场景空白</strong>
某类现实环境重要但鲜有研究。例如：大部分具身智能工作集中在桌面操作，而对“狭窄空间（抽屉内部、柜子深处）操作”的系统研究较少。</li>
<li><strong>能力空白</strong>
某种关键能力在现有方法中表现普遍较差。例如：对长期任务的跨阶段记忆、对语言中隐含约束（“轻拿轻放”）的遵循等。</li>
<li><strong>方法空白</strong>
某类思路在相关领域已被实践证明有效，但在具身智能中尚未系统尝试。例如：世界模型 + 规划在 RL 社区很活跃，但在真实机器人多任务操作上还相对缺乏系统验证。</li>
<li><strong>评价空白</strong>
某些重要指标（安全性、能耗、动作平滑度、对人类友好程度）在现有工作中很少作为主要评价指标出现。</li>
</ol>
<p>判断一个“空白”是否值得做，可以用三问法过滤：</p>
<ul>
<li>现实意义：填补这个空白会不会显著提高真实机器人系统的可用性/安全性？</li>
<li>学术意义：它是否涉及新问题或迫使我们提出新的方法，而不是简单工程堆砌？</li>
<li>可行性：现有资源和时间内能否以合理代价搭建实验平台并得到可验证的结论？</li>
</ul>
<p>真正好的选题，往往是上述三点之间的平衡，而不是某一维度的极端。</p>
<hr>
<h3 id="1133-提出可行新-idea-的能力缩小范围明确假设"><a class="header" href="#1133-提出可行新-idea-的能力缩小范围明确假设">11.3.3 提出可行新 idea 的能力：缩小范围、明确假设</a></h3>
<p>找到“有价值的空白”只是第一步，下一步是把它收缩为一个可操作的具体课题。这需要从“宽泛兴趣”逐渐下钻到“明确问题 + 可检验的假设”。研究方法论中普遍强调，选题要经历从初始兴趣、文献梳理到范围收缩、可行性评估的过程。(<a href="https://www.timscdrmumbai.in/choosing-a-research-topic-in-computer-applications-tips-for-phd-students/?utm_source=chatgpt.com">timscdrmumbai.in</a>)</p>
<h4 id="11331-明确问题"><a class="header" href="#11331-明确问题">11.3.3.1 明确问题</a></h4>
<p>一个好的研究问题至少要回答四个“W”：</p>
<ul>
<li><strong>研究对象是什么？</strong>
例如：“语言条件下的桌面抓取任务中的遮挡鲁棒性问题”。</li>
<li><strong>想改进的指标是什么？</strong>
如成功率、对新物体的泛化、对遮挡比例的鲁棒性等。</li>
<li><strong>相对于谁更好？</strong>
要有明确的比较参考（现有 SOTA 方法、某一真实系统基线等）。</li>
<li><strong>在什么环境下成立？</strong>
仿真还是现实？单臂机械臂还是移动操作平台？感知传感器配置如何？</li>
</ul>
<p>把这些内容写成一句规范的“研究问题表述”，例如：</p>
<blockquote>
<p>在桌面抓取任务中，当存在严重部分遮挡时，现有基于单视角视觉条件的 VLA 策略成功率显著下降。本研究的问题是：<strong>在不增加大规模示教成本的前提下，能否利用多视角信息提高对遮挡物体的抓取成功率？</strong></p>
</blockquote>
<p>这样的表述，比“提高机器人在复杂场景中的鲁棒性”之类的泛泛说法，已经具体和可操作得多。</p>
<h4 id="11332-假设切入"><a class="header" href="#11332-假设切入">11.3.3.2 假设切入</a></h4>
<p>问题明确之后，需要提出若干“可检验的假设”（hypothesis），说明你认为<strong>为什么</strong>现状不好，以及你打算通过什么机制改进。</p>
<p>假设要尽量简洁、有因果指向，并且<strong>可以被实验推翻</strong>。例如：</p>
<ul>
<li>假设 1：在训练阶段增加多视角图像输入，可以改善模型对遮挡部位的表征，从而提高遮挡场景下的抓取成功率。</li>
<li>假设 2：引入一个专门预测“遮挡区域显著性”的辅助任务，可以提高模型对关键几何结构的关注，从而提升鲁棒性。</li>
</ul>
<p>对于具身智能中的 VLA 模型，常见的假设切入点包括：</p>
<ul>
<li>表征层假设：更好的视觉/语言表征会带来更好的决策。</li>
<li>结构层假设：更合理的模态融合、记忆机制会改善长期任务表现。</li>
<li>训练策略假设：更合理的模仿 / RL / 自监督组合会提升样本效率和泛化。</li>
</ul>
<p>这里不需要一上来就设计一个庞大的“大一统架构”，而是先围绕一两个关键假设设计最小改动。</p>
<h4 id="11333-可行性评估"><a class="header" href="#11333-可行性评估">11.3.3.3 可行性评估</a></h4>
<p>在正式开始实现之前，必须冷静评估 idea 的可行性。这一步既是对时间和精力的保护，也是避免“论文写了一半发现做不完”的关键。</p>
<p>可以从三个维度快速评估：</p>
<ol>
<li><strong>资源</strong>
<ul>
<li>计算资源：需要训练的模型规模是否超出实验室 GPU 能力？训练一版模型要几天还是几周？</li>
<li>数据资源：是否已有合适的数据集？若需自采，采集和标注成本多大？</li>
</ul>
</li>
<li><strong>复杂度</strong>
<ul>
<li>软件工程复杂度：是否需要从头搭建完整机器人系统，还是在已有开源框架上做增量？</li>
<li>硬件复杂度：是否依赖难以维护的复杂硬件（多臂协作、特殊传感器）？</li>
</ul>
</li>
<li><strong>时间线</strong>
<ul>
<li>将整个项目拆成几个里程碑（baseline 复现 → 最小版本实现 → 完整实验 → 写作），估算每一步的时间。</li>
</ul>
</li>
</ol>
<p>一个实用的做法是给每个候选 idea 在“创新性 / 重要性 / 可行性”三个维度各打 1–5 分，再结合导师建议选出综合得分最高、风险可控的方向。</p>
<hr>
<h3 id="1134-设计实验验证假设对照组变量控制"><a class="header" href="#1134-设计实验验证假设对照组变量控制">11.3.4 设计实验验证假设：对照组、变量控制</a></h3>
<p>科学研究的核心不在于“提出多么炫的想法”，而在于“用严谨实验证明或否定这些想法”。在具身智能领域，这一点尤为重要：机器人实验昂贵、噪声大，如果实验设计不严谨，很容易得出偶然性结论。</p>
<p>【图 11-3-5：实验设计示意图。左侧为 baseline 流水线，右侧为在关键模块上添加新方法的改进流水线，二者共享相同的数据和评价协议。】</p>
<h4 id="11341-最小可行实验"><a class="header" href="#11341-最小可行实验">11.3.4.1 最小可行实验</a></h4>
<p>验证假设不一定要一开始就上真实机器人全流程。更高效的方式是设计一个<strong>最小可行实验（Minimal Viable Experiment, MVE）</strong>：</p>
<ul>
<li>环境可以简化：例如只用 3 种物体、固定光照和背景，而不是复杂家庭环境。</li>
<li>任务可以简化：先验证“抓起目标物体”这一基本操作，再逐步扩展到“抓起 + 放置”、“序列操作”。</li>
<li>模型可以简化：例如先将新表征模块接在一个较小的决策网络上，验证是否确实带来性能提升。</li>
</ul>
<p>最小可行实验的目标不是展示“很酷的 demo”，而是<strong>尽快验证核心假设是否成立</strong>。如果在高度受控、简化的环境中假设都站不住脚，就没有必要投入巨大工程量扩展到复杂场景。</p>
<h4 id="11342-控制变量"><a class="header" href="#11342-控制变量">11.3.4.2 控制变量</a></h4>
<p>要让实验结论可信，关键是实现“除了我要检验的因素之外，其余条件尽量保持不变”。在具身智能 / VLA 实验中，常见的控制变量包括：</p>
<ul>
<li><strong>数据集与任务配置</strong>：同一批训练数据、相同的训练/验证/测试划分、相同的随机种子或至少相同的随机化策略。</li>
<li><strong>模型容量与训练预算</strong>：比较方法时，应尽量保持参数量级和训练轮次接近，避免“多一倍参数”的方法天然占优。</li>
<li><strong>系统环境</strong>：在真实机器人实验中，需要保持相似的物体摆放难度、场景布置和硬件状态（如关节润滑、传感器标定状态）。</li>
</ul>
<p>形式上，你可以为每个假设设计一个或少量对照实验，例如：</p>
<ul>
<li>baseline：原始 VLA 模型。</li>
<li>
<ul>
<li>模块 A：只加入新的视觉辅助任务。</li>
</ul>
</li>
<li>
<ul>
<li>模块 B：只加入新的历史编码模块。</li>
</ul>
</li>
<li>
<ul>
<li>A + B：同时加入两者，看是否有叠加效果。</li>
</ul>
</li>
</ul>
<p>通过这种可控的“加减法”，读者才能清楚地看到每个改动对结果的真实贡献，而不是被一个“大杂烩模型”弄得云里雾里。</p>
<h4 id="11343-数据充分性"><a class="header" href="#11343-数据充分性">11.3.4.3 数据充分性</a></h4>
<p>最后一个容易被忽视但非常关键的问题是：<strong>你收集的数据和运行的实验是否足以支撑结论？</strong></p>
<p>在具身智能实验中，常见的“数据不充分”表现包括：</p>
<ul>
<li>每个设置只在极少数任务、极少数初始场景上测试；</li>
<li>只跑了 1 次或 2 次随机种子，结果差异可能只是运气；</li>
<li>没有报告失败案例，也没有分析模型在哪些条件下会崩溃。</li>
</ul>
<p>更稳妥的做法包括：</p>
<ul>
<li>对每种方法在多个任务、多个随机场景上进行足够次数的试验，报告均值和标准差或置信区间。</li>
<li>对关键任务绘制<strong>性能随训练步数变化的曲线</strong>，而不是只给出“最终数值”，帮助读者判断收敛速度和稳定性。</li>
<li>对典型失败案例进行可视化分析，解释可能的失败原因，为后续改进提供线索。</li>
</ul>
<p>在条件允许的情况下，也可以采用简单的统计检验（例如 t-test）来验证两种方法在多次重复实验中的差异是否具有统计显著性，而不是凭直观“看上去高了 3 个点”就下结论。</p>
<hr>
<p>本节从“如何分层阅读单篇论文”出发，延伸到“如何借助综述把握全局、从基准中发现空白”、“如何把空白压缩为明确假设”，再到“如何设计最小、但足够有力的实验验证这些假设”。掌握这一整套流程，意味着你不仅能理解他人的工作，更能在具身智能这个快速演化的领域中，稳步构建属于自己的研究方向。后续 11.4 将进一步讨论如何将研究过程中的成果凝练为论文与报告，使你的工作在学术共同体中被清晰地传播与评价。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="写作与展示"><a href="#写作与展示" class="header">写作与展示</a></h1>
<h2 id="114-写作与展示"><a class="header" href="#114-写作与展示">11.4 写作与展示</a></h2>
<p>本节讨论的不是“怎么做实验”，而是“怎样把已经做好的工作讲清楚”：写成论文、画成图、讲成报告，并且在团队中高效协作。对于具身智能方向的研究生而言，这几乎决定了你的工作能否真正被看到、被复现、被认可。</p>
<hr>
<h3 id="1141-研究报告与论文结构问题方法实验讨论"><a class="header" href="#1141-研究报告与论文结构问题方法实验讨论">11.4.1 研究报告与论文结构（问题、方法、实验、讨论）</a></h3>
<p>现代科学论文普遍采用 IMRaD 结构：Introduction（引言 / 问题）、Methods（方法）、Results（结果）、Discussion（讨论）。(<a href="https://writingcenter.gmu.edu/writing-resources/imrad/writing-an-imrad-report?utm_source=chatgpt.com">The Writing Center</a>)
不同期刊会有额外小节（相关工作、实验设置等），但核心逻辑是一致的：<strong>把科学探索过程压缩成一条清晰的故事线</strong>。</p>
<h4 id="11411-问题动机"><a class="header" href="#11411-问题动机">11.4.1.1 问题动机</a></h4>
<p>“问题动机”往往对应引言部分。它要完成三件事：</p>
<ol>
<li><strong>放置背景（Context）</strong>：
在具身智能领域，背景可以是：
<ul>
<li>机器人操作任务越来越复杂（家庭服务、多步骤装配等）；</li>
<li>VLA 模型在视觉、语言、动作之间的统一建模正在成为趋势；</li>
<li>现实部署时仍然存在样本效率、鲁棒性和安全性问题。</li>
</ul>
</li>
<li><strong>指出缺口（Gap）</strong>：
不是简单地说“尚缺研究”，而是具体指出：
<ul>
<li>现有方法在什么场景失败？例如只能处理短时操作，无法应对长时任务；</li>
<li>现有数据集 / 评测标准有什么盲点？比如只在仿真中评测，缺现实机器人结果；</li>
<li>现有模型在什么维度（样本效率、泛化、可解释性）明显不够好。</li>
</ul>
</li>
<li><strong>提出问题与贡献（Question &amp; Contribution）</strong>：
用一两句明确写出你要解决的问题，例如：</li>
</ol>
<blockquote>
<p>“我们研究如何让 VLA 模型在有限真实数据下，仍能泛化到新的桌面整理任务。”
随后用条目总结你的主要贡献（模型、数据集、理论分析等），让审稿人一眼看懂你做了什么。</p>
</blockquote>
<p>写“问题动机”时需要注意：</p>
<ul>
<li><strong>避免空泛口号</strong>：诸如“人工智能对人类社会很重要”这种句子对任何论文都成立，但不能帮助读者理解你的具体研究位置。</li>
<li><strong>尽量贴近“场景”</strong>：具身智能的天然优势是有具体物理场景，可以用 1–2 句描述一个真实情境（如“家庭机器人整理餐桌”），读者能立刻代入。</li>
<li><strong>适度关联前人工作</strong>：可以先概括几类主流方法，再指出它们的共同局限，将详细的 Related Work 放到单独小节展开。</li>
</ul>
<p>（插图占位：
<strong>【图 11-4-1：具身智能论文的“背景–缺口–贡献”三段式结构示意图】</strong>
用简单框图展示：现实场景 → 现有方法 → 存在问题 → 本文方案与贡献。）</p>
<h4 id="11412-方法描述"><a class="header" href="#11412-方法描述">11.4.1.2 方法描述</a></h4>
<p>“方法”部分要让读者<strong>既能理解你在做什么，又有机会复现</strong>。在具身智能论文中，常见的结构是：</p>
<ol>
<li><strong>整体框架图 + 概述</strong>
先用一张系统框图总览：输入（多模态观测、语言指令、机器人状态）→ VLA 模型结构 → 输出动作 → 与机器人控制器的接口。
用一小节（如 “Overview”）用文字走一遍图中信息流，不涉及细节，只讲模块之间如何协同。</li>
<li><strong>模型结构与关键思想</strong>
<ul>
<li>分别说明视觉编码、语言编码、历史轨迹编码、动作解码等模块；</li>
<li>对具身智能特有的设计要重点解释，例如：
<ul>
<li>动作 token 的离散化方式；</li>
<li>如何在 Transformer 中融合视觉与语言（Cross-Attention、早期/中期融合等）；</li>
<li>如何兼容多机器人、多任务。</li>
</ul>
</li>
<li>若提出了新的损失函数、正则项、训练范式（如 BC + RL + 自监督联合训练），给出清晰公式和符号表，保持全篇符号一致。(<a href="https://www.queensu.ca/offroad-robotics/learning/tips-technical-writing?utm_source=chatgpt.com">queensu.ca</a>)</li>
</ul>
</li>
<li><strong>训练与数据细节（但不变成“实验”）</strong>
在具身智能论文中，一些训练细节往往写在方法或“Implementation Details”小节：
<ul>
<li>使用哪些数据源（开源数据集 + 自建数据）；</li>
<li>预训练与微调的阶段划分；</li>
<li>重要超参数量级（学习率范围、batch size 数量级、训练总步数）。
细节不必穷尽，但要足够让他人可以复现主结果。</li>
</ul>
</li>
<li><strong>系统与硬件设置</strong>
对具身智能尤其重要：
<ul>
<li>说明所用机器人平台（机械臂型号、自由度、末端执行器类型），传感器（相机类型、安装方式）；</li>
<li>若涉及手眼标定、控制频率等关键工程设置，可在方法末尾概述，详细信息可放附录。</li>
</ul>
</li>
</ol>
<p>（插图占位：
<strong>【图 11-4-2：典型 VLA 具身智能系统结构框图（视觉、语言、动作与控制器的关系）】</strong>）</p>
<h4 id="11413-实验结果"><a class="header" href="#11413-实验结果">11.4.1.3 实验结果</a></h4>
<p>IMRaD 中的“结果”部分，主要任务是<strong>把数据呈现清楚，而不做过度解读</strong>，解读放到讨论。(<a href="https://writingcenter.gmu.edu/writing-resources/imrad/writing-an-imrad-report?utm_source=chatgpt.com">The Writing Center</a>)</p>
<p>在具身智能领域，实验结果一般包括几层：</p>
<ol>
<li><strong>实验设置简述</strong>
在 Results 开头简要提醒：
<ul>
<li>有哪些任务场景（抓取、分类搬运、开门等）；</li>
<li>使用哪些数据集 / 仿真环境 / 真实机器人；</li>
<li>评价指标是什么（成功率、路径长度、完成时间、安全约束违反次数等）。</li>
</ul>
</li>
<li><strong>核心定量结果</strong>
通常以<strong>表格 + 若干曲线图</strong>呈现：
<ul>
<li>与主流 baseline（例如 BC-only、纯 RL、无语言版本等）进行对比；</li>
<li>在多任务、多物体、多环境条件下拆分指标；</li>
<li>如果有消融实验（去掉语言条件、去掉历史轨迹、换 Visual backbone），建议用单独表格列出。
绘图时要遵守“图形完整性”原则，避免通过截断坐标轴等方式夸大差异。(<a href="https://pmc.ncbi.nlm.nih.gov/articles/PMC8700024/?utm_source=chatgpt.com">PMC</a>)</li>
</ul>
</li>
<li><strong>定性结果与可视化</strong>
<ul>
<li>展示典型任务执行序列（关键帧截图）；</li>
<li>展示注意力热图、动作分布等，帮助读者理解模型在“看哪里、做什么”；</li>
<li>展示成功和失败案例，并在讨论部分进一步分析原因。</li>
</ul>
</li>
<li><strong>泛化与鲁棒性实验</strong>
对具身智能来说，泛化常是审稿人关注重点：
<ul>
<li>新物体、新布局、新指令的表现；</li>
<li>仿真到现实（Sim2Real）的迁移结果；</li>
<li>噪声、延迟、遮挡条件下的表现。</li>
</ul>
</li>
</ol>
<p>结果部分的写作风格应尽量中性、克制，少用“极大地、革命性”等夸张形容词，让数据自己说话。</p>
<h4 id="11414-讨论启示"><a class="header" href="#11414-讨论启示">11.4.1.4 讨论启示</a></h4>
<p>“讨论”是从结果出发，回到你在引言中提出的问题，回答：<strong>这些结果说明了什么？有什么局限？对未来有什么启发？</strong>(<a href="https://www.sokogskriv.no/en/writing/the-imrad-format.html?utm_source=chatgpt.com">sokogskriv.no</a>)</p>
<p>可以考虑以下结构：</p>
<ol>
<li><strong>核心发现的总结</strong>
用 2–3 句话高度概括：
<ul>
<li>在什么场景下你的方法明显优于 baseline；</li>
<li>哪些能力（如长时规划、语言理解、多机器人泛化）得到显著提升。</li>
</ul>
</li>
<li><strong>为什么会这样：机制与直觉</strong>
尝试给出合理解释，而不仅是重复数字，例如：
<ul>
<li>多模态预训练让模型在新任务上表现更好，是因为视觉–语言对齐减少了“找错物体”的错误；</li>
<li>行为克隆 + RL 的组合在样本效率上优于纯 RL，是因为 BC 提供了合理的初始策略。</li>
</ul>
</li>
<li><strong>局限性与失败案例</strong>
对具身智能尤其重要：
<ul>
<li>指出在什么任务上仍然失败（如复杂接触操作、强遮挡）；</li>
<li>分析原因（感知不稳定、控制接口延迟、训练数据分布偏差）；</li>
<li>能适度提出你计划如何解决，但不要在这篇文章里承诺太多。</li>
</ul>
</li>
<li><strong>对领域的启示与未来方向</strong>
把你的工作放回到“通用机器人 / 具身智能”的大图景中：
<ul>
<li>你的结果是否支持某种建模路线（例如“统一 Transformer”确实在多任务上更有优势）；</li>
<li>对数据集设计、评测协议、系统架构的启示；</li>
<li>未来可以如何扩大到更复杂环境、多机器人协作等（可和本书第 12 章的前沿方向呼应）。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1142-图表与可视化的表达方式"><a class="header" href="#1142-图表与可视化的表达方式">11.4.2 图表与可视化的表达方式</a></h3>
<p>图表的作用，是把长篇的数字和文字压缩成一眼可见的结构。数据可视化研究强调：<strong>图形应该以最少的“视觉噪声”，准确传达尽可能多的有用信息</strong>，包括避免所谓“chart junk”（为装饰而存在的多余元素）。(<a href="https://luiscruz.github.io/2021/03/01/effective-visualizations.html?utm_source=chatgpt.com">Luís Cruz</a>)</p>
<p>具身智能论文里的图表常包括：</p>
<ul>
<li>训练曲线 / 学习曲线；</li>
<li>成功率、奖励等统计曲线；</li>
<li>对比 baseline 的指标表格；</li>
<li>机器人执行任务的关键帧、轨迹示意等。</li>
</ul>
<h4 id="11421-曲线图"><a class="header" href="#11421-曲线图">11.4.2.1 曲线图</a></h4>
<p>曲线图适合表达<strong>随时间或某个变量变化的趋势</strong>，比如：</p>
<ul>
<li>训练步数 vs 成功率 / 回报；</li>
<li>任务难度（物体数量、遮挡程度） vs 成功率；</li>
<li>不同方法在同一任务上的学习速度对比。</li>
</ul>
<p>设计曲线图时，可以遵循以下原则：(<a href="https://www.spiedigitallibrary.org/journals/Journal-of-MicroNanolithography-MEMS-and-MOEMS/volume-12/issue-04/040101/How-to-Write-a-Good-Scientific-Paper--Figures-Part/10.1117/1.JMM.12.4.040101.full?utm_source=chatgpt.com">SPIE Digital Library</a>)</p>
<ol>
<li><strong>坐标轴信息完整</strong>
<ul>
<li>轴名称 + 单位要写清楚，例如 “Environment Steps (×10⁵)”、“Success Rate (%)”；</li>
<li>若坐标轴截断或采用对数坐标，要在图上明确标明，否则容易误导。</li>
</ul>
</li>
<li><strong>曲线数量适中，易于区分</strong>
<ul>
<li>一张图中最好不要超过 4–5 条曲线；</li>
<li>使用不同线型（实线 / 虚线 / 点线）或色彩，配合清晰图例（legend）；</li>
<li>同一篇文章内尽量保持颜色含义一致（例如蓝色永远代表你的主方法）。</li>
</ul>
</li>
<li><strong>呈现波动与不确定性</strong>
<ul>
<li>可以绘制平均值 + 标准差（或标准误差）带状区域，让读者看到结果的稳定性；</li>
<li>避免只画单次运行的锯齿曲线，可在多次运行基础上平滑（移动平均）并注明处理方式。</li>
</ul>
</li>
<li><strong>图注（caption）要“可独立阅读”</strong>
很多写作指南建议：读者应该只看图和图注，也能大致理解结果含义。(<a href="https://www.spiedigitallibrary.org/journals/Journal-of-MicroNanolithography-MEMS-and-MOEMS/volume-12/issue-04/040101/How-to-Write-a-Good-Scientific-Paper--Figures-Part/10.1117/1.JMM.12.4.040101.full?utm_source=chatgpt.com">SPIE Digital Library</a>)
图注中应包含：
<ul>
<li>图的目的（比较什么 vs 什么）；</li>
<li>实验设定的关键信息；</li>
<li>主要观察结论（例如“我们的方法在大多数步数段均明显优于传统 BC”。）</li>
</ul>
</li>
</ol>
<p>（插图占位：
<strong>【图 11-4-3：不同方法在机器人抓取任务上的训练曲线对比示意图】</strong>
横轴为环境步数，纵轴为成功率，多条曲线表示不同算法。）</p>
<h4 id="11422-表格"><a class="header" href="#11422-表格">11.4.2.2 表格</a></h4>
<p>表格适合展示<strong>离散的、多维的最终结果对比</strong>，例如：</p>
<ul>
<li>多个任务、多种方法、多种指标（成功率、耗时、能耗）的对照；</li>
<li>消融实验不同配置（有 / 无语言条件、有 / 无历史轨迹）的结果；</li>
<li>不同机器人平台上的性能。</li>
</ul>
<p>设计表格时，建议注意：(<a href="https://www.queensu.ca/offroad-robotics/learning/tips-technical-writing?utm_source=chatgpt.com">queensu.ca</a>)</p>
<ol>
<li><strong>结构清晰</strong>
<ul>
<li>行一般是方法 / 配置，列是任务或指标；</li>
<li>对于多任务多指标，可以分块或用分组表头（multi-level header）。</li>
</ul>
</li>
<li><strong>突出重点</strong>
<ul>
<li>用粗体标记最优值，下划线或斜体标记次优值；</li>
<li>可以增加“平均分”或“排名”一列，帮助读者快速形成整体印象。</li>
</ul>
</li>
<li><strong>必要的统计信息</strong>
<ul>
<li>对关键结果提供标准差或置信区间；</li>
<li>若有统计显著性检验（如 t-test），可在表中用符号注明（例如“*”表示 p &lt; 0.05）。</li>
</ul>
</li>
<li><strong>表注说明变量和设定</strong>
<ul>
<li>在表格下方用简短表注解释缩写（如 “SR=Success Rate”）、实验设定（如“每个任务评估 50 次尝试”）；</li>
<li>若空间有限，可以在附录中放完整表格，在正文展示简化版。</li>
</ul>
</li>
</ol>
<p>（插图占位：
<strong>【表 11-4-1：多任务具身操作中不同 VLA 模型成功率对比示意表】</strong>）</p>
<h4 id="11423-图像示例"><a class="header" href="#11423-图像示例">11.4.2.3 图像示例</a></h4>
<p>对于具身智能论文，图像示例可以让读者<strong>直观看到机器人在做什么</strong>，弥补纯文字和数字难以传达的细节。例如：</p>
<ol>
<li><strong>任务执行序列</strong>
<ul>
<li>选取 3–6 张关键帧（初始、接近、抓取、放置等）拼成一行；</li>
<li>在每帧下标注时间步和动作摘要（如“t=5，末端执行器向左平移”）。</li>
</ul>
</li>
<li><strong>轨迹与注意力可视化</strong>
<ul>
<li>在图像上叠加末端执行器轨迹、抓取点、避障路径；</li>
<li>可视化模型内部注意力：比如在图像上用热图表示语言 token “red block” 所对应的视觉注意区域。</li>
</ul>
</li>
<li><strong>成功与失败对比</strong>
<ul>
<li>并列展示成功和失败的两个序列，帮助讨论模型在什么情况下容易失误（例如光照强烈反光、物体遮挡严重）。</li>
</ul>
</li>
</ol>
<p>在设计这些图像时，可以借鉴数据可视化的一个基本原则：在不牺牲准确性的前提下，尽量减少多余装饰，突出真正承载信息的部分。(<a href="https://www.geeksforgeeks.org/data-visualization/mastering-tuftes-data-visualization-principles/?utm_source=chatgpt.com">GeeksforGeeks</a>)</p>
<p>（插图占位：
<strong>【图 11-4-4：机器人执行“将红色积木放入盒子”的关键帧序列示意图】</strong>
<strong>【图 11-4-5：VLA 模型在不同语言指令下的视觉注意力热力图示意图】</strong>）</p>
<hr>
<h3 id="1143-组会报告与学术汇报的准备"><a class="header" href="#1143-组会报告与学术汇报的准备">11.4.3 组会报告与学术汇报的准备</a></h3>
<p>写论文是<strong>静态表达</strong>，报告与汇报则是<strong>动态表达</strong>。二者的核心逻辑类似：讲清楚问题、方法和结果；但报告需要在有限时间内，让不同背景的听众跟得上你的节奏。</p>
<h4 id="11431-针对听众"><a class="header" href="#11431-针对听众">11.4.3.1 针对听众</a></h4>
<p>准备报告前，先问自己三个问题：</p>
<ol>
<li><strong>听众是谁？</strong>
<ul>
<li>组会：大多是同门、导师，熟悉具身智能和你所在项目的背景，可以讲得更技术、更细；</li>
<li>学术会议：来自不同子领域（控制、视觉、NLP、强化学习），对你具体系统细节不熟，但对方法思想和实验设计很敏感；</li>
<li>企业或跨学科听众：可能更关心应用前景、系统稳定性和可落地性，而不是公式推导。</li>
</ul>
</li>
<li><strong>他们已经知道什么？</strong>
工程演讲指南通常建议：开头几分钟要明确说明你的目标和假定背景。(<a href="https://web.mst.edu/~stutts/me242/labmanual/techpresguide.pdf?utm_source=chatgpt.com">米苏里科技大学</a>)
<ul>
<li>对组会报告，可以假定大家了解基本的 RL / BC / Transformer；</li>
<li>对跨学科报告，则需要简要解释具身智能、VLA 和机器人任务设定。</li>
</ul>
</li>
<li><strong>他们最关心什么？</strong>
<ul>
<li>导师：你是否有实质性进展、遇到什么阻碍、下一步计划是什么；</li>
<li>程序委员会 / 会议听众：你的方法真的解决了一个清晰的问题吗？实验是否充分？</li>
<li>企业听众：系统在真实场景中表现如何？硬件成本和工程复杂度如何？</li>
</ul>
</li>
</ol>
<p>根据这些判断，你可以调整报告中“理论细节 vs 实验 vs 工程实现”的比例。</p>
<h4 id="11432-讲稿结构"><a class="header" href="#11432-讲稿结构">11.4.3.2 讲稿结构</a></h4>
<p>一次典型的技术报告（10–15 分钟）可以采用以下结构：(<a href="https://engineering.purdue.edu/abegsa/symposium/presentations/?utm_source=chatgpt.com">engineering.purdue.edu</a>)</p>
<ol>
<li><strong>标题与动机（1–2 张）</strong>
<ul>
<li>标题页：题目、作者、机构、机器人平台照片（增加直观印象）；</li>
<li>动机页：一张真实场景图片或视频截图，说明“我们想让机器人完成什么任务”，配合 2–3 句话说明现有方法的问题。</li>
</ul>
</li>
<li><strong>问题定义与挑战（1–2 张）</strong>
<ul>
<li>用图示说明任务设定：输入、输出、环境；</li>
<li>列出 2–3 个核心挑战，例如：多模态对齐、长时规划、Sim2Real 差距。</li>
</ul>
</li>
<li><strong>方法概览与关键模块（3–4 张）</strong>
<ul>
<li>打一张总框图，类似论文方法小节中的系统图；</li>
<li>每个关键模块一张图，例如“视觉编码器”、“语言条件模块”、“动作解码器”；</li>
<li>对具身智能系统，可以单独介绍“如何与真实机器人控制器接口”。</li>
</ul>
</li>
<li><strong>实验与结果（3–4 张）</strong>
<ul>
<li>1 页总结实验设置（任务、数据、指标）；</li>
<li>1–2 页展示关键定量结果（表格或曲线），突出结论性的比较；</li>
<li>1–2 页展示关键定性结果（任务执行视频 / 截图）。</li>
</ul>
</li>
<li><strong>讨论、局限与未来工作（1–2 张）</strong>
<ul>
<li>一页总结“我们学到了什么”（3 个要点）；</li>
<li>一页说明局限与下一步计划，例如“尚不支持多机器人协同”、“真实环境样本仍偏少”。</li>
</ul>
</li>
<li><strong>总结与提问（1 张）</strong>
<ul>
<li>用 3 条 bullet 总结贡献；</li>
<li>明确写出“欢迎提问”，并保留时间。</li>
</ul>
</li>
</ol>
<p>实际准备时，可以粗略以“<strong>1 分钟 ≈ 1 张内容丰富的幻灯片</strong>”来估计总页数。</p>
<p>（插图占位：
<strong>【图 11-4-6：具身智能项目技术报告的示例目录结构】</strong>）</p>
<h4 id="11433-演讲技巧"><a class="header" href="#11433-演讲技巧">11.4.3.3 演讲技巧</a></h4>
<p>技术演讲的目标不是表演，而是<strong>让尽可能多的听众真正理解你的工作</strong>。一些通用的工程演讲建议在机器人场景同样适用：(<a href="https://web.mst.edu/~stutts/me242/labmanual/techpresguide.pdf?utm_source=chatgpt.com">米苏里科技大学</a>)</p>
<ol>
<li><strong>节奏与时间控制</strong>
<ul>
<li>正式场合的 10–12 分钟报告，建议提前至少完整试讲 2–3 次，计时；</li>
<li>对每一页幻灯片有一个明确的“核心句子”，讲完这句就可以翻页，避免在某一页停留过久；</li>
<li>避免在最后几分钟仓促跳过关键实验，只能匆匆给出结论。</li>
</ul>
</li>
<li><strong>语言与表达</strong>
<ul>
<li>使用<strong>短句 + 明确主语</strong>，避免长而复杂的从句；</li>
<li>尽量少念 PPT 上的文字，而是用自己的话解释图和公式；</li>
<li>对于复杂公式，只讲它“代表什么关系”，不必逐项朗读。</li>
</ul>
</li>
<li><strong>图像与动画</strong>
<ul>
<li>具身智能报告非常适合带视频或动画演示，但应准备好备用方案（静态截图 + 说明），以防现场播放失败；</li>
<li>动画要简洁：比如展示轨迹演化、注意力随时间的变化，而不是花哨的转场效果。</li>
</ul>
</li>
<li><strong>面对提问</strong>
<ul>
<li>遇到没有想过的问题，可以先复述问题确认理解，再用你已有的分析框架尝试回答；</li>
<li>对于暂时无法回答的问题，可以坦诚说明：“我们还没有在那个场景下测试，但根据目前结果，我的直觉是……”，并可以记录下来作为后续工作线索。</li>
</ul>
</li>
<li><strong>线上报告</strong>
对远程会议，要特别注意：
<ul>
<li>提前测试网络与音频设备；</li>
<li>减少 PPT 上过小的文字，保证在小窗口里仍可看清图和公式；</li>
<li>使用激光笔/鼠标标记关键区域，帮助听众跟随。</li>
</ul>
</li>
</ol>
<hr>
<h3 id="1144-与导师和同组同学的协作方式"><a class="header" href="#1144-与导师和同组同学的协作方式">11.4.4 与导师和同组同学的协作方式</a></h3>
<p>具身智能项目通常是<strong>多人协作的大工程</strong>：模型、仿真、硬件、系统集成、数据工程等等。良好的协作能让你事半功倍，糟糕的协作则可能让好想法被埋没。</p>
<h4 id="11441-定期沟通"><a class="header" href="#11441-定期沟通">11.4.4.1 定期沟通</a></h4>
<p>研究生与导师、组员之间如果缺乏结构化沟通，很容易出现“方向偏了很久才发现”的情况。研究生–导师沟通的经验研究普遍建议：<strong>定期会议 + 明确记录 + 可执行的下一步任务</strong>。(<a href="https://howtowriteaphd.org/navigating-the-student-advisor-relationship.html?utm_source=chatgpt.com">howtowriteaphd.org</a>)</p>
<p>可以参考以下做法：</p>
<ol>
<li><strong>固定节奏</strong>
<ul>
<li>与导师至少保持每 1–2 周一次的正式沟通；</li>
<li>组内项目（尤其是涉及机器人实物操作）可以再单独有每周例会，汇报数据采集和系统状态。</li>
</ul>
</li>
<li><strong>会前准备</strong>
<ul>
<li>用一页或一两张幻灯片总结自上次会议以来的进展：完成了哪些实验、发现了哪些问题；</li>
<li>列出你需要讨论的关键问题（例如“动作离散化方案是否需要调整”、“真实机器人实验的安全限制如何设置”），避免会议变成单向汇报。</li>
</ul>
</li>
<li><strong>会后记录</strong>
<ul>
<li>会议结束后，整理一份简短的 Meeting Notes，通过邮件或协作平台发给导师和组员：
<ul>
<li>本次会议的结论（例如“优先在仿真验证多机器人场景”）；</li>
<li>明确分配的任务和 deadline；</li>
<li>需要进一步查阅文献或实验验证的开放问题。
这类做法被多篇指导文档视为缓解沟通误差的有效方式。(<a href="https://howtowriteaphd.org/navigating-the-student-advisor-relationship.html?utm_source=chatgpt.com">howtowriteaphd.org</a>)</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="11442-协作开发"><a class="header" href="#11442-协作开发">11.4.4.2 协作开发</a></h4>
<p>具身智能项目往往涉及大量代码、配置和实验脚本。良好实践包括：(<a href="https://www.nature.com/articles/s44271-025-00236-3?utm_source=chatgpt.com">Nature</a>)</p>
<ol>
<li><strong>版本控制与代码组织</strong>
<ul>
<li>使用 Git 等版本控制工具，建立统一的代码仓库；</li>
<li>按模块组织目录（data、models、training、robot_interface、evaluation 等），避免“一个巨大脚本包打天下”；</li>
<li>在 README 中写清楚“怎样从零跑起一个最小示例”。</li>
</ul>
</li>
<li><strong>统一编码规范</strong>
<ul>
<li>制定或采用现有的代码风格规范（如 Python 的 PEP 8），并在 CI（持续集成）中自动检查；</li>
<li>对涉及机器人控制的关键模块（安全检查、力矩限制等），要求至少一名组员进行 code review，以减少隐蔽 bug。</li>
</ul>
</li>
<li><strong>实验记录与可复现性</strong>
<ul>
<li>使用实验管理工具或简单的日志文件记录每次实验的配置（超参数、数据版本、代码提交哈希）；</li>
<li>对关键结果建立“再现脚本”，保证新成员或审稿人有机会复现实验。</li>
</ul>
</li>
<li><strong>软硬件协作</strong>
在具身智能项目中，一部分同学偏算法，一部分偏硬件：
<ul>
<li>建议建立清晰的接口文档（例如动作命令和传感器数据的消息格式），减少反复对接；</li>
<li>硬件同学在更改机械臂或相机配置时，应同步更新标定和系统参数，并通知算法同学。</li>
</ul>
</li>
</ol>
<p>良好的协作开发不仅提高效率，也是提升研究可复现性与可信度的重要途径。(<a href="https://www.nature.com/articles/s44271-025-00236-3?utm_source=chatgpt.com">Nature</a>)</p>
<h4 id="11443-互相审阅"><a class="header" href="#11443-互相审阅">11.4.4.3 互相审阅</a></h4>
<p>互相审阅包括：<strong>论文草稿、报告幻灯片、代码与实验设计</strong>。它的价值主要体现在三个方面：</p>
<ol>
<li><strong>提前发现问题</strong>
<ul>
<li>同门往往比审稿人更早看到你的初稿；</li>
<li>他们可以指出“这部分的符号定义看不懂”、“图 3 和图 4 的颜色含义不一致”等细节问题，也能指出实验缺失之处。</li>
</ul>
</li>
<li><strong>提升表达质量</strong>
<ul>
<li>邀请对该方向不太熟悉的同学阅读你的摘要和引言，如果他们能大致复述你的工作，你的表达就基本合格；</li>
<li>对于英文论文，请至少让一位写作较强的同学帮忙润色语法与措辞。</li>
</ul>
</li>
<li><strong>澄清贡献与署名</strong>
<ul>
<li>在涉及多位同学合作的大项目中，应尽早、透明地讨论各自贡献与论文作者顺序，避免后期产生分歧；(<a href="https://academia.stackexchange.com/questions/147057/professor-i-am-working-with-asked-for-my-code?utm_source=chatgpt.com">Academia Stack Exchange</a>)</li>
<li>在 code review 和实验设计审阅中，明确哪些贡献应被计入论文署名，哪些属于日常技术支持。</li>
</ul>
</li>
</ol>
<p>互相审阅的态度也很重要：</p>
<ul>
<li>给别人意见时，尽量具体、建设性（指出问题 + 给出可选改进方向）；</li>
<li>接受意见时，不要把批评当成“针对个人”，而是把其视作帮你提升文章质量和说服力的免费资源。</li>
</ul>
<hr>
<p>本节从论文结构、图表设计、口头报告到团队协作，构成了具身智能研究中“表达与沟通”的完整闭环。前面各章教你如何把机器人做“聪明”，而本节的目标，是让这些聪明真正被世界看见、理解并在此基础上继续演化。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="更通用的具身基础模型"><a href="#更通用的具身基础模型" class="header">更通用的具身基础模型</a></h1>
<p>在前面章节中，我们已经看到 VLA 模型如何把视觉、语言和动作统一到一个序列建模框架中。随着数据规模、模型规模以及机器人平台的不断扩展，一个自然的问题是：<strong>是否可以像 GPT 之于自然语言一样，构建“具身基础模型”（robotics / embodied foundation models），在不同机器人、不同任务和环境之间共享同一个“大脑”？</strong></p>
<p>近年的 Open X-Embodiment、RT-X、RT-1/RT-2、OpenVLA 等工作已经给出了早期答案：通过汇聚多机器人、多任务的示教数据，在统一的 Transformer 架构上进行大规模预训练，可以得到跨平台迁移能力较强的通用控制策略。(<a href="https://arxiv.org/abs/2310.08864?utm_source=chatgpt.com">arXiv</a>)</p>
<p>本节将进一步从三个方面展望更通用的具身基础模型形态：</p>
<ol>
<li><strong>统一感知–语言–动作–记忆的长序列建模</strong>：模型不再只看“当前几帧图像 + 指令”，而是能在长时间尺度上整合多模态历史和长期记忆。</li>
<li><strong>跨模态世界模型与规划能力</strong>：模型内部拥有可“想象”未来的世界模型，并在多模态空间（图像、语言、动作）中进行规划与推理。</li>
<li><strong>多机器人协作与群体智能</strong>：从单一机器人扩展到机器人群体，让基础模型在多智能体场景中学习协同、通信和分工。</li>
</ol>
<h3 id="1211-统一感知语言动作记忆的长序列建模"><a class="header" href="#1211-统一感知语言动作记忆的长序列建模">12.1.1 统一感知–语言–动作–记忆的长序列建模</a></h3>
<p>传统 VLA 更多关注“短序列”：几十到几百步的感知–动作序列，以及一句或几句指令。在真实应用中，机器人往往需要：</p>
<ul>
<li>记住数小时甚至数天前发生过什么；</li>
<li>融合多种传感器（视觉、力觉、触觉、语音、机体状态等）；</li>
<li>跨任务、跨场景复用过去经验。</li>
</ul>
<p>这意味着仅靠固定长度的 Transformer 上下文已经不够，需要在<strong>模态扩展</strong>与<strong>时间尺度扩展</strong>上同时进化。</p>
<p>【图 12-1：示意一条统一时间轴，沿时间维度排布图像帧、语言 token、关节状态、力觉读数和动作命令，每个都被编码为 token 输入同一个 Transformer。】</p>
<h4 id="12111-模态融合扩展"><a class="header" href="#12111-模态融合扩展">12.1.1.1 模态融合扩展</a></h4>
<p>当前的 VLA 多以“视觉 + 文本 + 动作”为主。例如 RT-1 / RT-2 和 OpenVLA 将图像帧、自然语言指令和机器人关节/末端命令统一编码为 token 序列，输入同一个 Transformer 决策器。(<a href="https://robotics-transformer-x.github.io/?utm_source=chatgpt.com">robotics-transformer-x.github.io</a>)</p>
<p>未来更通用的具身基础模型会在模态上进一步扩展：</p>
<ol>
<li><strong>感知层扩展</strong></li>
</ol>
<p>这些信号可以通过专门编码器（CNN/ViT、RNN/Transformer、MLP 等）转换成一系列向量 token，再按时间对齐后送入统一的序列模型。</p>
<ul>
<li><strong>视觉</strong>：不再只有 RGB，相机可能包括深度图、鱼眼、全景、多视角甚至事件相机；</li>
<li><strong>触觉与力觉</strong>：高维的触觉阵列、关节力矩传感器、六维力/力矩传感器等，反映接触和相互作用；</li>
<li><strong>机体状态</strong>：关节角、速度、温度、电流、电池电量等内部状态；</li>
<li><strong>语音与声音</strong>：语音命令、环境噪声，可用于人机交互和安全监控。</li>
</ul>
<ol start="2">
<li><strong>统一时间轴与多频采样</strong></li>
</ol>
<p>不同传感器的采样频率差异巨大：</p>
<p>典型做法包括：</p>
<ul>
<li>视觉 10–60 Hz；</li>
<li>力觉和关节状态可到 100–1000 Hz；</li>
<li>语言指令可能是几十秒才更新一次。</li>
<li>在较粗的时间步（如 10 Hz）上建模，使用<strong>统计或卷积池化</strong>将高频信号压缩到该时间步；</li>
<li>引入<strong>层级时间建模</strong>：底层网络处理高频控制，顶层网络在低频节奏上决策（与机器人控制章节呼应）。</li>
</ul>
<p>这样可以在不牺牲关键信息的前提下，把多模态信息统一描述在同一条序列上。</p>
<ol start="3">
<li><strong>高效注意力与结构化融合</strong></li>
</ol>
<p>当所有模态 token 都放进一个自注意力网络时，复杂度会随序列长度平方增长，这在长序列、多模态下极易失控。
未来的架构通常会采用：</p>
<ul>
<li>稀疏/分块注意力：例如对视觉 token 只在空间邻域内自注意，对时间和语言采用更稀疏的连接；</li>
<li>分组注意力：不同模态内部先各自进行自注意，再通过跨模态注意力交互；</li>
<li>图结构：把机器人不同部件、不同传感器看作图中的节点，仅在有物理或任务关系的节点间做消息传递。</li>
</ul>
<p>【图 12-2：多模态 Transformer 结构示意图，分别显示视觉、语言、机体状态、力觉四类 token，经各自编码后在中间层通过稀疏自注意力和跨模态注意力融合。】</p>
<h4 id="12112-长期记忆"><a class="header" href="#12112-长期记忆">12.1.1.2 长期记忆</a></h4>
<p>即便使用更高效的注意力结构，单个 Transformer 上下文仍然难以覆盖数小时乃至“终身”的交互历史。因此需要在序列模型之外设计<strong>长期记忆系统</strong>，类似于“记忆增强版大模型（memory-augmented models）”。(<a href="https://massimilianovurro.com/titans-vs-transformers-how-memory-augmented-ai-models-are-revolutionizing-machine-learning/?utm_source=chatgpt.com">massimilianovurro.com</a>)</p>
<ol>
<li><strong>短期工作记忆 vs 长期持久记忆</strong></li>
</ol>
<p>类似检索增强的 RL 与 Decision Transformer，会在当前状态基础上从外部记忆中检索相关子轨迹，提高决策能力。(<a href="https://proceedings.mlr.press/v162/goyal22a/goyal22a.pdf?utm_source=chatgpt.com">Proceedings of Machine Learning Research</a>)</p>
<ul>
<li><strong>工作记忆</strong>：模型当前上下文窗口内的若干百步历史，主要由 Transformer 自注意力负责；</li>
<li><strong>长期记忆</strong>：以外部存储形式保留过往的轨迹、地图、用户偏好、失败经验等，可以跨任务甚至跨天、跨月保留。</li>
</ul>
<ol start="2">
<li><strong>外部记忆的形式</strong></li>
</ol>
<p>在机器人场景中，长期记忆通常具有多种结构化形式：</p>
<p>近年来大量工作探讨多模态记忆在视觉和机器人中的应用，如为导航与操作提供长期上下文。(<a href="https://github.com/patrick-tssn/Awesome-Multimodal-Memory?utm_source=chatgpt.com">GitHub</a>)</p>
<ul>
<li><strong>轨迹记忆库</strong>：存储过去任务中的感知–动作–奖励序列，可以按“场景相似度”“任务类型”“语言指令”检索；</li>
<li><strong>知识库 / 语义图</strong>：存储“某个房间有哪些物体”“某用户习惯把什么放在哪”等抽象语义关系；</li>
<li><strong>地图与对象数据库</strong>：比如 SLAM 生成的拓扑/栅格地图，以及已知物体的 3D 模型、位姿分布等。</li>
</ul>
<ol start="3">
<li><strong>检索与更新机制</strong>
长期记忆要解决两大问题：<strong>如何取用</strong>和<strong>如何写入</strong>。典型思路包括：
<ul>
<li>检索：
<ul>
<li>通过 learned embedding 或 kNN，根据当前感知+指令在记忆库中查找“相似场景”;</li>
<li>使用注意力机制在大量候选记忆中软选择少量高相关子轨迹（如 Retrieval-Augmented RL、Retrieval-Augmented Embodied Agent）。(<a href="https://proceedings.mlr.press/v162/goyal22a/goyal22a.pdf?utm_source=chatgpt.com">Proceedings of Machine Learning Research</a>)</li>
</ul>
</li>
<li>更新：
<ul>
<li>机器人完成任务后，将经验以“摘要”形式写入：如一条轨迹 + 成功/失败标记 + 语言总结；</li>
<li>对冗余或过时记忆进行压缩或遗忘，避免无限膨胀和概念漂移。</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>【图 12-3：带外部记忆的 VLA 框架示意图：Transformer 主体左侧接收当前多模态输入，右侧通过检索接口连接一个“经验库”，检索得到的关键轨迹片段再反馈给 Transformer 用于决策。】</p>
<ol start="4">
<li><strong>记忆类型与机器人行为</strong>
可以借鉴认知科学，把机器人记忆分为：</li>
</ol>
<p>具身基础模型的长期记忆机制，很可能会自然形成这三类记忆的某种分工，从而支持更高层的推理（在 12.2 节将与终身学习联系起来）。</p>
<ul>
<li><strong>情景记忆（episodic）</strong>：具体任务执行过程，如“上周清理厨房时的操作轨迹”；</li>
<li><strong>语义记忆（semantic）</strong>：抽象的世界知识，如“抽屉一般向外拉开”；</li>
<li><strong>程序记忆（procedural）</strong>：技能级策略，如“如何平稳端起一杯水”。</li>
</ul>
<h4 id="12113-世界模型"><a class="header" href="#12113-世界模型">12.1.1.3 世界模型</a></h4>
<p><strong>世界模型（World Model）</strong> 指的是机器人内部学习到的、可预测环境未来变化的生成模型。与传统的显式物理仿真不同，世界模型通常通过神经网络从数据中学习，反映“观察–状态–动作–结果”的统计规律。(<a href="https://arxiv.org/abs/1803.10122?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>基本构成</strong>
典型世界模型会显式或隐式包含三个模块：</li>
</ol>
<p>例如 World Models、PlaNet、Dreamer 等工作，皆通过这种潜在空间的世界模型实现从图像输入的长视野控制。(<a href="https://arxiv.org/abs/1803.10122?utm_source=chatgpt.com">arXiv</a>)</p>
<ul>
<li><strong>表示模型（encoder）</strong>：将高维观测（图像、深度图等）编码为紧凑的潜在状态 $ z $ ；</li>
<li><strong>动态模型（transition）</strong>：给定当前潜在状态和动作，预测下一时刻的潜在状态；</li>
<li><strong>解码模型（decoder）</strong>：从潜在状态生成预测的观测（未来图像帧、深度图等）以及奖励或任务进展信号。</li>
</ul>
<ol start="2">
<li><strong>角色：机器人“想象力”的载体</strong></li>
<li></li>
</ol>
<p>世界模型的关键价值，在于让机器人可以在内部“做梦”或“想象”：</p>
<ul>
<li><strong>离线规划与评估</strong>：在真实执行之前，机器人可以在世界模型中模拟不同动作序列的结果，从中选出代价较低的一条；</li>
<li><strong>数据效率提升</strong>：在有限真实数据基础上，通过世界模型生成额外“虚拟轨迹”，用于训练策略（类似 Dyna、Dreamer 这类模型）；</li>
<li><strong>安全性</strong>：在执行潜在危险动作前预演可能后果，如预测是否会碰撞或打翻玻璃杯。</li>
</ul>
<ol start="3">
<li><strong>与长期记忆的关系</strong></li>
</ol>
<p>当二者结合时，机器人可以既依据<strong>一般规律</strong>预测未来，又能依据<strong>具体经验</strong>做出更加贴合现实的决定：例如世界模型知道“抽屉可以被拉开”，长期记忆知道“这个抽屉之前卡住过要用更大力 / 角度”。</p>
<ul>
<li><strong>世界模型</strong>更像是“环境的物理与语义规律”：如果在状态 $ s $ 做动作 $ a $ 会出现什么；</li>
<li><strong>长期记忆</strong>更像是“个体经历”：曾在某个房间做过什么、有过哪些成功或失败案例。</li>
</ul>
<p>【图 12-4：世界模型结构示意图：左侧从图像编码为潜在状态，中间用 RNN/Transformer 做潜在动态演化，右侧再解码回未来图像和奖励。】</p>
<hr>
<h3 id="1212-跨模态世界模型与规划能力"><a class="header" href="#1212-跨模态世界模型与规划能力">12.1.2 跨模态世界模型与规划能力</a></h3>
<p>上一小节从“长序列和记忆”的角度引出世界模型，本节进一步强调：<strong>真正通用的具身基础模型，其世界模型本身也应是“跨模态”的</strong>。
换句话说，它不仅能预测未来的视觉帧和物理状态，还可以在<strong>语言、符号和动作空间中进行交互式推理和规划</strong>。</p>
<h4 id="12121-世界模型跨模态视角"><a class="header" href="#12121-世界模型跨模态视角">12.1.2.1 世界模型（跨模态视角）</a></h4>
<p>从跨模态的视角来看，一个理想的世界模型应具备以下特点：(<a href="https://www.sciencedirect.com/science/article/pii/S0893608022001150?utm_source=chatgpt.com">科学直通车</a>)</p>
<ol>
<li><strong>统一潜在状态表示</strong></li>
</ol>
<p>例如，$ z $ 可同时支持问题：“如果执行该动作，下一帧会看到什么画面？”以及“用一句话描述刚才发生了什么？”</p>
<ul>
<li>将视觉、触觉、机体状态、语言指令等都嵌入到一个共享的潜在空间 $ z $ 中；</li>
<li>这个 $ z $ 能同时被“视觉解码器”还原成图像、“语言解码器”转换成自然语言描述、“状态解码器”还原为物理量。</li>
</ul>
<ol start="2">
<li><strong>条件化动态</strong></li>
</ol>
<p>例如，指令从“打扫桌面”改为“只整理左侧书本”，世界模型生成的“合理未来”应明显不同。</p>
<ul>
<li>在给定指令或任务上下文的条件下，世界模型可以预测<strong>在遵循该指令时</strong>环境将如何演化；</li>
<li>这类似于“带任务条件的物理模拟器”：同样的物理环境，按照不同任务策略，未来的轨迹会有显著差异。</li>
</ul>
<ol start="3">
<li><strong>不止会“看”，还能“说”</strong></li>
</ol>
<p>传统世界模型主要输出图像或状态序列。跨模态世界模型还可以：</p>
<p>这使得人类可以通过语言直接与世界模型交互，更易于理解和调试。</p>
<ul>
<li>生成自然语言解释（例如对模拟轨迹进行总结）；</li>
<li>接受自然语言问题，对未来的模拟结果进行问答。</li>
</ul>
<p>【图 12-5：跨模态世界模型示意图：中间是统一潜在状态，左侧是图像解码器，右侧是文本解码器，下方是物理状态解码器，上方是动作/指令条件输入。】</p>
<h4 id="12122-跨模态交互"><a class="header" href="#12122-跨模态交互">12.1.2.2 跨模态交互</a></h4>
<p>跨模态世界模型带来的新能力之一，是让机器人能够以类似“脑内演算 + 语言思考”的方式与世界进行交互。(<a href="https://openaccess.thecvf.com/content/CVPR2024/papers/Zhu_Retrieval-Augmented_Embodied_Agents_CVPR_2024_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</p>
<ol>
<li><strong>语言条件的想象（language-conditioned imagination）</strong>
示例流程：</li>
</ol>
<p>人类甚至可以直接要求机器人“先给我看一下可能的执行方式”，由世界模型生成几段短视频或帧序列供确认。</p>
<ul>
<li>人类： “把台面上的玻璃杯挪到右侧架子上，不要打翻任何东西。”</li>
<li>机器人：将指令编码后，调用世界模型生成若干“候选执行方式”的模拟视频/轨迹；</li>
<li>再由语言模块读取这些模拟结果，回答诸如“哪条方案更安全”“是否有可能碰到桌上的花瓶”。</li>
</ul>
<ol start="2">
<li><strong>从视觉到语言，再回到动作</strong></li>
</ol>
<p>这样，规划过程是可解释的：每一步都可以用语言解释“为什么这样走”。</p>
<ul>
<li>机器人通过视觉观测场景，用语言模块生成内部描述（例如“桌上有两个杯子，一个玻璃一个塑料，右侧有一个空架子”）；</li>
<li>世界模型在这个语言–视觉–动作的联合空间中模拟未来，输出既有图像又有文本解释的“计划脚本”；</li>
<li>最终 VLA 决策头将这些高层计划翻译为细致的动作序列。</li>
</ul>
<ol start="3">
<li><strong>跨模态一致性与自监督</strong></li>
</ol>
<p>在训练过程中，跨模态世界模型还可以利用<strong>自监督的跨模态一致约束</strong>：</p>
<p>这种一致性学习，有助于提升模型对物理规律与语言描述之间关系的理解。</p>
<ul>
<li>给定一段视频，模型需要同时预测其未来帧和未来的语言解说；</li>
<li>给定语言脚本，模型要生成对应的视觉轨迹。</li>
</ul>
<p>【图 12-6：跨模态交互示意图：左侧输入当前图像和指令，中间世界模型展开多条候选未来轨迹，右侧语言模块对每条轨迹给出解释和风险评估。】</p>
<h4 id="12123-规划推理"><a class="header" href="#12123-规划推理">12.1.2.3 规划推理</a></h4>
<p>有了跨模态世界模型，规划不再只是“在状态空间里搜索动作序列”，而是可以在<strong>视觉–语言–动作联合空间</strong>中进行更加灵活的推理。(<a href="https://arxiv.org/pdf/1912.01603?utm_source=chatgpt.com">arXiv</a>)</p>
<ol>
<li><strong>基于世界模型的规划（model-based planning）</strong></li>
</ol>
<p>基本思路与 Dreamer、MuZero 等工作类似：在世界模型中模拟不同动作序列的结果，挑选返回值最高的一条。区别是：</p>
<p>规划方法可以是：</p>
<ul>
<li>这里的状态不仅是隐变量和奖励，还包括未来观察到的图像和语言解释；</li>
<li>规划时可以显式加入语言约束（例如“避免打碎任何玻璃物品”），并在模拟轨迹上检查是否违反。</li>
<li>随机射击或 CEM（随机生成若干动作序列，保留较优者迭代优化）；</li>
<li>MCTS 树搜索（在世界模型中扩展搜索树）；</li>
<li>结合梯度的轨迹优化（在可微世界模型中直接优化连续动作）。</li>
</ul>
<ol start="2">
<li><strong>分层规划：语言–符号–几何的协同</strong></li>
</ol>
<p>通常会采用分层规划框架：</p>
<p>具身基础模型可以在中高层同时发挥作用：既参与子任务分解，又担任模拟器，统一了传统“符号规划 + 物理规划”的分裂结构。</p>
<ul>
<li><strong>高层（语言/符号层）</strong>：由语言模型或符号规划器生成一系列子目标/子任务（如“清空桌面 → 打开放置柜 → 逐个搬运物品”）；</li>
<li><strong>中层（世界模型层）</strong>：在每个子目标下，用世界模型评估不同策略的可行性和风险；</li>
<li><strong>低层（几何/控制层）</strong>：最终在真实机器人或高保真仿真中生成可执行轨迹。</li>
</ul>
<ol start="3">
<li><strong>带不确定性的推理与安全规划</strong></li>
</ol>
<p>世界模型必然是不完美的，它的预测存在不确定性。为了安全起见：</p>
<ul>
<li>模型可以对未来的预测给出不确定度估计，例如“80% 可能不会碰到花瓶，20% 可能发生轻微碰撞”；</li>
<li>规划算法可以将这种不确定性纳入代价函数，例如对高不确定性轨迹进行惩罚；</li>
<li>在高风险场景中，机器人可以主动请求人类确认，或者选择更保守的策略。</li>
</ul>
<p>【图 12-7：分层规划框架示意图：顶层语言 LLM 负责任务分解，中层跨模态世界模型负责模拟和评估，底层运动规划模块负责生成可执行轨迹。】</p>
<hr>
<h3 id="1213-多机器人协作与群体智能"><a class="header" href="#1213-多机器人协作与群体智能">12.1.3 多机器人协作与群体智能</a></h3>
<p>如果说“具身基础模型”解决的是 <strong>“单个机器人如何更聪明地行动”</strong>，那么下一步必然要面对的问题是：<strong>多个机器人如何在同一模型或同一知识体系下实现协作与群体智能</strong>。</p>
<p>从产业角度看，无论是仓储物流的海量移动机器人、工厂中协同搬运的机械臂，还是灾害救援中的无人机集群，多机器人系统相较单机具有更强的效率和冗余，但也带来任务分配、通信、冲突避免等一系列挑战。多智能体深度强化学习和群体机器人（swarm robotics）领域已经积累了大量成果，为未来的“群体具身基础模型”提供了理论基础。(<a href="https://www.mdpi.com/1424-8220/23/7/3625?utm_source=chatgpt.com">MDPI</a>)</p>
<p>【图 12-8：多机器人协作示意图：若干移动机器人在仓库中协同搬运货物，中心有一个共享的世界模型与任务调度模块，各机器人之间通过无线网络交换少量消息。】</p>
<h4 id="12131-协同策略"><a class="header" href="#12131-协同策略">12.1.3.1 协同策略</a></h4>
<p>在多机器人系统中，“策略”不再是单个智能体的映射，而是一个<strong>联合策略</strong> $ \pi(a_1, \dots, a_N | o_1, \dots, o_N) $，或者多智能体分别的局部策略 $ \pi_i(a_i | o_i, m_i) $（其中 $ m_i $ 代表收到的消息）。为了实现高效协同，常见范式包括：(<a href="https://www.mdpi.com/1424-8220/23/7/3625?utm_source=chatgpt.com">MDPI</a>)</p>
<ol>
<li><strong>集中训练、分布执行（CTDE）</strong>
<ul>
<li>训练时，所有机器人共享一个（或若干个）具身基础模型，能够访问全局观测和其他机器人内部状态；</li>
<li>执行时，每个机器人仅使用本地观测和少量通信消息进行决策；</li>
<li>这种范式能够在训练中利用全局信息提高样本效率，而在部署时保持分布式的鲁棒性。</li>
</ul>
</li>
<li><strong>角色与技能的显式分工</strong>
<ul>
<li>不同机器人可以在模型中被编码为不同“角色”（如“搬运”“侦察”“清扫”），每个角色对应不同的技能集；</li>
<li>具身基础模型可以利用“机器人 ID + 角色 embedding”的方式，在同一参数集下实现多机器人异质决策（这一点与 8.5 节的多机器人共享模型相呼应）。(<a href="https://arxiv.org/abs/2310.08864?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>隐式协同：通过共享世界模型</strong>
<ul>
<li>即使不显式引入消息传递，多个机器人在共享的世界模型/价值函数上优化时，也可能出现“涌现式协作”行为；</li>
<li>例如在仓储场景中，机器人可能自动学会错峰通过狭窄通道、轮流进入装卸区，以提高总体吞吐量。</li>
</ul>
</li>
</ol>
<p>【图 12-9：CTDE 框架示意：训练阶段中央服务器看到所有机器人观测和动作，更新共享策略；执行阶段每个机器人仅用局部信息和共享策略进行独立决策。】</p>
<h4 id="12132-通信与分工"><a class="header" href="#12132-通信与分工">12.1.3.2 通信与分工</a></h4>
<p>多机器人协作离不开<strong>信息交换</strong>和<strong>任务分工</strong>。在基础模型的框架下，可以把机器人间通信看作另一种“模态”，通过序列建模统一处理。(<a href="https://www.mdpi.com/1424-8220/23/7/3625?utm_source=chatgpt.com">MDPI</a>)</p>
<ol>
<li>
<p><strong>通信形式</strong>
具身基础模型可以在内部学习“哪些信息值得通报”，而不是预定义通信协议。例如，多智能体 RL 中常见的图网络架构，可被视为一种“可微通信”机制。(<a href="https://jmlr.org/papers/volume20/18-476/18-476.pdf?utm_source=chatgpt.com">机器学习研究杂志</a>)</p>
<ul>
<li><strong>隐式通信</strong>：机器人通过观察他人的动作或环境变化推断其意图，无需显式消息（类似人类通过肢体语言协同）；</li>
<li><strong>结构化消息</strong>：使用固定格式的向量或符号信息（如位置、负载、优先级），通常通过图神经网络进行消息传递；</li>
<li><strong>自然语言 / 类语言通信</strong>：在更高层次，机器人可以使用文本或压缩后的“伪语言 token”交流任务意图和状态摘要。</li>
</ul>
</li>
<li>
<p><strong>动态任务分配与负载均衡</strong></p>
<ul>
<li>在复杂场景中，任务往往是不断到来的，如新订单、新救援目标；</li>
<li>中心调度器或分布式协商算法需要考虑每个机器人的位置、剩余电量、当前任务负载等因素，动态分配任务；</li>
<li>具身基础模型可以在此扮演“学习型调度器”，通过大量历史数据学习到高效的任务分配策略，例如实时优化通道拥堵和整体效率。(<a href="https://arxiv.org/html/2510.03592v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li>
<p><strong>共享记忆与协作策略库</strong></p>
<ul>
<li>与 <a href="https://robotic-embodied-intelligence-from-zero-to-hero.yang-yang.me/Ch12.1.html#12112-%E9%95%BF%E6%9C%9F%E8%AE%B0%E5%BF%86">12.1.1.2</a> 的长期记忆类似，多个机器人可以共享一个“团队记忆库”，记录过去协作中使用过的策略和结果；</li>
<li>检索增强的具身智能（如 Retrieval-Augmented Embodied Agents）已经尝试让多个机器人从共享策略库中检索过去类似场景下的成功策略，再组合生成新策略。(<a href="https://openaccess.thecvf.com/content/CVPR2024/papers/Zhu_Retrieval-Augmented_Embodied_Agents_CVPR_2024_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</li>
</ul>
</li>
</ol>
<p>【图 12-10：多机器人通信与分工示意：机器人以图节点形式存在，边表示通信链路，每个节点从邻居接收消息并更新本地策略，中央或分布节点负责分配新任务。】</p>
<h4 id="12133-群体智能"><a class="header" href="#12133-群体智能">12.1.3.3 群体智能</a></h4>
<p><strong>群体智能（Swarm Intelligence）</strong> 是多机器人协作的更极端形态：大量简单机器人通过局部规则和有限通信，实现全局复杂行为。与传统的“少数高能力机器人”相比，群体机器人系统具有更高的鲁棒性和可扩展性。(<a href="https://www.researchgate.net/publication/281909644_An_Overview_of_Swarm_Robotics_Swarm_Intelligence_Applied_to_Multi-robotics?utm_source=chatgpt.com">ResearchGate</a>)</p>
<ol>
<li><strong>经典群体机器人范式</strong>
<ul>
<li>灵感来自蚂蚁觅食、蜜蜂分工、鸟群/鱼群聚集等自然系统；</li>
<li>典型任务包括集群移动、覆盖、搜索救援、分布式建造等；</li>
<li>控制策略多采用局部规则+随机性，无需全局控制器，仅依靠简单行为的叠加产生“涌现行为”。</li>
</ul>
</li>
<li><strong>多智能体深度强化学习在群体中的应用</strong>
<ul>
<li>近年来，多智能体深度 RL 已经被用来训练成百上千个机器人在复杂环境中协同工作，如队形控制、障碍绕行、资源分配等；(<a href="https://www.mdpi.com/1424-8220/23/7/3625?utm_source=chatgpt.com">MDPI</a>)</li>
<li>世界模型可以在此扮演“群体级模拟器”的角色，用于训练和评估大规模群体策略；</li>
<li>相比手工设计局部规则，学习得到的局部策略有望更适应复杂环境、具有更高的任务完成率。</li>
</ul>
</li>
<li><strong>群体具身基础模型的愿景</strong>
未来的一个重要方向，是构建面向群体的具身基础模型，使得：
<ul>
<li>同一个模型能够控制从数个到数百个机器人，且性能随规模扩展不明显退化；</li>
<li>模型不仅学习个体如何运动，还学习<strong>群体结构</strong>如何形成（如自动分组、形成队形、建立临时网络）；</li>
<li>高层可以通过简单的语言指令（如“搜索整个楼层”“协助人群疏散”）对群体下达命令，模型自动在群体内部完成分解与分工。(<a href="https://www.techrxiv.org/users/688241/articles/1249883-enhanced-multi-robot-systems-with-generative-ai-and-machine-learning-a-cost-effective-approach-for-swarm-robotics?utm_source=chatgpt.com">techrxiv.org</a>)</li>
</ul>
</li>
</ol>
<p>【图 12-11：群体智能示意图：上图展示几十个简单移动机器人在仓库中形成自组织交通流；下图展示一个“群体具身基础模型”通过高层指令控制整个群体的整体行为。】</p>
<hr>
<p>本节从<strong>长序列多模态建模</strong>、<strong>跨模态世界模型与规划</strong>以及<strong>多机器人协作与群体智能</strong>三个维度，对“更通用的具身基础模型”做了系统展望。下一节（12.2）将进一步聚焦模型的<strong>泛化与自适应能力</strong>，讨论如何让这些基础模型在极少样本、新环境和长期部署的场景中持续保持“越用越聪明”。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="更强的泛化与自适应能力"><a href="#更强的泛化与自适应能力" class="header">更强的泛化与自适应能力</a></h1>
<h3 id="1221-少样本--零样本任务泛化"><a class="header" href="#1221-少样本--零样本任务泛化">12.2.1 少样本 / 零样本任务泛化</a></h3>
<p>在前面的章节里，我们主要讨论了“在给定任务和数据下把模型训练好”。但真正投放到现实世界后，更棘手的问题是：<strong>新任务、新物体、新环境几乎每天都在出现</strong>，不可能为每一种情况都采集海量数据再重训一次模型。</p>
<p>少样本 / 零样本泛化，就是试图回答两个问题：</p>
<ul>
<li>只有很少甚至没有新数据时，如何让机器人“举一反三”？</li>
<li>怎样把互联网上海量、杂乱的人类经验，转成机器人可以直接利用的能力？</li>
</ul>
<h4 id="12211-元学习meta-learning"><a class="header" href="#12211-元学习meta-learning">12.2.1.1 元学习（Meta-Learning）</a></h4>
<p><strong>元学习</strong>常被称为“学会如何学习”（learning to learn）：不是只学某个具体任务的参数，而是学一个<strong>更新规则或初始化状态</strong>，让机器人在面对新任务时，只用极少数据和几个更新步骤就能适应。(<a href="https://dl.acm.org/doi/10.1145/3659943?utm_source=chatgpt.com">ACM数字图书馆</a>)</p>
<p>一个典型的公式可以这样写：</p>
<p>$$
\min_{\theta} \sum_{T \sim p(T)} \mathcal{L}_T\big(U(\theta, D_T^{\text{train}}), D_T^{\text{test}}\big)
$$</p>
<ul>
<li>$\theta$：“元参数”，比如所有任务共享的初始网络参数；</li>
<li>$U(\cdot)$：“内层更新算子”，比如在新任务上做几步梯度下降；</li>
<li>$D_T^{\text{train}}$ / $D_T^{\text{test}}$：任务 $T$ 的少量训练 / 测试数据。</li>
</ul>
<p><strong>经典方法类别</strong></p>
<ol>
<li><strong>优化式元学习</strong>：以 MAML 为代表，显式优化“经过几步梯度更新后的效果”。许多机器人 manipulation 工作将 MAML 和模仿学习结合，形成 <em>meta-imitation learning</em>：在大量不同的抓取/推拉任务上训练，让机器人只靠 1–3 条新示范就能学会一个新任务。(<a href="https://www.robot-learning.ml/2020/files/C7.pdf?utm_source=chatgpt.com">robot-learning.ml</a>)</li>
<li><strong>度量式元学习</strong>：如 Prototypical Networks，通过学习一个嵌入空间，使得“同一任务中的好动作/好状态”彼此接近，测试时只需在嵌入空间做最近邻检索即可。</li>
<li><strong>模型式元学习</strong>：直接用 RNN/Transformer 作为“学习器”，把一段交互历史（状态、动作、回报）当作序列输入，网络隐状态本身就扮演“在线更新”的角色。</li>
</ol>
<p><strong>在具身机器人中的应用</strong></p>
<ul>
<li>针对“新任务但物理性质相似”的场景，元学习格外有优势。例如针对不同地形上的“舀取沙土”任务，对每种地形只收集少量试验数据，用深高斯过程 + 元学习在不同地形间迁移，能快速在线调节策略，在未见过的目标地形上也能成功采样。(<a href="https://arxiv.org/abs/2303.02893?utm_source=chatgpt.com">arXiv</a>)</li>
<li>在多任务 manipulation 基准（如 Meta-World）上，Transformer + 元模仿学习模型可以只用几条新示范，就适配到新的组合任务。(<a href="https://www.robot-learning.ml/2020/files/C7.pdf?utm_source=chatgpt.com">robot-learning.ml</a>)</li>
</ul>
<p><strong>与 VLA 的结合</strong></p>
<p>在 VLA 场景中，一个“任务”通常是“语言指令 + 场景分布”的组合（例如“把任意红色杯子放到任意一层架子上”）。元学习提供几种思路：</p>
<ul>
<li>冻结大部分视觉–语言 backbone，只对<strong>动作解码头</strong>或小规模 Adapter 做快速梯度更新；</li>
<li>把“少量新示范轨迹”作为额外 token（上下文）拼进 Transformer，让模型做“<strong>in-context meta-learning</strong>”，在推理时就完成适配，无需显式梯度更新。</li>
</ul>
<blockquote>
<p>【图 12-10 占位：示意图：上层是很多不同任务的数据块，下层是共享的 VLA 模型，通过“外层更新”学会一个好初始化，面对新任务只需一两步更新即可。】</p>
</blockquote>
<p>从工程角度看，元学习适合那些<strong>任务切换频繁但每个任务可采集的数据都很有限</strong>的机器人系统，例如物流中心里频繁变更的拣货规则、实验室里不断变化的新实验操作流程。</p>
<hr>
<h4 id="12212-零样本迁移zero-shot-transfer"><a class="header" href="#12212-零样本迁移zero-shot-transfer">12.2.1.2 零样本迁移（Zero-Shot Transfer）</a></h4>
<p>少样本学习还有几条示范；<strong>零样本</strong>则更“硬核”：在新任务上没有机器人数据，甚至不做任何额外训练，就要直接表现出合理行为。</p>
<p>在具身机器人中，零样本能力主要依赖两类基础：</p>
<ol>
<li><strong>语义 / 表征层的零样本迁移</strong>
<ul>
<li>典型例子是 R3M 这类视觉表征：先在 Ego4D 等大规模人类视频上，通过时间对比学习 + 视频–语言对齐预训练一个视觉编码器，再在下游机器人任务上冻结这个编码器，只训练控制头。结果表明，相比从头训练或用 ImageNet/CLIP 表征，R3M 能显著提高样本效率和任务成功率，并在只用 20 条示范的情况下完成真实场景中的多种 manipulation 任务。(<a href="https://arxiv.org/pdf/2203.12601?utm_source=chatgpt.com">arXiv</a>)</li>
<li>类似地，用大规模 MAE（Masked Autoencoder）在互联网图像 + 机器人图像上预训练视觉骨干，再把它作为冻结 encoder，也可以在多种真实 manipulation 任务上超过传统 CLIP 和监督预训练。</li>
</ul>
</li>
<li><strong>策略 / 行为层的零样本迁移</strong>
<ul>
<li>RT-1 将超过 70 万个、覆盖 700+ 种语言条件任务的机器人执行轨迹训练成一个 Transformer policy，在<strong>训练中从未见过的组合指令和新物体上也能保持较高成功率</strong>，体现出一定零样本任务泛化能力。(<a href="https://robotics-transformer1.github.io/assets/rt1.pdf?utm_source=chatgpt.com">robotics-transformer1.github.io</a>)</li>
<li>RT-2 更进一步，把 web 规模视觉–语言模型与 RT-1 机器人数据<strong>共训练成 VLA 模型</strong>，使机器人能把仅在互联网图片或文本中出现过的概念（如特定公司的 logo、危险物品类别）转化为现实中的操作策略，实现“web 知识 → 机器人动作”的零样本迁移。(<a href="https://deepmind.google/blog/rt-2-new-model-translates-vision-and-language-into-action/?utm_source=chatgpt.com">Google DeepMind</a>)</li>
<li>CLIP-RT 利用预训练 CLIP embedding，把语言描述对齐到一组“动作原语”上，通过对比模仿学习，让机器人能对<strong>训练集中从未出现过的物体</strong>执行合理操作，在零样本设置下优于传统端到端视觉–动作策略。(<a href="https://www.researchgate.net/publication/385510350_CLIP-RT_Learning_Language-Conditioned_Robotic_Policies_from_Natural_Language_Supervision?utm_source=chatgpt.com">ResearchGate</a>)</li>
<li>SuSIE 则利用预训练的图像编辑 Diffusion 模型作为高层 planner，给定当前观测和语言指令，让模型生成若干“未来子目标图像”，再由低层 goal-conditioned policy 实现这些子目标。由于高层图像编辑模型来自大规模互联网图像预训练，SuSIE 能在大量<strong>未在机器人数据中出现过的物体和场景</strong>上实现零样本 manipulation。(<a href="https://arxiv.org/abs/2310.10639?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
</ol>
<p>另外，还有工作直接把预训练 VLM 接入机器人 pipeline，例如 MOO（Manipulation of Open-World Objects）使用 CLIP 从指令和当前图像中识别目标物体，再交给下游 policy 执行，从而在大量“新类别物体”上实现零样本操作。(<a href="https://arxiv.org/abs/2303.00905?utm_source=chatgpt.com">arXiv</a>)</p>
<p>从这些例子可以看出一个核心思想：<strong>把机器人输入/输出映射到人类语义空间</strong>。视觉–语言模型已经在互联网数据上学会了“什么是杯子、垃圾、可食用物品、危险物品”等概念；机器人只要在这个语义空间里操作，就能直接继承这些对世界的理解。</p>
<p>当然，零样本也有明显局限：</p>
<ul>
<li>基础模型的知识本身有限，可能带有互联网数据的偏置；</li>
<li>基本不包含动力学和接触力学等“身体知识”，导致在复杂物理交互（如插拔、拧紧）上仍然需要机器人自身的数据。</li>
</ul>
<hr>
<h4 id="12213-提示学习prompt-learning"><a class="header" href="#12213-提示学习prompt-learning">12.2.1.3 提示学习（Prompt Learning）</a></h4>
<p>在大模型时代，“改 prompt 比改网络更便宜”已经成为共识。对于机器人，<strong>提示（prompt）并不仅仅是自然语言句子</strong>，还可以是：</p>
<ul>
<li>一段示范轨迹（轨迹 prompt）；</li>
<li>一串“技能标识”或“原语 token”；</li>
<li>甚至是专门为模型学出的“向量化提示”（软 prompt）。</li>
</ul>
<p>这里可以从三个层面理解提示学习在具身智能中的角色。</p>
<p><strong>（1）自然语言提示：用指令驱动策略</strong></p>
<ul>
<li>像 SayCan 这样的框架，将大型语言模型（PaLM）和机器人 affordance 模型结合，语言模型负责在大量“技能描述”上做推理筛选，affordance 模型负责评估当前环境下执行某技能的成功概率，从而实现“Do as I can, not as I say”。(<a href="https://github.com/ksDreamer/Awesome-VLA-Robotics?utm_source=chatgpt.com">GitHub</a>)</li>
<li>Instruct2Act 则更进一步，直接让 LLM 生成 Python 程序，调用感知 API（例如 SAM、CLIP）和运动原语 API，把多模态指令映射为可执行的 perception–planning–action 流程，在桌面操作任务上展示了较强的零样本能力。(<a href="https://arxiv.org/abs/2305.11176?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>在这些系统中，人类给出的只是一个高层提示（自然语言指令），其余细节由 LLM + 基础模型推理补全。</p>
<p><strong>（2）技能 / 原语提示：Think Small, Act Big</strong></p>
<p>近期工作提出“Primitive Prompt Learning（PPL）”来解决终身 manipulation 中的知识复用问题。其核心思路是：(<a href="https://openaccess.thecvf.com/content/CVPR2025/papers/Yao_Think_Small_Act_Big_Primitive_Prompt_Learning_for_Lifelong_Robot_CVPR_2025_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</p>
<ul>
<li>把常用的动作模式（靠近、抓取、插入……）抽象成一组<strong>可重用的原语 embedding</strong>；</li>
<li>新任务学习时，不是从头学一段完整策略，而是学一串“primitive prompts”，即在适当时刻激活哪些原语、如何组合；</li>
<li>这样既缓解了灾难性遗忘，又方便在后续任务中复用已有技能。</li>
</ul>
<p>对于 VLA 模型而言，可以把这些原语 embedding 看成<strong>动作层面的“离散 token”</strong>，与语言 token、视觉 token 一起输入 Transformer，通过 prompt 形式控制当前任务的“技能组合方式”。</p>
<p><strong>（3）“软 prompt”与策略 in-context 学习</strong></p>
<p>除了显式语言或离散 token，还可以使用“软 prompt”——一组可学习的向量，拼在输入序列前面，作为对模型的隐式条件。这在以下场景尤其有用：</p>
<ul>
<li>不同机器人平台共享同一套 VLA 模型时，用 Embodiment prompt 区分当前机器人（类似 PaLM-E 中的硬件 embedding）。(<a href="https://arxiv.org/html/2507.10672v1?utm_source=chatgpt.com">arXiv</a>)</li>
<li>为不同用户或不同环境学习专属“偏好向量”，让机器人在不改动主网络的前提下呈现个性化行为。</li>
</ul>
<p>一个更极端的形式是<strong>轨迹作为 prompt</strong>：在输入序列前先放几条“示范观察–动作对”，然后再把当前观测接上，模型通过自注意力做“类比”，在前向推理过程中完成“few-shot 模仿”。这实际上是一种纯靠提示实现的元学习（in-context meta-learning），已经在多任务 Transformer policy 中表现出不错的 few-shot 泛化能力。(<a href="https://www.robot-learning.ml/2020/files/C7.pdf?utm_source=chatgpt.com">robot-learning.ml</a>)</p>
<blockquote>
<p>【图 12-11 占位：三类 Prompt 示意图：上方为自然语言指令 prompt，中间为 skill primitive prompt（小方块组合成序列），下方为轨迹 prompt（若干观测–动作配对），统一输入一个 Transformer。】</p>
</blockquote>
<p>从实践角度看，提示学习最大的价值在于：<strong>可以在不改模型参数的情况下切换任务或行为风格</strong>，非常适合部署后的在线使用与快速迭代。</p>
<hr>
<h3 id="1222-在线适应与终身学习lifelong-learning"><a class="header" href="#1222-在线适应与终身学习lifelong-learning">12.2.2 在线适应与终身学习（Lifelong Learning）</a></h3>
<p>少样本 / 零样本泛化更多是“在训练结束后面对新任务如何应对”；而<strong>在线适应和终身学习</strong>则强调：<strong>训练这件事本身在机器人整个生命周期中从未真正结束</strong>。</p>
<p>机器人每天都在遇到新用户、新环境、新硬件状态（磨损、偏移），如果我们能把这些经历转化为可持续累积的知识，系统就会越用越聪明。</p>
<h4 id="12221-在线学习online-learning"><a class="header" href="#12221-在线学习online-learning">12.2.2.1 在线学习（Online Learning）</a></h4>
<p>在经典机器学习中，在线学习指数据按时间序列到达，每次更新只能看到当前小批量甚至单个样本，且通常不能无限存储全部历史数据。</p>
<p>对机器人而言，在线学习体现为：</p>
<ul>
<li>部署期间，机器人不断接收新感知数据和交互反馈；</li>
<li>在不完全停机的前提下，对部分模型参数做<strong>小幅、频繁的更新</strong>；</li>
<li>希望既能快速适应新环境，又不破坏已有能力。</li>
</ul>
<p>典型实现策略包括：</p>
<ol>
<li><strong>局部微调 + 冻结 backbone</strong>
<ul>
<li>利用已经预训练好的视觉–语言 backbone（例如 MAE、R3M 或 VLM），在部署现场只对一小段动作头或 Adapter 层进行在线更新，这样既减轻计算开销，也减少对已有知识的干扰。(<a href="https://arxiv.org/pdf/2203.12601?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>在线强化学习 / 自监督更新</strong>
<ul>
<li>在安全约束下，允许机器人在环境中进行小规模探索，通过 RL 或自监督任务（例如未来预测、对比学习）持续微调控制模块或状态表征；</li>
<li>例如在深高斯过程元学习 scooping 工作中，机器人在新地形上通过极少交互数据在线更新模型超参数，实现对未建模物理差异的快速适应。(<a href="https://arxiv.org/abs/2303.02893?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>增量式重放缓冲（replay buffer）</strong>
<ul>
<li>在有限容量下维护一个“代表性经验集合”，新数据到来时与旧数据竞争存储位置，在线更新时既使用最新数据也适度重放旧经验，减缓短期偏移。</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 12-12 占位：在线学习流程图：传感器数据流 → 评估模块 → 小批量参数更新 → 新策略上线，旁边有一个有限大小的 replay buffer 支持重放。】</p>
</blockquote>
<p>与离线大规模训练相比，在线学习更强调<strong>稳定性与安全性</strong>：每次更新不能让策略“突然变坏”，否则真实机器人可能当场翻车。这也是在线学习在具身场景中推广较慢的主要原因之一。</p>
<hr>
<h4 id="12222-终身学习挑战lifelong--continual-learning"><a class="header" href="#12222-终身学习挑战lifelong--continual-learning">12.2.2.2 终身学习挑战（Lifelong / Continual Learning）</a></h4>
<p>在线学习通常只考虑短时间窗口内的适应，而<strong>终身学习</strong>则关注整个任务序列和生命周期。其目标是：</p>
<blockquote>
<p>在源源不断的新任务和新数据到来时，机器人能<strong>持续学习</strong>并<strong>保留以往能力</strong>，而不是“学一个忘一个”。</p>
</blockquote>
<p>在机器学习中，这通常被称为 <strong>Continual Learning（CL）</strong>，已经形成较系统的定义和框架：数据分布和学习目标随时间变化，算法需要在保持旧任务性能的同时，习得新任务。(<a href="https://www.sciencedirect.com/science/article/abs/pii/S1566253519307377?utm_source=chatgpt.com">科学直通车</a>)</p>
<p>在机器人 / 深度强化学习中的终身学习更加困难：<strong>RL 本身就难训练，再叠加任务序列与安全约束，问题变成“难上加难版 RL”</strong>。已有工作分析了 RL 场景下的 lifelong learning 特性，指出忘记旧任务、探索不安全、训练不稳定等问题都被放大。(<a href="https://proceedings.mlr.press/v164/yang22a/yang22a.pdf?utm_source=chatgpt.com">Proceedings of Machine Learning Research</a>)</p>
<p>关键挑战包括：</p>
<ol>
<li><strong>灾难性遗忘（Catastrophic Forgetting）</strong>
<ul>
<li>参数被新任务梯度强烈推动，旧任务相关表征被覆盖；</li>
<li>尤其在机器人 RL 中，一个新任务就可能需要数十万步更新，如果没有约束，很容易把旧技能“洗掉”。(<a href="https://www.nature.com/articles/s42256-025-00983-2?utm_source=chatgpt.com">Nature</a>)</li>
</ul>
</li>
<li><strong>容量与结构管理</strong>
<ul>
<li>不可能无限扩展模型大小；何时为新任务分配新参数、何时复用旧参数，是一个动态架构设计问题；</li>
<li>多机器人、多任务共享一个 VLA 模型时，还要考虑不同平台之间的结构差异。(<a href="https://arxiv.org/html/2507.10672v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>任务边界与任务识别</strong>
<ul>
<li>实际部署中“任务切换”往往是隐式的，例如用户换了一个说话方式，或环境布局发生变化，很难人为标出清晰的 task id。</li>
</ul>
</li>
<li><strong>评测与度量</strong>
<ul>
<li>终身学习不能只看“最新任务的成功率”，还要评估：
<ul>
<li>backward transfer（新任务训练后旧任务性能是否提升/下降）；</li>
<li>forgetting measure（对每个旧任务性能下降多少）；</li>
<li>forward transfer（在看到新任务数据前，模型对它的初始表现如何）。(<a href="https://www.sciencedirect.com/science/article/abs/pii/S1566253519307377?utm_source=chatgpt.com">科学直通车</a>)</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>在机器人场景中，已经出现了针对终身 manipulation 的专门框架。例如 LOTUS 通过在任务流中持续<strong>发现和维护动作技能库</strong>，再由高层 meta-controller 组合这些技能完成新任务，在长期多任务序列上显著优于传统方法。(<a href="https://arxiv.org/abs/2311.02058?utm_source=chatgpt.com">arXiv</a>)</p>
<p>还有工作探索如何在 RL 框架中“同时保留和组合知识”，提出针对机器人终身学习的深度 RL 算法，可以在任务流中长期稳定地保留已学策略。(<a href="https://www.nature.com/articles/s42256-025-00983-2?utm_source=chatgpt.com">Nature</a>)</p>
<blockquote>
<p>【图 12-13 占位：终身学习评测示意：横轴为任务序列，纵轴为不同任务的成功率，各条曲线显示随着时间对每个任务的遗忘/提升情况。】</p>
</blockquote>
<p>对 VLA 而言，终身学习未来很可能表现为：<strong>一个统一基础模型 + 不断扩展的技能 / prompt / Adapter 仓库</strong>，既维持通用的视觉–语言–世界知识，又不断积累针对具体环境和用户习惯的操作经验。</p>
<hr>
<h4 id="12223-连续自适应continuous-adaptation"><a class="header" href="#12223-连续自适应continuous-adaptation">12.2.2.3 连续自适应（Continuous Adaptation）</a></h4>
<p>相比“按任务阶段分块”的终身学习，现实世界更接近一种<strong>连续、无缝的分布漂移</strong>：光照逐渐变暗、桌面换了一批新物体、相机被轻微挪动、关节磨损增加……这些变化都不一定构成“新任务”，却会慢慢击穿原有模型的假设。</p>
<p><strong>连续自适应</strong>关注的是在这种缓慢、持续漂移下，机器人如何：</p>
<ul>
<li>一边执行任务，一边悄悄更新自己的感知和控制；</li>
<li>不需要显式“换任务模式”或人工干预。</li>
</ul>
<p>一些代表性思路包括：</p>
<ol>
<li><strong>域自适应 / 表征迁移</strong>
<ul>
<li>如 PeS（Perception Encoder Transfer）一类方法，不直接迁移整个策略，而是先对感知编码器做迁移，让新的视觉域映射到一个与旧策略兼容的表征空间，随后再小幅调整策略，在新环境中显著提升成功率。(<a href="https://arxiv.org/html/2406.19971v2?utm_source=chatgpt.com">arXiv</a>)</li>
<li>利用自监督目标（例如保持时序一致性、预测未来帧），在执行过程中对 encoder 做小步更新，使视觉表征对新光照、材质变化保持鲁棒。(<a href="https://arxiv.org/html/2404.19664v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
</li>
<li><strong>基于原语 / prompt 的渐进扩展</strong>
<ul>
<li>Primitive Prompt Learning 在终身 manipulation 中引入“可重用原语 + prompt 组合”的机制，也自然适合连续自适应：新任务往往只需要引入少量新原语 embedding 或新的原语组合方式，而不是完全重写策略网络。(<a href="https://openaccess.thecvf.com/content/CVPR2025/papers/Yao_Think_Small_Act_Big_Primitive_Prompt_Learning_for_Lifelong_Robot_CVPR_2025_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</li>
<li>类似地，CL-LoRA 这类“持续 LoRA”技术在图像增量学习中通过低秩 Adapter 连续吸收新知识，也为机器人领域提供了参数高效、适合长时间在线微调的手段。(<a href="https://github.com/xialeiliu/Awesome-Incremental-Learning?utm_source=chatgpt.com">GitHub</a>)</li>
</ul>
</li>
<li><strong>多时间尺度更新</strong>
<ul>
<li>可以把整个系统拆成“快变量”和“慢变量”：
<ul>
<li>快变量：如部分控制参数、正则项系数，允许在几秒到几分钟尺度上在线更新；</li>
<li>慢变量：如 backbone、世界模型结构，只在长时间聚集足够证据或 offline 维护时更新。</li>
</ul>
</li>
<li>这种结构和前面讲的元学习（内外层更新）概念自然呼应，只不过这里强调的是<strong>部署期间的工程实现形式</strong>。</li>
</ul>
</li>
<li><strong>个性化与用户习惯学习</strong>
<ul>
<li>对服务机器人而言，“连续自适应”还包括学习用户偏好：比如某位用户总是希望机器人把杯子放在桌子左上角，系统可以为这个用户维护一个特定的“偏好 prompt”或小型 Adapter，在识别出用户身份后激活。(<a href="https://dspace.mit.edu/bitstream/handle/1721.1/153895/mao-jerrym-meng-eecs-2024-thesis.pdf?isAllowed=y&amp;sequence=1&amp;utm_source=chatgpt.com">DSpace</a>)</li>
</ul>
</li>
</ol>
<blockquote>
<p>【图 12-14 占位：多时间尺度自适应示意：底层基础 VLA 模型参数缓慢演化，中间的 Adapter / LoRA / prompt 持续小步更新，顶层控制策略根据最近经验做快速调整。】</p>
</blockquote>
<p>从更长远的角度看，连续自适应是让机器人从“静态模型”走向“不断更新的数字生命体”的必要步骤，而如何在这一过程中保持可控性和可验证性，将是未来具身智能的重要研究主题。</p>
<hr>
<h3 id="1223-从互联网经验到物理世界的迁移"><a class="header" href="#1223-从互联网经验到物理世界的迁移">12.2.3 从互联网经验到物理世界的迁移</a></h3>
<p>互联网是一个巨大的“人类经验缓存”：数以亿计的视频、图像、教程文章、问答对话里，记录了人类如何操作物体、完成任务、描述世界。<strong>具身智能想要“从零到英雄”，不可能只靠实验室里那几台机器人摸索</strong>，必然要想办法让机器人“借用”这些人类经验。</p>
<p>本小节关心的是三个问题：</p>
<ol>
<li>互联网中的知识以什么形式存在，如何转成机器人可用的结构？</li>
<li>如何把 VLM / LLM 等基础模型与机器人控制模块<strong>融合</strong>？</li>
<li>有哪些已经证明“互联网 → 机器人”迁移可行的典型案例？</li>
</ol>
<hr>
<h4 id="12231-知识转移knowledge-transfer"><a class="header" href="#12231-知识转移knowledge-transfer">12.2.3.1 知识转移（Knowledge Transfer）</a></h4>
<p>互联网经验主要以三种形式存在：</p>
<ul>
<li><strong>静态图像 + 文本</strong>：图像配 caption、alt 文本、文章插图等；</li>
<li><strong>视频</strong>：人类演示各种操作的 egocentric 或第三人称视频；</li>
<li><strong>纯文本</strong>：教程、说明书、问答等，包含大量程序性知识。</li>
</ul>
<p>对应地，在机器人领域出现了三条主要的知识转移路径。</p>
<p><strong>（1）视觉表征迁移：R3M、MAE 等</strong></p>
<ul>
<li>R3M 利用 Ego4D 等大规模人类视频，通过时间对比学习、视频–语言对齐和稀疏正则化，训练出一个通用视觉 encoder；在 12 个模拟 manipulation 任务和真实 Franka Panda 机械臂上，使用 R3M 表征显著提高了任务成功率和数据效率。(<a href="https://arxiv.org/pdf/2203.12601?utm_source=chatgpt.com">arXiv</a>)</li>
<li>Real-World Robot Learning with Masked Visual Pre-training 使用 MAE 在互联网和机器人图片上预训练 ViT，再在多个真实场景任务中冻结视觉 encoder、只训练控制头，证明了<strong>大规模自监督视觉预训练对机器人学习的巨大加成</strong>。</li>
</ul>
<p>这些方法的共同点是：<strong>把视觉问题“解决”在互联网上</strong>，然后把机器人训练问题简化为“在一个已经很有语义和结构的表征上学控制”。</p>
<p><strong>（2）奖励与 affordance 迁移：RoboCLIP、MOO 等</strong></p>
<ul>
<li>RoboCLIP 利用预训练 VLM 对“视频示范或文本描述”与当前观察之间的相似度来构造奖励函数，使得 RL agent 在没有人工手写 reward 的情况下就能学会对应任务；更重要的是，它可以利用“人类示范视频”作为出域示范，实现跨领域的奖励构造。(<a href="https://arxiv.org/pdf/2310.07899?utm_source=chatgpt.com">arXiv</a>)</li>
<li>MOO（Manipulation of Open-World Objects）使用 CLIP 等 VLM 从自然语言命令和相机图像中抽取“目标物体标识”，把这些抽象信息输入 robot policy，从而实现对<strong>从未见过的新类别物体</strong>的操作，一定程度上弥补了机器人数据覆盖不全的问题。(<a href="https://arxiv.org/abs/2303.00905?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>这类方法把互联网知识转化为了“奖励信号”和“物体语义标签”，在 RL 和模仿学习中扮演裁判或教师的角色。</p>
<p><strong>（3）行为 / 轨迹迁移：学习从视频到控制</strong></p>
<ul>
<li>R3M 之后，许多工作直接用人类操作视频构建“手–物体交互的先验”，例如 VideoDex 和后续工作从互联网人手视频中学习 dexterous manipulation 先验，再迁移到机器人手。(<a href="https://proceedings.mlr.press/v205/shaw23a/shaw23a.pdf?utm_source=chatgpt.com">Proceedings of Machine Learning Research</a>)</li>
<li>大量综述系统梳理了“Learning from Video (LfV)”在机器人中的应用，强调通过从互联网视频提取物体 affordance、动作先验和时序结构，可以显著降低机器人实际需要的交互数据。(<a href="https://openreview.net/attachment?id=YInjGuFhfY&amp;name=pdf&amp;utm_source=chatgpt.com">OpenReview</a>)</li>
</ul>
<blockquote>
<p>【图 12-15 占位：三条转移路径示意：左侧是互联网图像/视频/文本，中间分别流向“视觉 encoder”、“reward/affordance 模型”、“world model / trajectory priors”，右侧汇入机器人控制模块。】</p>
</blockquote>
<p>总的来说，知识转移的哲学是：<strong>让机器人尽量少地“重复人类已经在互联网上做过一万遍的事情”，只在必要处进行具身补课</strong>。</p>
<hr>
<h4 id="12232-模型融合model-fusion"><a class="header" href="#12232-模型融合model-fusion">12.2.3.2 模型融合（Model Fusion）</a></h4>
<p>有了互联网预训练的 VLM/LLM，还有机器人自身的数据和控制模块，接下来问题变成：<strong>这些模型到底怎么拼在一起？</strong></p>
<p>实践中逐渐形成了几种主流的融合范式。</p>
<p><strong>（1）规划–控制分离：LLM/VLM 作为高层 planner</strong></p>
<ul>
<li>SayCan 使用 PaLM 语言模型去评估“在当前语言指令下，一组候选技能序列是否合理”，同时用一个从机器人数据训练的 affordance 模型评估每个技能在当前场景的可行性，通过两者结合选择下一步技能。(<a href="https://github.com/ksDreamer/Awesome-VLA-Robotics?utm_source=chatgpt.com">GitHub</a>)</li>
<li>SuSIE/相关工作使用 Diffusion 模型生成未来“子目标图像”，低层则是 goal-conditioned policy 或传统控制器。(<a href="https://arxiv.org/abs/2310.10639?utm_source=chatgpt.com">arXiv</a>)</li>
<li>Instruct2Act 让 LLM 直接生成 Python 程序，调用 SAM、CLIP 等视觉基础模型和预定义动作原语，形成一个“由 LLM glue 在一起的感知–规划–控制 pipeline”。(<a href="https://arxiv.org/abs/2305.11176?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>这种结构的特点是：<strong>互联网模型只负责“想”，机器人模型负责“做”</strong>，两者通过有限接口（技能列表、子目标、代码 API）耦合。</p>
<p><strong>（2）端到端共训练：VLM → VLA</strong></p>
<p>另一条路线是直接将 web 预训练的 VLM <strong>整体嵌入 VLA 模型</strong>中，通过在机器人数据上的联合微调，使其输出动作 token：</p>
<ul>
<li>RT-2 以 PaLI-X 等大规模 VLM 为基础，在 web 图文 + RT-1 机器人数据上共同训练，使模型在保留 web 任务能力（如图文问答、识别）的同时，能够直接输出机器人 action token，实现“真正意义上的 VLA 基础模型”。(<a href="https://deepmind.google/blog/rt-2-new-model-translates-vision-and-language-into-action/?utm_source=chatgpt.com">Google DeepMind</a>)</li>
<li>后续工作如 RT-X、DexVLA、π₀-FAST 等，在多机器人、多数据源上扩展这一思路，引入动作 token 压缩、跨具身编码等技术，让一个大模型尽可能服务更多平台。(<a href="https://arxiv.org/html/2507.10672v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>这类模型的优点是<strong>统一、强大</strong>，缺点是难以部署和更新：任何微小改动（例如适配新机器人）都可能需要大规模重新训练或复杂的 Adapter 设计。</p>
<p><strong>（3）模块化 / 分层融合：世界模型 + 代码 + 控制</strong></p>
<ul>
<li>使用 VLM 作为“多模态感知模块”，LLM 作为“符号规划模块”，传统运动规划 / RL 作为“连续控制模块”，三者通过明确 API 拼接成分层结构；</li>
<li>例如有工作将 PaLM-E 这类多模态模型作为统一语义中枢，同时为不同机器人平台接入不同“embodiment embedding”和动作 head，在 VLA 综述中被视为一种“跨具身统一大脑”的实现方式。(<a href="https://arxiv.org/html/2507.10672v1?utm_source=chatgpt.com">arXiv</a>)</li>
</ul>
<p>这一范式本质上是在<strong>深度学习基础模型之上重建一个“模块化机器人系统”</strong>，兼顾可解释性和灵活性，预计会在工业落地中占比较大。</p>
<blockquote>
<p>【图 12-16 占位：三种融合范式对比图：左边是 planner–controller 分离，中间是端到端 VLA，大模型直接出动作，右边是多模块分层系统。】</p>
</blockquote>
<hr>
<h4 id="12233-案例从互联网到真实机器人的完整链路"><a class="header" href="#12233-案例从互联网到真实机器人的完整链路">12.2.3.3 案例：从互联网到真实机器人的完整链路</a></h4>
<p>下面选几个具有代表性的系统，串联回本节的三个核心问题。</p>
<p><strong>案例一：RT-2——web 知识直接变成机器人动作</strong></p>
<ul>
<li>基础：PaLI-X 等 web 规模 VLM，拥有强大的视觉理解与语言推理能力。(<a href="https://deepmind.google/blog/rt-2-new-model-translates-vision-and-language-into-action/?utm_source=chatgpt.com">Google DeepMind</a>)</li>
<li>机器人数据：使用 RT-1 收集的大规模语言条件操作轨迹。(<a href="https://robotics-transformer1.github.io/assets/rt1.pdf?utm_source=chatgpt.com">robotics-transformer1.github.io</a>)</li>
<li>训练：将动作序列 token 化，与文字 token 一起喂入 Transformer，通过共训练让 VLM “顺带学会”输出动作；</li>
<li>效果：在只在 web 数据中出现过、但从未在机器人数据中出现过的概念（如某些 logo、抽象类别“可回收物”）上，RT-2 仍能做出合理操作，体现“web → robot”的零样本迁移。</li>
</ul>
<p><strong>案例二：R3M + 下游 RL / IL——互联网视频提取通用视觉</strong></p>
<ul>
<li>预训练阶段：在 Ego4D 等大规模人类视频上，用时间对比学习、视频–语言对齐等目标训练视觉 encoder；(<a href="https://arxiv.org/pdf/2203.12601?utm_source=chatgpt.com">arXiv</a>)</li>
<li>下游阶段：在模拟和真实 manipulation 任务上冻结 encoder，只训练控制头（RL 或 BC），得到显著更高的成功率和样本效率；</li>
<li>意义：说明<strong>仅仅在感知层使用互联网视频预训练，就可以极大缓解真实机器人数据短缺问题</strong>，为后续世界模型和 VLA 打下基础。</li>
</ul>
<p><strong>案例三：SuSIE ——用图像编辑 Diffusion 做高层规划</strong></p>
<ul>
<li>预训练：基于互联网图像训练 InstructPix2Pix 等图像编辑 Diffusion 模型；(<a href="https://arxiv.org/abs/2310.10639?utm_source=chatgpt.com">arXiv</a>)</li>
<li>强化阶段：在少量人类/机器人视频上微调，使得模型可以在给定当前观测图像和指令时，生成“合理的未来子目标图像”；</li>
<li>控制：用 goal-conditioned policy 实现这些子目标；</li>
<li>结果：在长时序 manipulation 任务中实现很强的零样本泛化，说明<strong>用图像编辑模型来“想象未来画面”是一种有效的高层规划方式</strong>。</li>
</ul>
<p><strong>案例四：Primitive Prompt Learning（PPL）——互联网技能与终身学习的桥梁</strong></p>
<ul>
<li>PPL 在终身 manipulation 中引入“原语 prompt”机制，将复杂任务分解为可重用原语，并通过 prompt 组合原语来适应工作流。(<a href="https://openaccess.thecvf.com/content/CVPR2025/papers/Yao_Think_Small_Act_Big_Primitive_Prompt_Learning_for_Lifelong_Robot_CVPR_2025_paper.pdf?utm_source=chatgpt.com">CVF开放获取</a>)</li>
<li>当这些原语一部分来自互联网数据预训练的基础模型，一部分来自机器人自身的操作经验时，PPL 实际上扮演了<strong>互联网知识与机器人终身技能库之间的“适配层”</strong>。</li>
</ul>
<blockquote>
<p>【图 12-17 占位：多案例拼图：左上 RT-2（web &amp; robot 双箭头），右上 R3M（视频 → encoder → 控制），左下 SuSIE（图像编辑生成未来子目标），右下 PPL（原语库 + prompt 组合）。】</p>
</blockquote>
<p>通过这些案例可以看到，本小节前面讨论的三个层面——知识转移、模型融合、在线/终身适应——在真正的系统中是紧密交织在一起的：<strong>互联网经验提供了大规模、廉价的“世界先验”，终身学习则是在此基础上进行具身微调和个性化演化</strong>。在接下来的章节中，我们还将从安全、伦理和社会影响的角度，重新审视这种“世界知识直接驱动物理行动”的新范式可能带来的风险与机遇。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="安全伦理与社会影响"><a href="#安全伦理与社会影响" class="header">安全、伦理与社会影响</a></h1>
<h3 id="1231-物理机器人系统安全标准与法规"><a class="header" href="#1231-物理机器人系统安全标准与法规">12.3.1 物理机器人系统安全标准与法规</a></h3>
<p>具身智能把“只活在显卡里的模型”拉进了真实世界：机器人会移动、抓取、接触人和环境。<strong>从研究走向应用的第一道门槛就是安全与合规</strong>。本节先从标准体系讲起，再看政策法规，最后介绍如何做系统性的安全评估，为后文责任与信任、产业落地打基础。</p>
<hr>
<h4 id="12311-安全标准"><a class="header" href="#12311-安全标准">12.3.1.1 安全标准</a></h4>
<ol>
<li><strong>机械安全标准体系的整体框架</strong></li>
</ol>
<p>国际上，机器安全标准大致形成了一个“三层结构”：</p>
<ul>
<li><strong>A 类标准（基础安全标准）</strong>：给出通用的安全术语、风险评估方法和设计原则，代表性标准是 ISO 12100《机械安全——设计通则 风险评估与风险降低》。它提出了经典的三步策略：
1）本质安全设计；
2）防护装置与附加保护措施；
3）使用信息（警示、说明书等）。</li>
<li><strong>B 类标准（通用安全标准）</strong>：针对某一类安全要素，如安全距离、急停按钮、双手启动装置，或安全控制系统的性能等级等。</li>
<li><strong>C 类标准（专用机械标准）</strong>：面向具体设备（工业机器人、AGV 等），给出该类设备的详细安全要求。</li>
</ul>
<p>ISO/TR 22100 系列则专门说明 A/B/C 标准之间如何配合使用，指导设计者通过风险评估与风险降低达到“可接受风险”水平。</p>
<blockquote>
<p>【图 12-X】国际机器人相关安全标准的层级关系示意图（占位：包括 ISO 12100、ISO 10218、ISO 13482、ISO 3691-4、ISO 14971 等的关系箭头图）</p>
</blockquote>
<ol start="2">
<li><strong>工业机器人与协作机器人的安全标准</strong></li>
</ol>
<p>工业机器人是最早被系统化规范安全的机器人门类。</p>
<ul>
<li><strong>ISO 10218-1/2</strong> 是工业机器人和工业机器人系统的核心安全标准：第 1 部分针对“机器人本体”，第 2 部分针对“机器人系统与集成”。它要求在设计阶段识别和控制典型危险（挤压、碰撞、意外启动等），并规定防护围栏、安全互锁、急停和安全控制系统等措施。</li>
<li>随着**人机协作机器人（cobot）**的兴起，<strong>ISO/TS 15066</strong> 进一步对协作模式下的安全提出细化要求，包括人体各部位允许的碰撞力/压强阈值、协作操作模式（力/功率限制、手导示教、速度与距离监控等）的具体设计指导。</li>
</ul>
<p>在中国，对应的 <strong>GB 11291《工业机器人安全要求》</strong> 系列等同或修改采用了 ISO 10218-2 的内容，用于指导国内工业机器人及生产线的设计与验收。</p>
<p>对具身智能和 VLA 来说，这意味着：<strong>即便高层是“会聊天、会看图”的模型，底层动作也必须被限制在满足 ISO 10218/ISO/TS 15066 等标准的安全包络内</strong>，例如限制协作机械臂末端最大速度、碰撞检测阈值等。</p>
<ol start="3">
<li><strong>服务与个人护理机器人安全标准</strong></li>
</ol>
<p>当机器人走出工厂、进入家庭和公共空间，与非专业用户长期共存时，安全要求发生了质变。</p>
<ul>
<li><strong>ISO 13482</strong> 是个人护理机器人（Personal Care Robot）的重要标准，涵盖：移动服务机器人、物理辅助机器人、载人机器人等三大类。
标准除了机械风险外，还特别强调：
<ul>
<li>对易受伤人群（老年人、儿童）的接触力限制；</li>
<li>稳定性、防跌落、防夹压设计；</li>
<li>对心理伤害和隐私侵犯的预防要求。</li>
</ul>
</li>
</ul>
<p>这类标准为养老机器人、陪伴机器人等提供了基本安全门槛，也为后续人形服务机器人、安全认证和产品责任提供了基础参照。</p>
<ol start="4">
<li><strong>移动机器人、AGV/AMR 的安全标准</strong></li>
</ol>
<p>在仓储、工厂和医院中，<strong>自动导引车（AGV）与自主移动机器人（AMR）</strong> 已经成为“地面具身智能”的主力军。</p>
<ul>
<li><strong>ISO 3691-4</strong> 专门规范无人驾驶工业车辆（AGV/AMR 等）的安全要求，如路径规划、制动性能、速度限制、障碍物检测和紧急停止等，并规定了安全功能的验证方法，属于典型 C 类标准。</li>
</ul>
<p>对于部署在仓库、工厂甚至医院走廊中的 VLA 机器人，这些标准意味着其行驶轨迹和速度必须满足严格的碰撞风险控制与制动距离约束，不能只依赖“模型觉得安全”。</p>
<ol start="5">
<li><strong>医疗机器人与医疗器械风险管理标准</strong></li>
</ol>
<p>医疗机器人一方面是机器人，另一方面又是<strong>医疗器械</strong>，同时受到机械安全与医疗监管的双重约束。</p>
<ul>
<li><strong>IEC 60601 系列</strong> 定义了医疗电气设备的基本安全与性能要求，各种手术设备、监护设备都在此框架下设计。</li>
<li>针对手术机器人等，IEC 80601-2-78 等专用标准给出了额外要求，例如系统冗余、故障安全状态等。</li>
<li><strong>ISO 14971</strong> 则是医疗器械领域通用的风险管理过程标准，从设计到报废全过程要求持续风险识别、控制与残余风险评估。</li>
</ul>
<p>这类标准对未来“VLA+手术机器人”的演进非常关键：<strong>再聪明的决策模型，也必须嵌入可以被审计和验证的风险管理流程中</strong>。</p>
<ol start="6">
<li><strong>国家与前沿领域标准的发展趋势</strong></li>
</ol>
<p>在国家层面，除了等同采用国际标准外，各国正针对新型机器人形态制定补充规范：</p>
<ul>
<li>我国近年来陆续发布了巡检机器人、腿式机器人、一体化关节等国家标准，补齐新形态机器人在安全与性能方面的空白。</li>
<li>2025 年，中国启动了<strong>人形机器人标准化委员会</strong>，准备在总体架构、安全与核心技术等方面制定国家标准，从制度层面为类人具身智能扫清障碍。</li>
</ul>
<blockquote>
<p>【图 12-Y】具身智能相关安全标准图谱（占位：按工业机器人、移动机器人、个人护理机器人、医疗机器人分区列出对应的 ISO/IEC/GB 标准）</p>
</blockquote>
<hr>
<h4 id="12312-政策法规"><a class="header" href="#12312-政策法规">12.3.1.2 政策法规</a></h4>
<p>安全标准告诉我们“<strong>如何做才安全</strong>”，而<strong>法律法规决定“什么是合法、谁负责任”</strong>。对打算让机器人真正进入产业与社会的研究者来说，了解基本监管框架是必需的。</p>
<ol>
<li><strong>欧盟：从机械法规到 AI 法案</strong></li>
</ol>
<ul>
<li><strong>欧盟《机械法规》2023/1230/EU</strong> 将在过渡期后取代旧的《机械指令》，规定了在欧盟市场投放机械产品（包括机器人）时必须满足的基本健康和安全要求（EHSR）。新法规一大特点是：
<ul>
<li>明确考虑数字化、联网和 AI 带来的新风险；</li>
<li>特别强调人机协作、远程更新和网络安全。</li>
</ul>
</li>
<li><strong>欧盟《AI 法案》（AI Act）</strong> 则从“算法”角度出发，对 AI 系统进行分级监管：
<ul>
<li>若 AI 系统是某种产品（如机器人）的<strong>安全部件</strong>，或本身是安全相关产品，则被归为<strong>高风险 AI</strong>；</li>
<li>高风险 AI 必须落实风险管理、数据治理、日志记录、透明性和人类监督等要求。</li>
</ul>
</li>
</ul>
<p>由于企业和各方压力，部分高风险条款的实施时间被推迟到 2027 年左右，但整体方向并未改变：<strong>将“看得见、摸得着”的机器人与其背后的“看不见的 AI”一起纳入安全监管</strong>。</p>
<ol start="2">
<li><strong>产品责任与 AI 责任的现代化</strong></li>
</ol>
<p>即便机器人满足安全标准，也可能因为设计缺陷、软件更新、训练数据偏差而造成损害。欧盟正在通过一系列新规来重塑责任规则：</p>
<ul>
<li><strong>新版《产品责任指令》（PLD, 2024/…）</strong> 将软件、数字文件和 AI 明确纳入“产品”范围，并扩展潜在责任主体（包括平台运营者、非欧盟制造商代理等），对于技术高度复杂导致因果关系难以证明的案件，引入了<strong>缺陷与因果关系的推定</strong>。</li>
<li>拟议中的 <strong>AI 责任指令</strong> 则试图调整 AI 相关损害中的举证规则和责任分配，使受害人不至于在面对复杂系统时完全无从下手。</li>
</ul>
<p>加上学界对“<strong>AI 是产品还是服务</strong>”的讨论，这些改革共同决定了：当一台搭载 VLA 的机器人出事时，责任可能如何在制造商、系统集成商、运营商、模型提供方之间分配。</p>
<ol start="3">
<li><strong>其他地区与本土监管举措</strong></li>
</ol>
<ul>
<li>在医疗领域，美国 FDA 已经对手术机器人等设备形成了较成熟的审批路径，并通过认可 IEC 60601、IEC 80601 等国际标准来判定“安全与性能”。</li>
<li>国内方面，工信部等部门发布了机器人产业规范条件和相关技术政策，地方政府（如上海）也针对人形机器人发布治理指引，强调技术标准、风险管理和价值观对齐的重要性。</li>
</ul>
<p>对具身智能研究者而言，一个简单的经验是：</p>
<blockquote>
<p><strong>“早在论文阶段，就要想清楚：如果把这套系统真正做成产品，它会落在哪些法规框架下？需要满足哪些强制性要求？”</strong></p>
</blockquote>
<hr>
<h4 id="12313-安全评估"><a class="header" href="#12313-安全评估">12.3.1.3 安全评估</a></h4>
<p>有了标准和法规，还需要一个<strong>可操作的安全评估流程</strong>，来回答三个问题：
1）哪些地方有危险？
2）风险是否可接受？
3）如何证明我们已经做得足够安全？</p>
<ol>
<li><strong>基于 ISO 12100 的通用风险评估流程</strong></li>
</ol>
<p>ISO 12100 提供了一个经典的迭代流程：</p>
<p>1）<strong>危险识别</strong>：识别所有可能导致伤害的源头，包括机械、控制、电气、热、噪声以及使用错误等。
2）<strong>风险估计</strong>：对每个危险，综合考虑伤害严重度、发生概率和暴露频率，给出风险等级。
3）<strong>风险评价</strong>：判断现有设计下风险是否在“可容忍范围”内。
4）<strong>风险降低</strong>：按照“本质安全设计优先”的原则，依次考虑结构改动、防护装置、安全控制系统和警示信息。
5）<strong>验证与文档化</strong>：通过测试、计算、审查等手段验证风险降低措施有效，并形成可追溯文档。</p>
<p>对于具身智能机器人，这个流程需要扩展到<strong>软件与算法层面</strong>，包括对模型失效模式、数据缺陷和更新机制的分析。</p>
<ol start="2">
<li><strong>医疗器械中的风险管理：ISO 14971 视角</strong></li>
</ol>
<p>ISO 14971 要求医疗器械制造商在整个生命周期中持续执行风险管理：</p>
<ul>
<li>在设计阶段进行系统性的危险分析和风险估计；</li>
<li>对每一项不可接受风险制定控制措施（设计更改、防护、信息）；</li>
<li>评估残余风险是否与收益相比仍可接受；</li>
<li>上市后通过上市后监测和事件报告，不断更新风险管理文件。</li>
</ul>
<p>对手术机器人、康复机器人等来说，这意味着<strong>每一次软件更新、模型再训练或控制策略变更，都需要重新评估风险影响</strong>，而不仅仅是“线上热更新一个模型”。</p>
<ol start="3">
<li><strong>具身智能系统特有的安全评估要点</strong></li>
</ol>
<p>相较传统机械，具身智能/ VLA 机器人的风险评估面临三类额外挑战：</p>
<ul>
<li><strong>功能不确定性</strong>：决策模型往往是统计式或深度学习式的，难以穷举所有输入–输出组合的行为，容易出现“分布外输入”或“幻觉式决策”。</li>
<li><strong>学习与更新</strong>：模型可能在部署后继续学习或更新（在线学习、联邦学习），风险特性随时间变化，必须将更新过程纳入风险管理边界。</li>
<li><strong>网络与数据安全</strong>：ISO/TR 22100-4 专门提醒制造商关注与机械安全相关的网络安全问题，例如远程攻击导致安全功能失效，这在云端控制的机器人中尤为关键。</li>
</ul>
<ol start="4">
<li><strong>方法工具：从 FMEA 到场景库测试</strong></li>
</ol>
<p>工程实践中常用的一些方法可以直接迁移到具身智能系统：</p>
<ul>
<li><strong>FMEA（失效模式及影响分析）/ FTA（故障树分析）</strong>：自顶向下分析哪些组件失效会引发危险行为，尤其适用于安全控制链路（传感器–控制器–执行器–监控系统）。</li>
<li><strong>STPA 等系统理论视角方法</strong>：从控制结构和约束角度分析事故原因，适合处理复杂人–机–组织系统。</li>
<li><strong>仿真+场景库测试</strong>：对移动机器人、自动驾驶和 AGV/AMR，常通过大规模仿真场景库覆盖各种极端工况，结合 ISO 3691-4 等标准规定的试验项目来验证安全功能。</li>
<li><strong>AI 合规测试</strong>：在 AI Act 的框架下，高风险 AI 还需要专门的性能、鲁棒性与偏差测试，并形成技术文档与日志，证明系统在设计范围内“足够安全”。</li>
</ul>
<blockquote>
<p>【图 12-Z】机器人系统安全评估与风险管理流程示意图（占位：左侧为危险识别与风险评估，右侧为设计/控制/使用三层风险降低措施，底部是文档与合规）</p>
</blockquote>
<hr>
<h3 id="1232-人机协作场景中的责任与信任"><a class="header" href="#1232-人机协作场景中的责任与信任">12.3.2 人机协作场景中的责任与信任</a></h3>
<p>当机器人不再被关在笼子里，而是与人共享空间、共同完成任务时，技术问题会自然升级为<strong>责任与信任问题</strong>：</p>
<ul>
<li>出事了谁负责？</li>
<li>用户应不应该相信它、相信到什么程度？</li>
<li>社会能不能接受这样的伙伴和“同事”？</li>
</ul>
<p>本节从责任划分、信任建立和社会接受度三个层面展开。</p>
<hr>
<h4 id="12321-责任划分"><a class="header" href="#12321-责任划分">12.3.2.1 责任划分</a></h4>
<ol>
<li><strong>人机协作中的多方主体</strong></li>
</ol>
<p>典型的人机协作场景包括：</p>
<ul>
<li>车间里协作机械臂与工人共同装配；</li>
<li>仓库里 AMR/人形机器人与拣货员共同搬运；</li>
<li>手术室中外科医生与手术机器人协同操作；</li>
<li>自动驾驶接驳车与安全员共同值守……</li>
</ul>
<p>在这些场景中，至少涉及以下几类责任主体：</p>
<ul>
<li><strong>制造商 / 算法开发者</strong>：机器人本体、控制系统、VLA 模型等的设计者；</li>
<li><strong>系统集成商</strong>：将机器人集成进具体产线或业务流程的一方；</li>
<li><strong>部署与运营方</strong>：工厂、物流公司、医院等，负责配置环境、下发任务、维护设备；</li>
<li><strong>人类操作员/监督者</strong>：负责给机器人发指令、监控状态、在必要时接管；</li>
<li><strong>关键部件/模型提供方</strong>：传感器供应商、通用大模型服务提供商等。</li>
</ul>
<p>不同法律体系下，损害发生后责任如何划分会有差异，但一个共识是：<strong>不能把一切都推给“前线操作员”</strong>。</p>
<ol start="2">
<li><strong>“道德缓冲区”（Moral Crumple Zone）现象</strong></li>
</ol>
<p>机器人伦理研究提出了“<strong>道德缓冲区（moral crumple zone）</strong>”概念：在高度自动化、多方参与的系统中，一旦事故发生，道德和法律责任往往集中落在那个“看起来在控制系统的人类”身上，即使他/她对整个系统的实际可控程度有限。</p>
<p>在机器人–人类协作中，这种现象表现为：</p>
<ul>
<li>协作机械臂伤人时，人往往指责“当班操作员没注意”；</li>
<li>自动驾驶出事时，舆论首先问的是“安全员在干什么”；</li>
<li>而系统设计者、算法提供方、组织层面的决策失误常常被淡化。</li>
</ul>
<p>未来在设计 VLA 系统时，需要在技术和制度层面避免这种“责任挤压”：</p>
<ul>
<li>在系统架构中<strong>明确控制权边界</strong>，例如哪些动作是机器人自主做出的，哪些动作必须经过人类确认；</li>
<li>完整记录决策与指令日志，让事后分析能够还原“谁在什么时候做了什么决定”；</li>
<li>在产品说明和培训中清楚告知操作员其职责和能力范围，避免“挂名负责但没有相应控制手段”的状态。</li>
</ul>
<ol start="3">
<li><strong>从研究原型到合同与保险</strong></li>
</ol>
<p>当研究原型向产品转化时，责任问题会具体体现在：</p>
<ul>
<li>合同如何约定事故责任与保险条款；</li>
<li>维护和更新职责如何划定（例如谁负责升级 VLA 模型，以及升级后如果出现异常由谁负责）；</li>
<li>是否需要针对高风险场景购买专门责任保险。</li>
</ul>
<p>对研究生和工程师来说，<strong>在设计系统时就考虑“责任可分解、可追溯”</strong>，会极大降低后续产业化阻力。</p>
<hr>
<h4 id="12322-建立信任"><a class="header" href="#12322-建立信任">12.3.2.2 建立信任</a></h4>
<p>信任不是“用户喜欢它就行”，而是<strong>用户对系统能力与边界形成符合现实的预期</strong>。对具身智能机器人来说，这种信任既有技术层面，也有人文层面。</p>
<ol>
<li><strong>信任的三个维度</strong></li>
</ol>
<p>相关研究表明，人们对社交机器人整体态度较为正面，但同时存在大量“犹豫”与“条件接受”。
可以把信任拆成三个维度：</p>
<ul>
<li><strong>技术可信</strong>：
<ul>
<li>行为可预测、重复性好；</li>
<li>遇到极端情况时能安全退避或求助，而不是“赌一把”；</li>
<li>有清晰的安全保障机制（力/速度限制、急停、冗余传感器等）。</li>
</ul>
</li>
<li><strong>交互可信</strong>：
<ul>
<li>机器人能用人类能理解的方式表达自己的状态和意图，如提示“我现在在学习环境、可能动作慢一些”；</li>
<li>不通过“过度拟人化”误导用户，把自己包装成真实的人类或“全知全能的 AI”；</li>
<li>尊重用户自主性（用户可以拒绝、修改命令）。</li>
</ul>
</li>
<li><strong>组织可信</strong>：
<ul>
<li>背后机构有明确的客服和事故处理机制；</li>
<li>有透明的隐私政策和数据使用说明；</li>
<li>在发生错误时愿意承担责任并改进系统。</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>技术手段：让信任“有依据”</strong></li>
</ol>
<p>对 VLA 型机器人来说，可以利用模型本身的语言能力来增强透明度和信任，例如：</p>
<ul>
<li><strong>自描述</strong>：在执行高风险动作前，用简短语言说明自己的理解和计划，如“我将以低速移动到你右侧，距离约 0.5 米”。</li>
<li><strong>不确定性提示</strong>：当视觉识别或语言理解置信度较低时，主动提示并请求确认，如“我不确定黄色小盒是不是你说的药箱，需要你确认一下”。</li>
<li><strong>多层自主等级</strong>：在医疗、协作工业场景中，允许用户选择“自动模式”“建议+确认模式”“纯手动模式”，并简明说明各模式下机器人会做什么。</li>
</ul>
<p>这些设计可以帮助用户形成**“不过度信任，也不过度怀疑”**的合理预期。</p>
<blockquote>
<p>【图 12-T】人–机器人协作中“控制权–责任–信任”关系示意图（占位：三角形结构，一角是人类操作者，一角是机器人，一角是组织/厂商，中间标注信息流和决策权）</p>
</blockquote>
<hr>
<h4 id="12323-社会接受度"><a class="header" href="#12323-社会接受度">12.3.2.3 社会接受度</a></h4>
<p>单个用户的信任可以通过设计慢慢建立，但要大规模部署具身智能机器人，还需要社会整体的接受与认可。</p>
<ol>
<li><strong>总体态度与关键顾虑</strong></li>
</ol>
<p>多项综述表明，人们对社交机器人和服务机器人总体态度偏向积极，但存在明显的<strong>分化和情境依赖</strong>：</p>
<ul>
<li>在医疗、养老场景中，如果机器人能缓解人力紧缺、提升照护质量，公众往往较为支持；</li>
<li>在监控、治安等敏感场景，则更担心隐私与权力滥用；</li>
<li>在就业压力较大的地区，人们会更关注机器人是否“抢工作”。</li>
</ul>
<ol start="2">
<li><strong>养老与照护场景的特殊敏感性</strong></li>
</ol>
<p>老年人、认知障碍患者等人群往往在技术讨论中被视作“受益者”，但伦理研究提醒我们：</p>
<ul>
<li>机器人带来的陪伴与照护不能替代人类关系；</li>
<li>长期监测可能损害隐私与尊严；</li>
<li>设计不当的机器人可能强化年龄歧视或“幼儿化”老年人。</li>
</ul>
<p>对具身智能来说，这意味着：</p>
<blockquote>
<p>在养老场景中，VLA 应当被设计为“赋能型”伙伴，帮助老年人保持自主，而不是替其做所有决定。</p>
</blockquote>
<ol start="3">
<li><strong>工业与物流中的社会影响</strong></li>
</ol>
<p>在工厂和仓库中，机器人既改善了安全与效率，也引发了对就业与技能结构的担忧：</p>
<ul>
<li>有研究表明，在部分地区工业机器人显著降低了工伤事故率，改善了工作环境。</li>
<li>同时，亚马逊等企业在仓库大规模应用机器人和 AI 调度系统，引发对工作节奏加快、岗位替代和劳动关系变化的讨论。</li>
</ul>
<p>对政策制定者来说，配套措施包括：</p>
<ul>
<li>将机器人部署与职业培训、岗位转型政策联动；</li>
<li>在引入具身智能系统前进行社会影响评估，与工会和员工充分沟通；</li>
<li>把安全收益与就业结构变化一并纳入成本–收益分析，而不是只看短期效率。</li>
</ul>
<ol start="4">
<li><strong>人形机器人的接受度与“拟人边界”</strong></li>
</ol>
<p>随着人形机器人大量进入仓储、制造和未来的服务业，新一轮社会讨论正在展开：</p>
<ul>
<li>支持者强调其与人类共享环境、复用人类工具的潜力；</li>
<li>批评者担忧其外形会让人高估其能力，从而导致危险；</li>
<li>有人认为在照护场景中过度拟人化会制造“情感错觉”。</li>
</ul>
<p>对具身智能研究来说，这提示我们：</p>
<blockquote>
<p>不要把“更像人”当作唯一优化目标，而要兼顾安全、伦理与社会接受度。</p>
</blockquote>
<hr>
<h3 id="1233-面向产业与社会的落地场景分析"><a class="header" href="#1233-面向产业与社会的落地场景分析">12.3.3 面向产业与社会的落地场景分析</a></h3>
<p>具身智能和 VLA 模型真正的价值，在于落地到具体产业与社会场景中。本节选取<strong>医疗机器人、辅助与养老、工业自动化与物流</strong>三个典型领域，分析其应用特点、安全与伦理挑战，以及对本书所讨论技术路线的需求。</p>
<hr>
<h4 id="12331-医疗机器人"><a class="header" href="#12331-医疗机器人">12.3.3.1 医疗机器人</a></h4>
<ol>
<li><strong>典型类型与应用场景</strong></li>
</ol>
<p>医疗机器人大致可分为：</p>
<ul>
<li><strong>手术机器人</strong>：如微创外科、骨科、神经外科机器人，用于提高精度、减少创伤；</li>
<li><strong>介入与影像引导机器人</strong>：辅助穿刺、导管导航等；</li>
<li><strong>康复机器人</strong>：外骨骼、下肢康复机器人等，用于训练和恢复运动功能；</li>
<li><strong>医院物流机器人</strong>：在医院内部运输药品、标本、被服等。</li>
</ul>
<p>以手术机器人为例，文献梳理了 2015–2023 年间 FDA 批准的多种机器人系统，并提出“手术机器人自主等级（LASR）”，从单纯工具辅助到高度自主分级，显示目前主流系统仍然强调“<strong>人主导，机器人辅助</strong>”。</p>
<ol start="2">
<li><strong>监管与标准框架</strong></li>
</ol>
<p>医疗机器人通常被视为<strong>医疗器械</strong>，其监管路径包括：</p>
<ul>
<li>符合 IEC 60601 系列的电气安全和基本性能要求；</li>
<li>按照 ISO 14971 执行风险管理，对每一种潜在危害进行识别和控制；</li>
<li>满足相关专用标准（如手术机器人 IEC 80601-2-78 等）；</li>
<li>在欧盟，还要符合 MDR 和 AI Act 中针对高风险医疗 AI 的额外要求。</li>
</ul>
<p>对 VLA 医疗机器人而言，一个现实的中短期路线是：</p>
<blockquote>
<p>把 VLA 放在“<strong>辅助决策与人机界面层</strong>”，而关键控制回路仍由可验证的安全控制系统承担。</p>
</blockquote>
<ol start="3">
<li><strong>具身智能在医疗场景中的角色</strong></li>
</ol>
<p>具身智能可以在多个层次增强医疗系统：</p>
<ul>
<li><strong>术前与术中理解</strong>：通过视觉–语言模型理解影像（CT/MRI/内窥镜）与医生口头/文本指令，将“病灶概念”和空间位置联系起来；</li>
<li><strong>人机协作界面</strong>：医生用自然语言提出高层目标（如“沿血管轴向推进 2 cm”），系统转换为一系列安全约束下的低层控制命令；</li>
<li><strong>术后与训练</strong>：通过语言解释手术过程，辅助术者反思；利用 VLA 在仿真环境中为年轻医生提供训练场景。</li>
</ul>
<p>但在监管层面，只要机器人动作直接作用于患者，<strong>高风险 AI 规则和医疗器械风险管理就会严格约束其自主程度</strong>，短期内很难完全替代医生。</p>
<blockquote>
<p>【图 12-M】手术机器人系统组成与 VLA 集成示意图（占位：左为医生控制台，右为机械臂和患者，中间标注 VLA 模块对影像和语言指令的处理）</p>
</blockquote>
<hr>
<h4 id="12332-辅助与养老"><a class="header" href="#12332-辅助与养老">12.3.3.2 辅助与养老</a></h4>
<ol>
<li><strong>老龄化背景与技术需求</strong></li>
</ol>
<p>在许多国家，老龄化和护理人力短缺正在成为结构性问题，社会机器人、服务机器人被视作缓解照护压力的重要工具。系统综述显示，人们期待这些机器人在陪伴、认知刺激和日常协助方面提供帮助，但同时指出大量伦理挑战。</p>
<p>典型应用包括：</p>
<ul>
<li>生活提醒与陪伴（吃药提醒、聊天、娱乐活动组织）；</li>
<li>移动与体力辅助（助行器、上肢/下肢助力设备）；</li>
<li>安全监测（跌倒检测、异常行为提醒）；</li>
<li>远程沟通（与家属、医生的视频连接）。</li>
</ul>
<ol start="2">
<li><strong>伦理与隐私问题</strong></li>
</ol>
<p>养老场景中，机器人往往长期驻留在家庭或机构中，这带来一系列伦理问题：</p>
<ul>
<li><strong>隐私与监控</strong>：连续的音视频采集和位置跟踪可能让老人感觉被“时时刻刻监督”；</li>
<li><strong>自主性与依赖</strong>：过度依赖机器人可能削弱老人的自理能力，或让照护机构以技术替代人际互动；</li>
<li><strong>尊严与刻板印象</strong>：如果机器人用过度幼儿化的语气或过分照看，会伤害老人尊严；</li>
<li><strong>数据与偏见</strong>：用于训练模型的数据可能带有年龄歧视或文化偏见，影响机器人对老人的态度和决策。</li>
</ul>
<ol start="3">
<li><strong>标准与治理框架</strong></li>
</ol>
<ul>
<li>在安全层面，个人护理与辅助机器人可首先参照 <strong>ISO 13482</strong> 及相关解释文档，以限制接触力、速度和行驶区域等。</li>
<li>在治理层面，地方性指引（如上海关于人形机器人的治理指南）开始加入伦理原则和风险管理要求，强调技术标准与人类价值观的一致性。</li>
<li>AI Act 在高风险 AI 章节中也强调，涉及弱势群体的系统必须特别关注基本权利与歧视问题。</li>
</ul>
<ol start="4">
<li><strong>VLA 在养老辅助中的机会与风险</strong></li>
</ol>
<p>VLA 对养老机器人极具吸引力：</p>
<ul>
<li>能理解自然语言指令和闲聊，降低使用门槛；</li>
<li>能结合视觉识别环境（药盒、轮椅、门锁）执行复杂任务；</li>
<li>能根据历史交互形成一定“记忆”，实现个性化陪伴。</li>
</ul>
<p>但这也放大了风险：</p>
<ul>
<li>语言能力越强，用户越容易把机器人视为“懂自己的人”，从而过度信任；</li>
<li>长期存储和分析个人生活数据会极大提高隐私泄露的后果；</li>
<li>若模型更新缺乏严格控制，可能在无意间引入新的偏见或行为模式。</li>
</ul>
<p>因此，在设计具身智能养老系统时，应坚持：</p>
<blockquote>
<p>“用具身智能提升老人的<strong>自主与尊严</strong>，而不是用技术掩盖照护体系本身的问题。”</p>
</blockquote>
<blockquote>
<p>【图 12-E】家庭环境中辅助机器人与老年人交互示意图（占位：标注视觉感知、语音/文本对话、行动规划模块，以及家庭成员/护理人员在闭环中的位置）</p>
</blockquote>
<hr>
<h4 id="12333-工业自动化与物流"><a class="header" href="#12333-工业自动化与物流">12.3.3.3 工业自动化与物流</a></h4>
<ol>
<li><strong>从固定机器人到“机器人同事”</strong></li>
</ol>
<p>在工业和物流领域，机器人已经从<strong>围栏内的机械臂</strong>发展到与人共享空间的 AMR、人形机器人和协作机械臂：</p>
<ul>
<li>仓储与配送中心大规模部署 AMR、分拣机械臂、自动装卸设备，显著提升效率与准确率；</li>
<li>在一些国家，引入机器人还与<strong>改善工人安全、降低工伤事故</strong>相关。</li>
<li>新兴的人形机器人开始在仓库执行搬运、上下货等任务，作为“通用工人”的候选形态。</li>
</ul>
<ol start="2">
<li><strong>安全与标准化基础</strong></li>
</ol>
<p>这些场景中的机器人通常需要同时满足多类标准：</p>
<ul>
<li>生产线上的机械臂遵循 <strong>ISO 10218</strong> 和 <strong>ISO/TS 15066</strong>，在协作区域内按规定限制速度和力。</li>
<li>仓库 AMR/AGV 依据 <strong>ISO 3691-4</strong> 做路径规划、防撞系统和紧急停车设计。</li>
<li>对于人形或多功能机器人，未来可能会综合适用服务机器人、移动机器人和人形机器人新的专用标准。</li>
</ul>
<p>同时，AI Act 可能会把控制装配线、化工过程或高风险仓储系统的 AI 归类为高风险 AI，要求更严格的合规管理。</p>
<ol start="3">
<li><strong>VLA 在工业和物流中的角色</strong></li>
</ol>
<p>在这些场景中，VLA 可以发挥出相当务实的价值：</p>
<ul>
<li><strong>任务理解与调度</strong>：把文本/语音订单（如“从 A 区取 10 箱 B 商品送到打包工位”）转化为一系列机器人可执行的高层和低层任务；</li>
<li><strong>环境理解</strong>：通过视觉–语言模型识别货架、托盘、标签和异常情况（破损、遮挡），自动调整计划；</li>
<li><strong>多机器人协作</strong>：用语言或符号协议协调多台机器人和人类工人的分工，实现“机器人车队”的高层调度；</li>
<li><strong>人机协作界面</strong>：工人可以直接用自然语言调整机器人行为（“你先帮我做 C 订单，这批货比较急”），而不是通过僵硬的终端界面。</li>
</ul>
<p>但所有这些能力都必须在<strong>安全控制层的约束之内</strong>：</p>
<ul>
<li>AMR 的最高速度和制动性能由 ISO 3691-4 等标准确定；</li>
<li>协作机械臂的接触力上限由 ISO/TS 15066 决定；</li>
<li>VLA 只能在这些硬约束之内调度动作，而不能突破它们“自由发挥”。</li>
</ul>
<ol start="4">
<li><strong>社会与劳动力市场影响</strong></li>
</ol>
<p>在物流与制造领域，机器人带来的影响不仅是效率，还包括：</p>
<ul>
<li>套用仓储行业的经验：机器人可以接手高强度、重复性和危险的工作（如搬重箱、进出冷库、装卸卡车），减少工伤和人员流失。</li>
<li>在劳动力短缺和人口老龄化严重的地区（如日本），自动化甚至被视为维持供应链运转的必要条件。</li>
<li>同时，岗位结构向更高技能迁移：需要更多机器人运维人员、数据工程师和系统集成工程师。</li>
</ul>
<p>对具身智能研究者而言，这里隐含着两类机会：</p>
<ul>
<li>一类是<strong>技术机会</strong>：如何用 VLA 改善人机协作体验、降低部署门槛；</li>
<li>另一类是<strong>制度与社会机会</strong>：如何在项目中主动设计培训、岗位转型和参与式决策机制，让机器人真正成为“放大人类能力”的工具，而不是简单的替代品。</li>
</ul>
<blockquote>
<p>【图 12-L】智能仓储中多种机器人与人协作的示意图（占位：包括机械臂、AGV/AMR、人形机器人与工人，标注安全区域和任务分配）</p>
</blockquote>
<hr>
<p>本节从标准、法规到责任、信任与应用场景，描绘了具身智能从“实验室原型”走向“现实世界系统”所必须面对的外部约束。后续章节在讨论更通用的基础模型与长期发展时，可以把这些安全与社会因素视为“边界条件”：真正成功的具身智能，不是只在 benchmark 上得分最高，而是能在复杂社会系统中长期、安全、可持续地运行。</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="个人发展与方向选择"><a href="#个人发展与方向选择" class="header">个人发展与方向选择</a></h1>
<p>具身智能并不只是算法、系统和实验室的故事，也是你个人职业叙事的一部分。
站在本书这一章，你已经大致看完了从数学、机器学习，到 VLA 模型、数据工程、部署评测的完整技术路径。接下来，问题从“怎么让机器人更聪明”，变成“我在这场长期演化里要扮演什么角色”。</p>
<p>本节不提供唯一正确答案，而是帮助你看清几条典型路线：
学术路径（博士 / 博后 / 科研机构）、工业路径（公司与研究院）、面向具体行业的交叉方向，以及无论走哪条路都离不开的持续学习方式。</p>
<blockquote>
<p>【图 12-4-1 占位：一张“学术 – 工业 – 交叉应用”三条路径的对比雷达图，维度包括：稳定性、自由度、创新风险、工程深度、与现实场景贴近程度等】</p>
</blockquote>
<hr>
<h3 id="1241-学术路径博士博后与科研机构"><a class="header" href="#1241-学术路径博士博后与科研机构">12.4.1 学术路径：博士、博后与科研机构</a></h3>
<p>学术路径的核心，是把“好奇心 + 系统性 + 长期耐心”变成一条用原创工作累积声誉的生涯。从博士开始，你逐步从“会用工具的人”变成“发明工具的人”。</p>
<h4 id="12411-攻读博士"><a class="header" href="#12411-攻读博士">12.4.1.1 攻读博士</a></h4>
<p><strong>（1）什么时候适合读博？</strong></p>
<p>大致有几类典型动机：</p>
<ul>
<li>你对某个具身智能子方向有很强的“钻到底”的冲动，比如：VLA 统一架构、世界模型、Sim2Real、机器人安全与验证等；</li>
<li>你希望未来在高校、研究所、头部工业研究院担任科研岗，而这些岗位普遍需要博士学位(<a href="https://www.uni.lu/en/jobs/postdoctoral-researcher-in-verification-validation-of-learning-based-perception-systems-for-robotic-proximity-operations/?utm_source=chatgpt.com">UNI EN</a>)；</li>
<li>你喜欢提出新问题、验证新想法，而不是主要以工程交付或产品迭代为主。</li>
</ul>
<p>如果这些描述听起来很像你，博士是一个值得严肃考虑的选择。</p>
<p><strong>（2）博士阶段究竟在做什么？</strong></p>
<p>可以用一句话概括：<strong>在导师和学术共同体的环境里，完成几次从“提出问题 → 解决问题 → 对外论证”的完整闭环。</strong>
具体通常包括：</p>
<ul>
<li><strong>确定研究方向与问题</strong>：在本书涉及的巨大知识图谱里，选一小块做“深挖”，例如：
<ul>
<li>基于大模型的策略学习与指令对齐；</li>
<li>高保真世界模型与长视野规划；</li>
<li>复杂物理交互中的安全验证与控制；</li>
<li>多机器人协作与群体具身智能等。</li>
</ul>
</li>
<li><strong>提出可发表的问题与方法</strong>：将问题抽象成清晰的研究设定，给出算法 / 模型 / 系统设计，并与已有工作进行细致比较（这部分可以回扣第 11 章关于论文阅读与选题的内容）。</li>
<li><strong>实验与系统验证</strong>：在仿真与真实机器人上进行系统实验，设计合理评价指标，确保结果既可信，又有说服力。</li>
<li><strong>写作与传播</strong>：将成果写成论文投稿到顶会/期刊（例如 ICRA、IROS、RSS、NeurIPS、ICLR 等），并通过报告、海报、开源代码等形式对外传播。</li>
</ul>
<p>在具身智能方向，博士往往不仅是“做几个算法”，而是要 <strong>亲手搭建和维护一个中等规模的实验系统</strong>：包括数据采集、仿真环境、机器人平台和训练管线，这一点与纯软件 AI 方向相比，要更重工程。</p>
<p><strong>（3）选导师与方向的一些原则</strong></p>
<ul>
<li><strong>导师 &gt; 学校 &gt; 城市。</strong> 顶级名校固然有资源，但更重要的是导师是否：
<ul>
<li>在你感兴趣方向有持续产出；</li>
<li>有时间指导学生（组太大可能导致稀释）；</li>
<li>在学术和工程上都重视具身智能，而不是只把机器人当“论文 demo”。</li>
</ul>
</li>
<li><strong>方向要兼顾“有趣 +可做 +有影响”</strong>：只“有趣”但太空泛，很难落到可操作课题；只“好做”但边缘，很难支撑完整博士；只“热门”但你无感，很难熬过数年的反复试错。</li>
<li><strong>理想的博士课题</strong>，往往是本书某条技术主线的一个深度延伸：
比如，你可以专注于“多机器人共享 VLA 模型的架构与训练范式”，或者“面向医疗手术机器人的安全 VLA 控制”。</li>
</ul>
<p><strong>（4）申请准备的现实侧</strong></p>
<p>很多高校与研究机构的机器人 / AI 博士项目会强调：扎实的数学、机器学习、编程与机器人背景，以及一定研究或工程经历是前提(<a href="https://nccr-robotics.ch/education/how-to-get-into-robotics/?utm_source=chatgpt.com">nccr-robotics.ch</a>)。因此在读博之前，你可以尽量做到：</p>
<ul>
<li>在硕士阶段完成一到两个具身智能相关的项目或论文（哪怕是小规模的复现 / 改进）；</li>
<li>参与开源项目或实验室工程，证明你能“把系统跑起来”，而不仅仅会写作业；</li>
<li>在方向相近的导师手下先做一段时间科研助理 / 实习，用实际合作来降低双方不确定性。</li>
</ul>
<blockquote>
<p>【图 12-4-2 占位：博士阶段能力成长路径示意图，从“执行者”到“独立研究者”，标出论文、系统、合作、人脉等几个维度的变化曲线】</p>
</blockquote>
<h4 id="12412-博士后和科研人员"><a class="header" href="#12412-博士后和科研人员">12.4.1.2 博士后和科研人员</a></h4>
<p>博士之后，如果你仍然希望以研究为主要工作内容，通常会经历或考虑两个角色：<strong>博士后</strong> 和 <strong>正式科研人员</strong>。</p>
<p><strong>博士后：从“学生”到“独立 PI”的过渡</strong></p>
<ul>
<li>在多数国家和机构中，博士后是 2–3 年左右的固定期限职位(<a href="https://academicpositions.com/jobs/position/post-doc/field/robotics?utm_source=chatgpt.com">academicpositions.com</a>)；</li>
<li>相比博士生，博士后：
<ul>
<li>课业负担基本消失，时间更多用于研究；</li>
<li>需要更清晰地建立自己的研究方向，不再完全依附导师；</li>
<li>开始承担项目管理、学生指导、合作沟通等工作；</li>
</ul>
</li>
<li>对具身智能而言，博士后往往负责：
<ul>
<li>领导大型数据采集与实验平台搭建；</li>
<li>承担跨组 / 跨机构合作项目，如多实验室共享机器人数据集或联合训练基础模型；</li>
<li>将研究从“单机器人 demo”扩展到具有代表性的 benchmark 或开放平台。</li>
</ul>
</li>
</ul>
<p><strong>科研人员：在大学、研究所和企业研究院中长期深耕</strong></p>
<p>正式科研岗可以分成几类：</p>
<ul>
<li><strong>高校：</strong> 助理教授 / 青年研究员 → 副教授 / 副研究员 → 教授 / 研究员；</li>
<li><strong>政府 / 国家实验室：</strong> 研究科学家 / 研究工程师，偏重长期战略课题和国家级项目；</li>
<li><strong>工业研究院：</strong> Research Scientist / Applied Scientist 类型岗位，介于“学术自由”与“公司战略目标”之间。</li>
</ul>
<p>这些岗位的共性是：<strong>用持续的、有影响力的成果，换取长期稳定的研究位置。</strong>
对具身智能方向来说，这些成果往往包括：
高质量论文、开源系统与数据集、广泛采用的算法框架以及对行业标准制定的参与。</p>
<h4 id="12413-学术成果从发论文到建设生态"><a class="header" href="#12413-学术成果从发论文到建设生态">12.4.1.3 学术成果：从“发论文”到“建设生态”</a></h4>
<p>在具身智能领域，“成果”不只是论文篇数，而是你对整个社区生态的贡献。</p>
<p>常见的几类成果包括：</p>
<ol>
<li><strong>学术论文</strong>
<ul>
<li>在机器人顶会 / AI 顶会上发表系统性工作：如新的 VLA 架构、世界模型方法、具身基准等；</li>
<li>真正有影响的工作往往不是“刷题式”的小修小补，而是回答了一个社区长期关心的核心问题。</li>
</ul>
</li>
<li><strong>代码、数据集和基准平台</strong>
<ul>
<li>对具身智能而言，高质量的 <strong>开源代码、数据集与仿真环境</strong> 本身就是一等公民；</li>
<li>如本书前面提到的多机器人多任务数据集、统一控制接口平台等，往往能深刻影响后续研究方向(<a href="https://roboticsjobs.co.uk/career-advice/career-paths-in-robotics-from-entry-level-roles-to-leadership-and-beyond?utm_source=chatgpt.com">Robotics Jobs</a>)。</li>
</ul>
</li>
<li><strong>系统与工具链</strong>
<ul>
<li>更工程向的成果：例如部署在多个实验室 / 公司使用的 VLA 训练框架、高效仿真引擎插件等；</li>
<li>很多具身智能的突破，恰恰来自于底层工程基础设施质量的升级。</li>
</ul>
</li>
<li><strong>社区贡献</strong>
<ul>
<li>组织 workshop、tutorial、暑校、挑战赛；</li>
<li>担任程序委员会、审稿人、领域主席等；</li>
<li>这些工作难以量化，但对你建立领域声誉和人脉非常重要。</li>
</ul>
</li>
</ol>
<p>从个人发展角度，一个健康的规划是：<strong>围绕一个清晰主线，产出一系列互相支撑的成果组合</strong>，而不是在完全无关的题目之间跳来跳去。</p>
<hr>
<h3 id="1242-工业路径机器人公司研究院与大模型公司"><a class="header" href="#1242-工业路径机器人公司研究院与大模型公司">12.4.2 工业路径：机器人公司、研究院与大模型公司</a></h3>
<p>工业路径的共同特点，是：<strong>真实用户、真实场景和真实约束</strong> 会不断推着你做取舍——性能、成本、交付时间、安全性，经常不能同时拉满。</p>
<h4 id="12421-机器人创业公司"><a class="header" href="#12421-机器人创业公司">12.4.2.1 机器人创业公司</a></h4>
<p>在全球范围内，机器人与自动化相关创业公司覆盖了仓储物流、协作机械臂、服务机器人、特种机器人、人形机器人等多个赛道(<a href="https://www.automate.org/industry-insights/robotics-and-automation-career-paths?utm_source=chatgpt.com">Automate</a>)。
很多具身智能相关的突破，将首先在这类公司里变成产品。</p>
<p><strong>典型角色</strong></p>
<ul>
<li>Robotics / Embodied AI Research Engineer</li>
<li>Perception / SLAM Engineer</li>
<li>Motion Planning / Control Engineer</li>
<li>Robot Software Engineer（系统与平台）</li>
<li>Machine Learning / Foundation Model Engineer（偏算法）</li>
</ul>
<p>这些岗位往往要求技术栈跨越本书多个章节：既要能理解论文里的 RL / IL / VLA 细节，又要能读懂 ROS 接口、硬件规格和安全文档(<a href="https://panav.gitbook.io/robotics-handbook/career-paths-and-research-opportunities/job-roles-in-robotics?utm_source=chatgpt.com">机器人手册</a>)。</p>
<p><strong>工作方式与节奏</strong></p>
<ul>
<li>团队规模小，角色边界模糊：
你可能同时负责模型训练、真机调试、客户现场部署和 bug 修复；</li>
<li>评估标准更偏向 <strong>“系统能否在某个 demo / 场景中稳定工作”</strong>，而不是论文指标；</li>
<li>决策链路短，试错快：
一个想法不需要写长篇提案，只要能在下一个版本中快速上线验证。</li>
</ul>
<p><strong>优劣势对比</strong></p>
<ul>
<li>优点：
<ul>
<li>成长曲线陡峭，对系统性能力要求高；</li>
<li>有机会把具身智能真正“装进机器人”，直面现实问题；</li>
<li>如果公司发展顺利，个人在股权 / 职业声誉上的回报也较高。</li>
</ul>
</li>
<li>挑战：
<ul>
<li>不确定性大，产品方向和技术路线可能多次 pivot；</li>
<li>工程压力与迭代速度高，对个人时间管理和心理韧性要求大；</li>
<li>纯学术成果（论文）可能不是首要关注，需要自己平衡。</li>
</ul>
</li>
</ul>
<h4 id="12422-大型研究院"><a class="header" href="#12422-大型研究院">12.4.2.2 大型研究院</a></h4>
<p>大型工业研究院（例如科技巨头旗下的 AI / Robotics Lab，以及汽车 / 制造企业的前瞻研究中心）处在 <strong>“工业”和“学术”之间的中间地带</strong>(<a href="https://eit-campus.eu/blog/building-a-career-in-robotics?utm_source=chatgpt.com">EIT Campus</a>)。</p>
<p><strong>它们通常具备几个特征：</strong></p>
<ul>
<li><strong>资源充足</strong>：
高性能计算平台、高质量机器人平台、多源传感器与自建数据中心；</li>
<li><strong>科研友好</strong>：
鼓励在顶会发表论文、开放部分代码或基准，有学术自由度；</li>
<li><strong>又必须对公司战略负责</strong>：
研究方向需和公司中长期目标挂钩，例如自动驾驶、智能制造、家庭机器人、通用具身智能等。</li>
</ul>
<p><strong>在这类机构的日常工作，通常包括：</strong></p>
<ul>
<li>设计和验证新算法 / 模型，撰写论文与技术报告；</li>
<li>参与搭建通用工具链：统一仿真平台、统一数据平台、统一 VLA 训练与部署框架；</li>
<li>与产品线团队对接：
将研究成果逐步下沉为可维护的组件，或为内部客户提供技术咨询。</li>
</ul>
<p><strong>适合的人群特征：</strong></p>
<ul>
<li>喜欢相对稳定的环境，又不想完全脱离学术前沿；</li>
<li>乐于在“基础研究”与“实际落地”之间做折中与沟通；</li>
<li>能适应公司制度、项目管理和跨部门协作。</li>
</ul>
<h4 id="12423-大模型企业"><a class="header" href="#12423-大模型企业">12.4.2.3 大模型企业</a></h4>
<p>近年来，很多大模型公司开始重启或加大机器人与具身智能投入，将其视为迈向更通用 AI 的关键路径之一(<a href="https://www.wired.com/story/openai-ramps-up-robotics-work-in-race-toward-agi?utm_source=chatgpt.com">WIRED</a>)。
典型的趋势包括：</p>
<ul>
<li>基于海量互联网图文和视频预训练的 <strong>视觉–语言–动作基础模型</strong>；</li>
<li>借助云端算力和仿真平台，进行大规模策略训练、世界模型学习；</li>
<li>通过遥操作、众包等方式采集真实机器人数据，优化 VLA 模型。</li>
</ul>
<p>在这些公司中，具身智能相关岗位常见的关键词包括：</p>
<ul>
<li><strong>Embodied AI / Robotics Foundation Model Researcher</strong>
设计和训练大规模 VLA / 世界模型；</li>
<li><strong>Simulation / Data Platform Engineer</strong>
负责构建 Isaac Gym 等大规模仿真和数据流水线；</li>
<li><strong>Teleoperation / Embodied Data Engineer</strong>
设计遥操作采集系统、质量评估与数据治理；</li>
<li><strong>Systems / Infrastructure Engineer</strong>
支撑数千 GPU 级别的分布式训练、模型部署。</li>
</ul>
<p>这一方向的显著特点是：<strong>“以大模型为中心”的具身智能观</strong> —— 技术栈从底层分布式系统，一路向上到 VLA 结构设计与机器人控制。
适合那些对“规模 + 系统 + 算法”三者都感兴趣的人，同时也能接受高度竞争与高强度的环境。</p>
<hr>
<h3 id="1243-交叉方向医疗机器人辅助机器人工业自动化等"><a class="header" href="#1243-交叉方向医疗机器人辅助机器人工业自动化等">12.4.3 交叉方向：医疗机器人、辅助机器人、工业自动化等</a></h3>
<p>如果说学术路径关注“知识边界”，工业路径关注“产品与市场”，那交叉方向更多关注 <strong>“具体行业的问题”</strong>：医疗、养老、制造、农业……
具身智能在这些场景中落地，需要你既懂机器人和 AI，又懂行业本身的规则与需求。</p>
<h4 id="12431-医工结合"><a class="header" href="#12431-医工结合">12.4.3.1 医工结合</a></h4>
<p>医疗是具身智能应用中技术门槛和安全要求最高的领域之一，典型包括：</p>
<ul>
<li>手术机器人（例如微创手术系统、骨科导航机器人等）(<a href="https://www.atalup.com/ai-and-robotics-top-8-career-opportunities/?utm_source=chatgpt.com">ATALUP</a>)；</li>
<li>康复机器人（如下肢外骨骼、上肢康复臂）；</li>
<li>智能假肢、辅具与远程超声 / 介入机器人。</li>
</ul>
<p><strong>这一方向的特点：</strong></p>
<ul>
<li><strong>安全与合规极其重要</strong>：
系统必须满足严格的医疗器械法规、认证流程与临床试验标准；</li>
<li><strong>跨学科协作强</strong>：
需要与医生、护士、康复治疗师、生物力学专家、医院管理者密切沟通；</li>
<li><strong>时间尺度长</strong>：
从实验室到真正临床部署，往往需要数年甚至十年以上。</li>
</ul>
<p>具身智能技术在其中的角色包括：</p>
<ul>
<li>高精度感知与定位（视觉 / 影像引导下的位姿估计与路径规划）；</li>
<li>与医生共享控制的人机协作（力控、阻抗控制、安全约束）；</li>
<li>个体化康复方案建模（世界模型 + 强化学习 + 安全约束）。</li>
</ul>
<p>适合的人，往往对医学和“改变患者命运”有很强的价值认同，能接受节奏较慢但回报极具社会意义的工作。</p>
<h4 id="12432-辅助--服务机器人"><a class="header" href="#12432-辅助--服务机器人">12.4.3.2 辅助 / 服务机器人</a></h4>
<p>辅助 / 服务机器人面对的，是日常生活中的真实人群：老人、小孩、患者、普通家庭用户。典型场景包括：</p>
<ul>
<li>家庭助理机器人：简单家务、取放物品、环境监测；</li>
<li>养老 / 康复辅助：提醒服药、情感陪伴、移动辅助；</li>
<li>公共服务：酒店、医院、商场中的引导与配送机器人。</li>
</ul>
<p>这一方向特别强调：</p>
<ul>
<li><strong>人机交互（HRI）与心理学</strong>：
如何让机器人动作、语言和外形让人感到安全、友好，而不是冰冷或压迫；</li>
<li><strong>语言与多模态理解</strong>：
很多任务以自然语言为主要接口，本书前面讲的 NLP / VLM / VLA 技术在这里发挥核心作用；</li>
<li><strong>隐私与伦理</strong>：
机器人摄像头和传感器深入家庭和个人空间，需要严格的数据保护与伦理规范（可与 12.3 节的讨论呼应）。</li>
</ul>
<p>对这类工作感兴趣的人，通常既喜欢做技术，又对人文社科、产品设计有好奇心。</p>
<h4 id="12433-工业-40-与自动化"><a class="header" href="#12433-工业-40-与自动化">12.4.3.3 工业 4.0 与自动化</a></h4>
<p>工业 4.0 强调的是 <strong>柔性、智能、互联的生产系统</strong>。
在工厂、仓储、能源等场景下，机器人与自动化早已大规模应用，并持续产生新的岗位与职责(<a href="https://www.automate.org/industry-insights/robotics-and-automation-career-paths?utm_source=chatgpt.com">Automate</a>)。</p>
<p>典型角色包括：</p>
<ul>
<li><strong>自动化 / 控制工程师</strong>：
设计和维护工业机器人、PLC、输送线、传感器网络，确保产线稳定运行；</li>
<li><strong>工业视觉 / 质检工程师</strong>：
使用机器视觉和深度学习进行质量检测、缺陷识别；</li>
<li><strong>智能制造系统工程师</strong>：
结合 MES / ERP / 仓储系统，设计整体调度与优化策略，将具身智能嵌入更大系统。</li>
</ul>
<p>这一方向的特点是：</p>
<ul>
<li>更强调 <strong>可靠性、可维护性和成本效益</strong>；</li>
<li>并不一味追求“最前沿”的模型，而是优先选择 <strong>可验证、可长期运行、符合标准</strong> 的方案；</li>
<li>就业市场相对稳定，短期风险比创业小，但创新空间仍然存在，例如将本书介绍的 VLA 模型用于灵活产线和仓储机器人。</li>
</ul>
<blockquote>
<p>【图 12-4-3 占位：三条交叉方向对比表，列出“医疗 / 辅助 / 工业自动化”的目标用户、监管强度、技术侧重点（感知 / 控制 / 语言 / 安全）、典型岗位】</p>
</blockquote>
<hr>
<h3 id="1244-持续学习与知识结构迭代"><a class="header" href="#1244-持续学习与知识结构迭代">12.4.4 持续学习与知识结构迭代</a></h3>
<p>无论你选择哪条路径，有一个事实恐怕无法逃避：
<strong>具身智能相关技术在可预见的未来仍会高速演化。</strong>
从早期的经典控制和规划，到深度强化学习，再到大规模 VLA 与世界模型，每隔几年就会出现一次范式升级。</p>
<p>因此，比“掌握某一具体框架”更重要的，是建立一套 <strong>可持续更新的知识结构</strong>。</p>
<h4 id="12441-紧跟前沿"><a class="header" href="#12441-紧跟前沿">12.4.4.1 紧跟前沿</a></h4>
<p>“紧跟前沿”不等于每天被 arXiv 热门论文刷屏，而是要 <strong>有节奏地摄入信息、筛选并消化</strong>。</p>
<p>可参考的做法：</p>
<ol>
<li><strong>建立固定的信息源组合</strong>
<ul>
<li>机器人与控制：ICRA、IROS、RSS、CoRL 等；</li>
<li>AI / VLA：NeurIPS、ICLR、ICML、CVPR 等；</li>
<li>arXiv 相关分类（cs.RO、cs.LG、cs.AI、cs.CV 等）；</li>
<li>高质量博客 / 技术报告 / 公司白皮书（很多具身智能实践经验出自工业界）。</li>
</ul>
</li>
<li><strong>分层阅读策略</strong>
<ul>
<li>“<strong>扫描层</strong>”：每周花固定时间浏览标题和摘要，标记看起来与你主线方向相关的工作；</li>
<li>“<strong>精读层</strong>”：从扫描层选出少量关键论文，深入阅读方法与实验，对照本书前面介绍的理论与实践知识进行消化；</li>
<li>“<strong>实践层</strong>”：对最重要的工作，尝试复现部分结果或将其嵌入自己的系统（可回扣第 11 章关于代码复现与消融实验的内容）。</li>
</ul>
</li>
<li><strong>线上线下社区</strong>
<ul>
<li>参加学术会议、暑校、workshop；</li>
<li>关注开源社区、技术论坛、专业微信群体 / mailing list；
研究表明，机器人与自动化相关岗位类型和数量仍在增长，形成了从初级工程师到研究科学家的完整职业梯度(<a href="https://www.neit.edu/blog/careers-in-robotics?utm_source=chatgpt.com">NEIT</a>)。</li>
</ul>
</li>
</ol>
<h4 id="12442-扩展技能树"><a class="header" href="#12442-扩展技能树">12.4.4.2 扩展技能树</a></h4>
<p>可以把你的能力结构想象成一个不断生长的“技能树”。</p>
<ul>
<li><strong>纵向：至少一个深度方向</strong>
例如：
<ul>
<li>深度强化学习和策略优化；</li>
<li>世界模型与长时预测；</li>
<li>机器人控制与安全验证；</li>
<li>大模型训练与微调。
这是你未来的“招牌”。</li>
</ul>
</li>
<li><strong>横向：多条支线能力</strong>本书已经隐含列出了一些你迟早要接触的支线：
<ul>
<li>工程向：分布式训练、云端部署、嵌入式与实时系统、ROS / ROS2 生态等；</li>
<li>行业向：根据你感兴趣的交叉方向，补充医学基础、工业流程、物流与供应链知识等；</li>
<li>软技能：项目管理、团队协作、跨学科沟通、写作与演讲。</li>
</ul>
</li>
<li>**刻意追求“可以被替代的技能组合很少”**单一技能（“会写 PyTorch 代码”、“懂一点 SLAM”）很容易被替代。
而例如“<strong>既能设计大规模 VLA 模型，又能亲自把模型部署到真实机械臂上调到可用</strong>”这样的组合，就会变得非常稀缺。</li>
</ul>
<blockquote>
<p>【图 12-4-4 占位：一个“技能树 / 雷达图”示意，展示算法、工程、行业知识、沟通协作等维度的能力分布，以及从学生到成熟工程师 / 研究者的变化】</p>
</blockquote>
<h4 id="12443-知识更新把自己的认知当作可重构系统"><a class="header" href="#12443-知识更新把自己的认知当作可重构系统">12.4.4.3 知识更新：把自己的认知当作“可重构系统”</a></h4>
<p>具身智能领域的技术迭代速度，意味着你必须定期对自己的知识结构做“重构”：</p>
<ol>
<li><strong>接受范式迁移</strong>
<ul>
<li>早年经典控制 → 纯 RL → 模仿学习 + RL → 大模型 + IL + RL + 世界模型
你会多次经历“旧习惯被新范式部分替代甚至颠覆”的过程；</li>
<li>面对新的技术潮流时，既要保持好奇，也要保持理性：区分“概念包装”与真正的本质变化。</li>
</ul>
</li>
<li><strong>定期整理自己的知识图谱</strong>
<ul>
<li>通过笔记、思维导图、知识管理工具把本书中的模块和你接触到的新内容统一整理；</li>
<li>标记哪些已经熟练掌握，哪些还停留在“听说过”的阶段；</li>
<li>对过时的认知（例如某些已被证明效果欠佳的范式）主动做“降级处理”，避免长久沿用。</li>
</ul>
</li>
<li><strong>将实践经验纳入“知识库”</strong>
<ul>
<li>很多对你最有价值的知识，并不在论文里，而在你自己搭系统、踩坑、修 bug 的过程中；</li>
<li>养成习惯：在每个项目结束后，写一份“工程后记”，总结：
<ul>
<li>哪些设计是对的；</li>
<li>哪些假设是错误的；</li>
<li>哪些地方可以提炼成可复用的组件或方法论。</li>
</ul>
</li>
</ul>
</li>
<li><strong>在不确定性中规划长期路线</strong>
<ul>
<li>具身智能未来 10 年肯定会经历若干次技术浪潮起落，但几个“相对稳定”的长期主题几乎不会过时：
<ul>
<li>更强的世界模型与长时规划；</li>
<li>更安全、更可信的物理交互；</li>
<li>与具体行业深度融合的应用系统；</li>
<li>可扩展、可协作的机器人群体。</li>
</ul>
</li>
<li>当你选择方向和规划技能树时，可以将这些长期主题作为锚点，在不同浪潮之间保持相对稳定的积累。</li>
</ul>
</li>
</ol>
<hr>
<p>本节从学术、工业到交叉应用，从路径选择到持续学习，给出了一个“人”的视角——你如何在本书铺陈的这张具身智能知识地图上，找到自己的位置，并随时间持续移动。</p>
<p>在后续的结语中，我们将回望整本书中关于 VLA 与具身智能的技术细节与实践经验，尝试回答一个更大的问题：<strong>当人类把智能从数字世界延展到实体世界，我们究竟在构建什么样的未来？</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->
        <script src="src/js/custom-links-620ec1bd.js"></script>

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>


    </div>
    </body>
</html>
